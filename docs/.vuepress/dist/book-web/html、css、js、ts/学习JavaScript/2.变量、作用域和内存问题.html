<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>2.变量、作用域和内存问题 | Liawn&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <meta charset="UTF-8">
  <link rel="icon" href="/blog-vuepress/favicon.ico">
    <meta name="description" content="用vuepress搭建的个人博客">
    <meta charset="UTF-8">
    
    <link rel="preload" href="/blog-vuepress/assets/css/0.styles.5c52d671.css" as="style"><link rel="preload" href="/blog-vuepress/assets/js/app.0d2e1fde.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/2.a046c74e.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/30.3c71597f.js" as="script"><link rel="prefetch" href="/blog-vuepress/assets/js/10.88d5532b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/100.a282e1e5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/101.1917817b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/102.426bef2e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/103.24a96e53.js"><link rel="prefetch" href="/blog-vuepress/assets/js/104.0b4b8196.js"><link rel="prefetch" href="/blog-vuepress/assets/js/105.98db5522.js"><link rel="prefetch" href="/blog-vuepress/assets/js/106.7a39c799.js"><link rel="prefetch" href="/blog-vuepress/assets/js/11.78e26b31.js"><link rel="prefetch" href="/blog-vuepress/assets/js/12.e39a10a3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/13.da0e53c1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/14.91a6c713.js"><link rel="prefetch" href="/blog-vuepress/assets/js/15.b9f3c2f3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/16.01c98a8e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/17.e733ec41.js"><link rel="prefetch" href="/blog-vuepress/assets/js/18.f4fea388.js"><link rel="prefetch" href="/blog-vuepress/assets/js/19.1d376bae.js"><link rel="prefetch" href="/blog-vuepress/assets/js/20.4751d85a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/21.00437d3b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/22.64839502.js"><link rel="prefetch" href="/blog-vuepress/assets/js/23.7a4335d7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/24.3ee2b263.js"><link rel="prefetch" href="/blog-vuepress/assets/js/25.0767dbc8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/26.c416d882.js"><link rel="prefetch" href="/blog-vuepress/assets/js/27.5e82d924.js"><link rel="prefetch" href="/blog-vuepress/assets/js/28.24de79c4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/29.5a1e4f8e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/3.0b0dd8a7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/31.f5f5fe9d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/32.eac572f0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/33.660b2af0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/34.b6f9bd89.js"><link rel="prefetch" href="/blog-vuepress/assets/js/35.2e5e8650.js"><link rel="prefetch" href="/blog-vuepress/assets/js/36.04d6e910.js"><link rel="prefetch" href="/blog-vuepress/assets/js/37.4ffc07ec.js"><link rel="prefetch" href="/blog-vuepress/assets/js/38.f31deb49.js"><link rel="prefetch" href="/blog-vuepress/assets/js/39.5bd11cdb.js"><link rel="prefetch" href="/blog-vuepress/assets/js/4.6edbb2a1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/40.c0dc0955.js"><link rel="prefetch" href="/blog-vuepress/assets/js/41.32840955.js"><link rel="prefetch" href="/blog-vuepress/assets/js/42.afdf16b6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/43.04bbcb6b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/44.3f372036.js"><link rel="prefetch" href="/blog-vuepress/assets/js/45.199528f2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/46.c23ffbe2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/47.33bc80d6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/48.c17f8a84.js"><link rel="prefetch" href="/blog-vuepress/assets/js/49.9f6c2490.js"><link rel="prefetch" href="/blog-vuepress/assets/js/5.c6c641ea.js"><link rel="prefetch" href="/blog-vuepress/assets/js/50.d6762688.js"><link rel="prefetch" href="/blog-vuepress/assets/js/51.1b65f46c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/52.d00b4d17.js"><link rel="prefetch" href="/blog-vuepress/assets/js/53.becdeb67.js"><link rel="prefetch" href="/blog-vuepress/assets/js/54.fe84cbfc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/55.42ca78e9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/56.38dc1cb5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/57.f4964e37.js"><link rel="prefetch" href="/blog-vuepress/assets/js/58.9b4d0044.js"><link rel="prefetch" href="/blog-vuepress/assets/js/59.cfb9c546.js"><link rel="prefetch" href="/blog-vuepress/assets/js/6.c6de6921.js"><link rel="prefetch" href="/blog-vuepress/assets/js/60.4f4f3658.js"><link rel="prefetch" href="/blog-vuepress/assets/js/61.e691fcda.js"><link rel="prefetch" href="/blog-vuepress/assets/js/62.fd6c77be.js"><link rel="prefetch" href="/blog-vuepress/assets/js/63.9acec8fc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/64.c6c33b9e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/65.30e05c43.js"><link rel="prefetch" href="/blog-vuepress/assets/js/66.fdb85611.js"><link rel="prefetch" href="/blog-vuepress/assets/js/67.4a8c9b0e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/68.cf4c210b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/69.b27adaff.js"><link rel="prefetch" href="/blog-vuepress/assets/js/7.4196f4e6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/70.a3316969.js"><link rel="prefetch" href="/blog-vuepress/assets/js/71.9eb46133.js"><link rel="prefetch" href="/blog-vuepress/assets/js/72.0fe4fe9a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/73.0bf36b4a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/74.fc2e628a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/75.205b56bf.js"><link rel="prefetch" href="/blog-vuepress/assets/js/76.8c2bf9b9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/77.a0993252.js"><link rel="prefetch" href="/blog-vuepress/assets/js/78.41709f17.js"><link rel="prefetch" href="/blog-vuepress/assets/js/79.c8733b25.js"><link rel="prefetch" href="/blog-vuepress/assets/js/8.f87272cd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/80.f5ed5113.js"><link rel="prefetch" href="/blog-vuepress/assets/js/81.ddb61980.js"><link rel="prefetch" href="/blog-vuepress/assets/js/82.1d3482a9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/83.a28d44e2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/84.ce75ed5e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/85.d4ffd27c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/86.14ffaf35.js"><link rel="prefetch" href="/blog-vuepress/assets/js/87.482be605.js"><link rel="prefetch" href="/blog-vuepress/assets/js/88.c1035bd5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/89.e739598f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/9.0f96b506.js"><link rel="prefetch" href="/blog-vuepress/assets/js/90.5a928d71.js"><link rel="prefetch" href="/blog-vuepress/assets/js/91.82d05736.js"><link rel="prefetch" href="/blog-vuepress/assets/js/92.8c0f11ee.js"><link rel="prefetch" href="/blog-vuepress/assets/js/93.5cff49c0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/94.8ad61574.js"><link rel="prefetch" href="/blog-vuepress/assets/js/95.f849a0b0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/96.31401883.js"><link rel="prefetch" href="/blog-vuepress/assets/js/97.98310d37.js"><link rel="prefetch" href="/blog-vuepress/assets/js/98.f626e78b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/99.6891a17b.js">
    <link rel="stylesheet" href="/blog-vuepress/assets/css/0.styles.5c52d671.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><a href="/blog-vuepress/" class="home-link router-link-active"><!----> <span class="site-name">Liawn's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav></div></header> <div class="sidebar-wrapper sidebar-hidden"><aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><!----> <span>web前端</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/" class="sidebar-heading clickable open"><span class="arrow down"></span> <span>学习JavaScript</span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/1.基础语法.html" class="sidebar-link">1.基础语法</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/2.变量、作用域和内存问题.html" class="active sidebar-link">2.变量、作用域和内存问题</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/3.引用类型.html" class="sidebar-link">3.引用类型</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/4.面向对象程序设计.html" class="sidebar-link">4.面向对象程序设计</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/5.函数表达式.html" class="sidebar-link">5.函数表达式</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/6.Http、Ajax和跨域.html" class="sidebar-link">6.Http、Ajax和跨域</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/7.异步编程.html" class="sidebar-link">7.异步编程</a></li><li><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/js零碎知识和案例.html" class="sidebar-link">js部分</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习CSS/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习CSS</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习TypeScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习TypeScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习Vue/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习Vue</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习React/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习React</span></a> <!----></section></li><li><a href="/blog-vuepress/book-web/web前端js框架/学习jQuery.html" class="sidebar-link">jQueryNote</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/LayaBox游戏引擎/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>H5游戏引擎Laya</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>数据结构与算法</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/数据结构与算法/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>数据结构与算法ts版</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>常用工具</span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/常用工具/Npm的使用.html" class="sidebar-link">Npm的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Git的使用.html" class="sidebar-link">Git的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/webpack的使用.html" class="sidebar-link">webpack的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/VSCode的使用.html" class="sidebar-link">VSCode的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Chrome的使用.html" class="sidebar-link">Chrome的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用docsify写blog.html" class="sidebar-link">使用docsify写blog</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用gitbook写blog.html" class="sidebar-link">使用gitbook写blog</a></li><li><a href="/blog-vuepress/book-web/web前端测试与调试/基于mocha+chai的单元测试.html" class="sidebar-link">使用mocha+chai进行单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>简单项目实践</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/项目/react+express+ts写爬虫/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>react+express+ts写爬虫</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>面试准备</span></p> <!----></section></li></ul> </aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div> <main class="page sidebar-hidden right-sidebar-hidden"> <div class="theme-default-content content__default"><h1 id="变量、作用域和内存问题"><a href="#变量、作用域和内存问题" class="header-anchor">#</a> 变量、作用域和内存问题</h1> <h2 id="一、基本类型和应用类型的值"><a href="#一、基本类型和应用类型的值" class="header-anchor">#</a> 一、基本类型和应用类型的值</h2> <p>ECMAScript变量的值可以是基本类型或引用类型，之前介绍了Undefined、Null、Boolean、Number和String这5种基本数据类型，它是按 <strong>值</strong> 访问可以 <strong>操作</strong> 保存在变量中的 <strong>实际值</strong>，而引用类型的值是保存在堆内存中，按 <strong>引用</strong> 访问的。</p> <h3 id="_1-1-动态的属性"><a href="#_1-1-动态的属性" class="header-anchor">#</a> 1.1 动态的属性</h3> <p>对于应用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性和方法，而对于基本类型的值我们不能添加属性，就算添加了后面访问这个属性也是undefined。</p> <h3 id="_1-2-复制变量值"><a href="#_1-2-复制变量值" class="header-anchor">#</a> 1.2 复制变量值</h3> <ol><li><p>如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把该值复制到为新变量分配的位置上，例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> num2 <span class="token operator">=</span> num1<span class="token punctuation">;</span> <span class="token comment">// num1的5和num2的5完全独立，两变量可以参与任何操作而不会互相影响。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/blog-vuepress/assets/img/基本类型的复制变量的值.c9412270.png" alt="基本类型的复制变量的值"></p></li> <li><p>如果从一个变量向另一个变量复制引用类型的值，也会把变量对象中的值赋值一份放到新变量分配的位置上。其实这个值的副本是个指针，和复制前变量指向堆内存中的同一个对象，例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span> <span class="token comment">// 地址值复制过去了，地址值之间互不影响，但要操作地址对应的对象就会有影响。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><img src="/blog-vuepress/assets/img/引用类型的复制变量的值.a9ee0a26.png" alt="引用类型的复制变量的值"></p></li></ol> <h3 id="_1-3-传递参数"><a href="#_1-3-传递参数" class="header-anchor">#</a> 1.3 传递参数</h3> <ul><li>按值传递：在参数传递过程中，形参和实参占用了 <strong>两个完全不同的内存空间（栈）</strong>，形参所存储的内容是实参存储内容的一份拷贝。</li> <li>按应用传递：在参数传递过程中，形参和实参完全是 <strong>同一块内存空间（栈）</strong>，两份不分彼此。</li> <li>而ECMAScript中所有函数的参数都是 <strong>按值传递</strong> 的。</li> <li>基本类型值的传递如同基本类型变量的复制一样，而应用类型值的传递则如同应用类型变量的复制一样（参考上一节）。</li></ul> <p>例1：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">addTen</span><span class="token punctuation">(</span><span class="token parameter">num2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num2 <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> num2<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> num1 <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token function">addTen</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 20</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 30</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在调用addTen函数时，num1存储内容复制了一份给num2，复制后num1和num2都为20但互不影响；在addTen函数里，num2加了10之后是对num1没有影响的，这是 <strong>按值传递</strong>，所以最后的输出结果num1是20，num2是30；假设它是 <strong>按引用传递</strong> ，那么num1和num2是同一份，最后的值应该都是30才对，与实际输出不一致。</p> <p>例2：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// (3) 如下图(2)(3)，将person的地址值复制了一份给obj，让obj也指向那个实例化对象</span>
    obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;N&quot;</span><span class="token punctuation">;</span>         <span class="token comment">// (4) 如下图(4)，给那个实例化对象新添一个name属性，该属性值为&quot;N&quot;</span>
    obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// (5) 如下图(5)，又创建了一个Oject的实例化对象，让obj指向这个新的实例化对象</span>
    obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;G&quot;</span><span class="token punctuation">;</span>         <span class="token comment">// (6) 如下图(6)，给新的实例化对象新添一个name属性，该属性值为&quot;G&quot;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// (1) 如下图(1)，声明了person变量，初始化的值是Oject引用类型的一个实例化对象</span>
<span class="token function">setName</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// (2) 去调用setName函数，将person这个变量传入</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// (7) 如下图(7)，函数调用完会清理其中的局部变量，只剩下外部的person和其指引的对象了</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><img src="/blog-vuepress/assets/img/引用类型的按值传递.c7342f21.png" alt="引用类型的复制变量的值"></p> <p>可以看出来，步骤(5)是关键，它可以指向新的实例化对象；如果是 <strong>按引用传递</strong> 的话，person和obj就是同一份（在栈里），在obj指向新对象时，person也指向新对象，实际上步骤(7)打印出的是&quot;N&quot;，所以它还是 <strong>按值传递</strong>（在堆确实还是同一份，但在栈里不是同一份，是复制了一份）。</p> <h3 id="_1-4-检测类型"><a href="#_1-4-检测类型" class="header-anchor">#</a> 1.4 检测类型</h3> <ul><li>检测变量是不是基本数据类型用<code>typeof</code>操作符，而检测引用类型变量是什么类型的对象可以用<code>instanceof</code>操作符；</li> <li>所有引用类型的值 <strong>都是Object的实例</strong>，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回 <strong>true</strong>；</li> <li>使用instanceof操作符检测 <strong>基本类型</strong> 会返回 <strong>false</strong>，基本类型不是对象。</li></ul> <h2 id="二、执行环境及作用域"><a href="#二、执行环境及作用域" class="header-anchor">#</a> 二、执行环境及作用域</h2> <p>在研读《JavaScript高级程序设计》的4.2节后仍有很多不解，需要去研读《你不知道的JavaScript(上卷)》的第一部的一二章和第二部的一二章，你会有转深刻的理解，这里就记录一些浅显的见解吧。</p> <ol><li><p>js是“解释执行”语言，这里不得不提到js的 <strong>引擎和编译器</strong>。引擎负责整个js程序的 <strong>编译和执行过程</strong>，引擎只是负责编译的 <strong>引导</strong> 而实际上具体编译的活是 <strong>编译器</strong> 在干（词法语法分析并生成可执行的机器指令）。</p></li> <li><p>js代码大多是一段段嵌套起来的，那么对代码段可以分成三种：<strong>全局代码段、函数代码段、eval代码段（不推荐使用）</strong>。js代码运行的时候，是先编译再执行，并且编译发生在化码执行前的几微秒甚至更短时间里。但是，这里的编译执行都是按照一段段来的，并不是把文件里的所有代码都编译后再执行的，而是 <strong>编译一段执行一段</strong>。</p></li> <li><p>js运行到某段代码时（某个函数被调用时），先编译分析这段代码并创建一个 <strong>执行环境(execution context)</strong>，也称 <strong>执行上文（简称EC）</strong>。执行环境有三个重要的组成：<strong>变量对象、作用域链、this</strong>。</p> <ul><li><strong>变量对象</strong>：variable object，简称VO。存储着执行环境里的 <strong>所有变量和函数声明</strong>。当执行流在这个执行坏境里执行时，这个变量对象就是 <strong>活动对象(activation object)</strong>。</li> <li><strong>作用域</strong>：scope。是 <strong>根据名称查找变量的一套规则</strong>，这个规则只在所处代码段里有效（这里指的是 <strong>作用域范围</strong>），其实作用域存的不是变量对象本身而是指向变量对象的 <strong>指针</strong>。</li> <li><strong>作用城链</strong>：scope chain。代码段的嵌套使得作用域可以连接到一起了，这祥就形成了一个能 <strong>一级级向上查找变量对象的有序链表</strong>（这样的有序链表其实就是一个指向作用域链范围内所有变量对象的 <strong>指针列表</strong>）。也就是说嵌套在里层的代码段能访问到外层定义的变量，而外层访问不了里层的。</li> <li><strong>this</strong>：记录着函数被调用时的信息，this绑定的是函数 <strong>调用处的对象</strong>（跟函数本身没关系）。有四种场景（已排优先级)：
<ul><li>如果函数是由new调用的（new绑定），那么this绑定的是新创建的对象。<code>var bar = new Foo();</code>，this绑定了bar；</li> <li>如果函数通过<code>call</code>、<code>apply</code>调用（显示绑定）或<code>bind</code>（硬绑定）调用，那么this绑定的是指定的对象。<code>var bar = foo.call(obj);</code>，this绑定了obj；</li> <li>如果函数由某个上下文对象调用（隐式绑定），那么this绑定的是那个上下文对象。<code>var bar = obj.foo();</code>，this绑定了obj；<code>obj1.obj2.foo();</code>，this绑定了obj2；</li> <li>如果不是上面三种，那就是使用默认绑定，this绑定的是全局对象window。严格模式下全局对象无法使用默认绑定，因此this会绑定到undefined。（有个坑爹的地方，假如函数创建在非严格模式的全局环境里，但是在一小块严格模式代码里调用了函数，这个函数可以绑定全局对象）</li></ul></li></ul></li> <li><p>假如代码段里有<code>var a = 0;</code>这句，<strong>编译遇到var</strong> 时（声明提升了），编译器会拿a这个名字 <strong>通过作用域链</strong> 去当前执行环境的 <strong>变量对象</strong> 里查找是否存在，不存在就在变量对象里 <strong>新声明一个a</strong>（存的是undefined），存在的话会 <strong>忽略var</strong> 并继续往下编译。这一段代码段 <strong>编译完后</strong>，<strong>就开始执行</strong> 这一段代码段，执行遇到<code>a = 0</code>时（声明提升了，a = 0还在原地），引擎会先拿a这个名字 <strong>通过作用域链</strong> 去当前执行环境的 <strong>变量对象</strong> 里查找是否有a这个变量存在，存在话就拿来用（也就是把0这个值赋给a变量），不存在的话继续向上一级查找，直到最外层的 <strong>全局执行环境</strong> 的 <strong>变量对象</strong> 里还没找到那就抛异常（其实在非严格模式下会在全局执行环境的变量对象里，创建一个全局变量，返回给引擎并不会抛异常）。</p></li> <li><p>在一段代码段运行完（编译了也执行完了），代码段抽象出的执行环境 <strong>会被销毁</strong>，连带着里面的 <strong>变量对象、作用域链和this</strong> 都会被销毁，只有代码段再次被调用时才会建立一个新的执行环境。</p></li> <li><p>之前说代码段被分成三种：<strong>全局代码段、函数代码段、eval代码段（不推荐使用）</strong>。那么可以说js <strong>没有块级作用域</strong>，只有 <strong>全局作用域</strong> 和 <strong>函数作用域</strong>，比如if和for这种语句的{}里的变量也可在外面使用。</p></li> <li><p>为什么不推荐用<code>eval()</code>，因为它可以在代码执行时，来声明“代码字符串”里的变量，从而 <strong>改变了编译时的作用域</strong>。类似还有<code>with()</code>，它是在代码执行时，把某些对象的属性也当做标识符，从而 <strong>新建了一个作用域</strong>。这两个 <strong>非但没有在编译期被优化，反而在执行期改变了作用域拖慢代码运行速度</strong>，而且这两个在严格模式下是被禁止的。</p></li> <li><p>可以去<a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/5.函数表达式.html#闭包">函数表达式#闭包</a>进一步学习。</p></li></ol> <h2 id="三、垃圾收集"><a href="#三、垃圾收集" class="header-anchor">#</a> 三、垃圾收集</h2> <p>js具有 <strong>自动</strong> 垃圾收集机制，这种机制原理：<strong>找出那些不再被使用的变量，然后释放其占用的内存</strong>。</p> <h3 id="_3-1-标识清除"><a href="#_3-1-标识清除" class="header-anchor">#</a> 3.1 标识清除</h3> <p>标识清除是js <strong>最常见</strong> 的垃极收集方式，垃圾收集器在运行时，它会先给内存中所有的变量 <strong>加上标记</strong>（不管变量有用还是无用），然后垃圾收集器会 <strong>去掉</strong> 那些 <strong>可以被访问</strong> 的变量身上的 <strong>标记</strong>，剩下的那些无法被访问的变量自然还留有标记，最后垃圾收集器对 <strong>留有标记</strong> 的变量进行 <strong>内存清除工作</strong>（销毁标记值和所占内存）。</p> <h3 id="_3-2-引用计数"><a href="#_3-2-引用计数" class="header-anchor">#</a> 3.2 引用计数</h3> <p>引用计数目前者 <strong>不再被使用在js引擎中</strong>，引用计数会跟踪记录每个值 <strong>被引用的次数</strong>。声明一个变量并给这个变量赋了一个引用类型的值，这个引用次数就是1；当这个引类型的值再被赋给另一个变量时，该值的引用次数加1；当这个引用类型的值不再被引用时，这个引用次数就变成了0，就会被回收。</p> <p><strong>循环引用</strong>：对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针。（<strong>例如对象A的某属性指向B对象，B对象的某属性指向A对象</strong>）</p> <p>当代码里存在循环引用这种情况，引用计数时他们的引用次数永远不会为0，<strong>被多次调用后就会导致大量的内有得不到回收</strong>。</p> <h3 id="_3-3-内存管理"><a href="#_3-3-内存管理" class="header-anchor">#</a> 3.3 内存管理</h3> <p>将变量的值 <strong>设为null</strong>，可以释放其引用（以便于被回收），这种做法叫做 <strong>解除引用</strong>。</p> <p>解除引用可以用在前面提到的 <strong>循环引用</strong> 上来 <strong>切断连接</strong>，也可以用在不再被使用的全局变量和全局变量的属性上，这也是优化内存占用的最佳方式，为执行中的代码只保有必要的数据，不必要的数据为其解除引用。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/6/2022, 3:41:21 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/1.基础语法.html" class="prev">
        1.基础语法
      </a></span> <span class="next"><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/3.引用类型.html">
        3.引用类型
      </a>
      →
    </span></p></div> </main> <div class="right-sidebar-wrapper right-sidebar-hidden"><aside class="right-sidebar"><ul><h4>本文目录</h4></ul></aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div></div><div class="global-ui"></div></div>
    <script src="/blog-vuepress/assets/js/app.0d2e1fde.js" defer></script><script src="/blog-vuepress/assets/js/2.a046c74e.js" defer></script><script src="/blog-vuepress/assets/js/30.3c71597f.js" defer></script>
  </body>
</html>
