<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>8.树 | Liawn&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <meta charset="UTF-8">
  <link rel="icon" href="/blog-vuepress/favicon.ico">
    <meta name="description" content="用vuepress搭建的个人博客">
    <meta charset="UTF-8">
    
    <link rel="preload" href="/blog-vuepress/assets/css/0.styles.5c52d671.css" as="style"><link rel="preload" href="/blog-vuepress/assets/js/app.0d2e1fde.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/2.a046c74e.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/8.f87272cd.js" as="script"><link rel="prefetch" href="/blog-vuepress/assets/js/10.88d5532b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/100.a282e1e5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/101.1917817b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/102.426bef2e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/103.24a96e53.js"><link rel="prefetch" href="/blog-vuepress/assets/js/104.0b4b8196.js"><link rel="prefetch" href="/blog-vuepress/assets/js/105.98db5522.js"><link rel="prefetch" href="/blog-vuepress/assets/js/106.7a39c799.js"><link rel="prefetch" href="/blog-vuepress/assets/js/11.78e26b31.js"><link rel="prefetch" href="/blog-vuepress/assets/js/12.e39a10a3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/13.da0e53c1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/14.91a6c713.js"><link rel="prefetch" href="/blog-vuepress/assets/js/15.b9f3c2f3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/16.01c98a8e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/17.e733ec41.js"><link rel="prefetch" href="/blog-vuepress/assets/js/18.f4fea388.js"><link rel="prefetch" href="/blog-vuepress/assets/js/19.1d376bae.js"><link rel="prefetch" href="/blog-vuepress/assets/js/20.4751d85a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/21.00437d3b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/22.64839502.js"><link rel="prefetch" href="/blog-vuepress/assets/js/23.7a4335d7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/24.3ee2b263.js"><link rel="prefetch" href="/blog-vuepress/assets/js/25.0767dbc8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/26.c416d882.js"><link rel="prefetch" href="/blog-vuepress/assets/js/27.5e82d924.js"><link rel="prefetch" href="/blog-vuepress/assets/js/28.24de79c4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/29.5a1e4f8e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/3.0b0dd8a7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/30.3c71597f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/31.f5f5fe9d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/32.eac572f0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/33.660b2af0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/34.b6f9bd89.js"><link rel="prefetch" href="/blog-vuepress/assets/js/35.2e5e8650.js"><link rel="prefetch" href="/blog-vuepress/assets/js/36.04d6e910.js"><link rel="prefetch" href="/blog-vuepress/assets/js/37.4ffc07ec.js"><link rel="prefetch" href="/blog-vuepress/assets/js/38.f31deb49.js"><link rel="prefetch" href="/blog-vuepress/assets/js/39.5bd11cdb.js"><link rel="prefetch" href="/blog-vuepress/assets/js/4.6edbb2a1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/40.c0dc0955.js"><link rel="prefetch" href="/blog-vuepress/assets/js/41.32840955.js"><link rel="prefetch" href="/blog-vuepress/assets/js/42.afdf16b6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/43.04bbcb6b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/44.3f372036.js"><link rel="prefetch" href="/blog-vuepress/assets/js/45.199528f2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/46.c23ffbe2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/47.33bc80d6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/48.c17f8a84.js"><link rel="prefetch" href="/blog-vuepress/assets/js/49.9f6c2490.js"><link rel="prefetch" href="/blog-vuepress/assets/js/5.c6c641ea.js"><link rel="prefetch" href="/blog-vuepress/assets/js/50.d6762688.js"><link rel="prefetch" href="/blog-vuepress/assets/js/51.1b65f46c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/52.d00b4d17.js"><link rel="prefetch" href="/blog-vuepress/assets/js/53.becdeb67.js"><link rel="prefetch" href="/blog-vuepress/assets/js/54.fe84cbfc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/55.42ca78e9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/56.38dc1cb5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/57.f4964e37.js"><link rel="prefetch" href="/blog-vuepress/assets/js/58.9b4d0044.js"><link rel="prefetch" href="/blog-vuepress/assets/js/59.cfb9c546.js"><link rel="prefetch" href="/blog-vuepress/assets/js/6.c6de6921.js"><link rel="prefetch" href="/blog-vuepress/assets/js/60.4f4f3658.js"><link rel="prefetch" href="/blog-vuepress/assets/js/61.e691fcda.js"><link rel="prefetch" href="/blog-vuepress/assets/js/62.fd6c77be.js"><link rel="prefetch" href="/blog-vuepress/assets/js/63.9acec8fc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/64.c6c33b9e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/65.30e05c43.js"><link rel="prefetch" href="/blog-vuepress/assets/js/66.fdb85611.js"><link rel="prefetch" href="/blog-vuepress/assets/js/67.4a8c9b0e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/68.cf4c210b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/69.b27adaff.js"><link rel="prefetch" href="/blog-vuepress/assets/js/7.4196f4e6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/70.a3316969.js"><link rel="prefetch" href="/blog-vuepress/assets/js/71.9eb46133.js"><link rel="prefetch" href="/blog-vuepress/assets/js/72.0fe4fe9a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/73.0bf36b4a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/74.fc2e628a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/75.205b56bf.js"><link rel="prefetch" href="/blog-vuepress/assets/js/76.8c2bf9b9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/77.a0993252.js"><link rel="prefetch" href="/blog-vuepress/assets/js/78.41709f17.js"><link rel="prefetch" href="/blog-vuepress/assets/js/79.c8733b25.js"><link rel="prefetch" href="/blog-vuepress/assets/js/80.f5ed5113.js"><link rel="prefetch" href="/blog-vuepress/assets/js/81.ddb61980.js"><link rel="prefetch" href="/blog-vuepress/assets/js/82.1d3482a9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/83.a28d44e2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/84.ce75ed5e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/85.d4ffd27c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/86.14ffaf35.js"><link rel="prefetch" href="/blog-vuepress/assets/js/87.482be605.js"><link rel="prefetch" href="/blog-vuepress/assets/js/88.c1035bd5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/89.e739598f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/9.0f96b506.js"><link rel="prefetch" href="/blog-vuepress/assets/js/90.5a928d71.js"><link rel="prefetch" href="/blog-vuepress/assets/js/91.82d05736.js"><link rel="prefetch" href="/blog-vuepress/assets/js/92.8c0f11ee.js"><link rel="prefetch" href="/blog-vuepress/assets/js/93.5cff49c0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/94.8ad61574.js"><link rel="prefetch" href="/blog-vuepress/assets/js/95.f849a0b0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/96.31401883.js"><link rel="prefetch" href="/blog-vuepress/assets/js/97.98310d37.js"><link rel="prefetch" href="/blog-vuepress/assets/js/98.f626e78b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/99.6891a17b.js">
    <link rel="stylesheet" href="/blog-vuepress/assets/css/0.styles.5c52d671.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><a href="/blog-vuepress/" class="home-link router-link-active"><!----> <span class="site-name">Liawn's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav></div></header> <div class="sidebar-wrapper sidebar-hidden"><aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>web前端</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习JavaScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习CSS/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习CSS</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习TypeScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习TypeScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习Vue/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习Vue</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习React/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习React</span></a> <!----></section></li><li><a href="/blog-vuepress/book-web/web前端js框架/学习jQuery.html" class="sidebar-link">jQueryNote</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/LayaBox游戏引擎/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>H5游戏引擎Laya</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><!----> <span>数据结构与算法</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/数据结构与算法/" class="sidebar-heading clickable open"><span class="arrow down"></span> <span>数据结构与算法ts版</span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/数据结构与算法/1.环境搭建.html" class="sidebar-link">1.环境搭建</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/2.栈.html" class="sidebar-link">2.栈</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/3.队列.html" class="sidebar-link">3.队列</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/4.链表.html" class="sidebar-link">4.链表</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/5.集合.html" class="sidebar-link">5.集合</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/6.字典和散列表.html" class="sidebar-link">6.字典和散列表</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/7.递归.html" class="sidebar-link">7.递归</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/8.树.html" class="active sidebar-link">8.树</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/9.二叉堆和堆排序.html" class="sidebar-link">9.二叉堆和堆排序</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/10.图.html" class="sidebar-link">10.图</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/11.排序和搜索算法.html" class="sidebar-link">11.排序和搜索算法</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/12.算法设计与技巧.html" class="sidebar-link">12.算法设计与技巧</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/13.算法复杂度.html" class="sidebar-link">13.算法复杂度</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>常用工具</span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/常用工具/Npm的使用.html" class="sidebar-link">Npm的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Git的使用.html" class="sidebar-link">Git的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/webpack的使用.html" class="sidebar-link">webpack的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/VSCode的使用.html" class="sidebar-link">VSCode的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Chrome的使用.html" class="sidebar-link">Chrome的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用docsify写blog.html" class="sidebar-link">使用docsify写blog</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用gitbook写blog.html" class="sidebar-link">使用gitbook写blog</a></li><li><a href="/blog-vuepress/book-web/web前端测试与调试/基于mocha+chai的单元测试.html" class="sidebar-link">使用mocha+chai进行单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>简单项目实践</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/项目/react+express+ts写爬虫/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>react+express+ts写爬虫</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>面试准备</span></p> <!----></section></li></ul> </aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div> <main class="page sidebar-hidden right-sidebar-hidden"> <div class="theme-default-content content__default"><h1 id="树"><a href="#树" class="header-anchor">#</a> 树</h1> <h2 id="树数据结构"><a href="#树数据结构" class="header-anchor">#</a> 树数据结构</h2> <p>    树(Tree)是一种分层数据的抽象模型。一个树结构包含一系列存在父子关系的节点，每个节点都有一个父子节点（除了树顶部的根节点）以及零个或多个子节点。</p> <p>    树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点，没有子节点的节点称为外部节点或叶节点。</p> <p>    一个节点的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。</p> <p>    子树是树中非根节点和它的后代构成的。节点有个属性叫深度，节点的深度取决于它祖先节点的数量。树的高度取决于所有节点深度的最大值。</p> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <p>    二叉树是一种一个节点最多有两个子节点的树，这两个子节点分别叫作：左侧子节点和右侧子节点。</p> <p>    二叉搜索树(BST)是二叉树中的一种，它的左侧子节点存储比父节点小的值，而右侧子节点存储比父节点大的值。</p> <p>    平衡二叉树(AVL)是特殊的二叉搜索树，特殊之处在于树中任何一个节点的左子树和右子树高度最多相差1。这样能避免树的某一分支出现很多层而其它分支却只有几层的现象（避免操作性能问题）。AVL树在添加或移除节点时会尽可能尝试转换为完全二叉树。</p> <p>    红黑树(RBT)是平衡二叉树的一种变体，它的左右子树高差有可能大于1（不一定要达到AVL式的平衡），所以它不是严格意义上的自平衡树。红黑树进行平衡的代价较低，其平均统计性能要强于AVL。（多增删少搜索用RBT，反之用AVL）</p> <h2 id="二叉搜索树的实现"><a href="#二叉搜索树的实现" class="header-anchor">#</a> 二叉搜索树的实现</h2> <p>    二叉搜索树的实现代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/binary-search-tree.ts" target="_blank" rel="noopener noreferrer">binary-search-tree.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="实现二叉搜索树的准备工作"><a href="#实现二叉搜索树的准备工作" class="header-anchor">#</a> 实现二叉搜索树的准备工作</h3> <p>    需要准备一个助手类<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/models/node.ts" target="_blank" rel="noopener noreferrer">Node<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，它有三个属性key、right、left，分别存储的是节点的值、节点的左侧子节点引用、节点的右侧子节点引用。</p> <p>    给BinarySearchTree声明一个变量_root，代表根节点，类型就是之前的Node。再声明一个变量_compareFn，用于存储比较函数。</p> <h3 id="二叉搜索树的插入元素"><a href="#二叉搜索树的插入元素" class="header-anchor">#</a> 二叉搜索树的插入元素</h3> <p>    insert向树中插入一个新的键。如果_root为null，证明此树为空，那么将新元素插入_root；否则，会与_root的值用_compareFn比较大小，比_root小的话再看_root的左侧子节点是否为空，为空就插入这个位置，不然又重复之前的逻辑比较大小...比_root大的话再看_root的右侧子节点是否为空，为空就插入这个位置，不然又重复之前的逻辑比较大小...这一样以来，完全可以用递归来实现它。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 向树中插入一个新的键
 */</span>
<span class="token keyword">public</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 根节点为空</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_root <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 插入到非根节点处需要比较大小才能插入</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 插入一个节点的左侧还是右侧，用比较函数来比较
 */</span>
<span class="token keyword">private</span> <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">LESS_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 第一个参数小于第二个参数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="二叉搜索树的遍历"><a href="#二叉搜索树的遍历" class="header-anchor">#</a> 二叉搜索树的遍历</h3> <h4 id="中序遍历"><a href="#中序遍历" class="header-anchor">#</a> 中序遍历</h4> <p>    中序遍历是一种上行顺序访问BST所有节点，也就是以“左侧子节点——父节点——右侧子节点”这样的形式遍历。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 通过中序遍历方式遍历所有节点
 */</span>
<span class="token keyword">public</span> <span class="token function">inOrderTraverse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">callBack</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 中序遍历
 */</span>
<span class="token keyword">private</span> <span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">callBack</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">callBack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在父节点就调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">inOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="先序遍历"><a href="#先序遍历" class="header-anchor">#</a> 先序遍历</h4> <p>    先序遍历是先访问该节点再访问其后代节点的顺序来遍历BST所有节点，也就是以“父节点——左侧子节点——右侧子节点”这样的形式遍历。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 通过先序遍历方式遍历所有节点
 */</span>
<span class="token keyword">public</span> <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">callBack</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 先序遍历
 */</span>
<span class="token keyword">private</span> <span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">callBack</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">callBack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在左节点之前就调用</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="后序遍历"><a href="#后序遍历" class="header-anchor">#</a> 后序遍历</h4> <p>    后序遍历是先访问后代节点再访问该节点的顺序来遍历BST所有节点，也就是以“左侧子节点——右侧子节点——父节点”这样的形式遍历。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 通过后序遍历方式遍历所有节点
 */</span>
<span class="token keyword">public</span> <span class="token function">postOrderTraverse</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">callBack</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 后序遍历
 */</span>
<span class="token keyword">private</span> <span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">callBack</span><span class="token operator">:</span> Function</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postOrderTraverseNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> callBack<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">callBack</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 在右节点之后就调用</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="二叉搜索树的最大值和最小值"><a href="#二叉搜索树的最大值和最小值" class="header-anchor">#</a> 二叉搜索树的最大值和最小值</h3> <h4 id="最大值"><a href="#最大值" class="header-anchor">#</a> 最大值</h4> <p>    二叉搜索树的最大值就是树的最右侧的叶节点。其实就是从_root开始向右搜索，找到他们最右侧的子节点。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 二叉搜索树的最大值
 */</span>
<span class="token keyword">public</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">maxNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 一直往右搜索找最大值
 */</span>
<span class="token keyword">private</span> <span class="token function">maxNode</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token literal-property property">current</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>right <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        current <span class="token operator">=</span> current<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> current<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h4 id="最小值"><a href="#最小值" class="header-anchor">#</a> 最小值</h4> <p>    二叉搜索树的最小值就是树的最左侧的叶节点。其实就是从_root开始向左搜索，找到他们最左侧的子节点。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 二叉搜索树的最小值
 */</span>
<span class="token keyword">public</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 *  一直往左搜索找最小值
 */</span>
<span class="token keyword">private</span> <span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token literal-property property">current</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>current <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>left <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        current <span class="token operator">=</span> current<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> current<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h3 id="二叉搜索树的查找元素"><a href="#二叉搜索树的查找元素" class="header-anchor">#</a> 二叉搜索树的查找元素</h3> <p>    search，在树中查找一个键。如果节点存在，则返回true，否则返回false。从_root开始，使用_compareFn来比较大小，相等就返回true；比_root小的话，从左边搜索，比_root大的话，从右边搜索。又可以使用递归来解决这个问题。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 在树中查找一个键。如果节点存在，则返回true，否则返回false
 */</span>
<span class="token keyword">public</span> <span class="token function">search</span><span class="token punctuation">(</span>key<span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 判断当前节点是否与key相等，如果key小于node.key就向左边迭代查找，大于就向右边查找，相等就返回
 */</span>
<span class="token keyword">private</span> <span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> boolean <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">LESS_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// key比这个node的key小就往左边走</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">BIGGER_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// key比这个node的key大就往右边走</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 直到相同就会返回true</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><h3 id="二叉搜索树的移除元素"><a href="#二叉搜索树的移除元素" class="header-anchor">#</a> 二叉搜索树的移除元素</h3> <p>    二叉搜索树中最复杂的方法remove，因为我们删除树中的某个节点时，可能还存留有它的子节点和子树，我们要考虑用哪个节点来替代它的位置。<br>
    当这个节点没有节点或者单纯只有一个子节点时，很好操作，没有子节点就不用管谁来替代它，只有一个子节点时就用这个子节点（包括子树）来替代它。<br>
    当它同时拥有左侧子节点和右侧子节点时，我们需要找出它右侧子树中最小的节点替代它（也就是值最接近它的节点来替代它）。但问题来了，这个替代的节点可能还有子树，所以我们不能单纯的移过去，需要从这个替代节点的父节点开始往下遍历删除这个替代的节点（也就是再调一次删除方法，来删除这个替代的节点）。
    还有一点需要考虑，删除的这个节点，它的父节点里指向子节点的引用（指针）需要更新，因为你用新元素替代了它的子节点而引用还没更新。实现这点的方式就是，每次在替代完后都需要放回这个新节点，在迭代之前就用父节点里对应的引用来接收这个返回。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 从移除二叉搜索树中的删除一项
 */</span>
<span class="token keyword">public</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更新根节点</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 删除的这项，要考虑它的子节点
 * 如果它的左侧和右侧子节点同时存在就要考虑用谁来替代它原来的位置
 * 目前按照常理，找它后方最接近它的项来替代它的位置，并把“被用来替代的项”也要用removeNode删除
 */</span>
<span class="token keyword">private</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">LESS_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// key比这个node的key小就往左边走</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 左侧子节点可能会变化，更新左侧子节点的引用（指针）</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新父节点的引用（指针）</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">BIGGER_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// key比这个node的key大就往右边走</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 右侧子节点可能会变化，更新右侧子节点的引用（指针）</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新父节点的引用（指针）</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 相等</span>
        <span class="token comment">// 没有左右侧子节点，直接删除</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新父节点的引用（指针）</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 没有右侧子节点，而有左侧子节点，那么将左侧子节点替代它</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新父节点的引用（指针）</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 没有左侧子节点，而有右侧子节点，那么将右侧子节点替代它</span>
            node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
            <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新父节点的引用（指针）</span>
        <span class="token punctuation">}</span>
        <span class="token comment">/*
            * 最特殊的情况，它有左侧子节点也有右侧子节点，删除它的话要选择合适的值替代它
            * 删除一个值一般都是从后面寻找最接近它的项，在二叉搜索树中最接近节点的项就是它右侧节点中最小的那个
            * 替代时，那个“被用来替代的项”也要删除，相当于用removeNode来迭代删除“被用来替代的项”
            */</span>
        <span class="token keyword">const</span> <span class="token literal-property property">aux</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>key <span class="token operator">=</span> aux<span class="token punctuation">.</span>key<span class="token punctuation">;</span> <span class="token comment">// 先替换这个值，下一步去删除引用</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> aux<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从右侧子节点开始删除那个“被用来替代的项”，并更新</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 更新父节点的引用（指针）</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h2 id="平衡二叉树的实现"><a href="#平衡二叉树的实现" class="header-anchor">#</a> 平衡二叉树的实现</h2> <p>    平衡二叉树的实现代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/avl-tree.ts" target="_blank" rel="noopener noreferrer">avl-tree.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h3 id="节点的高度和平衡因子"><a href="#节点的高度和平衡因子" class="header-anchor">#</a> 节点的高度和平衡因子</h3> <p>    节点的高度其实是该节点所形成的子树的高度（而子树的高度是子树上所有节点的深度最大值），一定要与节点的深度区分开来。节点的深度是向上遍历，看有多少层祖先，而节点的高度是向下遍历，看有多少层后代。</p> <p>    平衡因子是某个节点的左侧子树的高度（左侧子节点的高度）和右侧子树（右侧子节点的高度）的差值，在AVL中平衡因子只能是-1, 0, 1超过这些值的话需要旋转平衡。（最快的判断方法就是谁的左右两侧的层数超过了1）</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 计算节点所在树的高度（从上往下计算）
 */</span>
<span class="token keyword">private</span> <span class="token function">getNodeHeight</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> number <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getNodeHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getNodeHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 计算某个节点的平衡因子
 */</span>
<span class="token keyword">private</span> <span class="token function">getBalanceFactor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 左侧子树高度减去右侧子树高度</span>
    <span class="token keyword">const</span> heightDifference <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getNodeHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getNodeHeight</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>heightDifference<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>
            <span class="token keyword">return</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">SLIGHTLY_UNBALANCED_RIGHT</span><span class="token punctuation">;</span> <span class="token comment">// 平衡因子为1，右侧略微不平衡多1层</span>
        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
            <span class="token keyword">return</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">SLIGHTLY_UNBALANCED_LEFT</span><span class="token punctuation">;</span> <span class="token comment">// 平衡因子为1，左侧略微不平衡多1层</span>
        <span class="token keyword">case</span> <span class="token operator">-</span><span class="token number">2</span><span class="token operator">:</span>
            <span class="token keyword">return</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">UNBALANCED_RIGHT</span><span class="token punctuation">;</span> <span class="token comment">// 平衡因子为-2，代表节点的右侧比左侧多2层</span>
        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
            <span class="token keyword">return</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">UNBALANCED_LEFT</span><span class="token punctuation">;</span> <span class="token comment">// 平衡因子为2，代表节点的左侧比右侧多2层</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            <span class="token keyword">return</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">BALANCED</span><span class="token punctuation">;</span> <span class="token comment">// 左右完全平衡</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><h3 id="平衡二叉树的平衡操作"><a href="#平衡二叉树的平衡操作" class="header-anchor">#</a> 平衡二叉树的平衡操作</h3> <p>    向AVL树添加或移除节点后，需要计算出节点平衡因子，然后根据平衡因子来确定是否需要进行平衡操作。</p> <p>    新节点插入后，导致某个节点不平衡（平衡因子的绝对值达到了2），会形成了四种情况：<br>
        1.左-左(LL)：这个新节点是那个不平衡节点的左子树的左子树的叶节点。需要将不平衡节点进行右旋转就可以达到平衡。<br>
        2.右-右(RR)：这个新节点是那个不平衡节点的右子树的右子树的叶节点。需要将不平衡节点进行左旋转就可以达到平衡。<br>
        3.右-左(RL)：这个新节点是那个不平衡节点的右子树的左子树的叶节点。需要将不平衡节点的右节点进行右旋转然后将不平衡节点进行左旋转就可以达到平衡。<br>
        4.左-右(LR)：这个新节点是那个不平衡节点的左子树的右子树的叶节点。需要将不平衡节点的左节点进行左旋转然后将不平衡节点进行右旋转就可以达到平衡。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 左-左形式：需要右旋转
 * 将2插到5的左侧子节点，20那个节点将会不平衡，需要将20那
 * 个节点进行右旋转。15那个节点会挡住20那个节点，那么就需
 * 要先将15那个节点放到20那个节点的左侧子节点上，最后将20
 * 这个节点放到10这个节点的右侧子节点上，这样就完成了右旋
 * 转。
 * --------------------------------------------------
 *        20               10
 *       /  \             /  \
 *      10   25          5    20
 *     / \       ——&gt;    /     / \
 *    5   15           2     15  25
 *   ^
 *  2
 * --------------------------------------------------
 */</span>
<span class="token keyword">private</span> <span class="token function">rotationLL</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 临时保存不平衡节点的左侧子树</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token comment">// node准备右旋转，而temp的right上有多余的节点</span>
    <span class="token comment">// 这个多余的节点可以移到node的left上</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> temp<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token comment">// 完成旋转也就是node会旋转到temp的right上</span>
    temp<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 右-右形式：需要左旋转
 * 将28插到25的右侧子节点，10那个节点将会不平衡，需要将10
 * 那个节点进行左旋转。15那个节点会挡住10那个节点，那么就
 * 需要先将15那个节点放到10那个节点的右侧子节点上，最后将
 * 10这个节点放到20这个节点的左侧子节点上，这样就完成了左
 * 旋转。
 * --------------------------------------------------
 *    10                    20
 *   /  \                  /  \
 *  5   20                10   25
 *      / \       ——&gt;    /  \    \
 *     15  25           5   15    28
 *          ^
 *           28
 * --------------------------------------------------
 */</span>
<span class="token keyword">private</span> <span class="token function">rotationRR</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 临时保存右侧子树（node.right）</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token comment">// node准备左旋转，而temp的left上有多余的节点</span>
    <span class="token comment">// 这个多余的节点可以移到node的right上</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token comment">// 完成旋转也就是node会旋转到temp的left上</span>
    temp<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 左-右形式：先需要左旋转最后需要右旋转
 * 将18插到15的右侧子节点，20那个节点将会不平衡，需要将10
 * 那个节点进行左旋转，最后对20那个节点进行右旋转。
 * --------------------------------------------------
 *      20               20              15
 *     /  \             /  \            /  \
 *    10   25          15   25         10   20
 *   / \       ——&gt;    /  \      ——&gt;   /    /  \
 *  5   15           10  18          5    18   25
 *       ^          /
 *        18       5
 * --------------------------------------------------
 */</span>
<span class="token keyword">private</span> <span class="token function">rotationLR</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对不平衡节点的左侧子节点进行左旋转</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRR</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 对不平衡节点进行右旋转</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 右-左形式：先需要右旋转最后需要左旋转
 * 将13插到15的左侧子节点，10那个节点将会不平衡，需要将20
 * 那个节点进行右旋转，最后对10那个节点进行左旋转。
 * --------------------------------------------------
 *   10               10                  15
 *  /  \             /  \                /  \
 * 5   20           5   15              10   20
 *     / \     ——&gt;      / \     ——&gt;    /  \    \
 *    15  25           13  20         5   13   25
 *    ^                     \
 *   13                      25  
 * --------------------------------------------------
 */</span>
<span class="token keyword">private</span> <span class="token function">rotationRL</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对不平衡节点的右侧子节点进行右旋转</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLL</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 对不平衡节点进行左旋转</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br></div></div><p>    可以思考一下，左-右形式的能不能先右旋转再左旋转？右-左形式的能不能先左旋转再右旋转？</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 左-右形式：先特殊右旋转最后正常左旋转
 * --------------------------------------------------
 *      20            10                 15
 *     /  \          /  \               /  \
 *    10   25       5   15             10   20
 *   / \       ——&gt;     /  \    ——&gt;    /    /  \
 *  5   15            13  20         5    18   25
 *      ^                   \
 *     13                   25
 * --------------------------------------------------
 */</span>
<span class="token keyword">private</span> <span class="token function">specialRotationLR</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 进行特殊右旋转</span>
    node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">specialRotationLL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进行正常左旋转</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token function">specialRotationRL</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 进行特殊左旋转</span>
    node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">specialRotationRR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 进行正常右旋转</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 使用temp.left.left的原因就是，新添的叶节点就在这一层
 * 而且左-右或右-左能保证temp.left不为空，而左-左或右-右
 * 就不能保证temp.left不为空，所以左-左和右-右还是使用的
 * 正常的旋转
 */</span>
<span class="token keyword">private</span> <span class="token function">specialRotationRR</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> temp<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span>left<span class="token punctuation">.</span>left <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">private</span> <span class="token function">specialRotationLL</span><span class="token punctuation">(</span>node<span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> temp <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> temp<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span>right<span class="token punctuation">.</span>right <span class="token operator">=</span> node<span class="token punctuation">;</span>
    <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div><p>    左-右形式的能先右旋转再左旋转；右-左形式的能先左旋转再右旋转。但是没必要，因为这四种情景上有时还得使用正常的旋转，不然它可能会有不平衡的子树。</p> <h3 id="自平衡树的插入节点"><a href="#自平衡树的插入节点" class="header-anchor">#</a> 自平衡树的插入节点</h3> <p>    依然采用递归方法，去找寻适合的位置去插入，插入后新元素刚好在最底端，利用递归+return形式可以反过来检测元素是否平衡，不平衡再进行平衡操作。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 向树中插入一个新的键
 */</span>
<span class="token keyword">public</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_root<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/**
 * 插入一个节点的左侧还是右侧，用比较函数来比较
 * 插入后还需要反过来对node进行平衡检查
 */</span>
<span class="token keyword">protected</span> <span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接return，新键也不需要对这个键作平衡操作</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">LESS_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// key小于node.key</span>
        node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插左边</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">BIGGER_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// key大于node.key</span>
        node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 插右边</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 键重复，无需插入</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 直接return，键重复也不需要对这个键作平衡操作</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> balanceFactor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// node的平衡因子</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">UNBALANCED_LEFT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// node不平衡并且属于左边高</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>left<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">LESS_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 新键在node的左子树的左子树上</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// 新键在node的左子树的右子树上</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">UNBALANCED_RIGHT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// node不平衡并且属于右边高</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_compareFn</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> node<span class="token punctuation">.</span>right<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">===</span> Compare<span class="token punctuation">.</span><span class="token constant">BIGGER_THAN</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 新键在node的右子树的右子树上</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 迭代结合return，反过来对每次的node进行平衡检查</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><h3 id="自平衡树的移除节点"><a href="#自平衡树的移除节点" class="header-anchor">#</a> 自平衡树的移除节点</h3> <p>    在父类的删除基础上添加平衡操作的逻辑。其实跟添加的逻辑也很类似，区别比较大的是在判断是单旋双旋上，新增可以拿新增元素和node的子节点比较，而删除需要判断node的子节点平衡因子来作判断。</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code><span class="token comment">/**
 * 删除元素，重写父类的同名方法，会用到父类的逻辑再新增平衡操作的逻辑
 * 特殊之处：子类super调用父类同名方法，并且父类的那个方法递归调用自身。
 * 调用顺序就是子类removeNode方法——&gt;父类removeNode方法——&gt;递归调用子类
 * removeNode方法——&gt;父类removeNode方法——&gt;递归调用子类的removeNode方法，
 * 循环调用至边界条件。
 */</span>
<span class="token keyword">protected</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">node</span><span class="token operator">:</span> Node<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token literal-property property">key</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span> <span class="token comment">// 空的null不需要平衡</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">const</span> balanceFactor <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">UNBALANCED_LEFT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 左子树不平衡</span>
        <span class="token comment">// 左子树的左节点的平衡因子，如果这个平衡因子是0或者1，代表左子树是左-左型</span>
        <span class="token keyword">const</span> balanceFactorLeft <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactorLeft <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">BALANCED</span> <span class="token operator">||</span>
            balanceFactorLeft <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">SLIGHTLY_UNBALANCED_LEFT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactorLeft <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">SLIGHTLY_UNBALANCED_RIGHT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationLR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactor <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">UNBALANCED_RIGHT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 右子树不平衡</span>
        <span class="token comment">// 右子树的右节点的平衡因子，如果这个平衡因子是0或者1，代表右子树是右-右型</span>
        <span class="token keyword">const</span> balanceFactorRight <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBalanceFactor</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactorRight <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">BALANCED</span> <span class="token operator">||</span>
            balanceFactorRight <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">SLIGHTLY_UNBALANCED_RIGHT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRR</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>balanceFactorRight <span class="token operator">===</span> BalanceFactor<span class="token punctuation">.</span><span class="token constant">SLIGHTLY_UNBALANCED_LEFT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            node <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">rotationRL</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><p><strong>非常推荐去看一下AVL树的测试代码<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/test/ts/data-structures/avl-tree.spec.ts" target="_blank" rel="noopener noreferrer">avl-tree.spec.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，就算不运行它，也可以看一下里面的注释，包含AVL插入删除元素的实际例子推算！</strong></p> <h2 id="红黑树的实现"><a href="#红黑树的实现" class="header-anchor">#</a> 红黑树的实现</h2> <p>    红黑树的实现代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/red-black-tree.ts" target="_blank" rel="noopener noreferrer">red-black-tree.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>    首先我们要明确红黑树的性质：<br> <strong>1.每个节点非黑即红</strong><br> <strong>2.根节点是黑色的</strong><br> <strong>3.空的叶节点都是黑色的</strong><br> <strong>4.如果一个节点是红色的，那么它的父节点和子节点就只能是黑色的，也就是不能有连续的红色节点。</strong><br> <strong>5.任意节点到它后代的叶节点的所有路径上，拥有相同数量的黑色节点。</strong></p> <p>        对第3点解释一下，例如某个值为9的节点没有左子节点，其实9这个节点的左子节点就是个空节点也就是null（有些语言用nil描述的）；那么这个空节点相对于树来说就是空的叶节点。</p> <h3 id="红黑树的插入节点"><a href="#红黑树的插入节点" class="header-anchor">#</a> 红黑树的插入节点</h3> <p>    首先先规定新插入的元素是 <strong>红色</strong> ，插入时可分为以下几个场景：<br> <strong>场景1：红黑树是空树，新元素放到root上，其颜色置为黑色。</strong><br> <strong>场景2：插入的元素已经存在于红黑树了，不用插入该元素。</strong><br> <strong>场景3：新插入元素的父节点是黑色的，那么直接插入，无需进行红黑平衡。</strong> 违反性质5吗？没有，因为新插入的红色节点根本就不影响路径上黑色的数量。例如下图：新添元素9<br> <img src="/blog-vuepress/assets/img/case3.02e2ac77.png" alt="场景3"><br> <strong>场景4：新插入元素的父节点是红色，违反性质4，需要进行红黑平衡。</strong></p> <blockquote><p><strong>场景4.1：叔节点不存在。</strong> 先明确一下，新元素是红色，父节点是红色，那么祖父节点就是黑色，相应的这棵子树对外暴露的是黑色。例如下图：新添元素4，并且没有叔节点<br> <img src="/blog-vuepress/assets/img/case4.1.1.5302462d.png" alt="场景4.1.1"><br>
     方法一：采用对换颜色的方法，将父节点和祖父节点的颜色对调，那新子树对外暴露的是红色节点，这样可能会违反性质4，如果继续对换新的父节点和新的祖父节点的颜色，又违反性质5。例如下图：6和8颜色对换，但是8和10是连续的红色，违反性质4；10和12继续对换，又潍坊性质5.<br> <img src="/blog-vuepress/assets/img/case4.1.2.2bb8bd63.png" alt="场景4.1.2"><br> <strong>方法二：</strong> 其实叔节点为空就类似AVL不平衡场景，那么需要根据对应的情景进行对应的旋转，还要保证旋转前后的顶点颜色要不变（对调父节点和祖父节点的颜色）。这样得到的子树对外暴露的依然是黑色节点，不违反性质4和性质5。例如下面4个图：分别是左-左、左-右、右-右、右-左<br> <img src="/blog-vuepress/assets/img/case4.1.3.e0e68e47.png" alt="场景4.1.3"> <img src="/blog-vuepress/assets/img/case4.1.4.ab182d3e.png" alt="场景4.1.4"> <img src="/blog-vuepress/assets/img/case4.1.5.b14387ad.png" alt="场景4.1.5"> <img src="/blog-vuepress/assets/img/case4.1.6.0ef22a41.png" alt="场景4.1.6"><br> <strong>场景4.2：叔节点存在并且为红色。</strong>  按照以往的经验，直接去旋转再变换颜色。例如下图：最终不管是变色还是10和12都置为黑色，都无法同时满足性质4和性质5<br> <img src="/blog-vuepress/assets/img/case4.2.1.44b1676d.png" alt="场景4.2.1"><br> <strong>所以直接将叔节点这一代与祖父节点对调颜色</strong><br> <img src="/blog-vuepress/assets/img/case4.2.2.e681cb21.png" alt="场景4.2.2"><br> <strong>场景4.3：叔节点存在并且为黑色。</strong> 这个情况比较特殊，它在进行一次平衡后要进行第二次平衡时才可能出现。而解决这种场景的方法，单纯要调换颜色不行还需要旋转才可以，例如下图：<br> <img src="/blog-vuepress/assets/img/case4.3.1.ede9255b.png" alt="场景4.3.1"><br>
不要认为就一种，其实跟4.1场景的第二种方法一样有四种也就是左-左、左-右、右-右、右-左情形。</p></blockquote> <p>纵观这几个场景，其实可以整合一下。<br> <strong>叔节点存在并且为红色</strong>，直接对调父节点这一代和祖父节点的颜色。这课子树是平衡了，但祖父节点相对于其他子树可能还不平衡，需要将视角调到祖父节点上，然后继续检查是否平衡。<br> <strong>叔节点不存在或者叔节点存在并且为黑色</strong>，这两种场景的处理逻辑是一样的，先对调颜色，再进行旋转。这课子树是平衡了，并且相对于其他子树也是平衡的，不需要再继续检查平衡了。</p> <p>    文字和图可能还不懂，需要阅读实现代码<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/red-black-tree.ts" target="_blank" rel="noopener noreferrer">red-black-tree.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的insert方法，并且配上测试代码<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/test/ts/data-structures/red-black-tree.spec.ts" target="_blank" rel="noopener noreferrer">red-black-tree.spec.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一起阅读最好。</p> <h3 id="红黑树的移除节点"><a href="#红黑树的移除节点" class="header-anchor">#</a> 红黑树的移除节点</h3> <p>    先不忙讨论黑红树的移除，先回顾一下 <strong>二叉树的移除</strong> 。二叉树的移除最后归结为三种情形：<br> <strong>情形1：</strong> 待删除节点下没有子节点，那么删除它以后，没有节点可以补上它的位置。<br> <strong>情形2：</strong> 待删除节点下只有一个子节点，那么删除它以后，那个子节点会补上它的位置。<br> <strong>情形3：</strong> 待删除节点下同时拥有左右子节点，那么删除它以后，会从右子树中找最小值节点补上它的位置，并会从右子树中删除那个最小值节点，这又会是新一轮删除（<strong>递归</strong>），但它有边界条件，它最终还是会落到前两种情形里。</p> <hr> <p>    红黑树既然是继承自二叉树，那么它移除节点时也是上述三种情形，只是我们需要结合 <strong>红黑树的性质</strong> 来讨论。</p> <blockquote><p><strong>情形1：</strong> 待删除节点下没有子节点，那么删除它以后，没有节点可以补上它的位置。</p> <blockquote><p><strong>待删除节点可以是黑色也可以是红色。</strong><br> <strong>如果是红色，删除时不会导致红黑树失衡；如果是黑色，删除时会导致红黑树失衡。</strong><br>
如下图：17、13被删除<br> <img src="/blog-vuepress/assets/img/caseDe1.73ea3f6d.png" alt="caseDe1"></p></blockquote> <p><strong>情形2：</strong> 待删除节点下只有一个子节点，那么删除它以后，那个子节点会补上它的位置。</p> <blockquote><p>    由于只有一个子节点，根据红黑树性质5，<strong>这个子节点必然是红色的</strong>；又结合性质4，<strong>待删除节点必然是黑色的，并且那个红色子节点也必然没有后代。</strong><br> <strong>删除时，红色子节点会补到被删除位置，颜色不变只替换数值，也不会影响平衡。最后再删除那个红色节点，相当于回到了情形1。</strong><br>
如图：17被删除<br> <img src="/blog-vuepress/assets/img/caseDe2.66de91b6.png" alt="caseDe2"></p></blockquote> <p><strong>情形3：</strong> 待删除节点下同时拥有左右子节点，那么删除它以后，会从右子树中找最小值节点补上它的位置（<strong>颜色不变只替换数值</strong>），并会从右子树中删除那个最小值节点，这又会是新一轮删除（<strong>递归</strong>），但它有边界条件，<strong>它最终还是会落到前两种情形里。</strong><br>
如下图：删除17，18会补上来，最后一轮删除其实就是情形1<br> <img src="/blog-vuepress/assets/img/caseDe3.a1b6b886.png" alt="caseDe3"></p></blockquote> <p>    初步结论：红黑树的情形3和情形2最终都会变成情形1，所以只需要研究情形1即可。而情形1中只需要对“<strong>待删除节点是黑色</strong>”这种情况进行讨论，要怎样处理才能让它恢复红黑平衡。</p> <hr> <p>    我们需要对兄弟节点颜色进行分情况讨论，如下图：<br> <img src="/blog-vuepress/assets/img/caseDe4.24aa6062.png" alt="caseDe4"></p> <blockquote><p><strong>大致思路：</strong><br>
    节点删除后，兄弟节点这边会 <strong>多一层黑色</strong>，正常情况下，我们会先将兄弟节点这边的子节点这一层的 <strong>红色节点变为黑色节点</strong>，那么就 <strong>多出两层黑色的</strong>；那么再 <strong>将多出的其中一层黑色通过旋转借给删除节点那边</strong>，一般就会达到平衡了（<strong>新旧顶点颜色要一致</strong>）。<br>
    但是 <strong>如果借过去的是一层红色（兄弟节点是红色）怎么办</strong>？不能再用“多出两层黑色”这种办法了，红色的借过去的同时其实兄弟节点的子节点也被借过去了，并且也是比删除节点那边多一层黑色，其实又回到这个问题了！<strong>用递归，直到借过去的是黑色就可以平衡了。</strong></p> <p><strong>看图理解：</strong><br> <img src="/blog-vuepress/assets/img/caseDe4.1.535019c4.png" alt="caseDe4.1"><br> <img src="/blog-vuepress/assets/img/caseDe4.2.1.1649e5ad.png" alt="caseDe4.2.1"><br> <img src="/blog-vuepress/assets/img/caseDe4.2.2.34d59fa7.png" alt="caseDe4.2.2"><br> <strong>归纳总结：</strong></p> <blockquote><p><strong>场景1：红黑树是空树或者找不到要删除的元素，那就无需删除</strong>。<br> <strong>场景2：删除的节点是根节点或者是红色节点，那就直接删除它，无需作红黑平衡</strong>。<br> <strong>场景3：删除的节点是黑色节点，需要作红黑平衡</strong>。<br> <strong>场景3.1：其兄弟节点为黑色，并且兄弟节点有至少一个红色子节点</strong>。将其中一个红色子节点变为黑色，对调兄弟节点和父节点的颜色，再旋转黑色借给“轻”的那一边。<br> <strong>场景3.2：其兄弟节点为黑色，并且兄弟节点下没有子节点或者有两个黑色子节点</strong>。如果父节点为红色，直接对调兄弟节点和父节点的颜色。如果父节点为黑色，将兄弟节点变为红色，再以父节点为视角，重复“场景3”的处理。<br> <strong>场景3.3：其兄弟节点为红色</strong>。先旋转，再以新的子树作为视角，重复“场景3”的处理。</p></blockquote></blockquote> <hr> <p>    文字和图可能还不懂，需要阅读实现代码<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/red-black-tree.ts" target="_blank" rel="noopener noreferrer">red-black-tree.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的remove方法，并且配上测试代码<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/test/ts/data-structures/red-black-tree.spec.ts" target="_blank" rel="noopener noreferrer">red-black-tree.spec.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一起阅读最好。</p> <hr></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/6/2022, 3:41:21 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-vuepress/book-web/数据结构与算法/7.递归.html" class="prev">
        7.递归
      </a></span> <span class="next"><a href="/blog-vuepress/book-web/数据结构与算法/9.二叉堆和堆排序.html">
        9.二叉堆和堆排序
      </a>
      →
    </span></p></div> </main> <div class="right-sidebar-wrapper right-sidebar-hidden"><aside class="right-sidebar"><ul><h4>本文目录</h4></ul></aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div></div><div class="global-ui"></div></div>
    <script src="/blog-vuepress/assets/js/app.0d2e1fde.js" defer></script><script src="/blog-vuepress/assets/js/2.a046c74e.js" defer></script><script src="/blog-vuepress/assets/js/8.f87272cd.js" defer></script>
  </body>
</html>
