<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>11.排序和搜索算法 | Liawn&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <meta charset="UTF-8">
  <link rel="icon" href="/blog-vuepress/favicon.ico">
    <meta name="description" content="用vuepress搭建的个人博客">
    <meta charset="UTF-8">
    
    <link rel="preload" href="/blog-vuepress/assets/css/0.styles.5c52d671.css" as="style"><link rel="preload" href="/blog-vuepress/assets/js/app.0d2e1fde.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/2.a046c74e.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/18.f4fea388.js" as="script"><link rel="prefetch" href="/blog-vuepress/assets/js/10.88d5532b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/100.a282e1e5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/101.1917817b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/102.426bef2e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/103.24a96e53.js"><link rel="prefetch" href="/blog-vuepress/assets/js/104.0b4b8196.js"><link rel="prefetch" href="/blog-vuepress/assets/js/105.98db5522.js"><link rel="prefetch" href="/blog-vuepress/assets/js/106.7a39c799.js"><link rel="prefetch" href="/blog-vuepress/assets/js/11.78e26b31.js"><link rel="prefetch" href="/blog-vuepress/assets/js/12.e39a10a3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/13.da0e53c1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/14.91a6c713.js"><link rel="prefetch" href="/blog-vuepress/assets/js/15.b9f3c2f3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/16.01c98a8e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/17.e733ec41.js"><link rel="prefetch" href="/blog-vuepress/assets/js/19.1d376bae.js"><link rel="prefetch" href="/blog-vuepress/assets/js/20.4751d85a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/21.00437d3b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/22.64839502.js"><link rel="prefetch" href="/blog-vuepress/assets/js/23.7a4335d7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/24.3ee2b263.js"><link rel="prefetch" href="/blog-vuepress/assets/js/25.0767dbc8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/26.c416d882.js"><link rel="prefetch" href="/blog-vuepress/assets/js/27.5e82d924.js"><link rel="prefetch" href="/blog-vuepress/assets/js/28.24de79c4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/29.5a1e4f8e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/3.0b0dd8a7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/30.3c71597f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/31.f5f5fe9d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/32.eac572f0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/33.660b2af0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/34.b6f9bd89.js"><link rel="prefetch" href="/blog-vuepress/assets/js/35.2e5e8650.js"><link rel="prefetch" href="/blog-vuepress/assets/js/36.04d6e910.js"><link rel="prefetch" href="/blog-vuepress/assets/js/37.4ffc07ec.js"><link rel="prefetch" href="/blog-vuepress/assets/js/38.f31deb49.js"><link rel="prefetch" href="/blog-vuepress/assets/js/39.5bd11cdb.js"><link rel="prefetch" href="/blog-vuepress/assets/js/4.6edbb2a1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/40.c0dc0955.js"><link rel="prefetch" href="/blog-vuepress/assets/js/41.32840955.js"><link rel="prefetch" href="/blog-vuepress/assets/js/42.afdf16b6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/43.04bbcb6b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/44.3f372036.js"><link rel="prefetch" href="/blog-vuepress/assets/js/45.199528f2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/46.c23ffbe2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/47.33bc80d6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/48.c17f8a84.js"><link rel="prefetch" href="/blog-vuepress/assets/js/49.9f6c2490.js"><link rel="prefetch" href="/blog-vuepress/assets/js/5.c6c641ea.js"><link rel="prefetch" href="/blog-vuepress/assets/js/50.d6762688.js"><link rel="prefetch" href="/blog-vuepress/assets/js/51.1b65f46c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/52.d00b4d17.js"><link rel="prefetch" href="/blog-vuepress/assets/js/53.becdeb67.js"><link rel="prefetch" href="/blog-vuepress/assets/js/54.fe84cbfc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/55.42ca78e9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/56.38dc1cb5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/57.f4964e37.js"><link rel="prefetch" href="/blog-vuepress/assets/js/58.9b4d0044.js"><link rel="prefetch" href="/blog-vuepress/assets/js/59.cfb9c546.js"><link rel="prefetch" href="/blog-vuepress/assets/js/6.c6de6921.js"><link rel="prefetch" href="/blog-vuepress/assets/js/60.4f4f3658.js"><link rel="prefetch" href="/blog-vuepress/assets/js/61.e691fcda.js"><link rel="prefetch" href="/blog-vuepress/assets/js/62.fd6c77be.js"><link rel="prefetch" href="/blog-vuepress/assets/js/63.9acec8fc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/64.c6c33b9e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/65.30e05c43.js"><link rel="prefetch" href="/blog-vuepress/assets/js/66.fdb85611.js"><link rel="prefetch" href="/blog-vuepress/assets/js/67.4a8c9b0e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/68.cf4c210b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/69.b27adaff.js"><link rel="prefetch" href="/blog-vuepress/assets/js/7.4196f4e6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/70.a3316969.js"><link rel="prefetch" href="/blog-vuepress/assets/js/71.9eb46133.js"><link rel="prefetch" href="/blog-vuepress/assets/js/72.0fe4fe9a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/73.0bf36b4a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/74.fc2e628a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/75.205b56bf.js"><link rel="prefetch" href="/blog-vuepress/assets/js/76.8c2bf9b9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/77.a0993252.js"><link rel="prefetch" href="/blog-vuepress/assets/js/78.41709f17.js"><link rel="prefetch" href="/blog-vuepress/assets/js/79.c8733b25.js"><link rel="prefetch" href="/blog-vuepress/assets/js/8.f87272cd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/80.f5ed5113.js"><link rel="prefetch" href="/blog-vuepress/assets/js/81.ddb61980.js"><link rel="prefetch" href="/blog-vuepress/assets/js/82.1d3482a9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/83.a28d44e2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/84.ce75ed5e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/85.d4ffd27c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/86.14ffaf35.js"><link rel="prefetch" href="/blog-vuepress/assets/js/87.482be605.js"><link rel="prefetch" href="/blog-vuepress/assets/js/88.c1035bd5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/89.e739598f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/9.0f96b506.js"><link rel="prefetch" href="/blog-vuepress/assets/js/90.5a928d71.js"><link rel="prefetch" href="/blog-vuepress/assets/js/91.82d05736.js"><link rel="prefetch" href="/blog-vuepress/assets/js/92.8c0f11ee.js"><link rel="prefetch" href="/blog-vuepress/assets/js/93.5cff49c0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/94.8ad61574.js"><link rel="prefetch" href="/blog-vuepress/assets/js/95.f849a0b0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/96.31401883.js"><link rel="prefetch" href="/blog-vuepress/assets/js/97.98310d37.js"><link rel="prefetch" href="/blog-vuepress/assets/js/98.f626e78b.js"><link rel="prefetch" href="/blog-vuepress/assets/js/99.6891a17b.js">
    <link rel="stylesheet" href="/blog-vuepress/assets/css/0.styles.5c52d671.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><a href="/blog-vuepress/" class="home-link router-link-active"><!----> <span class="site-name">Liawn's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav></div></header> <div class="sidebar-wrapper sidebar-hidden"><aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>web前端</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习JavaScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习CSS/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习CSS</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习TypeScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习TypeScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习Vue/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习Vue</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习React/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习React</span></a> <!----></section></li><li><a href="/blog-vuepress/book-web/web前端js框架/学习jQuery.html" class="sidebar-link">jQueryNote</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/LayaBox游戏引擎/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>H5游戏引擎Laya</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><!----> <span>数据结构与算法</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/数据结构与算法/" class="sidebar-heading clickable open"><span class="arrow down"></span> <span>数据结构与算法ts版</span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/数据结构与算法/1.环境搭建.html" class="sidebar-link">1.环境搭建</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/2.栈.html" class="sidebar-link">2.栈</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/3.队列.html" class="sidebar-link">3.队列</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/4.链表.html" class="sidebar-link">4.链表</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/5.集合.html" class="sidebar-link">5.集合</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/6.字典和散列表.html" class="sidebar-link">6.字典和散列表</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/7.递归.html" class="sidebar-link">7.递归</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/8.树.html" class="sidebar-link">8.树</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/9.二叉堆和堆排序.html" class="sidebar-link">9.二叉堆和堆排序</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/10.图.html" class="sidebar-link">10.图</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/11.排序和搜索算法.html" class="active sidebar-link">11.排序和搜索算法</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/12.算法设计与技巧.html" class="sidebar-link">12.算法设计与技巧</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/13.算法复杂度.html" class="sidebar-link">13.算法复杂度</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>常用工具</span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/常用工具/Npm的使用.html" class="sidebar-link">Npm的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Git的使用.html" class="sidebar-link">Git的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/webpack的使用.html" class="sidebar-link">webpack的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/VSCode的使用.html" class="sidebar-link">VSCode的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Chrome的使用.html" class="sidebar-link">Chrome的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用docsify写blog.html" class="sidebar-link">使用docsify写blog</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用gitbook写blog.html" class="sidebar-link">使用gitbook写blog</a></li><li><a href="/blog-vuepress/book-web/web前端测试与调试/基于mocha+chai的单元测试.html" class="sidebar-link">使用mocha+chai进行单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>简单项目实践</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/项目/react+express+ts写爬虫/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>react+express+ts写爬虫</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>面试准备</span></p> <!----></section></li></ul> </aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div> <main class="page sidebar-hidden right-sidebar-hidden"> <div class="theme-default-content content__default"><h1 id="排序和搜索算法"><a href="#排序和搜索算法" class="header-anchor">#</a> 排序和搜索算法</h1> <h2 id="排序算法"><a href="#排序算法" class="header-anchor">#</a> 排序算法</h2> <h3 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h3> <p>    冒泡排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/bubble-sort.ts" target="_blank" rel="noopener noreferrer">bubble-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>冒泡排序(bubble-sort)</strong>：每轮都比较数组里相邻两项，如果左项大于右项就交换彼此，目的是每轮都让最大的移到数组末尾，所有轮结束后数组就是升序排序的了（降序是将最小移到末尾）。</p> <p>    值得注意的是，在每轮都将最大的冒泡到末尾后，在下一轮时是无需再处理末尾项了，所以在内部循环时要记得减去 i 。还有就是如果某轮里，没有交换过左右项，那么可以提前退出算法，因为上一轮排完凑巧就排完了。</p> <p>    平均、最差场景的时间复杂度是O(n^2)，最好情况是O(n)；空间复杂度是O(1)，相邻项交换是常量级的临时空间。<br> <img src="/blog-vuepress/assets/img/bubble-sort.3ee15c0a.png" alt="bubble-sort"></p> <h3 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h3> <p>    选择排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/selection-sort.ts" target="_blank" rel="noopener noreferrer">selection-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>选择排序(selection-sort)</strong>：每轮从数组里选一个比目标项小并且是最小的项（剩余项里最小的），记住它的下标，在每轮结束时交换目标项与该项的值，所有轮结束后数组就是升序的了。</p> <p>    值得注意的是，在每轮都找出比目标项小的项，这个项还要在剩余项里最小，所以每轮的j都是从i+1开始的，还要记住最小项的索引。</p> <p>    选择排序与冒泡排序的相同点：都是比较当前项和目标项的大小，并且每轮都让最大或最小项移到数组的一边。其实就是从剩余项中找出最大或最小项，然后排到数组的一端。<br>
    选择排序与冒泡排序的不同点：冒泡排序是一直交换当前项和目标项以达到目的；选择排序是记住最大或最小项的位置，到一轮快结束时才交换以达到目的。<br>
    两者核心思想相似，但处理手段不同，这也决定它们的最差、平均时间复杂度都是O(n^2)，空间复杂度都是O(1)。而选择排序的最好时间复杂度还是O(n^2)不能提前退出，因为它减少了交换次数。<br> <img src="/blog-vuepress/assets/img/selection-sort.a1b6fe79.png" alt="selection-sort"></p> <h3 id="插入排序"><a href="#插入排序" class="header-anchor">#</a> 插入排序</h3> <p>    插入排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/insertion-sort.ts" target="_blank" rel="noopener noreferrer">insertion-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>    与冒泡和选择两种排序不同的是，<strong>插入排序(insertion-sort)</strong> 不会从剩余项中找最大或最小项放入数组一端，它是每轮从剩余项中随意取一项（默认取第一个），将它与排好序的项进行比较，然后放入适当的位置；一直到剩余项都处理完。</p> <p>    可以说插入排序是反其道而行，随意从剩余项中取一项然后按顺序插入已排序列表里，例如插扑克牌。最差、平均时间复杂度是O(n^2)，最好情况是O(n)；空间复杂度是O(1)。<br> <img src="/blog-vuepress/assets/img/insertion-sort.33004ae1.png" alt="insertion-sort"></p> <h3 id="希尔排序"><a href="#希尔排序" class="header-anchor">#</a> 希尔排序</h3> <p>    希尔排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/shell-sort.ts" target="_blank" rel="noopener noreferrer">shell-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>希尔排序(shell-sort)</strong>：先取一个增量k（可以是数组长度的一半，也可以是更好的增量取法），对数组里所有互相隔k距离的元素进行插入排序；下一轮将增量折半（或者更好增量取法），重复之前的步骤，直到增量为1（最后一个增量必须为1）并执行完插入排序后结束整个算法。</p> <p>    折半式增量是最先提出来的，其最好情况下的时间复杂度为O(n)，平均时间复杂度为O(n^(1.3))，最坏时间复杂度是O(n^2)。</p> <p>    Hibbard在1963年提出的[1, 3, 7, ..., 2^n-1]这样的增量序列，特点是没有公因子。其最坏时间复杂度是O(n^(3/2))，其平均时间复杂度被模拟出来是O(n^(5/4))。</p> <p>    Sedgewick在1982年提出[1, 8, 23, 77, 281, 1073, 4193, 16577...]，除了第一项的通项公式：4 * 2^(2 * i) + 3 * 2^i + 1（其中i为0,1,2,3,4...）；又在1986年提出[1, 5, 19, 41, 109, ...]（偶数项的通项公式：9 * 2^i - 9 * 2^(i/2) + 1，奇数项的通项公式：8 * 2^i - 6 * 2^((i+1)/2) + 1）。Sedgewick提出的几种，最坏情形时间复杂度是O(n^(4/3))，平均时间复杂度猜测在O(n^(7/6))，要比Hibbard好很多</p> <p>    希尔排序是基于插入排序的，它没有快速排序快（如果有合适的增量序列，在小规模数组中将会比堆排序、快速排序快），但在中等规模表现良好，涉及到大规模数据将不如快速排序。有一个在大规模数据中表现优异的增量序列是（斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)<br> <img src="/blog-vuepress/assets/img/shell-sort.b054ac91.png" alt="shell-sort"></p> <h3 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h3> <p>    归并排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/merge-sort.ts" target="_blank" rel="noopener noreferrer">merge-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>归并排序(merge-sort)</strong> 跟冒泡、选择、插入三种排序方式区别很大，它运用了分而治之的思想。一直将数组分割成长度近似的两段，直到长度为1不可分割；再将其一一合并，归并的过程中会将左右两边的元素进行依次排序（从左右分别拿一项进行比较，排好序放入新数组，直到左右其中一个里元素被取完，而剩余的也会被连接到新数组），最后合并得到的新数组就是排好序的数组。</p> <p>    最差、平均、最好时间复杂度都是O(nlogn)；空间复杂度是O(n)，因为在每次合并的过程中都使用了一个临时数组存储。<br> <img src="/blog-vuepress/assets/img/merge-sort.83bfef3d.png" alt="merge-sort"></p> <h3 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h3> <p>    快速排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/quick-sort.ts" target="_blank" rel="noopener noreferrer">quick-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>快速排序(quick-sort)</strong>：将数组分隔成两段，分隔时会对数组进行简单排序，将较小项移到分隔点左边，对应右边是较大项。但由于左右两边里面也没顺序，那将左右两边也进行分隔处理，直到不能再分隔，这样使得每个小段都有了顺序，进而整段也是有了顺序。<br>
    这样看来快速排序也是分而治之的一种应用，跟归并排序很像，两者区别就是：一个是分开时简单分类（大致顺序）后面直接合并， 另一个是分开时不处理后面合并时再排序。</p> <p>    快速排序的空间复杂度都是O(1)，没有每轮借助临时数组；快速排序的最好、平均时间复杂度都是O(nlogn)；最差时间复杂度是O(n^2)，因为当数组原本是降序的，要求排成升序的，并且基准点取的是最左边时，算出的下一轮的基准点还是最左边（一般返回给下一轮的应该是中间点），这就导致它没有了左右两边数组的递归了，而是就是它本身去排序了，退化成n^2这样的排序了。<br> <img src="/blog-vuepress/assets/img/quick-sort.b4c7e55e.png" alt="quick-sort"></p> <h3 id="计数排序"><a href="#计数排序" class="header-anchor">#</a> 计数排序</h3> <p>    计数排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/counting-sort.ts" target="_blank" rel="noopener noreferrer">counting-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>计数排序(counting-sort)</strong>：目标数组有n个元素，其中最大值为k；先构造一个长度为k+1的统计数组，这个统计数组的索引对应着目标数组里的元素值；然后去统计目标数组里每个元素出现的次数，存储到统计数组对应索引上（次数分布到统计数组里）；最后遍历统计数组，将其索引当作新项加到新数组里，而“次数”是有几次就给新数组加同样的项几次。</p> <p>    值得注意的是，此方法很局限，它适合对小范围的非负整数的数组进行排序；当n不大而k很大时，是不适合使用计数排序的，因为会导致统计数组的长度过长。</p> <p>    计数排序的空间复杂度是O(n+k)，因为它额外使用了一个k+1长的统计数组。平均的时间复杂度是O(n+k)，最后由统计数组到新数组时，先遍历了k次，再此基础上还总共遍历了n次插入重复值；当k=n时也就是最好时间复杂度是O(n)；当k远大于n，而n很小，主要依赖于k，所以最差时间复杂度是O(k)。<br> <img src="/blog-vuepress/assets/img/counting-sort.14be5845.png" alt="counting-sort"></p> <h3 id="桶排序"><a href="#桶排序" class="header-anchor">#</a> 桶排序</h3> <p>    桶排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/bucket-sort.ts" target="_blank" rel="noopener noreferrer">bucket-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>桶排序(bucket-sort)</strong>：跟计数排序类似，只是我们准备的不是统计数组，而是桶这样的二维数组；遍历目标数组，将每个元素按照大小分配到对应的桶里（将元素分布到桶里）；所有元素遍历完后，桶之间是有顺序的但桶内部是没有顺序的，这里我们就需要对桶内部进行排序，一般选择快速排序或插入排序；每个桶都排完序后，将桶合并就会得到排好序的数组。</p> <p>    尽量将n个数据平均分配到k个桶中，这样每个桶就有n/k个数据量；尽量的增大桶的数量，极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的排序操作。当然，做到这一点很不容易，数据量巨大的情况下，会使得桶的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p> <p>    对于n个待排数据，k个桶，平均每个桶n/k个数据这样情景的平均时间复杂度为：O(n)+O(k*(n/k)*log(n/k))=O(n+nlog(n/k))。当k=n时，是最好效率的排序，也就是最好时间复杂度是O(n)。空间复杂度是O(n+k)<br> <img src="/blog-vuepress/assets/img/bucket-sort.6ffa024a.png" alt="bucket-sort"></p> <h3 id="基数排序"><a href="#基数排序" class="header-anchor">#</a> 基数排序</h3> <p>    基数排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/radix-sort.ts" target="_blank" rel="noopener noreferrer">radix-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>基数排序(radix-sort)</strong>：一种特殊的桶排序，主要是对整数或字符串的每一位进行排序，可以从低位开始也可以从高位开始；桶的数量（基数）就是一个数的进制数。例如数组是十进制整数的，那么桶数（基数）就是10，分别是从0到9这样的10个桶；然后依次从个位、十位、百位、千位这样从低到高进行每一轮排序，结束后每位上都是相对有序的，整体上也是有序的。</p> <p>    如果数组里的元素是位数比较多的整数，那么就适合从高位开始排，位数比较低的就适合从低位开始排；时间空间复杂度都是O(n*k)，k是元素的位数。<br> <img src="/blog-vuepress/assets/img/radix-sort.5061d0d2.png" alt="radix-sort"></p> <h3 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h3> <p>    在前面章节已经说过了：<a href="/blog-vuepress/book-web/数据结构与算法/9.二叉堆和堆排序.html">堆排序</a></p> <h2 id="搜索算法"><a href="#搜索算法" class="header-anchor">#</a> 搜索算法</h2> <h3 id="顺序搜索-线性搜索"><a href="#顺序搜索-线性搜索" class="header-anchor">#</a> 顺序搜索（线性搜索）</h3> <p>    顺序搜索（线性搜索）代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/search/sequential-search.ts" target="_blank" rel="noopener noreferrer">sequential-search.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>顺序搜索（线性搜索）</strong>：遍历该线性数据结构，将每个元素和要找的元素一一进行对比，如果相同就立即返回结果，不同就继续查找。</p> <h3 id="二分搜索"><a href="#二分搜索" class="header-anchor">#</a> 二分搜索</h3> <p>    二分搜索代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/search/binary-search.ts" target="_blank" rel="noopener noreferrer">binary-search.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>二分搜索</strong>：<br>
        1.在待选区间里选择中间值，如果中间值就是待搜索值，就直接返回；<br>
        2.如果待搜索值比中间值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复步骤1；<br>
        3.如果待搜索值比中间值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复步骤1。</p> <h3 id="内插搜索"><a href="#内插搜索" class="header-anchor">#</a> 内插搜索</h3> <p>    内插搜索代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/search/interpolation-search.ts" target="_blank" rel="noopener noreferrer">interpolation-search.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>内插搜索</strong>：改良版的二分搜索，要在步骤1中使用一个特殊公式去选定一个值。<br>
        1.在待选区间里利用公式选定一个值，如果选定值就是待搜索值，就直接返回；<br>
        2.如果待搜索值比选定值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复之前步骤；<br>
        3.如果待搜索值比选定值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复之前步骤。</p> <p>    公式是这样的，先算出搜索值在“max和min的差值”的“占比”，再将“max的索引和min的索引的差值”乘以这个“占比”，就可以大致推断出搜索值的索引。</p> <h2 id="随机算法"><a href="#随机算法" class="header-anchor">#</a> 随机算法</h2> <h3 id="fisher-yates随机"><a href="#fisher-yates随机" class="header-anchor">#</a> Fisher-Yates随机</h3> <p>    Fisher-Yates随机代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/shuffle/fisher%E2%80%93yates.ts" target="_blank" rel="noopener noreferrer">fisher–yates.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>Fisher-Yates随机</strong>：从最后一项开始并将当前位置和一个随机位置进行交换，这个随机位置要比当前位置小。</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/6/2022, 3:41:21 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-vuepress/book-web/数据结构与算法/10.图.html" class="prev">
        10.图
      </a></span> <span class="next"><a href="/blog-vuepress/book-web/数据结构与算法/12.算法设计与技巧.html">
        12.算法设计与技巧
      </a>
      →
    </span></p></div> </main> <div class="right-sidebar-wrapper right-sidebar-hidden"><aside class="right-sidebar"><ul><h4>本文目录</h4></ul></aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div></div><div class="global-ui"></div></div>
    <script src="/blog-vuepress/assets/js/app.0d2e1fde.js" defer></script><script src="/blog-vuepress/assets/js/2.a046c74e.js" defer></script><script src="/blog-vuepress/assets/js/18.f4fea388.js" defer></script>
  </body>
</html>
