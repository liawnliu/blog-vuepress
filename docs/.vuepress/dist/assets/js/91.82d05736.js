(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{714:function(t,e,r){"use strict";r.r(e);var a=r(13),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),r("h2",{attrs:{id:"背景"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),r("blockquote",[r("p",[t._v("要存储多个元素，数组（或列表）可能是最常用的数据结构。它非常方便，提供了[]语法来访问其元素。但它有个缺点：（在大多数语言中）数组的大小是固定的，并且从数组的起点或中间插入或移除项的成本很高，因为需要移动元素。（尽管有来自Array类方法可以帮助我们做这些事，但背后的情况同样如此）——"),r("a",{attrs:{href:"https://www.ituring.com.cn/book/2653",target:"_blank",rel:"noopener noreferrer"}},[t._v("《学习JavaScript数据结构与算法》"),r("OutboundLink")],1)])]),t._v(" "),r("h2",{attrs:{id:"链表数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表数据结构"}},[t._v("#")]),t._v(" 链表数据结构")]),t._v(" "),r("p",[t._v("    链表(LinkedList)是一个数据元素按照链式存储结构进行存储的并且逻辑结构上符合一般线性表特性的数据结构。它的数据元素由一个存储元素本身的节点和一个指向下一个元素的引用（指针）组成的（因此形成了元素之间的一对一的关系，也就是线性结构特性）。")]),t._v(" "),r("p",[t._v("    它相对于数组的好处是，添加或移除元素的时候不需要移动其他元素。但是链表需要使用指针，并且访问链表中的元素需要从起点（链表首部）开始迭代至你需要的元素。")]),t._v(" "),r("h2",{attrs:{id:"栈、队列与链表的区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈、队列与链表的区别"}},[t._v("#")]),t._v(" 栈、队列与链表的区别")]),t._v(" "),r("p",[t._v("    在逻辑结构上，他们都具有线性结构也就是线性表的特性（有唯一的前驱和后继），栈和队列属于受限线性表（受限表示对结点的操作受限制），而链表属于一般线性表（也就是不受限）。"),r("br"),t._v("\n    在存储结构上，栈和队列是顺序存储结构，也就是用一组地址连续的存储单元依次存储线性表中的数据元素；而链表就不一样了，它是链式存储结构，也就是用一组任意的存储单元存储线性表中的数据元素（可连续也可不连续）。")]),t._v(" "),r("h2",{attrs:{id:"链表的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链表的实现"}},[t._v("#")]),t._v(" 链表的实现")]),t._v(" "),r("p",[t._v("    链表的实现代码细节："),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/linked-list.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("linked-list.ts"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("    1.需要准备一个助手类"),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/models/linked-list-models.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("Node"),r("OutboundLink")],1),t._v("，这个助手类有两个属性，一个是本身的值，另一个是指向下一个Node的指针。")]),t._v(" "),r("p",[t._v("    2.声明一个protected级别的变量head，用于追踪首部元素；声明一个count用于记录链表的大小；声明一个equalsFn，保存实例化时传来的“比较函数”。")]),t._v(" "),r("p",[t._v("    3.返回链表中特定位置的元素getElementAt："),r("br"),t._v("\n        从head首部元素开始向后遍历，直到遍历到指定位置就返回这个位置的项，当然如果当前项是空的自然就中断遍历返回空结果。")]),t._v(" "),r("p",[t._v("    4.返回元素在链表中的索引indexOf："),r("br"),t._v("\n        从head首部元素开始向后遍历，直到当前项与目标项通过equalsFn对比结果为相同时结束遍历并返回当前项的索引，遍历完都没找到相同的话就返回-1，当然如果当前项是空的自然就中断遍历返回-1。")]),t._v(" "),r("p",[t._v("    5.往链表尾部添加元素push："),r("br"),t._v("\n        链表为空时，添加的新元素就是head首部元素；链表不为空时，需要将新元素追加到尾部，用迭代的方式（getElementAt方法）拿到尾部元素（node.next为空时代表node就是尾部元素）。最后记得更新count的值。")]),t._v(" "),r("p",[t._v("    6.从链表中移除元素removeAt："),r("br"),t._v("\n        和push类似，当链表只有一个元素时只需把head清空；当链表元素多于一个时，需要迭代（getElementAt方法）到指定位置再将其移除，移除后还要把它的next与它的上一个位置连接起来，保证移除一个元素后链表是完整的。"),r("br"),t._v("\n        扩展：用indexOf和removeAt配合可以组成新的移除方法，就是移除与指定项相同的元素（目前只能移除一个）。")]),t._v(" "),r("p",[t._v("    7.往链表首部添加元素unshift："),r("br"),t._v("\n        链表为空时，添加的新元素就是head首部元素；链表不为空时，需要将新元素的next指向head，然后再把新元素赋给head以完成新元素与链表的连接。最后记得更新count的值。")]),t._v(" "),r("p",[t._v("    8.往链表中特定位置插入一个新元素insert："),r("br"),t._v("\n        要放到第一个位置时，其实就是调用unshift；其他情况，需要拿到指定位置的前一个位置的元素，并把这个元素的next赋给新元素，再让这个元素的next指向新元素，以完成链表的连接。最后记得更新count的值。")]),t._v(" "),r("p",[t._v("    9.链表的其他方法isEmpty、size、clear、toString很好实现。")]),t._v(" "),r("h2",{attrs:{id:"双向链表数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向链表数据结构"}},[t._v("#")]),t._v(" 双向链表数据结构")]),t._v(" "),r("p",[t._v("    双向链表(DoublyLinkedList)是一个特殊的链表。区别就是它的数据元素由一个存储元素本身的节点、一个指向下一个元素的引用、一个指向上一个元素的引用组成的。也就是说双向链表拥有双向的引用，而链表拥有单向的引用。")]),t._v(" "),r("h2",{attrs:{id:"双向链表的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向链表的实现"}},[t._v("#")]),t._v(" 双向链表的实现")]),t._v(" "),r("p",[t._v("    双向链表的实现代码细节："),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/doubly-linked-list.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("doubly-linked-list.ts"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("    1.我们需要准备一个跟Node不一样的助手类"),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/models/linked-list-models.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("DoublyNode"),r("OutboundLink")],1),t._v("，这个助手类有三个属性，一个是本身的值，另一个是指向下一个DoublyNode的指针，最后一个是指向上一个DoublyNode的指针。")]),t._v(" "),r("p",[t._v("    2.我们让DoublyLinkedList继承LinkedList，可以使用父类的方法和属性。声明两个属性，head指向首部元素（第一个），tail指向尾部元素（最后一个），记得类型得是DoublyNode，其他的同LinkedList。")]),t._v(" "),r("p",[t._v("    3.往双向链表尾部添加元素push："),r("br"),t._v("\n        链表为空时，将新元素赋给head和tail；链表不为空时，需要将新元素追加到尾部，也就是将新元素的next指向tail的next，新元素的prev指向tail，但此时的链表还没指向新元素，那么就让tail的next指向新元素，最后把tail更新也就是把新元素赋给tail（这四个步骤要仔细理清楚）。最后记得更新count的值。")]),t._v(" "),r("p",[t._v("    4.往双向链表首部添加元素unshift："),r("br"),t._v("\n        链表为空时，将新元素赋给head和tail；链表不为空时，需要将新元素追加到首部，也就是将新元素的prev指向head的prev，新元素的next指向head，但此时的链表还没指向新元素，那么就让head的prev指向新元素，最后把head更新也就是把新元素赋给head（这四个步骤有个别顺序不能打乱，自己理一理）。最后记得更新count的值。")]),t._v(" "),r("p",[t._v("    5.在双向链表的任意位置插入新元素insert："),r("br"),t._v("\n        当要插入的位置是第一个位置或者最后一个位置，相当于调用unshift或push方法；其他场景，需要拿到指定位置的前一个位置的元素，然后把新元素连接到刚刚这元素后面，再更新一些引用（指针），例如：新元素的next要指向刚刚这元素的next，新元素的next的prev要指向新元素，新元素的prev要指向刚刚这元素，刚刚这元素的next要指向新元素（比起unshift和push要复杂，理清楚就好了）。最后记得更新count的值。")]),t._v(" "),r("p",[t._v("    6.从双向链表中移除元素removeAt："),r("br"),t._v("\n        当链表只有一个元素时只需把head和tail清空；当移除的是首部元素时，需要将head指向head的next，再把head的prev置空即可；当移除的是尾部元素时，需要将tail指向tail的prev，再把tail的next置空即可；需要迭代（getElementAt方法）到指定位置，再把这个位置的prev的next指向这个位置的next，再把这个位置的next的prev指向这个位置的prev，这样就可以把这个位置上的元素从双向链表中移除。"),r("br"),t._v("\n        扩展：用indexOf和removeAt配合可以组成新的移除方法，就是移除与指定项相同的元素（目前只能移除一个）。")]),t._v(" "),r("p",[t._v("    7.双向链表的其他方法isEmpty和size继承父类即可，clear需要先调父类的clear然后再清空tail，toString逻辑跟父类一样只是里面用的是DoublyNode，inverseToString跟toString类似，只需要将head换成tail然后next换成prev即可。")]),t._v(" "),r("h2",{attrs:{id:"循环链表数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环链表数据结构"}},[t._v("#")]),t._v(" 循环链表数据结构")]),t._v(" "),r("p",[t._v("    在链表的基础上，将尾部元素的next指向首部元素而不是置空，以此形成循环。")]),t._v(" "),r("h2",{attrs:{id:"循环链表的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环链表的实现"}},[t._v("#")]),t._v(" 循环链表的实现")]),t._v(" "),r("p",[t._v("    循环链表代码细节："),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/circular-linked-list.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("circular-linked-list.ts"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("    循环链表是基于链表的，那么让CircularLinkedList继承LinkedList，再重写push、unshift、removeAt方法。很简单，先super调用父类的同名方法，再调一下固定方法formingCycle以此形成循环。formingCycle方法其实就是遍历链表找到尾部元素，然后将尾部元素的next指向head即可。")]),t._v(" "),r("h2",{attrs:{id:"双向循环链表数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向循环链表数据结构"}},[t._v("#")]),t._v(" 双向循环链表数据结构")]),t._v(" "),r("p",[t._v("    在双向链表的基础上，将尾部元素的next指向首部元素，将首部元素的prev指向尾部元素，以此形成循环。")]),t._v(" "),r("h2",{attrs:{id:"双向循环链表的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向循环链表的实现"}},[t._v("#")]),t._v(" 双向循环链表的实现")]),t._v(" "),r("p",[t._v("    双向循环链表代码细节："),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/doubly-circular-linked-list.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("doubly-circular-linked-list.ts"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("    双向循环链表是基于双向链表的那么让DoublyCircularLinkedList继承DoublyLinkedList，再重写push、unshift、removeAt方法。很简单，先super调用父类的同名方法，再调一下固定方法formingCycle以此形成循环。formingCycle方法其实就是将tail的next指向head再将head的prev指向tail。")]),t._v(" "),r("h2",{attrs:{id:"有序链表数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有序链表数据结构"}},[t._v("#")]),t._v(" 有序链表数据结构")]),t._v(" "),r("p",[t._v("    保证元素按照一定规则顺序插入的链表结构。（这个顺序指的是元素的值的顺序，而链表本身因为指针也是有顺序的，要区别开这两个“顺序”）")]),t._v(" "),r("h2",{attrs:{id:"有序链表的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#有序链表的实现"}},[t._v("#")]),t._v(" 有序链表的实现")]),t._v(" "),r("p",[t._v("    有序链表代码细节："),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/sorted-linked-list.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("sorted-linked-list.ts"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("    有序链表是基于单向链表的，也可以用双向的，这里实现的是单向的有序链表。让SortedLinkedList继承LinkedList，声明一个compareFn属性（初始化时默认传的是升序比较函数）。"),r("br"),t._v("\n    push、unshift其实相当于调用insert，因为插入都要走统一的比较方法。在插入时，要比较新元素与链表里元素的值，这里因为是升序，所以必选找到比新元素的大的位置，这个位置将会由新元素插入，当然旧元素会补到这个新元素的next上，以此形成升序；如果找不到比新元素的大的位置，那么新元素会放到尾部元素的next上，因为它最大。")]),t._v(" "),r("h2",{attrs:{id:"基于双向链表的栈数据结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于双向链表的栈数据结构"}},[t._v("#")]),t._v(" 基于双向链表的栈数据结构")]),t._v(" "),r("p",[t._v("    实现栈时，我们也可以选用双向链表，当然你选单向链表也是可以的（要稍微调整一下代码）。")]),t._v(" "),r("h2",{attrs:{id:"基于双向链表的栈的实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于双向链表的栈的实现"}},[t._v("#")]),t._v(" 基于双向链表的栈的实现")]),t._v(" "),r("p",[t._v("    基于双向链表的栈代码细节："),r("a",{attrs:{href:"https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/data-structures/stack-linked-list.ts",target:"_blank",rel:"noopener noreferrer"}},[t._v("stack-linked-list.ts"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("    声明一个私有变量_items，类型为DoublyLinkedList，入栈时就调用双向链表的push方法，而出栈时就调用双向链表的removeAt(this.size() - 1)，查看栈顶元素就调用双向链表的getTail方法，其他的功能很好实现。")])])}),[],!1,null,null,null);e.default=s.exports}}]);