(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{496:function(s,t,a){s.exports=a.p+"assets/img/基本类型的复制变量的值.c9412270.png"},497:function(s,t,a){s.exports=a.p+"assets/img/引用类型的复制变量的值.a9ee0a26.png"},498:function(s,t,a){s.exports=a.p+"assets/img/引用类型的按值传递.c7342f21.png"},718:function(s,t,a){"use strict";a.r(t);var n=a(16),r=Object(n.a)({},(function(){var s=this,t=s.$createElement,n=s._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[n("h1",{attrs:{id:"变量、作用域和内存问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#变量、作用域和内存问题"}},[s._v("#")]),s._v(" 变量、作用域和内存问题")]),s._v(" "),n("h2",{attrs:{id:"一、基本类型和应用类型的值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#一、基本类型和应用类型的值"}},[s._v("#")]),s._v(" 一、基本类型和应用类型的值")]),s._v(" "),n("p",[s._v("ECMAScript 变量的值可以是基本类型或引用类型，之前介绍了 Undefined、Null、Boolean、Number 和 String 这 5 种基本数据类型，它是按 "),n("strong",[s._v("值")]),s._v(" 访问可以 "),n("strong",[s._v("操作")]),s._v(" 保存在变量中的 "),n("strong",[s._v("实际值")]),s._v("，而引用类型的值是保存在堆内存中，按 "),n("strong",[s._v("引用")]),s._v(" 访问的。")]),s._v(" "),n("h3",{attrs:{id:"_1-1-动态的属性"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-动态的属性"}},[s._v("#")]),s._v(" 1.1 动态的属性")]),s._v(" "),n("p",[s._v("对于应用类型的值，我们可以为其添加属性和方法，也可以改变和删除属性和方法，而对于基本类型的值我们不能添加属性，就算添加了后面访问这个属性也是 undefined。")]),s._v(" "),n("h3",{attrs:{id:"_1-2-复制变量值"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-复制变量值"}},[s._v("#")]),s._v(" 1.2 复制变量值")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("如果从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值。然后把该值复制到为新变量分配的位置上，例：")]),s._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" num1 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("5")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" num2 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" num1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// num1的5和num2的5完全独立，两变量可以参与任何操作而不会互相影响。")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("img",{attrs:{src:a(496),alt:"基本类型的复制变量的值"}})])]),s._v(" "),n("li",[n("p",[s._v("如果从一个变量向另一个变量复制引用类型的值，也会把变量对象中的值赋值一份放到新变量分配的位置上。其实这个值的副本是个指针，和复制前变量指向堆内存中的同一个对象，例：")]),s._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" obj1 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" obj2 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" obj1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 地址值复制过去了，地址值之间互不影响，但要操作地址对应的对象就会有影响。")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br")])]),n("p",[n("img",{attrs:{src:a(497),alt:"引用类型的复制变量的值"}})])])]),s._v(" "),n("h3",{attrs:{id:"_1-3-传递参数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-传递参数"}},[s._v("#")]),s._v(" 1.3 传递参数")]),s._v(" "),n("ul",[n("li",[s._v("按值传递：在参数传递过程中，形参和实参占用了 "),n("strong",[s._v("两个完全不同的内存空间（栈）")]),s._v("，形参所存储的内容是实参存储内容的一份拷贝。")]),s._v(" "),n("li",[s._v("按应用传递：在参数传递过程中，形参和实参完全是 "),n("strong",[s._v("同一块内存空间（栈）")]),s._v("，两份不分彼此。")]),s._v(" "),n("li",[s._v("而 ECMAScript 中所有函数的参数都是 "),n("strong",[s._v("按值传递")]),s._v(" 的。")]),s._v(" "),n("li",[s._v("基本类型值的传递如同基本类型变量的复制一样，而应用类型值的传递则如同应用类型变量的复制一样（参考上一节）。")])]),s._v(" "),n("p",[s._v("例 1：")]),s._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("addTen")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("num2")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  num2 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("10")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" num2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" num1 "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token number"}},[s._v("20")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" result "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("addTen")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("num1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("num1"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 20")]),s._v("\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("num2"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// 30")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br")])]),n("p",[s._v("在调用 addTen 函数时，num1 存储内容复制了一份给 num2，复制后 num1 和 num2 都为 20 但互不影响；在 addTen 函数里，num2 加了 10 之后是对 num1 没有影响的，这是 "),n("strong",[s._v("按值传递")]),s._v("，所以最后的输出结果 num1 是 20，num2 是 30；假设它是 "),n("strong",[s._v("按引用传递")]),s._v(" ，那么 num1 和 num2 是同一份，最后的值应该都是 30 才对，与实际输出不一致。")]),s._v(" "),n("p",[s._v("例 2：")]),s._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("setName")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("obj")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// (3) 如下图(2)(3)，将person的地址值复制了一份给obj，让obj也指向那个实例化对象")]),s._v("\n  obj"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"N"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v('// (4) 如下图(4)，给那个实例化对象新添一个name属性，该属性值为"N"')]),s._v("\n  obj "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// (5) 如下图(5)，又创建了一个Oject的实例化对象，让obj指向这个新的实例化对象")]),s._v("\n  obj"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("name "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[s._v('"G"')]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v('// (6) 如下图(6)，给新的实例化对象新添一个name属性，该属性值为"G"')]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("var")]),s._v(" person "),n("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// (1) 如下图(1)，声明了person变量，初始化的值是Oject引用类型的一个实例化对象")]),s._v("\n"),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("setName")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("person"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// (2) 去调用setName函数，将person这个变量传入")]),s._v("\nconsole"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("person"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("name"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v(" "),n("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// (7) 如下图(7)，函数调用完会清理其中的局部变量，只剩下外部的person和其指引的对象了")]),s._v("\n")])]),s._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[s._v("1")]),n("br"),n("span",{staticClass:"line-number"},[s._v("2")]),n("br"),n("span",{staticClass:"line-number"},[s._v("3")]),n("br"),n("span",{staticClass:"line-number"},[s._v("4")]),n("br"),n("span",{staticClass:"line-number"},[s._v("5")]),n("br"),n("span",{staticClass:"line-number"},[s._v("6")]),n("br"),n("span",{staticClass:"line-number"},[s._v("7")]),n("br"),n("span",{staticClass:"line-number"},[s._v("8")]),n("br"),n("span",{staticClass:"line-number"},[s._v("9")]),n("br")])]),n("p",[n("img",{attrs:{src:a(498),alt:"引用类型的复制变量的值"}})]),s._v(" "),n("p",[s._v("可以看出来，步骤(5)是关键，它可以指向新的实例化对象；如果是 "),n("strong",[s._v("按引用传递")]),s._v(' 的话，person 和 obj 就是同一份（在栈里），在 obj 指向新对象时，person 也指向新对象，实际上步骤(7)打印出的是"N"，所以它还是 '),n("strong",[s._v("按值传递")]),s._v("（在堆确实还是同一份，但在栈里不是同一份，是复制了一份）。")]),s._v(" "),n("h3",{attrs:{id:"_1-4-检测类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-检测类型"}},[s._v("#")]),s._v(" 1.4 检测类型")]),s._v(" "),n("ul",[n("li",[s._v("检测变量是不是基本数据类型用"),n("code",{pre:!0},[s._v("typeof")]),s._v("操作符，而检测引用类型变量是什么类型的对象可以用"),n("code",{pre:!0},[s._v("instanceof")]),s._v("操作符；")]),s._v(" "),n("li",[s._v("所有引用类型的值 "),n("strong",[s._v("都是 Object 的实例")]),s._v("，在检测一个引用类型值和 Object 构造函数时，instanceof 操作符始终会返回 "),n("strong",[s._v("true")]),s._v("；")]),s._v(" "),n("li",[s._v("使用 instanceof 操作符检测 "),n("strong",[s._v("基本类型")]),s._v(" 会返回 "),n("strong",[s._v("false")]),s._v("，基本类型不是对象。")])]),s._v(" "),n("h2",{attrs:{id:"二、执行环境及作用域"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#二、执行环境及作用域"}},[s._v("#")]),s._v(" 二、执行环境及作用域")]),s._v(" "),n("p",[s._v("在研读《JavaScript 高级程序设计》的 4.2 节后仍有很多不解，需要去研读《你不知道的 JavaScript(上卷)》的第一部的一二章和第二部的一二章，你会有转深刻的理解，这里就记录一些浅显的见解吧。")]),s._v(" "),n("ol",[n("li",[n("p",[s._v("js 是“解释执行”语言，这里不得不提到 js 的 "),n("strong",[s._v("引擎和编译器")]),s._v("。引擎负责整个 js 程序的 "),n("strong",[s._v("编译和执行过程")]),s._v("，引擎只是负责编译的 "),n("strong",[s._v("引导")]),s._v(" 而实际上具体编译的活是 "),n("strong",[s._v("编译器")]),s._v(" 在干（词法语法分析并生成可执行的机器指令）。")])]),s._v(" "),n("li",[n("p",[s._v("js 代码大多是一段段嵌套起来的，那么对代码段可以分成三种："),n("strong",[s._v("全局代码段、函数代码段、eval 代码段（不推荐使用）")]),s._v("。js 代码运行的时候，是先编译再执行，并且编译发生在化码执行前的几微秒甚至更短时间里。但是，这里的编译执行都是按照一段段来的，并不是把文件里的所有代码都编译后再执行的，而是 "),n("strong",[s._v("编译一段执行一段")]),s._v("。")])]),s._v(" "),n("li",[n("p",[s._v("js 运行到某段代码时（某个函数被调用时），先编译分析这段代码并创建一个 "),n("strong",[s._v("执行环境(execution context)")]),s._v("，也称 "),n("strong",[s._v("执行上文（简称 EC）")]),s._v("。执行环境有三个重要的组成："),n("strong",[s._v("变量对象、作用域链、this")]),s._v("。")]),s._v(" "),n("ul",[n("li",[n("strong",[s._v("变量对象")]),s._v("：variable object，简称 VO。存储着执行环境里的 "),n("strong",[s._v("所有变量和函数声明")]),s._v("。当执行流在这个执行坏境里执行时，这个变量对象就是 "),n("strong",[s._v("活动对象(activation object)")]),s._v("。")]),s._v(" "),n("li",[n("strong",[s._v("作用域")]),s._v("：scope。是 "),n("strong",[s._v("根据名称查找变量的一套规则")]),s._v("，这个规则只在所处代码段里有效（这里指的是 "),n("strong",[s._v("作用域范围")]),s._v("），其实作用域存的不是变量对象本身而是指向变量对象的 "),n("strong",[s._v("指针")]),s._v("。")]),s._v(" "),n("li",[n("strong",[s._v("作用城链")]),s._v("：scope chain。代码段的嵌套使得作用域可以连接到一起了，这祥就形成了一个能 "),n("strong",[s._v("一级级向上查找变量对象的有序链表")]),s._v("（这样的有序链表其实就是一个指向作用域链范围内所有变量对象的 "),n("strong",[s._v("指针列表")]),s._v("）。也就是说嵌套在里层的代码段能访问到外层定义的变量，而外层访问不了里层的。")]),s._v(" "),n("li",[n("strong",[s._v("this")]),s._v("：记录着函数被调用时的信息，this 绑定的是函数 "),n("strong",[s._v("调用处的对象")]),s._v("（跟函数本身没关系）。有四种场景（已排优先级)：\n"),n("ul",[n("li",[s._v("如果函数是由 new 调用的（new 绑定），那么 this 绑定的是新创建的对象。"),n("code",{pre:!0},[s._v("var bar = new Foo();")]),s._v("，this 绑定了 bar；")]),s._v(" "),n("li",[s._v("如果函数通过"),n("code",{pre:!0},[s._v("call")]),s._v("、"),n("code",{pre:!0},[s._v("apply")]),s._v("调用（显示绑定）或"),n("code",{pre:!0},[s._v("bind")]),s._v("（硬绑定）调用，那么 this 绑定的是指定的对象。"),n("code",{pre:!0},[s._v("var bar = foo.call(obj);")]),s._v("，this 绑定了 obj；")]),s._v(" "),n("li",[s._v("如果函数由某个上下文对象调用（隐式绑定），那么 this 绑定的是那个上下文对象。"),n("code",{pre:!0},[s._v("var bar = obj.foo();")]),s._v("，this 绑定了 obj；"),n("code",{pre:!0},[s._v("obj1.obj2.foo();")]),s._v("，this 绑定了 obj2；")]),s._v(" "),n("li",[s._v("如果不是上面三种，那就是使用默认绑定，this 绑定的是全局对象 window。严格模式下全局对象无法使用默认绑定，因此 this 会绑定到 undefined。（有个坑爹的地方，假如函数创建在非严格模式的全局环境里，但是在一小块严格模式代码里调用了函数，这个函数可以绑定全局对象）")])])])])]),s._v(" "),n("li",[n("p",[s._v("假如代码段里有"),n("code",{pre:!0},[s._v("var a = 0;")]),s._v("这句，"),n("strong",[s._v("编译遇到 var")]),s._v(" 时（声明提升了），编译器会拿 a 这个名字 "),n("strong",[s._v("通过作用域链")]),s._v(" 去当前执行环境的 "),n("strong",[s._v("变量对象")]),s._v(" 里查找是否存在，不存在就在变量对象里 "),n("strong",[s._v("新声明一个 a")]),s._v("（存的是 undefined），存在的话会 "),n("strong",[s._v("忽略 var")]),s._v(" 并继续往下编译。这一段代码段 "),n("strong",[s._v("编译完后")]),s._v("，"),n("strong",[s._v("就开始执行")]),s._v(" 这一段代码段，执行遇到"),n("code",{pre:!0},[s._v("a = 0")]),s._v("时（声明提升了，a = 0 还在原地），引擎会先拿 a 这个名字 "),n("strong",[s._v("通过作用域链")]),s._v(" 去当前执行环境的 "),n("strong",[s._v("变量对象")]),s._v(" 里查找是否有 a 这个变量存在，存在话就拿来用（也就是把 0 这个值赋给 a 变量），不存在的话继续向上一级查找，直到最外层的 "),n("strong",[s._v("全局执行环境")]),s._v(" 的 "),n("strong",[s._v("变量对象")]),s._v(" 里还没找到那就抛异常（其实在非严格模式下会在全局执行环境的变量对象里，创建一个全局变量，返回给引擎并不会抛异常）。")])]),s._v(" "),n("li",[n("p",[s._v("在一段代码段运行完（编译了也执行完了），代码段抽象出的执行环境 "),n("strong",[s._v("会被销毁")]),s._v("，连带着里面的 "),n("strong",[s._v("变量对象、作用域链和 this")]),s._v(" 都会被销毁，只有代码段再次被调用时才会建立一个新的执行环境。")])]),s._v(" "),n("li",[n("p",[s._v("之前说代码段被分成三种："),n("strong",[s._v("全局代码段、函数代码段、eval 代码段（不推荐使用）")]),s._v("。那么可以说 js "),n("strong",[s._v("没有块级作用域")]),s._v("，只有 "),n("strong",[s._v("全局作用域")]),s._v(" 和 "),n("strong",[s._v("函数作用域")]),s._v("，比如 if 和 for 这种语句的{}里的变量也可在外面使用。")])]),s._v(" "),n("li",[n("p",[s._v("为什么不推荐用"),n("code",{pre:!0},[s._v("eval()")]),s._v("，因为它可以在代码执行时，来声明“代码字符串”里的变量，从而 "),n("strong",[s._v("改变了编译时的作用域")]),s._v("。类似还有"),n("code",{pre:!0},[s._v("with()")]),s._v("，它是在代码执行时，把某些对象的属性也当做标识符，从而 "),n("strong",[s._v("新建了一个作用域")]),s._v("。这两个 "),n("strong",[s._v("非但没有在编译期被优化，反而在执行期改变了作用域拖慢代码运行速度")]),s._v("，而且这两个在严格模式下是被禁止的。")])]),s._v(" "),n("li",[n("p",[s._v("可以去"),n("RouterLink",{attrs:{to:"/book-web/html、css、js、ts/学习JavaScript/5.函数表达式.html#三、闭包"}},[s._v("函数表达式#闭包")]),s._v("进一步学习。")],1)])]),s._v(" "),n("h2",{attrs:{id:"三、垃圾收集"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#三、垃圾收集"}},[s._v("#")]),s._v(" 三、垃圾收集")]),s._v(" "),n("p",[s._v("js 具有 "),n("strong",[s._v("自动")]),s._v(" 垃圾收集机制，这种机制原理："),n("strong",[s._v("找出那些不再被使用的变量，然后释放其占用的内存")]),s._v("。")]),s._v(" "),n("h3",{attrs:{id:"_3-1-标识清除"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-标识清除"}},[s._v("#")]),s._v(" 3.1 标识清除")]),s._v(" "),n("p",[s._v("标识清除是 js "),n("strong",[s._v("最常见")]),s._v(" 的垃极收集方式，垃圾收集器在运行时，它会先给内存中所有的变量 "),n("strong",[s._v("加上标记")]),s._v("（不管变量有用还是无用），然后垃圾收集器会 "),n("strong",[s._v("去掉")]),s._v(" 那些 "),n("strong",[s._v("可以被访问")]),s._v(" 的变量身上的 "),n("strong",[s._v("标记")]),s._v("，剩下的那些无法被访问的变量自然还留有标记，最后垃圾收集器对 "),n("strong",[s._v("留有标记")]),s._v(" 的变量进行 "),n("strong",[s._v("内存清除工作")]),s._v("（销毁标记值和所占内存）。")]),s._v(" "),n("h3",{attrs:{id:"_3-2-引用计数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-引用计数"}},[s._v("#")]),s._v(" 3.2 引用计数")]),s._v(" "),n("p",[s._v("引用计数目前者 "),n("strong",[s._v("不再被使用在 js 引擎中")]),s._v("，引用计数会跟踪记录每个值 "),n("strong",[s._v("被引用的次数")]),s._v("。声明一个变量并给这个变量赋了一个引用类型的值，这个引用次数就是 1；当这个引类型的值再被赋给另一个变量时，该值的引用次数加 1；当这个引用类型的值不再被引用时，这个引用次数就变成了 0，就会被回收。")]),s._v(" "),n("p",[n("strong",[s._v("循环引用")]),s._v("：对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的指针。（"),n("strong",[s._v("例如对象 A 的某属性指向 B 对象，B 对象的某属性指向 A 对象")]),s._v("）")]),s._v(" "),n("p",[s._v("当代码里存在循环引用这种情况，引用计数时他们的引用次数永远不会为 0，"),n("strong",[s._v("被多次调用后就会导致大量的内有得不到回收")]),s._v("。")]),s._v(" "),n("h3",{attrs:{id:"_3-3-内存管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-内存管理"}},[s._v("#")]),s._v(" 3.3 内存管理")]),s._v(" "),n("p",[s._v("将变量的值 "),n("strong",[s._v("设为 null")]),s._v("，可以释放其引用（以便于被回收），这种做法叫做 "),n("strong",[s._v("解除引用")]),s._v("。")]),s._v(" "),n("p",[s._v("解除引用可以用在前面提到的 "),n("strong",[s._v("循环引用")]),s._v(" 上来 "),n("strong",[s._v("切断连接")]),s._v("，也可以用在不再被使用的全局变量和全局变量的属性上，这也是优化内存占用的最佳方式，为执行中的代码只保有必要的数据，不必要的数据为其解除引用。")])])}),[],!1,null,null,null);t.default=r.exports}}]);