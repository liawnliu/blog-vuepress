<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>11.排序和搜索算法 | Liawn&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.7">
    <meta charset="UTF-8">
  <link rel="icon" href="/blog-vuepress/favicon.ico">
  <link rel="manifest" href="/blog-vuepress/manifest.json">
  <meta name="theme-color" content="#ffffff">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/blog-vuepress/apple-touch-icon-152x152.png">
  <link rel="mask-icon" href="/blog-vuepress/safari-pinned-tab.svg" color="#ffffff">
  <meta name="msapplication-TileImage" content="/msapplication-icon-144x144.png">
  <meta name="msapplication-TileColor" content="#000000">
    <meta name="description" content="用vuepress搭建的个人博客">
    <meta charset="UTF-8">
    <meta name="theme-color" content="#ffffff">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#000000">
    
    <link rel="preload" href="/blog-vuepress/assets/css/0.styles.2f620dda.css" as="style"><link rel="preload" href="/blog-vuepress/assets/js/app.34680ebc.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/2.1e7adb41.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/19.4b561714.js" as="script"><link rel="preload" href="/blog-vuepress/assets/js/38.cec9a03e.js" as="script"><link rel="prefetch" href="/blog-vuepress/assets/js/10.1e723314.js"><link rel="prefetch" href="/blog-vuepress/assets/js/100.311567ba.js"><link rel="prefetch" href="/blog-vuepress/assets/js/101.ef72e26e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/102.c3759919.js"><link rel="prefetch" href="/blog-vuepress/assets/js/103.98e877a9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/104.e27de6a0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/105.3a1ef548.js"><link rel="prefetch" href="/blog-vuepress/assets/js/106.59ee0f92.js"><link rel="prefetch" href="/blog-vuepress/assets/js/107.e68abe87.js"><link rel="prefetch" href="/blog-vuepress/assets/js/108.8fcda232.js"><link rel="prefetch" href="/blog-vuepress/assets/js/109.422d008d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/11.58bde1dd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/110.f713fc26.js"><link rel="prefetch" href="/blog-vuepress/assets/js/111.58efaae4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/112.c6bdfbe0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/113.8dbd693e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/114.8a85e37a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/115.54a6972e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/116.56b2d8b8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/117.11470546.js"><link rel="prefetch" href="/blog-vuepress/assets/js/118.1a39e213.js"><link rel="prefetch" href="/blog-vuepress/assets/js/119.41f15fbd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/12.613505ee.js"><link rel="prefetch" href="/blog-vuepress/assets/js/120.9ac14643.js"><link rel="prefetch" href="/blog-vuepress/assets/js/121.83954220.js"><link rel="prefetch" href="/blog-vuepress/assets/js/122.bef8fade.js"><link rel="prefetch" href="/blog-vuepress/assets/js/123.25446ff9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/124.6acf9e60.js"><link rel="prefetch" href="/blog-vuepress/assets/js/125.42c6fb5e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/126.b9b98daa.js"><link rel="prefetch" href="/blog-vuepress/assets/js/127.382eea79.js"><link rel="prefetch" href="/blog-vuepress/assets/js/13.75740994.js"><link rel="prefetch" href="/blog-vuepress/assets/js/14.febc6ec1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/15.6e16849c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/16.70db9d99.js"><link rel="prefetch" href="/blog-vuepress/assets/js/17.f098e403.js"><link rel="prefetch" href="/blog-vuepress/assets/js/18.21ad25ae.js"><link rel="prefetch" href="/blog-vuepress/assets/js/20.8dae8a78.js"><link rel="prefetch" href="/blog-vuepress/assets/js/21.7d09e2a3.js"><link rel="prefetch" href="/blog-vuepress/assets/js/22.7838f809.js"><link rel="prefetch" href="/blog-vuepress/assets/js/23.2444198c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/24.099866db.js"><link rel="prefetch" href="/blog-vuepress/assets/js/25.d059d716.js"><link rel="prefetch" href="/blog-vuepress/assets/js/26.243af3f2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/27.97e455c9.js"><link rel="prefetch" href="/blog-vuepress/assets/js/28.97ce9b54.js"><link rel="prefetch" href="/blog-vuepress/assets/js/29.392d550e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/3.49db6791.js"><link rel="prefetch" href="/blog-vuepress/assets/js/30.9161535d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/31.46b99656.js"><link rel="prefetch" href="/blog-vuepress/assets/js/32.c2fd0854.js"><link rel="prefetch" href="/blog-vuepress/assets/js/33.3080b8a5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/34.e15baec0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/35.f144a7bd.js"><link rel="prefetch" href="/blog-vuepress/assets/js/36.e1175535.js"><link rel="prefetch" href="/blog-vuepress/assets/js/37.72ec58bc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/39.fc6f4606.js"><link rel="prefetch" href="/blog-vuepress/assets/js/4.eca03551.js"><link rel="prefetch" href="/blog-vuepress/assets/js/40.b74ded47.js"><link rel="prefetch" href="/blog-vuepress/assets/js/41.cee8cec1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/42.7f4e1373.js"><link rel="prefetch" href="/blog-vuepress/assets/js/43.10c6d899.js"><link rel="prefetch" href="/blog-vuepress/assets/js/44.4f190d43.js"><link rel="prefetch" href="/blog-vuepress/assets/js/45.5c2f36ae.js"><link rel="prefetch" href="/blog-vuepress/assets/js/46.9a5337f5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/47.161b10c1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/48.93192e20.js"><link rel="prefetch" href="/blog-vuepress/assets/js/49.72ba1cc4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/5.aacc9c46.js"><link rel="prefetch" href="/blog-vuepress/assets/js/50.bfc0c26a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/51.05bbb696.js"><link rel="prefetch" href="/blog-vuepress/assets/js/52.84b5a67c.js"><link rel="prefetch" href="/blog-vuepress/assets/js/53.220715ca.js"><link rel="prefetch" href="/blog-vuepress/assets/js/54.d433d73f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/55.f8221d0f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/56.2ec79246.js"><link rel="prefetch" href="/blog-vuepress/assets/js/57.01a3b85e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/58.9015a667.js"><link rel="prefetch" href="/blog-vuepress/assets/js/59.73311086.js"><link rel="prefetch" href="/blog-vuepress/assets/js/6.0c335663.js"><link rel="prefetch" href="/blog-vuepress/assets/js/60.976cf8cc.js"><link rel="prefetch" href="/blog-vuepress/assets/js/61.4a1c95f1.js"><link rel="prefetch" href="/blog-vuepress/assets/js/62.865f814a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/63.0d882dec.js"><link rel="prefetch" href="/blog-vuepress/assets/js/64.c74f770a.js"><link rel="prefetch" href="/blog-vuepress/assets/js/65.0d5262a8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/66.1cd8fc00.js"><link rel="prefetch" href="/blog-vuepress/assets/js/67.a73db0e8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/68.2fe7b184.js"><link rel="prefetch" href="/blog-vuepress/assets/js/69.763746bf.js"><link rel="prefetch" href="/blog-vuepress/assets/js/7.09a81cb8.js"><link rel="prefetch" href="/blog-vuepress/assets/js/70.2f10d153.js"><link rel="prefetch" href="/blog-vuepress/assets/js/71.f0476a16.js"><link rel="prefetch" href="/blog-vuepress/assets/js/72.b3aa24c4.js"><link rel="prefetch" href="/blog-vuepress/assets/js/73.d90b4378.js"><link rel="prefetch" href="/blog-vuepress/assets/js/74.5f3afc25.js"><link rel="prefetch" href="/blog-vuepress/assets/js/75.610a9393.js"><link rel="prefetch" href="/blog-vuepress/assets/js/76.397a07d0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/77.a7a16098.js"><link rel="prefetch" href="/blog-vuepress/assets/js/78.0a76e3c0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/79.d9bf3b6d.js"><link rel="prefetch" href="/blog-vuepress/assets/js/8.7a4382cf.js"><link rel="prefetch" href="/blog-vuepress/assets/js/80.6653af85.js"><link rel="prefetch" href="/blog-vuepress/assets/js/81.7bfd7632.js"><link rel="prefetch" href="/blog-vuepress/assets/js/82.e5ec57b6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/83.7728c890.js"><link rel="prefetch" href="/blog-vuepress/assets/js/84.dd67c36e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/85.7387a0e5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/86.bbfe7f7f.js"><link rel="prefetch" href="/blog-vuepress/assets/js/87.2de3f2a7.js"><link rel="prefetch" href="/blog-vuepress/assets/js/88.809122f0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/89.321e8e47.js"><link rel="prefetch" href="/blog-vuepress/assets/js/9.26929067.js"><link rel="prefetch" href="/blog-vuepress/assets/js/90.5ce6c826.js"><link rel="prefetch" href="/blog-vuepress/assets/js/91.075154c5.js"><link rel="prefetch" href="/blog-vuepress/assets/js/92.11b94685.js"><link rel="prefetch" href="/blog-vuepress/assets/js/93.a9d4d5f0.js"><link rel="prefetch" href="/blog-vuepress/assets/js/94.306ece7e.js"><link rel="prefetch" href="/blog-vuepress/assets/js/95.817525f6.js"><link rel="prefetch" href="/blog-vuepress/assets/js/96.beed2305.js"><link rel="prefetch" href="/blog-vuepress/assets/js/97.b4c539f2.js"><link rel="prefetch" href="/blog-vuepress/assets/js/98.8e445314.js"><link rel="prefetch" href="/blog-vuepress/assets/js/99.558669ea.js">
    <link rel="stylesheet" href="/blog-vuepress/assets/css/0.styles.2f620dda.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><a href="/blog-vuepress/" class="home-link router-link-active"><!----> <span class="site-name">Liawn's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav></div></header> <div class="sidebar-wrapper sidebar-hidden"><aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog-vuepress/book-web/" class="nav-link router-link-active">
  Web
</a></div><div class="nav-item"><a href="/blog-vuepress/book-sketches/" class="nav-link">
  生活
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>web前端</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习JavaScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习JavaScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习CSS/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习CSS</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/html、css、js、ts/学习TypeScript/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习TypeScript</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习Vue/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习Vue</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web前端js框架/学习React/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习React</span></a> <!----></section></li><li><a href="/blog-vuepress/book-web/web前端js框架/学习jQuery.html" class="sidebar-link">jQueryNote</a></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/LayaBox游戏引擎/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>H5游戏引擎Laya</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>常用工具</span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/常用工具/Npm的使用.html" class="sidebar-link">Npm 的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Git的使用.html" class="sidebar-link">Git 的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/webpack的使用.html" class="sidebar-link">webpack 的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/VSCode的使用.html" class="sidebar-link">VSCode 的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/Chrome的使用.html" class="sidebar-link">Chrome 的使用</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用vuepress写blog.html" class="sidebar-link">使用 vuepress 写 blog</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用docsify写blog.html" class="sidebar-link">使用 docsify 写 blog</a></li><li><a href="/blog-vuepress/book-web/常用工具/使用gitbook写blog.html" class="sidebar-link">使用 gitbook 写 blog</a></li><li><a href="/blog-vuepress/book-web/web前端测试与调试/基于mocha+chai的单元测试.html" class="sidebar-link">使用 mocha+chai 进行单元测试</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>Web后端</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web后端/学习node.js/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习node.js</span></a> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/web后端/学习python/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>学习python</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>简单项目实践</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/项目/react+express+ts写爬虫/" class="sidebar-heading clickable"><span class="arrow right"></span> <span>react+express+ts写爬虫</span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><!----> <span>数据结构与算法</span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/blog-vuepress/book-web/数据结构与算法/" class="sidebar-heading clickable open"><span class="arrow down"></span> <span>数据结构与算法ts版</span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog-vuepress/book-web/数据结构与算法/1.环境搭建.html" class="sidebar-link">1.环境搭建</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/2.栈.html" class="sidebar-link">2.栈</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/3.队列.html" class="sidebar-link">3.队列</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/4.链表.html" class="sidebar-link">4.链表</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/5.集合.html" class="sidebar-link">5.集合</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/6.字典和散列表.html" class="sidebar-link">6.字典和散列表</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/7.递归.html" class="sidebar-link">7.递归</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/8.树.html" class="sidebar-link">8.树</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/9.二叉堆和堆排序.html" class="sidebar-link">9.二叉堆和堆排序</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/10.图.html" class="sidebar-link">10.图</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/11.排序和搜索算法.html" class="active sidebar-link">11.排序和搜索算法</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/12.算法设计与技巧.html" class="sidebar-link">12.算法设计与技巧</a></li><li><a href="/blog-vuepress/book-web/数据结构与算法/13.算法复杂度.html" class="sidebar-link">13.算法复杂度</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><!----> <span>面试准备</span></p> <!----></section></li></ul> </aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div> <main class="page sidebar-hidden right-sidebar-hidden"> <div class="theme-default-content content__default"><h1 id="排序和搜索算法"><a href="#排序和搜索算法" class="header-anchor">#</a> 排序和搜索算法</h1> <h2 id="排序算法"><a href="#排序算法" class="header-anchor">#</a> 排序算法</h2> <h3 id="冒泡排序"><a href="#冒泡排序" class="header-anchor">#</a> 冒泡排序</h3> <p>    冒泡排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/bubble-sort.ts" target="_blank" rel="noopener noreferrer">bubble-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>冒泡排序(bubble-sort)</strong>：每轮都比较数组里相邻两项，如果左项大于右项就交换彼此，目的是每轮都让最大的移到数组末尾，所有轮结束后数组就是升序排序的了（降序是将最小移到末尾）。</p> <p>    值得注意的是，在每轮都将最大的冒泡到末尾后，在下一轮时是无需再处理末尾项了，所以在内部循环时要记得减去 i 。还有就是如果某轮里，没有交换过左右项，那么可以提前退出算法，因为上一轮排完凑巧就排完了。</p> <p>    平均、最差场景的时间复杂度是 O(n^2)，最好情况是 O(n)；空间复杂度是 O(1)，相邻项交换是常量级的临时空间。<br> <img src="/blog-vuepress/assets/img/bubble-sort.3ee15c0a.png" alt="bubble-sort"></p> <h3 id="选择排序"><a href="#选择排序" class="header-anchor">#</a> 选择排序</h3> <p>    选择排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/selection-sort.ts" target="_blank" rel="noopener noreferrer">selection-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>选择排序(selection-sort)</strong>：每轮从数组里选一个比目标项小并且是最小的项（剩余项里最小的），记住它的下标，在每轮结束时交换目标项与该项的值，所有轮结束后数组就是升序的了。</p> <p>    值得注意的是，在每轮都找出比目标项小的项，这个项还要在剩余项里最小，所以每轮的 j 都是从 i+1 开始的，还要记住最小项的索引。</p> <p>    选择排序与冒泡排序的相同点：都是比较当前项和目标项的大小，并且每轮都让最大或最小项移到数组的一边。其实就是从剩余项中找出最大或最小项，然后排到数组的一端。<br>
    选择排序与冒泡排序的不同点：冒泡排序是一直交换当前项和目标项以达到目的；选择排序是记住最大或最小项的位置，到一轮快结束时才交换以达到目的。<br>
    两者核心思想相似，但处理手段不同，这也决定它们的最差、平均时间复杂度都是 O(n^2)，空间复杂度都是 O(1)。而选择排序的最好时间复杂度还是 O(n^2)不能提前退出，因为它减少了交换次数。<br> <img src="/blog-vuepress/assets/img/selection-sort.a1b6fe79.png" alt="selection-sort"></p> <h3 id="插入排序"><a href="#插入排序" class="header-anchor">#</a> 插入排序</h3> <p>    插入排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/insertion-sort.ts" target="_blank" rel="noopener noreferrer">insertion-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>    与冒泡和选择两种排序不同的是，<strong>插入排序(insertion-sort)</strong> 不会从剩余项中找最大或最小项放入数组一端，它是每轮从剩余项中随意取一项（默认取第一个），将它与排好序的项进行比较，然后放入适当的位置；一直到剩余项都处理完。</p> <p>    可以说插入排序是反其道而行，随意从剩余项中取一项然后按顺序插入已排序列表里，例如插扑克牌。最差、平均时间复杂度是 O(n^2)，最好情况是 O(n)；空间复杂度是 O(1)。<br> <img src="/blog-vuepress/assets/img/insertion-sort.33004ae1.png" alt="insertion-sort"></p> <h3 id="希尔排序"><a href="#希尔排序" class="header-anchor">#</a> 希尔排序</h3> <p>    希尔排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/shell-sort.ts" target="_blank" rel="noopener noreferrer">shell-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>希尔排序(shell-sort)</strong>：先取一个增量 k（可以是数组长度的一半，也可以是更好的增量取法），对数组里所有互相隔 k 距离的元素进行插入排序；下一轮将增量折半（或者更好增量取法），重复之前的步骤，直到增量为 1（最后一个增量必须为 1）并执行完插入排序后结束整个算法。</p> <p>    折半式增量是最先提出来的，其最好情况下的时间复杂度为 O(n)，平均时间复杂度为 O(n^(1.3))，最坏时间复杂度是 O(n^2)。</p> <p>    Hibbard 在 1963 年提出的[1, 3, 7, ..., 2^n-1]这样的增量序列，特点是没有公因子。其最坏时间复杂度是 O(n^(3/2))，其平均时间复杂度被模拟出来是 O(n^(5/4))。</p> <p>    Sedgewick 在 1982 年提出[1, 8, 23, 77, 281, 1073, 4193, 16577...]，除了第一项的通项公式：4 * 2^(2 * i) + 3 * 2^i + 1（其中 i 为 0,1,2,3,4...）；又在 1986 年提出[1, 5, 19, 41, 109, ...]（偶数项的通项公式：9 * 2^i - 9 * 2^(i/2) + 1，奇数项的通项公式：8 * 2^i - 6 * 2^((i+1)/2) + 1）。Sedgewick 提出的几种，最坏情形时间复杂度是 O(n^(4/3))，平均时间复杂度猜测在 O(n^(7/6))，要比 Hibbard 好很多</p> <p>    希尔排序是基于插入排序的，它没有快速排序快（如果有合适的增量序列，在小规模数组中将会比堆排序、快速排序快），但在中等规模表现良好，涉及到大规模数据将不如快速排序。有一个在大规模数据中表现优异的增量序列是（斐波那契数列除去 0 和 1 将剩余的数以黄金分割比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)<br> <img src="/blog-vuepress/assets/img/shell-sort.b054ac91.png" alt="shell-sort"></p> <h3 id="归并排序"><a href="#归并排序" class="header-anchor">#</a> 归并排序</h3> <p>    归并排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/merge-sort.ts" target="_blank" rel="noopener noreferrer">merge-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>归并排序(merge-sort)</strong> 跟冒泡、选择、插入三种排序方式区别很大，它运用了分而治之的思想。一直将数组分割成长度近似的两段，直到长度为 1 不可分割；再将其一一合并，归并的过程中会将左右两边的元素进行依次排序（从左右分别拿一项进行比较，排好序放入新数组，直到左右其中一个里元素被取完，而剩余的也会被连接到新数组），最后合并得到的新数组就是排好序的数组。</p> <p>    最差、平均、最好时间复杂度都是 O(nlogn)；空间复杂度是 O(n)，因为在每次合并的过程中都使用了一个临时数组存储。<br> <img src="/blog-vuepress/assets/img/merge-sort.83bfef3d.png" alt="merge-sort"></p> <h3 id="快速排序"><a href="#快速排序" class="header-anchor">#</a> 快速排序</h3> <p>    快速排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/quick-sort.ts" target="_blank" rel="noopener noreferrer">quick-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>快速排序(quick-sort)</strong>：将数组分隔成两段，分隔时会对数组进行简单排序，将较小项移到分隔点左边，对应右边是较大项。但由于左右两边里面也没顺序，那将左右两边也进行分隔处理，直到不能再分隔，这样使得每个小段都有了顺序，进而整段也是有了顺序。<br>
    这样看来快速排序也是分而治之的一种应用，跟归并排序很像，两者区别就是：一个是分开时简单分类（大致顺序）后面直接合并， 另一个是分开时不处理后面合并时再排序。</p> <p>    快速排序的空间复杂度都是 O(1)，没有每轮借助临时数组；快速排序的最好、平均时间复杂度都是 O(nlogn)；最差时间复杂度是 O(n^2)，因为当数组原本是降序的，要求排成升序的，并且基准点取的是最左边时，算出的下一轮的基准点还是最左边（一般返回给下一轮的应该是中间点），这就导致它没有了左右两边数组的递归了，而是就是它本身去排序了，退化成 n^2 这样的排序了。<br> <img src="/blog-vuepress/assets/img/quick-sort.b4c7e55e.png" alt="quick-sort"></p> <h3 id="计数排序"><a href="#计数排序" class="header-anchor">#</a> 计数排序</h3> <p>    计数排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/counting-sort.ts" target="_blank" rel="noopener noreferrer">counting-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>计数排序(counting-sort)</strong>：目标数组有 n 个元素，其中最大值为 k；先构造一个长度为 k+1 的统计数组，这个统计数组的索引对应着目标数组里的元素值；然后去统计目标数组里每个元素出现的次数，存储到统计数组对应索引上（次数分布到统计数组里）；最后遍历统计数组，将其索引当作新项加到新数组里，而“次数”是有几次就给新数组加同样的项几次。</p> <p>    值得注意的是，此方法很局限，它适合对小范围的非负整数的数组进行排序；当 n 不大而 k 很大时，是不适合使用计数排序的，因为会导致统计数组的长度过长。</p> <p>    计数排序的空间复杂度是 O(n+k)，因为它额外使用了一个 k+1 长的统计数组。平均的时间复杂度是 O(n+k)，最后由统计数组到新数组时，先遍历了 k 次，再此基础上还总共遍历了 n 次插入重复值；当 k=n 时也就是最好时间复杂度是 O(n)；当 k 远大于 n，而 n 很小，主要依赖于 k，所以最差时间复杂度是 O(k)。<br> <img src="/blog-vuepress/assets/img/counting-sort.14be5845.png" alt="counting-sort"></p> <h3 id="桶排序"><a href="#桶排序" class="header-anchor">#</a> 桶排序</h3> <p>    桶排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/bucket-sort.ts" target="_blank" rel="noopener noreferrer">bucket-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>桶排序(bucket-sort)</strong>：跟计数排序类似，只是我们准备的不是统计数组，而是桶这样的二维数组；遍历目标数组，将每个元素按照大小分配到对应的桶里（将元素分布到桶里）；所有元素遍历完后，桶之间是有顺序的但桶内部是没有顺序的，这里我们就需要对桶内部进行排序，一般选择快速排序或插入排序；每个桶都排完序后，将桶合并就会得到排好序的数组。</p> <p>    尽量将 n 个数据平均分配到 k 个桶中，这样每个桶就有 n/k 个数据量；尽量的增大桶的数量，极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的排序操作。当然，做到这一点很不容易，数据量巨大的情况下，会使得桶的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p> <p>    对于 n 个待排数据，k 个桶，平均每个桶 n/k 个数据这样情景的平均时间复杂度为：O(n)+O(k*(n/k)*log(n/k))=O(n+nlog(n/k))。当 k=n 时，是最好效率的排序，也就是最好时间复杂度是 O(n)。空间复杂度是 O(n+k)<br> <img src="/blog-vuepress/assets/img/bucket-sort.6ffa024a.png" alt="bucket-sort"></p> <h3 id="基数排序"><a href="#基数排序" class="header-anchor">#</a> 基数排序</h3> <p>    基数排序代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/sorting/radix-sort.ts" target="_blank" rel="noopener noreferrer">radix-sort.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>基数排序(radix-sort)</strong>：一种特殊的桶排序，主要是对整数或字符串的每一位进行排序，可以从低位开始也可以从高位开始；桶的数量（基数）就是一个数的进制数。例如数组是十进制整数的，那么桶数（基数）就是 10，分别是从 0 到 9 这样的 10 个桶；然后依次从个位、十位、百位、千位这样从低到高进行每一轮排序，结束后每位上都是相对有序的，整体上也是有序的。</p> <p>    如果数组里的元素是位数比较多的整数，那么就适合从高位开始排，位数比较低的就适合从低位开始排；时间空间复杂度都是 O(n*k)，k 是元素的位数。<br> <img src="/blog-vuepress/assets/img/radix-sort.5061d0d2.png" alt="radix-sort"></p> <h3 id="堆排序"><a href="#堆排序" class="header-anchor">#</a> 堆排序</h3> <p>    在前面章节已经说过了：<a href="/blog-vuepress/book-web/数据结构与算法/9.二叉堆和堆排序.html">堆排序</a></p> <h2 id="搜索算法"><a href="#搜索算法" class="header-anchor">#</a> 搜索算法</h2> <h3 id="顺序搜索-线性搜索"><a href="#顺序搜索-线性搜索" class="header-anchor">#</a> 顺序搜索（线性搜索）</h3> <p>    顺序搜索（线性搜索）代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/search/sequential-search.ts" target="_blank" rel="noopener noreferrer">sequential-search.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>顺序搜索（线性搜索）</strong>：遍历该线性数据结构，将每个元素和要找的元素一一进行对比，如果相同就立即返回结果，不同就继续查找。</p> <h3 id="二分搜索"><a href="#二分搜索" class="header-anchor">#</a> 二分搜索</h3> <p>    二分搜索代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/search/binary-search.ts" target="_blank" rel="noopener noreferrer">binary-search.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>二分搜索</strong>：<br>
        1.在待选区间里选择中间值，如果中间值就是待搜索值，就直接返回；<br>
        2.如果待搜索值比中间值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复步骤 1；<br>
        3.如果待搜索值比中间值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复步骤 1。</p> <h3 id="内插搜索"><a href="#内插搜索" class="header-anchor">#</a> 内插搜索</h3> <p>    内插搜索代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/search/interpolation-search.ts" target="_blank" rel="noopener noreferrer">interpolation-search.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>内插搜索</strong>：改良版的二分搜索，要在步骤 1 中使用一个特殊公式去选定一个值。<br>
        1.在待选区间里利用公式选定一个值，如果选定值就是待搜索值，就直接返回；<br>
        2.如果待搜索值比选定值要小，就将目前区间的左区间（较小区间）作为待选区间，然后重复之前步骤；<br>
        3.如果待搜索值比选定值要大，就将目前区间的右区间（较大区间）作为待选区间，然后重复之前步骤。</p> <p>    公式是这样的，先算出搜索值在“max 和 min 的差值”的“占比”，再将“max 的索引和 min 的索引的差值”乘以这个“占比”，就可以大致推断出搜索值的索引。</p> <h2 id="随机算法"><a href="#随机算法" class="header-anchor">#</a> 随机算法</h2> <h3 id="fisher-yates-随机"><a href="#fisher-yates-随机" class="header-anchor">#</a> Fisher-Yates 随机</h3> <p>    Fisher-Yates 随机代码细节：<a href="https://gitee.com/liawnliu/datastructures_ts/blob/master/src/ts/algorithms/shuffle/fisher%E2%80%93yates.ts" target="_blank" rel="noopener noreferrer">fisher–yates.ts<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><strong>Fisher-Yates 随机</strong>：从最后一项开始并将当前位置和一个随机位置进行交换，这个随机位置要比当前位置小。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog-vuepress/book-web/数据结构与算法/10.图.html" class="prev">
        10.图
      </a></span> <span class="next"><a href="/blog-vuepress/book-web/数据结构与算法/12.算法设计与技巧.html">
        12.算法设计与技巧
      </a>
      →
    </span></p></div> </main> <div class="right-sidebar-wrapper right-sidebar-hidden"><aside class="right-sidebar"><div><div class="title">本文目录</div><h1><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#排序和搜索算法" title="排序和搜索算法">排序和搜索算法</a></h1><h2><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#排序算法" title="排序算法">排序算法</a></h2><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#冒泡排序" title="冒泡排序">冒泡排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#选择排序" title="选择排序">选择排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#插入排序" title="插入排序">插入排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#希尔排序" title="希尔排序">希尔排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#归并排序" title="归并排序">归并排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#快速排序" title="快速排序">快速排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#计数排序" title="计数排序">计数排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#桶排序" title="桶排序">桶排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#基数排序" title="基数排序">基数排序</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#堆排序" title="堆排序">堆排序</a></h3><h2><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#搜索算法" title="搜索算法">搜索算法</a></h2><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#顺序搜索-线性搜索" title="顺序搜索（线性搜索）">顺序搜索（线性搜索）</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#二分搜索" title="二分搜索">二分搜索</a></h3><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#内插搜索" title="内插搜索">内插搜索</a></h3><h2><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#随机算法" title="随机算法">随机算法</a></h2><h3><a href="/blog-vuepress/book-web/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/11.%E6%8E%92%E5%BA%8F%E5%92%8C%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95.html#fisher-yates-随机" title="Fisher-Yates 随机">Fisher-Yates 随机</a></h3></div></aside> <div class="sidebar-toggle" data-v-10bfdc0c><div class="sidebar-toggle-button" data-v-10bfdc0c><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span><span data-v-10bfdc0c></span></div></div></div></div><div class="global-ui"><!----></div></div>
    <script src="/blog-vuepress/assets/js/app.34680ebc.js" defer></script><script src="/blog-vuepress/assets/js/2.1e7adb41.js" defer></script><script src="/blog-vuepress/assets/js/19.4b561714.js" defer></script><script src="/blog-vuepress/assets/js/38.cec9a03e.js" defer></script>
  </body>
</html>
